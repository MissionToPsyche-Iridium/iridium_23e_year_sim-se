let wt, aa;
let __tla = (async () => {
  (function() {
    const or = document.createElement("link").relList;
    if (or && or.supports && or.supports("modulepreload")) return;
    for (const nt of document.querySelectorAll('link[rel="modulepreload"]')) la(nt);
    new MutationObserver((nt) => {
      for (const At of nt) if (At.type === "childList") for (const Xt of At.addedNodes) Xt.tagName === "LINK" && Xt.rel === "modulepreload" && la(Xt);
    }).observe(document, {
      childList: true,
      subtree: true
    });
    function On(nt) {
      const At = {};
      return nt.integrity && (At.integrity = nt.integrity), nt.referrerPolicy && (At.referrerPolicy = nt.referrerPolicy), nt.crossOrigin === "use-credentials" ? At.credentials = "include" : nt.crossOrigin === "anonymous" ? At.credentials = "omit" : At.credentials = "same-origin", At;
    }
    function la(nt) {
      if (nt.ep) return;
      nt.ep = true;
      const At = On(nt);
      fetch(nt.href, At);
    }
  })();
  const GE = "modulepreload", WE = function(oa) {
    return "/" + oa;
  }, tg = {}, XE = function(or, On, la) {
    let nt = Promise.resolve();
    if (On && On.length > 0) {
      document.getElementsByTagName("link");
      const Xt = document.querySelector("meta[property=csp-nonce]"), rt = (Xt == null ? void 0 : Xt.nonce) || (Xt == null ? void 0 : Xt.getAttribute("nonce"));
      nt = Promise.allSettled(On.map((gt) => {
        if (gt = WE(gt), gt in tg) return;
        tg[gt] = true;
        const Ut = gt.endsWith(".css"), Pt = Ut ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${gt}"]${Pt}`)) return;
        const ft = document.createElement("link");
        if (ft.rel = Ut ? "stylesheet" : GE, Ut || (ft.as = "script"), ft.crossOrigin = "", ft.href = gt, rt && ft.setAttribute("nonce", rt), document.head.appendChild(ft), Ut) return new Promise((Lt, fi) => {
          ft.addEventListener("load", Lt), ft.addEventListener("error", () => fi(new Error(`Unable to preload CSS for ${gt}`)));
        });
      }));
    }
    function At(Xt) {
      const rt = new Event("vite:preloadError", {
        cancelable: true
      });
      if (rt.payload = Xt, window.dispatchEvent(rt), !rt.defaultPrevented) throw Xt;
    }
    return nt.then((Xt) => {
      for (const rt of Xt || []) rt.status === "rejected" && At(rt.reason);
      return or().catch(At);
    });
  };
  (async () => {
    (function() {
      const nt = document.createElement("link").relList;
      if (nt && nt.supports && nt.supports("modulepreload")) return;
      for (const rt of document.querySelectorAll('link[rel="modulepreload"]')) Xt(rt);
      new MutationObserver((rt) => {
        for (const gt of rt) if (gt.type === "childList") for (const Ut of gt.addedNodes) Ut.tagName === "LINK" && Ut.rel === "modulepreload" && Xt(Ut);
      }).observe(document, {
        childList: true,
        subtree: true
      });
      function At(rt) {
        const gt = {};
        return rt.integrity && (gt.integrity = rt.integrity), rt.referrerPolicy && (gt.referrerPolicy = rt.referrerPolicy), rt.crossOrigin === "use-credentials" ? gt.credentials = "include" : rt.crossOrigin === "anonymous" ? gt.credentials = "omit" : gt.credentials = "same-origin", gt;
      }
      function Xt(rt) {
        if (rt.ep) return;
        rt.ep = true;
        const gt = At(rt);
        fetch(rt.href, gt);
      }
    })();
    const oa = "modulepreload", or = function(nt) {
      return "/" + nt;
    }, On = {}, la = function(nt, At, Xt) {
      let rt = Promise.resolve();
      if (At && At.length > 0) {
        document.getElementsByTagName("link");
        const Ut = document.querySelector("meta[property=csp-nonce]"), Pt = (Ut == null ? void 0 : Ut.nonce) || (Ut == null ? void 0 : Ut.getAttribute("nonce"));
        rt = Promise.allSettled(At.map((ft) => {
          if (ft = or(ft), ft in On) return;
          On[ft] = true;
          const Lt = ft.endsWith(".css"), fi = Lt ? '[rel="stylesheet"]' : "";
          if (document.querySelector(`link[href="${ft}"]${fi}`)) return;
          const jt = document.createElement("link");
          if (jt.rel = Lt ? "stylesheet" : oa, Lt || (jt.as = "script"), jt.crossOrigin = "", jt.href = ft, Pt && jt.setAttribute("nonce", Pt), document.head.appendChild(jt), Lt) return new Promise((Fn, qr) => {
            jt.addEventListener("load", Fn), jt.addEventListener("error", () => qr(new Error(`Unable to preload CSS for ${ft}`)));
          });
        }));
      }
      function gt(Ut) {
        const Pt = new Event("vite:preloadError", {
          cancelable: true
        });
        if (Pt.payload = Ut, window.dispatchEvent(Pt), !Pt.defaultPrevented) throw Ut;
      }
      return rt.then((Ut) => {
        for (const Pt of Ut || []) Pt.status === "rejected" && gt(Pt.reason);
        return nt().catch(gt);
      });
    };
    (async () => {
      (function() {
        const n = document.createElement("link").relList;
        if (n && n.supports && n.supports("modulepreload")) return;
        for (const i of document.querySelectorAll('link[rel="modulepreload"]')) t(i);
        new MutationObserver((i) => {
          for (const r of i) if (r.type === "childList") for (const s of r.addedNodes) s.tagName === "LINK" && s.rel === "modulepreload" && t(s);
        }).observe(document, {
          childList: true,
          subtree: true
        });
        function e(i) {
          const r = {};
          return i.integrity && (r.integrity = i.integrity), i.referrerPolicy && (r.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? r.credentials = "include" : i.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r;
        }
        function t(i) {
          if (i.ep) return;
          i.ep = true;
          const r = e(i);
          fetch(i.href, r);
        }
      })();
      const nt = "173", At = 0, Xt = 1, rt = 2, gt = 1, Ut = 2, Pt = 3, ft = 0, Lt = 1, fi = 2, jt = 0, Fn = 1, qr = 2, Bh = 3, zh = 4, ig = 5, lr = 100, ng = 101, rg = 102, sg = 103, ag = 104, og = 200, lg = 201, cg = 202, ug = 203, wl = 204, Al = 205, hg = 206, dg = 207, pg = 208, fg = 209, mg = 210, gg = 211, _g = 212, vg = 213, xg = 214, Rl = 0, Cl = 1, Pl = 2, Yr = 3, Ll = 4, Dl = 5, Il = 6, Nl = 7, kh = 0, yg = 1, Mg = 2, Bn = 0, Tg = 1, bg = 2, Sg = 3, Eg = 4, wg = 5, Ag = 6, Rg = 7, Vh = "attached", Cg = "detached", Hh = 300, Kr = 301, Zr = 302, Ul = 303, Ol = 304, oo = 306, Jr = 1e3, zn = 1001, lo = 1002, ai = 1003, Gh = 1004, ca = 1005, Mi = 1006, co = 1007, pn = 1008, fn = 1009, Wh = 1010, Xh = 1011, ua = 1012, Fl = 1013, cr = 1014, Vi = 1015, mn = 1016, Bl = 1017, zl = 1018, $r = 1020, jh = 35902, qh = 1021, Yh = 1022, Di = 1023, Kh = 1024, Zh = 1025, Qr = 1026, es = 1027, kl = 1028, Vl = 1029, Jh = 1030, Hl = 1031, Gl = 1033, uo = 33776, ho = 33777, po = 33778, fo = 33779, Wl = 35840, Xl = 35841, jl = 35842, ql = 35843, Yl = 36196, Kl = 37492, Zl = 37496, Jl = 37808, $l = 37809, Ql = 37810, ec = 37811, tc = 37812, ic = 37813, nc = 37814, rc = 37815, sc = 37816, ac = 37817, oc = 37818, lc = 37819, cc = 37820, uc = 37821, mo = 36492, hc = 36494, dc = 36495, $h = 36283, pc = 36284, fc = 36285, mc = 36286, ha = 2300, da = 2301, gc = 2302, Qh = 2400, ed = 2401, td = 2402, Pg = 2500, Lg = 0, id = 1, _c = 2, Dg = 3200, Ig = 3201, nd = 0, Ng = 1, kn = "", Kt = "srgb", oi = "srgb-linear", go = "linear", ct = "srgb", ts = 7680, rd = 519, Ug = 512, Og = 513, Fg = 514, sd = 515, Bg = 516, zg = 517, kg = 518, Vg = 519, vc = 35044, ad = "300 es", gn = 2e3, _o = 2001;
      class is {
        addEventListener(e, t) {
          this._listeners === void 0 && (this._listeners = {});
          const i = this._listeners;
          i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
        }
        hasEventListener(e, t) {
          const i = this._listeners;
          return i === void 0 ? false : i[e] !== void 0 && i[e].indexOf(t) !== -1;
        }
        removeEventListener(e, t) {
          const i = this._listeners;
          if (i === void 0) return;
          const r = i[e];
          if (r !== void 0) {
            const s = r.indexOf(t);
            s !== -1 && r.splice(s, 1);
          }
        }
        dispatchEvent(e) {
          const t = this._listeners;
          if (t === void 0) return;
          const i = t[e.type];
          if (i !== void 0) {
            e.target = this;
            const r = i.slice(0);
            for (let s = 0, a = r.length; s < a; s++) r[s].call(this, e);
            e.target = null;
          }
        }
      }
      const Qt = [
        "00",
        "01",
        "02",
        "03",
        "04",
        "05",
        "06",
        "07",
        "08",
        "09",
        "0a",
        "0b",
        "0c",
        "0d",
        "0e",
        "0f",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "1a",
        "1b",
        "1c",
        "1d",
        "1e",
        "1f",
        "20",
        "21",
        "22",
        "23",
        "24",
        "25",
        "26",
        "27",
        "28",
        "29",
        "2a",
        "2b",
        "2c",
        "2d",
        "2e",
        "2f",
        "30",
        "31",
        "32",
        "33",
        "34",
        "35",
        "36",
        "37",
        "38",
        "39",
        "3a",
        "3b",
        "3c",
        "3d",
        "3e",
        "3f",
        "40",
        "41",
        "42",
        "43",
        "44",
        "45",
        "46",
        "47",
        "48",
        "49",
        "4a",
        "4b",
        "4c",
        "4d",
        "4e",
        "4f",
        "50",
        "51",
        "52",
        "53",
        "54",
        "55",
        "56",
        "57",
        "58",
        "59",
        "5a",
        "5b",
        "5c",
        "5d",
        "5e",
        "5f",
        "60",
        "61",
        "62",
        "63",
        "64",
        "65",
        "66",
        "67",
        "68",
        "69",
        "6a",
        "6b",
        "6c",
        "6d",
        "6e",
        "6f",
        "70",
        "71",
        "72",
        "73",
        "74",
        "75",
        "76",
        "77",
        "78",
        "79",
        "7a",
        "7b",
        "7c",
        "7d",
        "7e",
        "7f",
        "80",
        "81",
        "82",
        "83",
        "84",
        "85",
        "86",
        "87",
        "88",
        "89",
        "8a",
        "8b",
        "8c",
        "8d",
        "8e",
        "8f",
        "90",
        "91",
        "92",
        "93",
        "94",
        "95",
        "96",
        "97",
        "98",
        "99",
        "9a",
        "9b",
        "9c",
        "9d",
        "9e",
        "9f",
        "a0",
        "a1",
        "a2",
        "a3",
        "a4",
        "a5",
        "a6",
        "a7",
        "a8",
        "a9",
        "aa",
        "ab",
        "ac",
        "ad",
        "ae",
        "af",
        "b0",
        "b1",
        "b2",
        "b3",
        "b4",
        "b5",
        "b6",
        "b7",
        "b8",
        "b9",
        "ba",
        "bb",
        "bc",
        "bd",
        "be",
        "bf",
        "c0",
        "c1",
        "c2",
        "c3",
        "c4",
        "c5",
        "c6",
        "c7",
        "c8",
        "c9",
        "ca",
        "cb",
        "cc",
        "cd",
        "ce",
        "cf",
        "d0",
        "d1",
        "d2",
        "d3",
        "d4",
        "d5",
        "d6",
        "d7",
        "d8",
        "d9",
        "da",
        "db",
        "dc",
        "dd",
        "de",
        "df",
        "e0",
        "e1",
        "e2",
        "e3",
        "e4",
        "e5",
        "e6",
        "e7",
        "e8",
        "e9",
        "ea",
        "eb",
        "ec",
        "ed",
        "ee",
        "ef",
        "f0",
        "f1",
        "f2",
        "f3",
        "f4",
        "f5",
        "f6",
        "f7",
        "f8",
        "f9",
        "fa",
        "fb",
        "fc",
        "fd",
        "fe",
        "ff"
      ];
      let od = 1234567;
      const pa = Math.PI / 180, ns = 180 / Math.PI;
      function Ii() {
        const n = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
        return (Qt[n & 255] + Qt[n >> 8 & 255] + Qt[n >> 16 & 255] + Qt[n >> 24 & 255] + "-" + Qt[e & 255] + Qt[e >> 8 & 255] + "-" + Qt[e >> 16 & 15 | 64] + Qt[e >> 24 & 255] + "-" + Qt[t & 63 | 128] + Qt[t >> 8 & 255] + "-" + Qt[t >> 16 & 255] + Qt[t >> 24 & 255] + Qt[i & 255] + Qt[i >> 8 & 255] + Qt[i >> 16 & 255] + Qt[i >> 24 & 255]).toLowerCase();
      }
      function Ge(n, e, t) {
        return Math.max(e, Math.min(t, n));
      }
      function xc(n, e) {
        return (n % e + e) % e;
      }
      function Hg(n, e, t, i, r) {
        return i + (n - e) * (r - i) / (t - e);
      }
      function Gg(n, e, t) {
        return n !== e ? (t - n) / (e - n) : 0;
      }
      function fa(n, e, t) {
        return (1 - t) * n + t * e;
      }
      function Wg(n, e, t, i) {
        return fa(n, e, 1 - Math.exp(-t * i));
      }
      function Xg(n, e = 1) {
        return e - Math.abs(xc(n, e * 2) - e);
      }
      function jg(n, e, t) {
        return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * (3 - 2 * n));
      }
      function qg(n, e, t) {
        return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * n * (n * (n * 6 - 15) + 10));
      }
      function Yg(n, e) {
        return n + Math.floor(Math.random() * (e - n + 1));
      }
      function Kg(n, e) {
        return n + Math.random() * (e - n);
      }
      function Zg(n) {
        return n * (0.5 - Math.random());
      }
      function Jg(n) {
        n !== void 0 && (od = n);
        let e = od += 1831565813;
        return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
      }
      function $g(n) {
        return n * pa;
      }
      function Qg(n) {
        return n * ns;
      }
      function e_(n) {
        return (n & n - 1) === 0 && n !== 0;
      }
      function t_(n) {
        return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
      }
      function i_(n) {
        return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
      }
      function n_(n, e, t, i, r) {
        const s = Math.cos, a = Math.sin, o = s(t / 2), l = a(t / 2), c = s((e + i) / 2), u = a((e + i) / 2), h = s((e - i) / 2), d = a((e - i) / 2), p = s((i - e) / 2), f = a((i - e) / 2);
        switch (r) {
          case "XYX":
            n.set(o * u, l * h, l * d, o * c);
            break;
          case "YZY":
            n.set(l * d, o * u, l * h, o * c);
            break;
          case "ZXZ":
            n.set(l * h, l * d, o * u, o * c);
            break;
          case "XZX":
            n.set(o * u, l * f, l * p, o * c);
            break;
          case "YXY":
            n.set(l * p, o * u, l * f, o * c);
            break;
          case "ZYZ":
            n.set(l * f, l * p, o * u, o * c);
            break;
          default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r);
        }
      }
      function Hi(n, e) {
        switch (e.constructor) {
          case Float32Array:
            return n;
          case Uint32Array:
            return n / 4294967295;
          case Uint16Array:
            return n / 65535;
          case Uint8Array:
            return n / 255;
          case Int32Array:
            return Math.max(n / 2147483647, -1);
          case Int16Array:
            return Math.max(n / 32767, -1);
          case Int8Array:
            return Math.max(n / 127, -1);
          default:
            throw new Error("Invalid component type.");
        }
      }
      function at(n, e) {
        switch (e.constructor) {
          case Float32Array:
            return n;
          case Uint32Array:
            return Math.round(n * 4294967295);
          case Uint16Array:
            return Math.round(n * 65535);
          case Uint8Array:
            return Math.round(n * 255);
          case Int32Array:
            return Math.round(n * 2147483647);
          case Int16Array:
            return Math.round(n * 32767);
          case Int8Array:
            return Math.round(n * 127);
          default:
            throw new Error("Invalid component type.");
        }
      }
      const r_ = {
        DEG2RAD: pa,
        RAD2DEG: ns,
        generateUUID: Ii,
        clamp: Ge,
        euclideanModulo: xc,
        mapLinear: Hg,
        inverseLerp: Gg,
        lerp: fa,
        damp: Wg,
        pingpong: Xg,
        smoothstep: jg,
        smootherstep: qg,
        randInt: Yg,
        randFloat: Kg,
        randFloatSpread: Zg,
        seededRandom: Jg,
        degToRad: $g,
        radToDeg: Qg,
        isPowerOfTwo: e_,
        ceilPowerOfTwo: t_,
        floorPowerOfTwo: i_,
        setQuaternionFromProperEuler: n_,
        normalize: at,
        denormalize: Hi
      };
      class ee {
        constructor(e = 0, t = 0) {
          ee.prototype.isVector2 = true, this.x = e, this.y = t;
        }
        get width() {
          return this.x;
        }
        set width(e) {
          this.x = e;
        }
        get height() {
          return this.y;
        }
        set height(e) {
          this.y = e;
        }
        set(e, t) {
          return this.x = e, this.y = t, this;
        }
        setScalar(e) {
          return this.x = e, this.y = e, this;
        }
        setX(e) {
          return this.x = e, this;
        }
        setY(e) {
          return this.y = e, this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(e) {
          return this.x = e.x, this.y = e.y, this;
        }
        add(e) {
          return this.x += e.x, this.y += e.y, this;
        }
        addScalar(e) {
          return this.x += e, this.y += e, this;
        }
        addVectors(e, t) {
          return this.x = e.x + t.x, this.y = e.y + t.y, this;
        }
        addScaledVector(e, t) {
          return this.x += e.x * t, this.y += e.y * t, this;
        }
        sub(e) {
          return this.x -= e.x, this.y -= e.y, this;
        }
        subScalar(e) {
          return this.x -= e, this.y -= e, this;
        }
        subVectors(e, t) {
          return this.x = e.x - t.x, this.y = e.y - t.y, this;
        }
        multiply(e) {
          return this.x *= e.x, this.y *= e.y, this;
        }
        multiplyScalar(e) {
          return this.x *= e, this.y *= e, this;
        }
        divide(e) {
          return this.x /= e.x, this.y /= e.y, this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
          const t = this.x, i = this.y, r = e.elements;
          return this.x = r[0] * t + r[3] * i + r[6], this.y = r[1] * t + r[4] * i + r[7], this;
        }
        min(e) {
          return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
        }
        max(e) {
          return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
        }
        clamp(e, t) {
          return this.x = Ge(this.x, e.x, t.x), this.y = Ge(this.y, e.y, t.y), this;
        }
        clampScalar(e, t) {
          return this.x = Ge(this.x, e, t), this.y = Ge(this.y, e, t), this;
        }
        clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(Ge(i, e, t));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        }
        roundToZero() {
          return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y;
        }
        cross(e) {
          return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (t === 0) return Math.PI / 2;
          const i = this.dot(e) / t;
          return Math.acos(Ge(i, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x, i = this.y - e.y;
          return t * t + i * i;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
        }
        lerpVectors(e, t, i) {
          return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
          return this.x = e[t], this.y = e[t + 1], this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this.x, e[t + 1] = this.y, e;
        }
        fromBufferAttribute(e, t) {
          return this.x = e.getX(t), this.y = e.getY(t), this;
        }
        rotateAround(e, t) {
          const i = Math.cos(t), r = Math.sin(t), s = this.x - e.x, a = this.y - e.y;
          return this.x = s * i - a * r + e.x, this.y = s * r + a * i + e.y, this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      class ze {
        constructor(e, t, i, r, s, a, o, l, c) {
          ze.prototype.isMatrix3 = true, this.elements = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          ], e !== void 0 && this.set(e, t, i, r, s, a, o, l, c);
        }
        set(e, t, i, r, s, a, o, l, c) {
          const u = this.elements;
          return u[0] = e, u[1] = r, u[2] = o, u[3] = t, u[4] = s, u[5] = l, u[6] = i, u[7] = a, u[8] = c, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(e) {
          const t = this.elements, i = e.elements;
          return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this;
        }
        extractBasis(e, t, i) {
          return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
        }
        setFromMatrix4(e) {
          const t = e.elements;
          return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const i = e.elements, r = t.elements, s = this.elements, a = i[0], o = i[3], l = i[6], c = i[1], u = i[4], h = i[7], d = i[2], p = i[5], f = i[8], _ = r[0], g = r[3], m = r[6], y = r[1], x = r[4], v = r[7], A = r[2], E = r[5], w = r[8];
          return s[0] = a * _ + o * y + l * A, s[3] = a * g + o * x + l * E, s[6] = a * m + o * v + l * w, s[1] = c * _ + u * y + h * A, s[4] = c * g + u * x + h * E, s[7] = c * m + u * v + h * w, s[2] = d * _ + p * y + f * A, s[5] = d * g + p * x + f * E, s[8] = d * m + p * v + f * w, this;
        }
        multiplyScalar(e) {
          const t = this.elements;
          return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
        }
        determinant() {
          const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], a = e[4], o = e[5], l = e[6], c = e[7], u = e[8];
          return t * a * u - t * o * c - i * s * u + i * o * l + r * s * c - r * a * l;
        }
        invert() {
          const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], a = e[4], o = e[5], l = e[6], c = e[7], u = e[8], h = u * a - o * c, d = o * l - u * s, p = c * s - a * l, f = t * h + i * d + r * p;
          if (f === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const _ = 1 / f;
          return e[0] = h * _, e[1] = (r * c - u * i) * _, e[2] = (o * i - r * a) * _, e[3] = d * _, e[4] = (u * t - r * l) * _, e[5] = (r * s - o * t) * _, e[6] = p * _, e[7] = (i * l - c * t) * _, e[8] = (a * t - i * s) * _, this;
        }
        transpose() {
          let e;
          const t = this.elements;
          return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
        }
        getNormalMatrix(e) {
          return this.setFromMatrix4(e).invert().transpose();
        }
        transposeIntoArray(e) {
          const t = this.elements;
          return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
        }
        setUvTransform(e, t, i, r, s, a, o) {
          const l = Math.cos(s), c = Math.sin(s);
          return this.set(i * l, i * c, -i * (l * a + c * o) + a + e, -r * c, r * l, -r * (-c * a + l * o) + o + t, 0, 0, 1), this;
        }
        scale(e, t) {
          return this.premultiply(yc.makeScale(e, t)), this;
        }
        rotate(e) {
          return this.premultiply(yc.makeRotation(-e)), this;
        }
        translate(e, t) {
          return this.premultiply(yc.makeTranslation(e, t)), this;
        }
        makeTranslation(e, t) {
          return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
        }
        makeRotation(e) {
          const t = Math.cos(e), i = Math.sin(e);
          return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
        }
        makeScale(e, t) {
          return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
        }
        equals(e) {
          const t = this.elements, i = e.elements;
          for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return false;
          return true;
        }
        fromArray(e, t = 0) {
          for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const i = this.elements;
          return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e;
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      const yc = new ze();
      function ld(n) {
        for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return true;
        return false;
      }
      function ma(n) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", n);
      }
      function s_() {
        const n = ma("canvas");
        return n.style.display = "block", n;
      }
      const cd = {};
      function rs(n) {
        n in cd || (cd[n] = true, console.warn(n));
      }
      function a_(n, e, t) {
        return new Promise(function(i, r) {
          function s() {
            switch (n.clientWaitSync(e, n.SYNC_FLUSH_COMMANDS_BIT, 0)) {
              case n.WAIT_FAILED:
                r();
                break;
              case n.TIMEOUT_EXPIRED:
                setTimeout(s, t);
                break;
              default:
                i();
            }
          }
          setTimeout(s, t);
        });
      }
      function o_(n) {
        const e = n.elements;
        e[2] = 0.5 * e[2] + 0.5 * e[3], e[6] = 0.5 * e[6] + 0.5 * e[7], e[10] = 0.5 * e[10] + 0.5 * e[11], e[14] = 0.5 * e[14] + 0.5 * e[15];
      }
      function l_(n) {
        const e = n.elements;
        e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1);
      }
      const ud = new ze().set(0.4123908, 0.3575843, 0.1804808, 0.212639, 0.7151687, 0.0721923, 0.0193308, 0.1191948, 0.9505322), hd = new ze().set(3.2409699, -1.5373832, -0.4986108, -0.9692436, 1.8759675, 0.0415551, 0.0556301, -0.203977, 1.0569715);
      function c_() {
        const n = {
          enabled: true,
          workingColorSpace: oi,
          spaces: {},
          convert: function(r, s, a) {
            return this.enabled === false || s === a || !s || !a || (this.spaces[s].transfer === ct && (r.r = _n(r.r), r.g = _n(r.g), r.b = _n(r.b)), this.spaces[s].primaries !== this.spaces[a].primaries && (r.applyMatrix3(this.spaces[s].toXYZ), r.applyMatrix3(this.spaces[a].fromXYZ)), this.spaces[a].transfer === ct && (r.r = ss(r.r), r.g = ss(r.g), r.b = ss(r.b))), r;
          },
          fromWorkingColorSpace: function(r, s) {
            return this.convert(r, this.workingColorSpace, s);
          },
          toWorkingColorSpace: function(r, s) {
            return this.convert(r, s, this.workingColorSpace);
          },
          getPrimaries: function(r) {
            return this.spaces[r].primaries;
          },
          getTransfer: function(r) {
            return r === kn ? go : this.spaces[r].transfer;
          },
          getLuminanceCoefficients: function(r, s = this.workingColorSpace) {
            return r.fromArray(this.spaces[s].luminanceCoefficients);
          },
          define: function(r) {
            Object.assign(this.spaces, r);
          },
          _getMatrix: function(r, s, a) {
            return r.copy(this.spaces[s].toXYZ).multiply(this.spaces[a].fromXYZ);
          },
          _getDrawingBufferColorSpace: function(r) {
            return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace;
          },
          _getUnpackColorSpace: function(r = this.workingColorSpace) {
            return this.spaces[r].workingColorSpaceConfig.unpackColorSpace;
          }
        }, e = [
          0.64,
          0.33,
          0.3,
          0.6,
          0.15,
          0.06
        ], t = [
          0.2126,
          0.7152,
          0.0722
        ], i = [
          0.3127,
          0.329
        ];
        return n.define({
          [oi]: {
            primaries: e,
            whitePoint: i,
            transfer: go,
            toXYZ: ud,
            fromXYZ: hd,
            luminanceCoefficients: t,
            workingColorSpaceConfig: {
              unpackColorSpace: Kt
            },
            outputColorSpaceConfig: {
              drawingBufferColorSpace: Kt
            }
          },
          [Kt]: {
            primaries: e,
            whitePoint: i,
            transfer: ct,
            toXYZ: ud,
            fromXYZ: hd,
            luminanceCoefficients: t,
            outputColorSpaceConfig: {
              drawingBufferColorSpace: Kt
            }
          }
        }), n;
      }
      const Ke = c_();
      function _n(n) {
        return n < 0.04045 ? n * 0.0773993808 : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
      }
      function ss(n) {
        return n < 31308e-7 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
      }
      let as;
      class u_ {
        static getDataURL(e) {
          if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
          let t;
          if (e instanceof HTMLCanvasElement) t = e;
          else {
            as === void 0 && (as = ma("canvas")), as.width = e.width, as.height = e.height;
            const i = as.getContext("2d");
            e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = as;
          }
          return t.toDataURL("image/png");
        }
        static sRGBToLinear(e) {
          if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = ma("canvas");
            t.width = e.width, t.height = e.height;
            const i = t.getContext("2d");
            i.drawImage(e, 0, 0, e.width, e.height);
            const r = i.getImageData(0, 0, e.width, e.height), s = r.data;
            for (let a = 0; a < s.length; a++) s[a] = _n(s[a] / 255) * 255;
            return i.putImageData(r, 0, 0), t;
          } else if (e.data) {
            const t = e.data.slice(0);
            for (let i = 0; i < t.length; i++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(_n(t[i] / 255) * 255) : t[i] = _n(t[i]);
            return {
              data: t,
              width: e.width,
              height: e.height
            };
          } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
        }
      }
      let h_ = 0;
      class dd {
        constructor(e = null) {
          this.isSource = true, Object.defineProperty(this, "id", {
            value: h_++
          }), this.uuid = Ii(), this.data = e, this.dataReady = true, this.version = 0;
        }
        set needsUpdate(e) {
          e === true && this.version++;
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
          const i = {
            uuid: this.uuid,
            url: ""
          }, r = this.data;
          if (r !== null) {
            let s;
            if (Array.isArray(r)) {
              s = [];
              for (let a = 0, o = r.length; a < o; a++) r[a].isDataTexture ? s.push(Mc(r[a].image)) : s.push(Mc(r[a]));
            } else s = Mc(r);
            i.url = s;
          }
          return t || (e.images[this.uuid] = i), i;
        }
      }
      function Mc(n) {
        return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? u_.getDataURL(n) : n.data ? {
          data: Array.from(n.data),
          width: n.width,
          height: n.height,
          type: n.data.constructor.name
        } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      let d_ = 0;
      class kt extends is {
        constructor(e = kt.DEFAULT_IMAGE, t = kt.DEFAULT_MAPPING, i = zn, r = zn, s = Mi, a = pn, o = Di, l = fn, c = kt.DEFAULT_ANISOTROPY, u = kn) {
          super(), this.isTexture = true, Object.defineProperty(this, "id", {
            value: d_++
          }), this.uuid = Ii(), this.name = "", this.source = new dd(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = i, this.wrapT = r, this.magFilter = s, this.minFilter = a, this.anisotropy = c, this.format = o, this.internalFormat = null, this.type = l, this.offset = new ee(0, 0), this.repeat = new ee(1, 1), this.center = new ee(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new ze(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.colorSpace = u, this.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = false, this.pmremVersion = 0;
        }
        get image() {
          return this.source.data;
        }
        set image(e = null) {
          this.source.data = e;
        }
        updateMatrix() {
          this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = true, this;
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
          const i = {
            metadata: {
              version: 4.6,
              type: "Texture",
              generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [
              this.repeat.x,
              this.repeat.y
            ],
            offset: [
              this.offset.x,
              this.offset.y
            ],
            center: [
              this.center.x,
              this.center.y
            ],
            rotation: this.rotation,
            wrap: [
              this.wrapS,
              this.wrapT
            ],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
          };
          return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        transformUv(e) {
          if (this.mapping !== Hh) return e;
          if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
            case Jr:
              e.x = e.x - Math.floor(e.x);
              break;
            case zn:
              e.x = e.x < 0 ? 0 : 1;
              break;
            case lo:
              Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
              break;
          }
          if (e.y < 0 || e.y > 1) switch (this.wrapT) {
            case Jr:
              e.y = e.y - Math.floor(e.y);
              break;
            case zn:
              e.y = e.y < 0 ? 0 : 1;
              break;
            case lo:
              Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
              break;
          }
          return this.flipY && (e.y = 1 - e.y), e;
        }
        set needsUpdate(e) {
          e === true && (this.version++, this.source.needsUpdate = true);
        }
        set needsPMREMUpdate(e) {
          e === true && this.pmremVersion++;
        }
      }
      kt.DEFAULT_IMAGE = null, kt.DEFAULT_MAPPING = Hh, kt.DEFAULT_ANISOTROPY = 1;
      class it {
        constructor(e = 0, t = 0, i = 0, r = 1) {
          it.prototype.isVector4 = true, this.x = e, this.y = t, this.z = i, this.w = r;
        }
        get width() {
          return this.z;
        }
        set width(e) {
          this.z = e;
        }
        get height() {
          return this.w;
        }
        set height(e) {
          this.w = e;
        }
        set(e, t, i, r) {
          return this.x = e, this.y = t, this.z = i, this.w = r, this;
        }
        setScalar(e) {
          return this.x = e, this.y = e, this.z = e, this.w = e, this;
        }
        setX(e) {
          return this.x = e, this;
        }
        setY(e) {
          return this.y = e, this;
        }
        setZ(e) {
          return this.z = e, this;
        }
        setW(e) {
          return this.w = e, this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            case 3:
              this.w = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e) {
          return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
        }
        add(e) {
          return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
        }
        addScalar(e) {
          return this.x += e, this.y += e, this.z += e, this.w += e, this;
        }
        addVectors(e, t) {
          return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
        }
        addScaledVector(e, t) {
          return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
        }
        sub(e) {
          return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
        }
        subScalar(e) {
          return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
        }
        subVectors(e, t) {
          return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
        }
        multiply(e) {
          return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
        }
        multiplyScalar(e) {
          return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
        }
        applyMatrix4(e) {
          const t = this.x, i = this.y, r = this.z, s = this.w, a = e.elements;
          return this.x = a[0] * t + a[4] * i + a[8] * r + a[12] * s, this.y = a[1] * t + a[5] * i + a[9] * r + a[13] * s, this.z = a[2] * t + a[6] * i + a[10] * r + a[14] * s, this.w = a[3] * t + a[7] * i + a[11] * r + a[15] * s, this;
        }
        divide(e) {
          return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        setAxisAngleFromQuaternion(e) {
          this.w = 2 * Math.acos(e.w);
          const t = Math.sqrt(1 - e.w * e.w);
          return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
        }
        setAxisAngleFromRotationMatrix(e) {
          let t, i, r, s;
          const a = e.elements, o = a[0], l = a[4], c = a[8], u = a[1], h = a[5], d = a[9], p = a[2], f = a[6], _ = a[10];
          if (Math.abs(l - u) < 0.01 && Math.abs(c - p) < 0.01 && Math.abs(d - f) < 0.01) {
            if (Math.abs(l + u) < 0.1 && Math.abs(c + p) < 0.1 && Math.abs(d + f) < 0.1 && Math.abs(o + h + _ - 3) < 0.1) return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const m = (o + 1) / 2, y = (h + 1) / 2, x = (_ + 1) / 2, v = (l + u) / 4, A = (c + p) / 4, E = (d + f) / 4;
            return m > y && m > x ? m < 0.01 ? (i = 0, r = 0.707106781, s = 0.707106781) : (i = Math.sqrt(m), r = v / i, s = A / i) : y > x ? y < 0.01 ? (i = 0.707106781, r = 0, s = 0.707106781) : (r = Math.sqrt(y), i = v / r, s = E / r) : x < 0.01 ? (i = 0.707106781, r = 0.707106781, s = 0) : (s = Math.sqrt(x), i = A / s, r = E / s), this.set(i, r, s, t), this;
          }
          let g = Math.sqrt((f - d) * (f - d) + (c - p) * (c - p) + (u - l) * (u - l));
          return Math.abs(g) < 1e-3 && (g = 1), this.x = (f - d) / g, this.y = (c - p) / g, this.z = (u - l) / g, this.w = Math.acos((o + h + _ - 1) / 2), this;
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this;
        }
        min(e) {
          return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
        }
        max(e) {
          return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
        }
        clamp(e, t) {
          return this.x = Ge(this.x, e.x, t.x), this.y = Ge(this.y, e.y, t.y), this.z = Ge(this.z, e.z, t.z), this.w = Ge(this.w, e.w, t.w), this;
        }
        clampScalar(e, t) {
          return this.x = Ge(this.x, e, t), this.y = Ge(this.y, e, t), this.z = Ge(this.z, e, t), this.w = Ge(this.w, e, t), this;
        }
        clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(Ge(i, e, t));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
        }
        roundToZero() {
          return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
        }
        lerpVectors(e, t, i) {
          return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
        }
        fromArray(e, t = 0) {
          return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
        }
        fromBufferAttribute(e, t) {
          return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      }
      class p_ extends is {
        constructor(e = 1, t = 1, i = {}) {
          super(), this.isRenderTarget = true, this.width = e, this.height = t, this.depth = 1, this.scissor = new it(0, 0, e, t), this.scissorTest = false, this.viewport = new it(0, 0, e, t);
          const r = {
            width: e,
            height: t,
            depth: 1
          };
          i = Object.assign({
            generateMipmaps: false,
            internalFormat: null,
            minFilter: Mi,
            depthBuffer: true,
            stencilBuffer: false,
            resolveDepthBuffer: true,
            resolveStencilBuffer: true,
            depthTexture: null,
            samples: 0,
            count: 1
          }, i);
          const s = new kt(r, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
          s.flipY = false, s.generateMipmaps = i.generateMipmaps, s.internalFormat = i.internalFormat, this.textures = [];
          const a = i.count;
          for (let o = 0; o < a; o++) this.textures[o] = s.clone(), this.textures[o].isRenderTargetTexture = true, this.textures[o].renderTarget = this;
          this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = i.depthTexture, this.samples = i.samples;
        }
        get texture() {
          return this.textures[0];
        }
        set texture(e) {
          this.textures[0] = e;
        }
        set depthTexture(e) {
          this._depthTexture !== null && (this._depthTexture.renderTarget = null), e !== null && (e.renderTarget = this), this._depthTexture = e;
        }
        get depthTexture() {
          return this._depthTexture;
        }
        setSize(e, t, i = 1) {
          if (this.width !== e || this.height !== t || this.depth !== i) {
            this.width = e, this.height = t, this.depth = i;
            for (let r = 0, s = this.textures.length; r < s; r++) this.textures[r].image.width = e, this.textures[r].image.height = t, this.textures[r].image.depth = i;
            this.dispose();
          }
          this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
          for (let i = 0, r = e.textures.length; i < r; i++) this.textures[i] = e.textures[i].clone(), this.textures[i].isRenderTargetTexture = true, this.textures[i].renderTarget = this;
          const t = Object.assign({}, e.texture.image);
          return this.texture.source = new dd(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      class Gi extends p_ {
        constructor(e = 1, t = 1, i = {}) {
          super(e, t, i), this.isWebGLRenderTarget = true;
        }
      }
      class pd extends kt {
        constructor(e = null, t = 1, i = 1, r = 1) {
          super(null), this.isDataArrayTexture = true, this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
          }, this.magFilter = ai, this.minFilter = ai, this.wrapR = zn, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
        }
        addLayerUpdate(e) {
          this.layerUpdates.add(e);
        }
        clearLayerUpdates() {
          this.layerUpdates.clear();
        }
      }
      class f_ extends kt {
        constructor(e = null, t = 1, i = 1, r = 1) {
          super(null), this.isData3DTexture = true, this.image = {
            data: e,
            width: t,
            height: i,
            depth: r
          }, this.magFilter = ai, this.minFilter = ai, this.wrapR = zn, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
        }
      }
      class Vn {
        constructor(e = 0, t = 0, i = 0, r = 1) {
          this.isQuaternion = true, this._x = e, this._y = t, this._z = i, this._w = r;
        }
        static slerpFlat(e, t, i, r, s, a, o) {
          let l = i[r + 0], c = i[r + 1], u = i[r + 2], h = i[r + 3];
          const d = s[a + 0], p = s[a + 1], f = s[a + 2], _ = s[a + 3];
          if (o === 0) {
            e[t + 0] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = h;
            return;
          }
          if (o === 1) {
            e[t + 0] = d, e[t + 1] = p, e[t + 2] = f, e[t + 3] = _;
            return;
          }
          if (h !== _ || l !== d || c !== p || u !== f) {
            let g = 1 - o;
            const m = l * d + c * p + u * f + h * _, y = m >= 0 ? 1 : -1, x = 1 - m * m;
            if (x > Number.EPSILON) {
              const A = Math.sqrt(x), E = Math.atan2(A, m * y);
              g = Math.sin(g * E) / A, o = Math.sin(o * E) / A;
            }
            const v = o * y;
            if (l = l * g + d * v, c = c * g + p * v, u = u * g + f * v, h = h * g + _ * v, g === 1 - o) {
              const A = 1 / Math.sqrt(l * l + c * c + u * u + h * h);
              l *= A, c *= A, u *= A, h *= A;
            }
          }
          e[t] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = h;
        }
        static multiplyQuaternionsFlat(e, t, i, r, s, a) {
          const o = i[r], l = i[r + 1], c = i[r + 2], u = i[r + 3], h = s[a], d = s[a + 1], p = s[a + 2], f = s[a + 3];
          return e[t] = o * f + u * h + l * p - c * d, e[t + 1] = l * f + u * d + c * h - o * p, e[t + 2] = c * f + u * p + o * d - l * h, e[t + 3] = u * f - o * h - l * d - c * p, e;
        }
        get x() {
          return this._x;
        }
        set x(e) {
          this._x = e, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          this._y = e, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          this._z = e, this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(e) {
          this._w = e, this._onChangeCallback();
        }
        set(e, t, i, r) {
          return this._x = e, this._y = t, this._z = i, this._w = r, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e) {
          return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
        }
        setFromEuler(e, t = true) {
          const i = e._x, r = e._y, s = e._z, a = e._order, o = Math.cos, l = Math.sin, c = o(i / 2), u = o(r / 2), h = o(s / 2), d = l(i / 2), p = l(r / 2), f = l(s / 2);
          switch (a) {
            case "XYZ":
              this._x = d * u * h + c * p * f, this._y = c * p * h - d * u * f, this._z = c * u * f + d * p * h, this._w = c * u * h - d * p * f;
              break;
            case "YXZ":
              this._x = d * u * h + c * p * f, this._y = c * p * h - d * u * f, this._z = c * u * f - d * p * h, this._w = c * u * h + d * p * f;
              break;
            case "ZXY":
              this._x = d * u * h - c * p * f, this._y = c * p * h + d * u * f, this._z = c * u * f + d * p * h, this._w = c * u * h - d * p * f;
              break;
            case "ZYX":
              this._x = d * u * h - c * p * f, this._y = c * p * h + d * u * f, this._z = c * u * f - d * p * h, this._w = c * u * h + d * p * f;
              break;
            case "YZX":
              this._x = d * u * h + c * p * f, this._y = c * p * h + d * u * f, this._z = c * u * f - d * p * h, this._w = c * u * h - d * p * f;
              break;
            case "XZY":
              this._x = d * u * h - c * p * f, this._y = c * p * h - d * u * f, this._z = c * u * f + d * p * h, this._w = c * u * h + d * p * f;
              break;
            default:
              console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
          }
          return t === true && this._onChangeCallback(), this;
        }
        setFromAxisAngle(e, t) {
          const i = t / 2, r = Math.sin(i);
          return this._x = e.x * r, this._y = e.y * r, this._z = e.z * r, this._w = Math.cos(i), this._onChangeCallback(), this;
        }
        setFromRotationMatrix(e) {
          const t = e.elements, i = t[0], r = t[4], s = t[8], a = t[1], o = t[5], l = t[9], c = t[2], u = t[6], h = t[10], d = i + o + h;
          if (d > 0) {
            const p = 0.5 / Math.sqrt(d + 1);
            this._w = 0.25 / p, this._x = (u - l) * p, this._y = (s - c) * p, this._z = (a - r) * p;
          } else if (i > o && i > h) {
            const p = 2 * Math.sqrt(1 + i - o - h);
            this._w = (u - l) / p, this._x = 0.25 * p, this._y = (r + a) / p, this._z = (s + c) / p;
          } else if (o > h) {
            const p = 2 * Math.sqrt(1 + o - i - h);
            this._w = (s - c) / p, this._x = (r + a) / p, this._y = 0.25 * p, this._z = (l + u) / p;
          } else {
            const p = 2 * Math.sqrt(1 + h - i - o);
            this._w = (a - r) / p, this._x = (s + c) / p, this._y = (l + u) / p, this._z = 0.25 * p;
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(e, t) {
          let i = e.dot(t) + 1;
          return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize();
        }
        angleTo(e) {
          return 2 * Math.acos(Math.abs(Ge(this.dot(e), -1, 1)));
        }
        rotateTowards(e, t) {
          const i = this.angleTo(e);
          if (i === 0) return this;
          const r = Math.min(1, t / i);
          return this.slerp(e, r), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
        }
        dot(e) {
          return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
        }
        lengthSq() {
          return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
        }
        length() {
          return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
        }
        normalize() {
          let e = this.length();
          return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
        }
        multiply(e) {
          return this.multiplyQuaternions(this, e);
        }
        premultiply(e) {
          return this.multiplyQuaternions(e, this);
        }
        multiplyQuaternions(e, t) {
          const i = e._x, r = e._y, s = e._z, a = e._w, o = t._x, l = t._y, c = t._z, u = t._w;
          return this._x = i * u + a * o + r * c - s * l, this._y = r * u + a * l + s * o - i * c, this._z = s * u + a * c + i * l - r * o, this._w = a * u - i * o - r * l - s * c, this._onChangeCallback(), this;
        }
        slerp(e, t) {
          if (t === 0) return this;
          if (t === 1) return this.copy(e);
          const i = this._x, r = this._y, s = this._z, a = this._w;
          let o = a * e._w + i * e._x + r * e._y + s * e._z;
          if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = a, this._x = i, this._y = r, this._z = s, this;
          const l = 1 - o * o;
          if (l <= Number.EPSILON) {
            const p = 1 - t;
            return this._w = p * a + t * this._w, this._x = p * i + t * this._x, this._y = p * r + t * this._y, this._z = p * s + t * this._z, this.normalize(), this;
          }
          const c = Math.sqrt(l), u = Math.atan2(c, o), h = Math.sin((1 - t) * u) / c, d = Math.sin(t * u) / c;
          return this._w = a * h + this._w * d, this._x = i * h + this._x * d, this._y = r * h + this._y * d, this._z = s * h + this._z * d, this._onChangeCallback(), this;
        }
        slerpQuaternions(e, t, i) {
          return this.copy(e).slerp(t, i);
        }
        random() {
          const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), i = Math.random(), r = Math.sqrt(1 - i), s = Math.sqrt(i);
          return this.set(r * Math.sin(e), r * Math.cos(e), s * Math.sin(t), s * Math.cos(t));
        }
        equals(e) {
          return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
        }
        fromArray(e, t = 0) {
          return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
        }
        fromBufferAttribute(e, t) {
          return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
        }
        toJSON() {
          return this.toArray();
        }
        _onChange(e) {
          return this._onChangeCallback = e, this;
        }
        _onChangeCallback() {
        }
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._w;
        }
      }
      class D {
        constructor(e = 0, t = 0, i = 0) {
          D.prototype.isVector3 = true, this.x = e, this.y = t, this.z = i;
        }
        set(e, t, i) {
          return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this;
        }
        setScalar(e) {
          return this.x = e, this.y = e, this.z = e, this;
        }
        setX(e) {
          return this.x = e, this;
        }
        setY(e) {
          return this.y = e, this;
        }
        setZ(e) {
          return this.z = e, this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(e) {
          return this.x = e.x, this.y = e.y, this.z = e.z, this;
        }
        add(e) {
          return this.x += e.x, this.y += e.y, this.z += e.z, this;
        }
        addScalar(e) {
          return this.x += e, this.y += e, this.z += e, this;
        }
        addVectors(e, t) {
          return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
        }
        addScaledVector(e, t) {
          return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
        }
        sub(e) {
          return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
        }
        subScalar(e) {
          return this.x -= e, this.y -= e, this.z -= e, this;
        }
        subVectors(e, t) {
          return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
        }
        multiply(e) {
          return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
        }
        multiplyScalar(e) {
          return this.x *= e, this.y *= e, this.z *= e, this;
        }
        multiplyVectors(e, t) {
          return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
        }
        applyEuler(e) {
          return this.applyQuaternion(fd.setFromEuler(e));
        }
        applyAxisAngle(e, t) {
          return this.applyQuaternion(fd.setFromAxisAngle(e, t));
        }
        applyMatrix3(e) {
          const t = this.x, i = this.y, r = this.z, s = e.elements;
          return this.x = s[0] * t + s[3] * i + s[6] * r, this.y = s[1] * t + s[4] * i + s[7] * r, this.z = s[2] * t + s[5] * i + s[8] * r, this;
        }
        applyNormalMatrix(e) {
          return this.applyMatrix3(e).normalize();
        }
        applyMatrix4(e) {
          const t = this.x, i = this.y, r = this.z, s = e.elements, a = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
          return this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * a, this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * a, this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * a, this;
        }
        applyQuaternion(e) {
          const t = this.x, i = this.y, r = this.z, s = e.x, a = e.y, o = e.z, l = e.w, c = 2 * (a * r - o * i), u = 2 * (o * t - s * r), h = 2 * (s * i - a * t);
          return this.x = t + l * c + a * h - o * u, this.y = i + l * u + o * c - s * h, this.z = r + l * h + s * u - a * c, this;
        }
        project(e) {
          return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
        }
        unproject(e) {
          return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
        }
        transformDirection(e) {
          const t = this.x, i = this.y, r = this.z, s = e.elements;
          return this.x = s[0] * t + s[4] * i + s[8] * r, this.y = s[1] * t + s[5] * i + s[9] * r, this.z = s[2] * t + s[6] * i + s[10] * r, this.normalize();
        }
        divide(e) {
          return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        min(e) {
          return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
        }
        max(e) {
          return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
        }
        clamp(e, t) {
          return this.x = Ge(this.x, e.x, t.x), this.y = Ge(this.y, e.y, t.y), this.z = Ge(this.z, e.z, t.z), this;
        }
        clampScalar(e, t) {
          return this.x = Ge(this.x, e, t), this.y = Ge(this.y, e, t), this.z = Ge(this.z, e, t), this;
        }
        clampLength(e, t) {
          const i = this.length();
          return this.divideScalar(i || 1).multiplyScalar(Ge(i, e, t));
        }
        floor() {
          return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
        }
        ceil() {
          return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
        }
        round() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
        }
        roundToZero() {
          return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
        }
        negate() {
          return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
        }
        lerpVectors(e, t, i) {
          return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this;
        }
        cross(e) {
          return this.crossVectors(this, e);
        }
        crossVectors(e, t) {
          const i = e.x, r = e.y, s = e.z, a = t.x, o = t.y, l = t.z;
          return this.x = r * l - s * o, this.y = s * a - i * l, this.z = i * o - r * a, this;
        }
        projectOnVector(e) {
          const t = e.lengthSq();
          if (t === 0) return this.set(0, 0, 0);
          const i = e.dot(this) / t;
          return this.copy(e).multiplyScalar(i);
        }
        projectOnPlane(e) {
          return Tc.copy(this).projectOnVector(e), this.sub(Tc);
        }
        reflect(e) {
          return this.sub(Tc.copy(e).multiplyScalar(2 * this.dot(e)));
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (t === 0) return Math.PI / 2;
          const i = this.dot(e) / t;
          return Math.acos(Ge(i, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x, i = this.y - e.y, r = this.z - e.z;
          return t * t + i * i + r * r;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
        }
        setFromSpherical(e) {
          return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        }
        setFromSphericalCoords(e, t, i) {
          const r = Math.sin(t) * e;
          return this.x = r * Math.sin(i), this.y = Math.cos(t) * e, this.z = r * Math.cos(i), this;
        }
        setFromCylindrical(e) {
          return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        }
        setFromCylindricalCoords(e, t, i) {
          return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this;
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return this.x = t[12], this.y = t[13], this.z = t[14], this;
        }
        setFromMatrixScale(e) {
          const t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), r = this.setFromMatrixColumn(e, 2).length();
          return this.x = t, this.y = i, this.z = r, this;
        }
        setFromMatrixColumn(e, t) {
          return this.fromArray(e.elements, t * 4);
        }
        setFromMatrix3Column(e, t) {
          return this.fromArray(e.elements, t * 3);
        }
        setFromEuler(e) {
          return this.x = e._x, this.y = e._y, this.z = e._z, this;
        }
        setFromColor(e) {
          return this.x = e.r, this.y = e.g, this.z = e.b, this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z;
        }
        fromArray(e, t = 0) {
          return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
        }
        fromBufferAttribute(e, t) {
          return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
        }
        random() {
          return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
        }
        randomDirection() {
          const e = Math.random() * Math.PI * 2, t = Math.random() * 2 - 1, i = Math.sqrt(1 - t * t);
          return this.x = i * Math.cos(e), this.y = t, this.z = i * Math.sin(e), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      }
      const Tc = new D(), fd = new Vn();
      class vn {
        constructor(e = new D(1 / 0, 1 / 0, 1 / 0), t = new D(-1 / 0, -1 / 0, -1 / 0)) {
          this.isBox3 = true, this.min = e, this.max = t;
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromArray(e) {
          this.makeEmpty();
          for (let t = 0, i = e.length; t < i; t += 3) this.expandByPoint(Wi.fromArray(e, t));
          return this;
        }
        setFromBufferAttribute(e) {
          this.makeEmpty();
          for (let t = 0, i = e.count; t < i; t++) this.expandByPoint(Wi.fromBufferAttribute(e, t));
          return this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const i = Wi.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
        }
        setFromObject(e, t = false) {
          return this.makeEmpty(), this.expandByObject(e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
        }
        getCenter(e) {
          return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(e) {
          return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        expandByObject(e, t = false) {
          e.updateWorldMatrix(false, false);
          const i = e.geometry;
          if (i !== void 0) {
            const s = i.getAttribute("position");
            if (t === true && s !== void 0 && e.isInstancedMesh !== true) for (let a = 0, o = s.count; a < o; a++) e.isMesh === true ? e.getVertexPosition(a, Wi) : Wi.fromBufferAttribute(s, a), Wi.applyMatrix4(e.matrixWorld), this.expandByPoint(Wi);
            else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), vo.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), vo.copy(i.boundingBox)), vo.applyMatrix4(e.matrixWorld), this.union(vo);
          }
          const r = e.children;
          for (let s = 0, a = r.length; s < a; s++) this.expandByObject(r[s], t);
          return this;
        }
        containsPoint(e) {
          return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
        }
        containsBox(e) {
          return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
        }
        getParameter(e, t) {
          return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
        }
        intersectsBox(e) {
          return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
        }
        intersectsSphere(e) {
          return this.clampPoint(e.center, Wi), Wi.distanceToSquared(e.center) <= e.radius * e.radius;
        }
        intersectsPlane(e) {
          let t, i;
          return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant;
        }
        intersectsTriangle(e) {
          if (this.isEmpty()) return false;
          this.getCenter(ga), xo.subVectors(this.max, ga), os.subVectors(e.a, ga), ls.subVectors(e.b, ga), cs.subVectors(e.c, ga), Hn.subVectors(ls, os), Gn.subVectors(cs, ls), ur.subVectors(os, cs);
          let t = [
            0,
            -Hn.z,
            Hn.y,
            0,
            -Gn.z,
            Gn.y,
            0,
            -ur.z,
            ur.y,
            Hn.z,
            0,
            -Hn.x,
            Gn.z,
            0,
            -Gn.x,
            ur.z,
            0,
            -ur.x,
            -Hn.y,
            Hn.x,
            0,
            -Gn.y,
            Gn.x,
            0,
            -ur.y,
            ur.x,
            0
          ];
          return !bc(t, os, ls, cs, xo) || (t = [
            1,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            1
          ], !bc(t, os, ls, cs, xo)) ? false : (yo.crossVectors(Hn, Gn), t = [
            yo.x,
            yo.y,
            yo.z
          ], bc(t, os, ls, cs, xo));
        }
        clampPoint(e, t) {
          return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
          return this.clampPoint(e, Wi).distanceTo(e);
        }
        getBoundingSphere(e) {
          return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Wi).length() * 0.5), e;
        }
        intersect(e) {
          return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        applyMatrix4(e) {
          return this.isEmpty() ? this : (xn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), xn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), xn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), xn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), xn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), xn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), xn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), xn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(xn), this);
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }
      const xn = [
        new D(),
        new D(),
        new D(),
        new D(),
        new D(),
        new D(),
        new D(),
        new D()
      ], Wi = new D(), vo = new vn(), os = new D(), ls = new D(), cs = new D(), Hn = new D(), Gn = new D(), ur = new D(), ga = new D(), xo = new D(), yo = new D(), hr = new D();
      function bc(n, e, t, i, r) {
        for (let s = 0, a = n.length - 3; s <= a; s += 3) {
          hr.fromArray(n, s);
          const o = r.x * Math.abs(hr.x) + r.y * Math.abs(hr.y) + r.z * Math.abs(hr.z), l = e.dot(hr), c = t.dot(hr), u = i.dot(hr);
          if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > o) return false;
        }
        return true;
      }
      const m_ = new vn(), _a = new D(), Sc = new D();
      class $i {
        constructor(e = new D(), t = -1) {
          this.isSphere = true, this.center = e, this.radius = t;
        }
        set(e, t) {
          return this.center.copy(e), this.radius = t, this;
        }
        setFromPoints(e, t) {
          const i = this.center;
          t !== void 0 ? i.copy(t) : m_.setFromPoints(e).getCenter(i);
          let r = 0;
          for (let s = 0, a = e.length; s < a; s++) r = Math.max(r, i.distanceToSquared(e[s]));
          return this.radius = Math.sqrt(r), this;
        }
        copy(e) {
          return this.center.copy(e.center), this.radius = e.radius, this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), this.radius = -1, this;
        }
        containsPoint(e) {
          return e.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e) {
          return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
          const t = this.radius + e.radius;
          return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
          return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
          return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
          const i = this.center.distanceToSquared(e);
          return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
        }
        getBoundingBox(e) {
          return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
        }
        applyMatrix4(e) {
          return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
        }
        translate(e) {
          return this.center.add(e), this;
        }
        expandByPoint(e) {
          if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
          _a.subVectors(e, this.center);
          const t = _a.lengthSq();
          if (t > this.radius * this.radius) {
            const i = Math.sqrt(t), r = (i - this.radius) * 0.5;
            this.center.addScaledVector(_a, r / i), this.radius += r;
          }
          return this;
        }
        union(e) {
          return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === true ? this.radius = Math.max(this.radius, e.radius) : (Sc.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(_a.copy(e.center).add(Sc)), this.expandByPoint(_a.copy(e.center).sub(Sc))), this);
        }
        equals(e) {
          return e.center.equals(this.center) && e.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const yn = new D(), Ec = new D(), Mo = new D(), Wn = new D(), wc = new D(), To = new D(), Ac = new D();
      class va {
        constructor(e = new D(), t = new D(0, 0, -1)) {
          this.origin = e, this.direction = t;
        }
        set(e, t) {
          return this.origin.copy(e), this.direction.copy(t), this;
        }
        copy(e) {
          return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
        }
        at(e, t) {
          return t.copy(this.origin).addScaledVector(this.direction, e);
        }
        lookAt(e) {
          return this.direction.copy(e).sub(this.origin).normalize(), this;
        }
        recast(e) {
          return this.origin.copy(this.at(e, yn)), this;
        }
        closestPointToPoint(e, t) {
          t.subVectors(e, this.origin);
          const i = t.dot(this.direction);
          return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i);
        }
        distanceToPoint(e) {
          return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
          const t = yn.subVectors(e, this.origin).dot(this.direction);
          return t < 0 ? this.origin.distanceToSquared(e) : (yn.copy(this.origin).addScaledVector(this.direction, t), yn.distanceToSquared(e));
        }
        distanceSqToSegment(e, t, i, r) {
          Ec.copy(e).add(t).multiplyScalar(0.5), Mo.copy(t).sub(e).normalize(), Wn.copy(this.origin).sub(Ec);
          const s = e.distanceTo(t) * 0.5, a = -this.direction.dot(Mo), o = Wn.dot(this.direction), l = -Wn.dot(Mo), c = Wn.lengthSq(), u = Math.abs(1 - a * a);
          let h, d, p, f;
          if (u > 0) if (h = a * l - o, d = a * o - l, f = s * u, h >= 0) if (d >= -f) if (d <= f) {
            const _ = 1 / u;
            h *= _, d *= _, p = h * (h + a * d + 2 * o) + d * (a * h + d + 2 * l) + c;
          } else d = s, h = Math.max(0, -(a * d + o)), p = -h * h + d * (d + 2 * l) + c;
          else d = -s, h = Math.max(0, -(a * d + o)), p = -h * h + d * (d + 2 * l) + c;
          else d <= -f ? (h = Math.max(0, -(-a * s + o)), d = h > 0 ? -s : Math.min(Math.max(-s, -l), s), p = -h * h + d * (d + 2 * l) + c) : d <= f ? (h = 0, d = Math.min(Math.max(-s, -l), s), p = d * (d + 2 * l) + c) : (h = Math.max(0, -(a * s + o)), d = h > 0 ? s : Math.min(Math.max(-s, -l), s), p = -h * h + d * (d + 2 * l) + c);
          else d = a > 0 ? -s : s, h = Math.max(0, -(a * d + o)), p = -h * h + d * (d + 2 * l) + c;
          return i && i.copy(this.origin).addScaledVector(this.direction, h), r && r.copy(Ec).addScaledVector(Mo, d), p;
        }
        intersectSphere(e, t) {
          yn.subVectors(e.center, this.origin);
          const i = yn.dot(this.direction), r = yn.dot(yn) - i * i, s = e.radius * e.radius;
          if (r > s) return null;
          const a = Math.sqrt(s - r), o = i - a, l = i + a;
          return l < 0 ? null : o < 0 ? this.at(l, t) : this.at(o, t);
        }
        intersectsSphere(e) {
          return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
          const t = e.normal.dot(this.direction);
          if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
          const i = -(this.origin.dot(e.normal) + e.constant) / t;
          return i >= 0 ? i : null;
        }
        intersectPlane(e, t) {
          const i = this.distanceToPlane(e);
          return i === null ? null : this.at(i, t);
        }
        intersectsPlane(e) {
          const t = e.distanceToPoint(this.origin);
          return t === 0 || e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
          let i, r, s, a, o, l;
          const c = 1 / this.direction.x, u = 1 / this.direction.y, h = 1 / this.direction.z, d = this.origin;
          return c >= 0 ? (i = (e.min.x - d.x) * c, r = (e.max.x - d.x) * c) : (i = (e.max.x - d.x) * c, r = (e.min.x - d.x) * c), u >= 0 ? (s = (e.min.y - d.y) * u, a = (e.max.y - d.y) * u) : (s = (e.max.y - d.y) * u, a = (e.min.y - d.y) * u), i > a || s > r || ((s > i || isNaN(i)) && (i = s), (a < r || isNaN(r)) && (r = a), h >= 0 ? (o = (e.min.z - d.z) * h, l = (e.max.z - d.z) * h) : (o = (e.max.z - d.z) * h, l = (e.min.z - d.z) * h), i > l || o > r) || ((o > i || i !== i) && (i = o), (l < r || r !== r) && (r = l), r < 0) ? null : this.at(i >= 0 ? i : r, t);
        }
        intersectsBox(e) {
          return this.intersectBox(e, yn) !== null;
        }
        intersectTriangle(e, t, i, r, s) {
          wc.subVectors(t, e), To.subVectors(i, e), Ac.crossVectors(wc, To);
          let a = this.direction.dot(Ac), o;
          if (a > 0) {
            if (r) return null;
            o = 1;
          } else if (a < 0) o = -1, a = -a;
          else return null;
          Wn.subVectors(this.origin, e);
          const l = o * this.direction.dot(To.crossVectors(Wn, To));
          if (l < 0) return null;
          const c = o * this.direction.dot(wc.cross(Wn));
          if (c < 0 || l + c > a) return null;
          const u = -o * Wn.dot(Ac);
          return u < 0 ? null : this.at(u / a, s);
        }
        applyMatrix4(e) {
          return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
        }
        equals(e) {
          return e.origin.equals(this.origin) && e.direction.equals(this.direction);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Fe {
        constructor(e, t, i, r, s, a, o, l, c, u, h, d, p, f, _, g) {
          Fe.prototype.isMatrix4 = true, this.elements = [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
          ], e !== void 0 && this.set(e, t, i, r, s, a, o, l, c, u, h, d, p, f, _, g);
        }
        set(e, t, i, r, s, a, o, l, c, u, h, d, p, f, _, g) {
          const m = this.elements;
          return m[0] = e, m[4] = t, m[8] = i, m[12] = r, m[1] = s, m[5] = a, m[9] = o, m[13] = l, m[2] = c, m[6] = u, m[10] = h, m[14] = d, m[3] = p, m[7] = f, m[11] = _, m[15] = g, this;
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new Fe().fromArray(this.elements);
        }
        copy(e) {
          const t = this.elements, i = e.elements;
          return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this;
        }
        copyPosition(e) {
          const t = this.elements, i = e.elements;
          return t[12] = i[12], t[13] = i[13], t[14] = i[14], this;
        }
        setFromMatrix3(e) {
          const t = e.elements;
          return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
        }
        extractBasis(e, t, i) {
          return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
        }
        makeBasis(e, t, i) {
          return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this;
        }
        extractRotation(e) {
          const t = this.elements, i = e.elements, r = 1 / us.setFromMatrixColumn(e, 0).length(), s = 1 / us.setFromMatrixColumn(e, 1).length(), a = 1 / us.setFromMatrixColumn(e, 2).length();
          return t[0] = i[0] * r, t[1] = i[1] * r, t[2] = i[2] * r, t[3] = 0, t[4] = i[4] * s, t[5] = i[5] * s, t[6] = i[6] * s, t[7] = 0, t[8] = i[8] * a, t[9] = i[9] * a, t[10] = i[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
        }
        makeRotationFromEuler(e) {
          const t = this.elements, i = e.x, r = e.y, s = e.z, a = Math.cos(i), o = Math.sin(i), l = Math.cos(r), c = Math.sin(r), u = Math.cos(s), h = Math.sin(s);
          if (e.order === "XYZ") {
            const d = a * u, p = a * h, f = o * u, _ = o * h;
            t[0] = l * u, t[4] = -l * h, t[8] = c, t[1] = p + f * c, t[5] = d - _ * c, t[9] = -o * l, t[2] = _ - d * c, t[6] = f + p * c, t[10] = a * l;
          } else if (e.order === "YXZ") {
            const d = l * u, p = l * h, f = c * u, _ = c * h;
            t[0] = d + _ * o, t[4] = f * o - p, t[8] = a * c, t[1] = a * h, t[5] = a * u, t[9] = -o, t[2] = p * o - f, t[6] = _ + d * o, t[10] = a * l;
          } else if (e.order === "ZXY") {
            const d = l * u, p = l * h, f = c * u, _ = c * h;
            t[0] = d - _ * o, t[4] = -a * h, t[8] = f + p * o, t[1] = p + f * o, t[5] = a * u, t[9] = _ - d * o, t[2] = -a * c, t[6] = o, t[10] = a * l;
          } else if (e.order === "ZYX") {
            const d = a * u, p = a * h, f = o * u, _ = o * h;
            t[0] = l * u, t[4] = f * c - p, t[8] = d * c + _, t[1] = l * h, t[5] = _ * c + d, t[9] = p * c - f, t[2] = -c, t[6] = o * l, t[10] = a * l;
          } else if (e.order === "YZX") {
            const d = a * l, p = a * c, f = o * l, _ = o * c;
            t[0] = l * u, t[4] = _ - d * h, t[8] = f * h + p, t[1] = h, t[5] = a * u, t[9] = -o * u, t[2] = -c * u, t[6] = p * h + f, t[10] = d - _ * h;
          } else if (e.order === "XZY") {
            const d = a * l, p = a * c, f = o * l, _ = o * c;
            t[0] = l * u, t[4] = -h, t[8] = c * u, t[1] = d * h + _, t[5] = a * u, t[9] = p * h - f, t[2] = f * h - p, t[6] = o * u, t[10] = _ * h + d;
          }
          return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
        }
        makeRotationFromQuaternion(e) {
          return this.compose(g_, e, __);
        }
        lookAt(e, t, i) {
          const r = this.elements;
          return Ti.subVectors(e, t), Ti.lengthSq() === 0 && (Ti.z = 1), Ti.normalize(), Xn.crossVectors(i, Ti), Xn.lengthSq() === 0 && (Math.abs(i.z) === 1 ? Ti.x += 1e-4 : Ti.z += 1e-4, Ti.normalize(), Xn.crossVectors(i, Ti)), Xn.normalize(), bo.crossVectors(Ti, Xn), r[0] = Xn.x, r[4] = bo.x, r[8] = Ti.x, r[1] = Xn.y, r[5] = bo.y, r[9] = Ti.y, r[2] = Xn.z, r[6] = bo.z, r[10] = Ti.z, this;
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const i = e.elements, r = t.elements, s = this.elements, a = i[0], o = i[4], l = i[8], c = i[12], u = i[1], h = i[5], d = i[9], p = i[13], f = i[2], _ = i[6], g = i[10], m = i[14], y = i[3], x = i[7], v = i[11], A = i[15], E = r[0], w = r[4], R = r[8], S = r[12], T = r[1], L = r[5], B = r[9], F = r[13], H = r[2], X = r[6], k = r[10], K = r[14], G = r[3], ie = r[7], ue = r[11], we = r[15];
          return s[0] = a * E + o * T + l * H + c * G, s[4] = a * w + o * L + l * X + c * ie, s[8] = a * R + o * B + l * k + c * ue, s[12] = a * S + o * F + l * K + c * we, s[1] = u * E + h * T + d * H + p * G, s[5] = u * w + h * L + d * X + p * ie, s[9] = u * R + h * B + d * k + p * ue, s[13] = u * S + h * F + d * K + p * we, s[2] = f * E + _ * T + g * H + m * G, s[6] = f * w + _ * L + g * X + m * ie, s[10] = f * R + _ * B + g * k + m * ue, s[14] = f * S + _ * F + g * K + m * we, s[3] = y * E + x * T + v * H + A * G, s[7] = y * w + x * L + v * X + A * ie, s[11] = y * R + x * B + v * k + A * ue, s[15] = y * S + x * F + v * K + A * we, this;
        }
        multiplyScalar(e) {
          const t = this.elements;
          return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
        }
        determinant() {
          const e = this.elements, t = e[0], i = e[4], r = e[8], s = e[12], a = e[1], o = e[5], l = e[9], c = e[13], u = e[2], h = e[6], d = e[10], p = e[14], f = e[3], _ = e[7], g = e[11], m = e[15];
          return f * (+s * l * h - r * c * h - s * o * d + i * c * d + r * o * p - i * l * p) + _ * (+t * l * p - t * c * d + s * a * d - r * a * p + r * c * u - s * l * u) + g * (+t * c * h - t * o * p - s * a * h + i * a * p + s * o * u - i * c * u) + m * (-r * o * u - t * l * h + t * o * d + r * a * h - i * a * d + i * l * u);
        }
        transpose() {
          const e = this.elements;
          let t;
          return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
        }
        setPosition(e, t, i) {
          const r = this.elements;
          return e.isVector3 ? (r[12] = e.x, r[13] = e.y, r[14] = e.z) : (r[12] = e, r[13] = t, r[14] = i), this;
        }
        invert() {
          const e = this.elements, t = e[0], i = e[1], r = e[2], s = e[3], a = e[4], o = e[5], l = e[6], c = e[7], u = e[8], h = e[9], d = e[10], p = e[11], f = e[12], _ = e[13], g = e[14], m = e[15], y = h * g * c - _ * d * c + _ * l * p - o * g * p - h * l * m + o * d * m, x = f * d * c - u * g * c - f * l * p + a * g * p + u * l * m - a * d * m, v = u * _ * c - f * h * c + f * o * p - a * _ * p - u * o * m + a * h * m, A = f * h * l - u * _ * l - f * o * d + a * _ * d + u * o * g - a * h * g, E = t * y + i * x + r * v + s * A;
          if (E === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const w = 1 / E;
          return e[0] = y * w, e[1] = (_ * d * s - h * g * s - _ * r * p + i * g * p + h * r * m - i * d * m) * w, e[2] = (o * g * s - _ * l * s + _ * r * c - i * g * c - o * r * m + i * l * m) * w, e[3] = (h * l * s - o * d * s - h * r * c + i * d * c + o * r * p - i * l * p) * w, e[4] = x * w, e[5] = (u * g * s - f * d * s + f * r * p - t * g * p - u * r * m + t * d * m) * w, e[6] = (f * l * s - a * g * s - f * r * c + t * g * c + a * r * m - t * l * m) * w, e[7] = (a * d * s - u * l * s + u * r * c - t * d * c - a * r * p + t * l * p) * w, e[8] = v * w, e[9] = (f * h * s - u * _ * s - f * i * p + t * _ * p + u * i * m - t * h * m) * w, e[10] = (a * _ * s - f * o * s + f * i * c - t * _ * c - a * i * m + t * o * m) * w, e[11] = (u * o * s - a * h * s - u * i * c + t * h * c + a * i * p - t * o * p) * w, e[12] = A * w, e[13] = (u * _ * r - f * h * r + f * i * d - t * _ * d - u * i * g + t * h * g) * w, e[14] = (f * o * r - a * _ * r - f * i * l + t * _ * l + a * i * g - t * o * g) * w, e[15] = (a * h * r - u * o * r + u * i * l - t * h * l - a * i * d + t * o * d) * w, this;
        }
        scale(e) {
          const t = this.elements, i = e.x, r = e.y, s = e.z;
          return t[0] *= i, t[4] *= r, t[8] *= s, t[1] *= i, t[5] *= r, t[9] *= s, t[2] *= i, t[6] *= r, t[10] *= s, t[3] *= i, t[7] *= r, t[11] *= s, this;
        }
        getMaxScaleOnAxis() {
          const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
          return Math.sqrt(Math.max(t, i, r));
        }
        makeTranslation(e, t, i) {
          return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this;
        }
        makeRotationX(e) {
          const t = Math.cos(e), i = Math.sin(e);
          return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
        }
        makeRotationY(e) {
          const t = Math.cos(e), i = Math.sin(e);
          return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
        }
        makeRotationZ(e) {
          const t = Math.cos(e), i = Math.sin(e);
          return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        makeRotationAxis(e, t) {
          const i = Math.cos(t), r = Math.sin(t), s = 1 - i, a = e.x, o = e.y, l = e.z, c = s * a, u = s * o;
          return this.set(c * a + i, c * o - r * l, c * l + r * o, 0, c * o + r * l, u * o + i, u * l - r * a, 0, c * l - r * o, u * l + r * a, s * l * l + i, 0, 0, 0, 0, 1), this;
        }
        makeScale(e, t, i) {
          return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
        }
        makeShear(e, t, i, r, s, a) {
          return this.set(1, i, s, 0, e, 1, a, 0, t, r, 1, 0, 0, 0, 0, 1), this;
        }
        compose(e, t, i) {
          const r = this.elements, s = t._x, a = t._y, o = t._z, l = t._w, c = s + s, u = a + a, h = o + o, d = s * c, p = s * u, f = s * h, _ = a * u, g = a * h, m = o * h, y = l * c, x = l * u, v = l * h, A = i.x, E = i.y, w = i.z;
          return r[0] = (1 - (_ + m)) * A, r[1] = (p + v) * A, r[2] = (f - x) * A, r[3] = 0, r[4] = (p - v) * E, r[5] = (1 - (d + m)) * E, r[6] = (g + y) * E, r[7] = 0, r[8] = (f + x) * w, r[9] = (g - y) * w, r[10] = (1 - (d + _)) * w, r[11] = 0, r[12] = e.x, r[13] = e.y, r[14] = e.z, r[15] = 1, this;
        }
        decompose(e, t, i) {
          const r = this.elements;
          let s = us.set(r[0], r[1], r[2]).length();
          const a = us.set(r[4], r[5], r[6]).length(), o = us.set(r[8], r[9], r[10]).length();
          this.determinant() < 0 && (s = -s), e.x = r[12], e.y = r[13], e.z = r[14], Xi.copy(this);
          const l = 1 / s, c = 1 / a, u = 1 / o;
          return Xi.elements[0] *= l, Xi.elements[1] *= l, Xi.elements[2] *= l, Xi.elements[4] *= c, Xi.elements[5] *= c, Xi.elements[6] *= c, Xi.elements[8] *= u, Xi.elements[9] *= u, Xi.elements[10] *= u, t.setFromRotationMatrix(Xi), i.x = s, i.y = a, i.z = o, this;
        }
        makePerspective(e, t, i, r, s, a, o = gn) {
          const l = this.elements, c = 2 * s / (t - e), u = 2 * s / (i - r), h = (t + e) / (t - e), d = (i + r) / (i - r);
          let p, f;
          if (o === gn) p = -(a + s) / (a - s), f = -2 * a * s / (a - s);
          else if (o === _o) p = -a / (a - s), f = -a * s / (a - s);
          else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
          return l[0] = c, l[4] = 0, l[8] = h, l[12] = 0, l[1] = 0, l[5] = u, l[9] = d, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = p, l[14] = f, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
        }
        makeOrthographic(e, t, i, r, s, a, o = gn) {
          const l = this.elements, c = 1 / (t - e), u = 1 / (i - r), h = 1 / (a - s), d = (t + e) * c, p = (i + r) * u;
          let f, _;
          if (o === gn) f = (a + s) * h, _ = -2 * h;
          else if (o === _o) f = s * h, _ = -1 * h;
          else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
          return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -d, l[1] = 0, l[5] = 2 * u, l[9] = 0, l[13] = -p, l[2] = 0, l[6] = 0, l[10] = _, l[14] = -f, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
        }
        equals(e) {
          const t = this.elements, i = e.elements;
          for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return false;
          return true;
        }
        fromArray(e, t = 0) {
          for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const i = this.elements;
          return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e;
        }
      }
      const us = new D(), Xi = new Fe(), g_ = new D(0, 0, 0), __ = new D(1, 1, 1), Xn = new D(), bo = new D(), Ti = new D(), md = new Fe(), gd = new Vn();
      class Qi {
        constructor(e = 0, t = 0, i = 0, r = Qi.DEFAULT_ORDER) {
          this.isEuler = true, this._x = e, this._y = t, this._z = i, this._order = r;
        }
        get x() {
          return this._x;
        }
        set x(e) {
          this._x = e, this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          this._y = e, this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          this._z = e, this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(e) {
          this._order = e, this._onChangeCallback();
        }
        set(e, t, i, r = this._order) {
          return this._x = e, this._y = t, this._z = i, this._order = r, this._onChangeCallback(), this;
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(e) {
          return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
        }
        setFromRotationMatrix(e, t = this._order, i = true) {
          const r = e.elements, s = r[0], a = r[4], o = r[8], l = r[1], c = r[5], u = r[9], h = r[2], d = r[6], p = r[10];
          switch (t) {
            case "XYZ":
              this._y = Math.asin(Ge(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-a, s)) : (this._x = Math.atan2(d, c), this._z = 0);
              break;
            case "YXZ":
              this._x = Math.asin(-Ge(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(o, p), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, s), this._z = 0);
              break;
            case "ZXY":
              this._x = Math.asin(Ge(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-a, c)) : (this._y = 0, this._z = Math.atan2(l, s));
              break;
            case "ZYX":
              this._y = Math.asin(-Ge(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-a, c));
              break;
            case "YZX":
              this._z = Math.asin(Ge(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-h, s)) : (this._x = 0, this._y = Math.atan2(o, p));
              break;
            case "XZY":
              this._z = Math.asin(-Ge(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(o, s)) : (this._x = Math.atan2(-u, p), this._y = 0);
              break;
            default:
              console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
          }
          return this._order = t, i === true && this._onChangeCallback(), this;
        }
        setFromQuaternion(e, t, i) {
          return md.makeRotationFromQuaternion(e), this.setFromRotationMatrix(md, t, i);
        }
        setFromVector3(e, t = this._order) {
          return this.set(e.x, e.y, e.z, t);
        }
        reorder(e) {
          return gd.setFromEuler(this), this.setFromQuaternion(gd, e);
        }
        equals(e) {
          return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
        }
        fromArray(e) {
          return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
        }
        _onChange(e) {
          return this._onChangeCallback = e, this;
        }
        _onChangeCallback() {
        }
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._order;
        }
      }
      Qi.DEFAULT_ORDER = "XYZ";
      class Rc {
        constructor() {
          this.mask = 1;
        }
        set(e) {
          this.mask = (1 << e | 0) >>> 0;
        }
        enable(e) {
          this.mask |= 1 << e | 0;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(e) {
          this.mask ^= 1 << e | 0;
        }
        disable(e) {
          this.mask &= ~(1 << e | 0);
        }
        disableAll() {
          this.mask = 0;
        }
        test(e) {
          return (this.mask & e.mask) !== 0;
        }
        isEnabled(e) {
          return (this.mask & (1 << e | 0)) !== 0;
        }
      }
      let v_ = 0;
      const _d = new D(), hs = new Vn(), Mn = new Fe(), So = new D(), xa = new D(), x_ = new D(), y_ = new Vn(), vd = new D(1, 0, 0), xd = new D(0, 1, 0), yd = new D(0, 0, 1), Md = {
        type: "added"
      }, M_ = {
        type: "removed"
      }, ds = {
        type: "childadded",
        child: null
      }, Cc = {
        type: "childremoved",
        child: null
      };
      class Tt extends is {
        constructor() {
          super(), this.isObject3D = true, Object.defineProperty(this, "id", {
            value: v_++
          }), this.uuid = Ii(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Tt.DEFAULT_UP.clone();
          const e = new D(), t = new Qi(), i = new Vn(), r = new D(1, 1, 1);
          function s() {
            i.setFromEuler(t, false);
          }
          function a() {
            t.setFromQuaternion(i, void 0, false);
          }
          t._onChange(s), i._onChange(a), Object.defineProperties(this, {
            position: {
              configurable: true,
              enumerable: true,
              value: e
            },
            rotation: {
              configurable: true,
              enumerable: true,
              value: t
            },
            quaternion: {
              configurable: true,
              enumerable: true,
              value: i
            },
            scale: {
              configurable: true,
              enumerable: true,
              value: r
            },
            modelViewMatrix: {
              value: new Fe()
            },
            normalMatrix: {
              value: new ze()
            }
          }), this.matrix = new Fe(), this.matrixWorld = new Fe(), this.matrixAutoUpdate = Tt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Tt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = false, this.layers = new Rc(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
        }
        onBeforeShadow() {
        }
        onAfterShadow() {
        }
        onBeforeRender() {
        }
        onAfterRender() {
        }
        applyMatrix4(e) {
          this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(e) {
          return this.quaternion.premultiply(e), this;
        }
        setRotationFromAxisAngle(e, t) {
          this.quaternion.setFromAxisAngle(e, t);
        }
        setRotationFromEuler(e) {
          this.quaternion.setFromEuler(e, true);
        }
        setRotationFromMatrix(e) {
          this.quaternion.setFromRotationMatrix(e);
        }
        setRotationFromQuaternion(e) {
          this.quaternion.copy(e);
        }
        rotateOnAxis(e, t) {
          return hs.setFromAxisAngle(e, t), this.quaternion.multiply(hs), this;
        }
        rotateOnWorldAxis(e, t) {
          return hs.setFromAxisAngle(e, t), this.quaternion.premultiply(hs), this;
        }
        rotateX(e) {
          return this.rotateOnAxis(vd, e);
        }
        rotateY(e) {
          return this.rotateOnAxis(xd, e);
        }
        rotateZ(e) {
          return this.rotateOnAxis(yd, e);
        }
        translateOnAxis(e, t) {
          return _d.copy(e).applyQuaternion(this.quaternion), this.position.add(_d.multiplyScalar(t)), this;
        }
        translateX(e) {
          return this.translateOnAxis(vd, e);
        }
        translateY(e) {
          return this.translateOnAxis(xd, e);
        }
        translateZ(e) {
          return this.translateOnAxis(yd, e);
        }
        localToWorld(e) {
          return this.updateWorldMatrix(true, false), e.applyMatrix4(this.matrixWorld);
        }
        worldToLocal(e) {
          return this.updateWorldMatrix(true, false), e.applyMatrix4(Mn.copy(this.matrixWorld).invert());
        }
        lookAt(e, t, i) {
          e.isVector3 ? So.copy(e) : So.set(e, t, i);
          const r = this.parent;
          this.updateWorldMatrix(true, false), xa.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Mn.lookAt(xa, So, this.up) : Mn.lookAt(So, xa, this.up), this.quaternion.setFromRotationMatrix(Mn), r && (Mn.extractRotation(r.matrixWorld), hs.setFromRotationMatrix(Mn), this.quaternion.premultiply(hs.invert()));
        }
        add(e) {
          if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this;
          }
          return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(Md), ds.child = e, this.dispatchEvent(ds), ds.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
        }
        remove(e) {
          if (arguments.length > 1) {
            for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
            return this;
          }
          const t = this.children.indexOf(e);
          return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(M_), Cc.child = e, this.dispatchEvent(Cc), Cc.child = null), this;
        }
        removeFromParent() {
          const e = this.parent;
          return e !== null && e.remove(this), this;
        }
        clear() {
          return this.remove(...this.children);
        }
        attach(e) {
          return this.updateWorldMatrix(true, false), Mn.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(true, false), Mn.multiply(e.parent.matrixWorld)), e.applyMatrix4(Mn), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(false, true), e.dispatchEvent(Md), ds.child = e, this.dispatchEvent(ds), ds.child = null, this;
        }
        getObjectById(e) {
          return this.getObjectByProperty("id", e);
        }
        getObjectByName(e) {
          return this.getObjectByProperty("name", e);
        }
        getObjectByProperty(e, t) {
          if (this[e] === t) return this;
          for (let i = 0, r = this.children.length; i < r; i++) {
            const s = this.children[i].getObjectByProperty(e, t);
            if (s !== void 0) return s;
          }
        }
        getObjectsByProperty(e, t, i = []) {
          this[e] === t && i.push(this);
          const r = this.children;
          for (let s = 0, a = r.length; s < a; s++) r[s].getObjectsByProperty(e, t, i);
          return i;
        }
        getWorldPosition(e) {
          return this.updateWorldMatrix(true, false), e.setFromMatrixPosition(this.matrixWorld);
        }
        getWorldQuaternion(e) {
          return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(xa, e, x_), e;
        }
        getWorldScale(e) {
          return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(xa, y_, e), e;
        }
        getWorldDirection(e) {
          this.updateWorldMatrix(true, false);
          const t = this.matrixWorld.elements;
          return e.set(t[8], t[9], t[10]).normalize();
        }
        raycast() {
        }
        traverse(e) {
          e(this);
          const t = this.children;
          for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e);
        }
        traverseVisible(e) {
          if (this.visible === false) return;
          e(this);
          const t = this.children;
          for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e);
        }
        traverseAncestors(e) {
          const t = this.parent;
          t !== null && (e(t), t.traverseAncestors(e));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
        }
        updateMatrixWorld(e) {
          this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === true && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = false, e = true);
          const t = this.children;
          for (let i = 0, r = t.length; i < r; i++) t[i].updateMatrixWorld(e);
        }
        updateWorldMatrix(e, t) {
          const i = this.parent;
          if (e === true && i !== null && i.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === true && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === true) {
            const r = this.children;
            for (let s = 0, a = r.length; s < a; s++) r[s].updateWorldMatrix(false, true);
          }
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string", i = {};
          t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
          }, i.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
          });
          const r = {};
          r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === true && (r.castShadow = true), this.receiveShadow === true && (r.receiveShadow = true), this.visible === false && (r.visible = false), this.frustumCulled === false && (r.frustumCulled = false), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), r.up = this.up.toArray(), this.matrixAutoUpdate === false && (r.matrixAutoUpdate = false), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (r.type = "BatchedMesh", r.perObjectFrustumCulled = this.perObjectFrustumCulled, r.sortObjects = this.sortObjects, r.drawRanges = this._drawRanges, r.reservedRanges = this._reservedRanges, r.visibility = this._visibility, r.active = this._active, r.bounds = this._bounds.map((o) => ({
            boxInitialized: o.boxInitialized,
            boxMin: o.box.min.toArray(),
            boxMax: o.box.max.toArray(),
            sphereInitialized: o.sphereInitialized,
            sphereRadius: o.sphere.radius,
            sphereCenter: o.sphere.center.toArray()
          })), r.maxInstanceCount = this._maxInstanceCount, r.maxVertexCount = this._maxVertexCount, r.maxIndexCount = this._maxIndexCount, r.geometryInitialized = this._geometryInitialized, r.geometryCount = this._geometryCount, r.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (r.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (r.boundingSphere = {
            center: r.boundingSphere.center.toArray(),
            radius: r.boundingSphere.radius
          }), this.boundingBox !== null && (r.boundingBox = {
            min: r.boundingBox.min.toArray(),
            max: r.boundingBox.max.toArray()
          }));
          function s(o, l) {
            return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid;
          }
          if (this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true && (r.environment = this.environment.toJSON(e).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            r.geometry = s(e.geometries, this.geometry);
            const o = this.geometry.parameters;
            if (o !== void 0 && o.shapes !== void 0) {
              const l = o.shapes;
              if (Array.isArray(l)) for (let c = 0, u = l.length; c < u; c++) {
                const h = l[c];
                s(e.shapes, h);
              }
              else s(e.shapes, l);
            }
          }
          if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
            const o = [];
            for (let l = 0, c = this.material.length; l < c; l++) o.push(s(e.materials, this.material[l]));
            r.material = o;
          } else r.material = s(e.materials, this.material);
          if (this.children.length > 0) {
            r.children = [];
            for (let o = 0; o < this.children.length; o++) r.children.push(this.children[o].toJSON(e).object);
          }
          if (this.animations.length > 0) {
            r.animations = [];
            for (let o = 0; o < this.animations.length; o++) {
              const l = this.animations[o];
              r.animations.push(s(e.animations, l));
            }
          }
          if (t) {
            const o = a(e.geometries), l = a(e.materials), c = a(e.textures), u = a(e.images), h = a(e.shapes), d = a(e.skeletons), p = a(e.animations), f = a(e.nodes);
            o.length > 0 && (i.geometries = o), l.length > 0 && (i.materials = l), c.length > 0 && (i.textures = c), u.length > 0 && (i.images = u), h.length > 0 && (i.shapes = h), d.length > 0 && (i.skeletons = d), p.length > 0 && (i.animations = p), f.length > 0 && (i.nodes = f);
          }
          return i.object = r, i;
          function a(o) {
            const l = [];
            for (const c in o) {
              const u = o[c];
              delete u.metadata, l.push(u);
            }
            return l;
          }
        }
        clone(e) {
          return new this.constructor().copy(this, e);
        }
        copy(e, t = true) {
          if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === true) for (let i = 0; i < e.children.length; i++) {
            const r = e.children[i];
            this.add(r.clone());
          }
          return this;
        }
      }
      Tt.DEFAULT_UP = new D(0, 1, 0), Tt.DEFAULT_MATRIX_AUTO_UPDATE = true, Tt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
      const ji = new D(), Tn = new D(), Pc = new D(), bn = new D(), ps = new D(), fs = new D(), Td = new D(), Lc = new D(), Dc = new D(), Ic = new D(), Nc = new it(), Uc = new it(), Oc = new it();
      class qi {
        constructor(e = new D(), t = new D(), i = new D()) {
          this.a = e, this.b = t, this.c = i;
        }
        static getNormal(e, t, i, r) {
          r.subVectors(i, t), ji.subVectors(e, t), r.cross(ji);
          const s = r.lengthSq();
          return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
        }
        static getBarycoord(e, t, i, r, s) {
          ji.subVectors(r, t), Tn.subVectors(i, t), Pc.subVectors(e, t);
          const a = ji.dot(ji), o = ji.dot(Tn), l = ji.dot(Pc), c = Tn.dot(Tn), u = Tn.dot(Pc), h = a * c - o * o;
          if (h === 0) return s.set(0, 0, 0), null;
          const d = 1 / h, p = (c * l - o * u) * d, f = (a * u - o * l) * d;
          return s.set(1 - p - f, f, p);
        }
        static containsPoint(e, t, i, r) {
          return this.getBarycoord(e, t, i, r, bn) === null ? false : bn.x >= 0 && bn.y >= 0 && bn.x + bn.y <= 1;
        }
        static getInterpolation(e, t, i, r, s, a, o, l) {
          return this.getBarycoord(e, t, i, r, bn) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(s, bn.x), l.addScaledVector(a, bn.y), l.addScaledVector(o, bn.z), l);
        }
        static getInterpolatedAttribute(e, t, i, r, s, a) {
          return Nc.setScalar(0), Uc.setScalar(0), Oc.setScalar(0), Nc.fromBufferAttribute(e, t), Uc.fromBufferAttribute(e, i), Oc.fromBufferAttribute(e, r), a.setScalar(0), a.addScaledVector(Nc, s.x), a.addScaledVector(Uc, s.y), a.addScaledVector(Oc, s.z), a;
        }
        static isFrontFacing(e, t, i, r) {
          return ji.subVectors(i, t), Tn.subVectors(e, t), ji.cross(Tn).dot(r) < 0;
        }
        set(e, t, i) {
          return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
        }
        setFromPointsAndIndices(e, t, i, r) {
          return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this;
        }
        setFromAttributeAndIndices(e, t, i, r) {
          return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, r), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
        }
        getArea() {
          return ji.subVectors(this.c, this.b), Tn.subVectors(this.a, this.b), ji.cross(Tn).length() * 0.5;
        }
        getMidpoint(e) {
          return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
        }
        getNormal(e) {
          return qi.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
          return e.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(e, t) {
          return qi.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getInterpolation(e, t, i, r, s) {
          return qi.getInterpolation(e, this.a, this.b, this.c, t, i, r, s);
        }
        containsPoint(e) {
          return qi.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
          return qi.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
          return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
          const i = this.a, r = this.b, s = this.c;
          let a, o;
          ps.subVectors(r, i), fs.subVectors(s, i), Lc.subVectors(e, i);
          const l = ps.dot(Lc), c = fs.dot(Lc);
          if (l <= 0 && c <= 0) return t.copy(i);
          Dc.subVectors(e, r);
          const u = ps.dot(Dc), h = fs.dot(Dc);
          if (u >= 0 && h <= u) return t.copy(r);
          const d = l * h - u * c;
          if (d <= 0 && l >= 0 && u <= 0) return a = l / (l - u), t.copy(i).addScaledVector(ps, a);
          Ic.subVectors(e, s);
          const p = ps.dot(Ic), f = fs.dot(Ic);
          if (f >= 0 && p <= f) return t.copy(s);
          const _ = p * c - l * f;
          if (_ <= 0 && c >= 0 && f <= 0) return o = c / (c - f), t.copy(i).addScaledVector(fs, o);
          const g = u * f - p * h;
          if (g <= 0 && h - u >= 0 && p - f >= 0) return Td.subVectors(s, r), o = (h - u) / (h - u + (p - f)), t.copy(r).addScaledVector(Td, o);
          const m = 1 / (g + _ + d);
          return a = _ * m, o = d * m, t.copy(i).addScaledVector(ps, a).addScaledVector(fs, o);
        }
        equals(e) {
          return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
        }
      }
      const bd = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
      }, jn = {
        h: 0,
        s: 0,
        l: 0
      }, Eo = {
        h: 0,
        s: 0,
        l: 0
      };
      function Fc(n, e, t) {
        return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n;
      }
      class Ae {
        constructor(e, t, i) {
          return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, i);
        }
        set(e, t, i) {
          if (t === void 0 && i === void 0) {
            const r = e;
            r && r.isColor ? this.copy(r) : typeof r == "number" ? this.setHex(r) : typeof r == "string" && this.setStyle(r);
          } else this.setRGB(e, t, i);
          return this;
        }
        setScalar(e) {
          return this.r = e, this.g = e, this.b = e, this;
        }
        setHex(e, t = Kt) {
          return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Ke.toWorkingColorSpace(this, t), this;
        }
        setRGB(e, t, i, r = Ke.workingColorSpace) {
          return this.r = e, this.g = t, this.b = i, Ke.toWorkingColorSpace(this, r), this;
        }
        setHSL(e, t, i, r = Ke.workingColorSpace) {
          if (e = xc(e, 1), t = Ge(t, 0, 1), i = Ge(i, 0, 1), t === 0) this.r = this.g = this.b = i;
          else {
            const s = i <= 0.5 ? i * (1 + t) : i + t - i * t, a = 2 * i - s;
            this.r = Fc(a, s, e + 1 / 3), this.g = Fc(a, s, e), this.b = Fc(a, s, e - 1 / 3);
          }
          return Ke.toWorkingColorSpace(this, r), this;
        }
        setStyle(e, t = Kt) {
          function i(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
          }
          let r;
          if (r = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let s;
            const a = r[1], o = r[2];
            switch (a) {
              case "rgb":
              case "rgba":
                if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return i(s[4]), this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
                if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return i(s[4]), this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
                break;
              case "hsl":
              case "hsla":
                if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return i(s[4]), this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
                break;
              default:
                console.warn("THREE.Color: Unknown color model " + e);
            }
          } else if (r = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const s = r[1], a = s.length;
            if (a === 3) return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
            if (a === 6) return this.setHex(parseInt(s, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e);
          } else if (e && e.length > 0) return this.setColorName(e, t);
          return this;
        }
        setColorName(e, t = Kt) {
          const i = bd[e.toLowerCase()];
          return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this;
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(e) {
          return this.r = e.r, this.g = e.g, this.b = e.b, this;
        }
        copySRGBToLinear(e) {
          return this.r = _n(e.r), this.g = _n(e.g), this.b = _n(e.b), this;
        }
        copyLinearToSRGB(e) {
          return this.r = ss(e.r), this.g = ss(e.g), this.b = ss(e.b), this;
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(e = Kt) {
          return Ke.fromWorkingColorSpace(ei.copy(this), e), Math.round(Ge(ei.r * 255, 0, 255)) * 65536 + Math.round(Ge(ei.g * 255, 0, 255)) * 256 + Math.round(Ge(ei.b * 255, 0, 255));
        }
        getHexString(e = Kt) {
          return ("000000" + this.getHex(e).toString(16)).slice(-6);
        }
        getHSL(e, t = Ke.workingColorSpace) {
          Ke.fromWorkingColorSpace(ei.copy(this), t);
          const i = ei.r, r = ei.g, s = ei.b, a = Math.max(i, r, s), o = Math.min(i, r, s);
          let l, c;
          const u = (o + a) / 2;
          if (o === a) l = 0, c = 0;
          else {
            const h = a - o;
            switch (c = u <= 0.5 ? h / (a + o) : h / (2 - a - o), a) {
              case i:
                l = (r - s) / h + (r < s ? 6 : 0);
                break;
              case r:
                l = (s - i) / h + 2;
                break;
              case s:
                l = (i - r) / h + 4;
                break;
            }
            l /= 6;
          }
          return e.h = l, e.s = c, e.l = u, e;
        }
        getRGB(e, t = Ke.workingColorSpace) {
          return Ke.fromWorkingColorSpace(ei.copy(this), t), e.r = ei.r, e.g = ei.g, e.b = ei.b, e;
        }
        getStyle(e = Kt) {
          Ke.fromWorkingColorSpace(ei.copy(this), e);
          const t = ei.r, i = ei.g, r = ei.b;
          return e !== Kt ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(r * 255)})`;
        }
        offsetHSL(e, t, i) {
          return this.getHSL(jn), this.setHSL(jn.h + e, jn.s + t, jn.l + i);
        }
        add(e) {
          return this.r += e.r, this.g += e.g, this.b += e.b, this;
        }
        addColors(e, t) {
          return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
        }
        addScalar(e) {
          return this.r += e, this.g += e, this.b += e, this;
        }
        sub(e) {
          return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
        }
        multiply(e) {
          return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
        }
        multiplyScalar(e) {
          return this.r *= e, this.g *= e, this.b *= e, this;
        }
        lerp(e, t) {
          return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
        }
        lerpColors(e, t, i) {
          return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this;
        }
        lerpHSL(e, t) {
          this.getHSL(jn), e.getHSL(Eo);
          const i = fa(jn.h, Eo.h, t), r = fa(jn.s, Eo.s, t), s = fa(jn.l, Eo.l, t);
          return this.setHSL(i, r, s), this;
        }
        setFromVector3(e) {
          return this.r = e.x, this.g = e.y, this.b = e.z, this;
        }
        applyMatrix3(e) {
          const t = this.r, i = this.g, r = this.b, s = e.elements;
          return this.r = s[0] * t + s[3] * i + s[6] * r, this.g = s[1] * t + s[4] * i + s[7] * r, this.b = s[2] * t + s[5] * i + s[8] * r, this;
        }
        equals(e) {
          return e.r === this.r && e.g === this.g && e.b === this.b;
        }
        fromArray(e, t = 0) {
          return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
        }
        toArray(e = [], t = 0) {
          return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
        }
        fromBufferAttribute(e, t) {
          return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r, yield this.g, yield this.b;
        }
      }
      const ei = new Ae();
      Ae.NAMES = bd;
      let T_ = 0;
      class en extends is {
        constructor() {
          super(), this.isMaterial = true, Object.defineProperty(this, "id", {
            value: T_++
          }), this.uuid = Ii(), this.name = "", this.type = "Material", this.blending = Fn, this.side = ft, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.alphaHash = false, this.blendSrc = wl, this.blendDst = Al, this.blendEquation = lr, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Ae(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Yr, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = rd, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = ts, this.stencilZFail = ts, this.stencilZPass = ts, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.forceSinglePass = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(e) {
          this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
        }
        onBeforeRender() {
        }
        onBeforeCompile() {
        }
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(e) {
          if (e !== void 0) for (const t in e) {
            const i = e[t];
            if (i === void 0) {
              console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
              continue;
            }
            const r = this[t];
            if (r === void 0) {
              console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
              continue;
            }
            r && r.isColor ? r.set(i) : r && r.isVector3 && i && i.isVector3 ? r.copy(i) : this[t] = i;
          }
        }
        toJSON(e) {
          const t = e === void 0 || typeof e == "string";
          t && (e = {
            textures: {},
            images: {}
          });
          const i = {
            metadata: {
              version: 4.6,
              type: "Material",
              generator: "Material.toJSON"
            }
          };
          i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (i.dispersion = this.dispersion), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== Fn && (i.blending = this.blending), this.side !== ft && (i.side = this.side), this.vertexColors === true && (i.vertexColors = true), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === true && (i.transparent = true), this.blendSrc !== wl && (i.blendSrc = this.blendSrc), this.blendDst !== Al && (i.blendDst = this.blendDst), this.blendEquation !== lr && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== Yr && (i.depthFunc = this.depthFunc), this.depthTest === false && (i.depthTest = this.depthTest), this.depthWrite === false && (i.depthWrite = this.depthWrite), this.colorWrite === false && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== rd && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== ts && (i.stencilFail = this.stencilFail), this.stencilZFail !== ts && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== ts && (i.stencilZPass = this.stencilZPass), this.stencilWrite === true && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === true && (i.polygonOffset = true), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === true && (i.dithering = true), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === true && (i.alphaHash = true), this.alphaToCoverage === true && (i.alphaToCoverage = true), this.premultipliedAlpha === true && (i.premultipliedAlpha = true), this.forceSinglePass === true && (i.forceSinglePass = true), this.wireframe === true && (i.wireframe = true), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === true && (i.flatShading = true), this.visible === false && (i.visible = false), this.toneMapped === false && (i.toneMapped = false), this.fog === false && (i.fog = false), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
          function r(s) {
            const a = [];
            for (const o in s) {
              const l = s[o];
              delete l.metadata, a.push(l);
            }
            return a;
          }
          if (t) {
            const s = r(e.textures), a = r(e.images);
            s.length > 0 && (i.textures = s), a.length > 0 && (i.images = a);
          }
          return i;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
          const t = e.clippingPlanes;
          let i = null;
          if (t !== null) {
            const r = t.length;
            i = new Array(r);
            for (let s = 0; s !== r; ++s) i[s] = t[s].clone();
          }
          return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
        set needsUpdate(e) {
          e === true && this.version++;
        }
        onBuild() {
          console.warn("Material: onBuild() has been removed.");
        }
      }
      class tn extends en {
        constructor(e) {
          super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new Ae(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Qi(), this.combine = kh, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
        }
      }
      const Ot = new D(), wo = new ee();
      let b_ = 0;
      class li {
        constructor(e, t, i = false) {
          if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
          this.isBufferAttribute = true, Object.defineProperty(this, "id", {
            value: b_++
          }), this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i, this.usage = vc, this.updateRanges = [], this.gpuType = Vi, this.version = 0;
        }
        onUploadCallback() {
        }
        set needsUpdate(e) {
          e === true && this.version++;
        }
        setUsage(e) {
          return this.usage = e, this;
        }
        addUpdateRange(e, t) {
          this.updateRanges.push({
            start: e,
            count: t
          });
        }
        clearUpdateRanges() {
          this.updateRanges.length = 0;
        }
        copy(e) {
          return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
        }
        copyAt(e, t, i) {
          e *= this.itemSize, i *= t.itemSize;
          for (let r = 0, s = this.itemSize; r < s; r++) this.array[e + r] = t.array[i + r];
          return this;
        }
        copyArray(e) {
          return this.array.set(e), this;
        }
        applyMatrix3(e) {
          if (this.itemSize === 2) for (let t = 0, i = this.count; t < i; t++) wo.fromBufferAttribute(this, t), wo.applyMatrix3(e), this.setXY(t, wo.x, wo.y);
          else if (this.itemSize === 3) for (let t = 0, i = this.count; t < i; t++) Ot.fromBufferAttribute(this, t), Ot.applyMatrix3(e), this.setXYZ(t, Ot.x, Ot.y, Ot.z);
          return this;
        }
        applyMatrix4(e) {
          for (let t = 0, i = this.count; t < i; t++) Ot.fromBufferAttribute(this, t), Ot.applyMatrix4(e), this.setXYZ(t, Ot.x, Ot.y, Ot.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, i = this.count; t < i; t++) Ot.fromBufferAttribute(this, t), Ot.applyNormalMatrix(e), this.setXYZ(t, Ot.x, Ot.y, Ot.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, i = this.count; t < i; t++) Ot.fromBufferAttribute(this, t), Ot.transformDirection(e), this.setXYZ(t, Ot.x, Ot.y, Ot.z);
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        getComponent(e, t) {
          let i = this.array[e * this.itemSize + t];
          return this.normalized && (i = Hi(i, this.array)), i;
        }
        setComponent(e, t, i) {
          return this.normalized && (i = at(i, this.array)), this.array[e * this.itemSize + t] = i, this;
        }
        getX(e) {
          let t = this.array[e * this.itemSize];
          return this.normalized && (t = Hi(t, this.array)), t;
        }
        setX(e, t) {
          return this.normalized && (t = at(t, this.array)), this.array[e * this.itemSize] = t, this;
        }
        getY(e) {
          let t = this.array[e * this.itemSize + 1];
          return this.normalized && (t = Hi(t, this.array)), t;
        }
        setY(e, t) {
          return this.normalized && (t = at(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
        }
        getZ(e) {
          let t = this.array[e * this.itemSize + 2];
          return this.normalized && (t = Hi(t, this.array)), t;
        }
        setZ(e, t) {
          return this.normalized && (t = at(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
        }
        getW(e) {
          let t = this.array[e * this.itemSize + 3];
          return this.normalized && (t = Hi(t, this.array)), t;
        }
        setW(e, t) {
          return this.normalized && (t = at(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
        }
        setXY(e, t, i) {
          return e *= this.itemSize, this.normalized && (t = at(t, this.array), i = at(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this;
        }
        setXYZ(e, t, i, r) {
          return e *= this.itemSize, this.normalized && (t = at(t, this.array), i = at(i, this.array), r = at(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this;
        }
        setXYZW(e, t, i, r, s) {
          return e *= this.itemSize, this.normalized && (t = at(t, this.array), i = at(i, this.array), r = at(r, this.array), s = at(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = r, this.array[e + 3] = s, this;
        }
        onUpload(e) {
          return this.onUploadCallback = e, this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
          };
          return this.name !== "" && (e.name = this.name), this.usage !== vc && (e.usage = this.usage), e;
        }
      }
      class Sd extends li {
        constructor(e, t, i) {
          super(new Uint16Array(e), t, i);
        }
      }
      class Ed extends li {
        constructor(e, t, i) {
          super(new Uint32Array(e), t, i);
        }
      }
      class Zt extends li {
        constructor(e, t, i) {
          super(new Float32Array(e), t, i);
        }
      }
      let S_ = 0;
      const Ni = new Fe(), Bc = new Tt(), ms = new D(), bi = new vn(), ya = new vn(), qt = new D();
      class mi extends is {
        constructor() {
          super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", {
            value: S_++
          }), this.uuid = Ii(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
          }, this.userData = {};
        }
        getIndex() {
          return this.index;
        }
        setIndex(e) {
          return Array.isArray(e) ? this.index = new (ld(e) ? Ed : Sd)(e, 1) : this.index = e, this;
        }
        setIndirect(e) {
          return this.indirect = e, this;
        }
        getIndirect() {
          return this.indirect;
        }
        getAttribute(e) {
          return this.attributes[e];
        }
        setAttribute(e, t) {
          return this.attributes[e] = t, this;
        }
        deleteAttribute(e) {
          return delete this.attributes[e], this;
        }
        hasAttribute(e) {
          return this.attributes[e] !== void 0;
        }
        addGroup(e, t, i = 0) {
          this.groups.push({
            start: e,
            count: t,
            materialIndex: i
          });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(e, t) {
          this.drawRange.start = e, this.drawRange.count = t;
        }
        applyMatrix4(e) {
          const t = this.attributes.position;
          t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = true);
          const i = this.attributes.normal;
          if (i !== void 0) {
            const s = new ze().getNormalMatrix(e);
            i.applyNormalMatrix(s), i.needsUpdate = true;
          }
          const r = this.attributes.tangent;
          return r !== void 0 && (r.transformDirection(e), r.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
        }
        applyQuaternion(e) {
          return Ni.makeRotationFromQuaternion(e), this.applyMatrix4(Ni), this;
        }
        rotateX(e) {
          return Ni.makeRotationX(e), this.applyMatrix4(Ni), this;
        }
        rotateY(e) {
          return Ni.makeRotationY(e), this.applyMatrix4(Ni), this;
        }
        rotateZ(e) {
          return Ni.makeRotationZ(e), this.applyMatrix4(Ni), this;
        }
        translate(e, t, i) {
          return Ni.makeTranslation(e, t, i), this.applyMatrix4(Ni), this;
        }
        scale(e, t, i) {
          return Ni.makeScale(e, t, i), this.applyMatrix4(Ni), this;
        }
        lookAt(e) {
          return Bc.lookAt(e), Bc.updateMatrix(), this.applyMatrix4(Bc.matrix), this;
        }
        center() {
          return this.computeBoundingBox(), this.boundingBox.getCenter(ms).negate(), this.translate(ms.x, ms.y, ms.z), this;
        }
        setFromPoints(e) {
          const t = this.getAttribute("position");
          if (t === void 0) {
            const i = [];
            for (let r = 0, s = e.length; r < s; r++) {
              const a = e[r];
              i.push(a.x, a.y, a.z || 0);
            }
            this.setAttribute("position", new Zt(i, 3));
          } else {
            const i = Math.min(e.length, t.count);
            for (let r = 0; r < i; r++) {
              const s = e[r];
              t.setXYZ(r, s.x, s.y, s.z || 0);
            }
            e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), t.needsUpdate = true;
          }
          return this;
        }
        computeBoundingBox() {
          this.boundingBox === null && (this.boundingBox = new vn());
          const e = this.attributes.position, t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new D(-1 / 0, -1 / 0, -1 / 0), new D(1 / 0, 1 / 0, 1 / 0));
            return;
          }
          if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e), t) for (let i = 0, r = t.length; i < r; i++) {
              const s = t[i];
              bi.setFromBufferAttribute(s), this.morphTargetsRelative ? (qt.addVectors(this.boundingBox.min, bi.min), this.boundingBox.expandByPoint(qt), qt.addVectors(this.boundingBox.max, bi.max), this.boundingBox.expandByPoint(qt)) : (this.boundingBox.expandByPoint(bi.min), this.boundingBox.expandByPoint(bi.max));
            }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
        computeBoundingSphere() {
          this.boundingSphere === null && (this.boundingSphere = new $i());
          const e = this.attributes.position, t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new D(), 1 / 0);
            return;
          }
          if (e) {
            const i = this.boundingSphere.center;
            if (bi.setFromBufferAttribute(e), t) for (let s = 0, a = t.length; s < a; s++) {
              const o = t[s];
              ya.setFromBufferAttribute(o), this.morphTargetsRelative ? (qt.addVectors(bi.min, ya.min), bi.expandByPoint(qt), qt.addVectors(bi.max, ya.max), bi.expandByPoint(qt)) : (bi.expandByPoint(ya.min), bi.expandByPoint(ya.max));
            }
            bi.getCenter(i);
            let r = 0;
            for (let s = 0, a = e.count; s < a; s++) qt.fromBufferAttribute(e, s), r = Math.max(r, i.distanceToSquared(qt));
            if (t) for (let s = 0, a = t.length; s < a; s++) {
              const o = t[s], l = this.morphTargetsRelative;
              for (let c = 0, u = o.count; c < u; c++) qt.fromBufferAttribute(o, c), l && (ms.fromBufferAttribute(e, c), qt.add(ms)), r = Math.max(r, i.distanceToSquared(qt));
            }
            this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        }
        computeTangents() {
          const e = this.index, t = this.attributes;
          if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return;
          }
          const i = t.position, r = t.normal, s = t.uv;
          this.hasAttribute("tangent") === false && this.setAttribute("tangent", new li(new Float32Array(4 * i.count), 4));
          const a = this.getAttribute("tangent"), o = [], l = [];
          for (let R = 0; R < i.count; R++) o[R] = new D(), l[R] = new D();
          const c = new D(), u = new D(), h = new D(), d = new ee(), p = new ee(), f = new ee(), _ = new D(), g = new D();
          function m(R, S, T) {
            c.fromBufferAttribute(i, R), u.fromBufferAttribute(i, S), h.fromBufferAttribute(i, T), d.fromBufferAttribute(s, R), p.fromBufferAttribute(s, S), f.fromBufferAttribute(s, T), u.sub(c), h.sub(c), p.sub(d), f.sub(d);
            const L = 1 / (p.x * f.y - f.x * p.y);
            isFinite(L) && (_.copy(u).multiplyScalar(f.y).addScaledVector(h, -p.y).multiplyScalar(L), g.copy(h).multiplyScalar(p.x).addScaledVector(u, -f.x).multiplyScalar(L), o[R].add(_), o[S].add(_), o[T].add(_), l[R].add(g), l[S].add(g), l[T].add(g));
          }
          let y = this.groups;
          y.length === 0 && (y = [
            {
              start: 0,
              count: e.count
            }
          ]);
          for (let R = 0, S = y.length; R < S; ++R) {
            const T = y[R], L = T.start, B = T.count;
            for (let F = L, H = L + B; F < H; F += 3) m(e.getX(F + 0), e.getX(F + 1), e.getX(F + 2));
          }
          const x = new D(), v = new D(), A = new D(), E = new D();
          function w(R) {
            A.fromBufferAttribute(r, R), E.copy(A);
            const S = o[R];
            x.copy(S), x.sub(A.multiplyScalar(A.dot(S))).normalize(), v.crossVectors(E, S);
            const T = v.dot(l[R]) < 0 ? -1 : 1;
            a.setXYZW(R, x.x, x.y, x.z, T);
          }
          for (let R = 0, S = y.length; R < S; ++R) {
            const T = y[R], L = T.start, B = T.count;
            for (let F = L, H = L + B; F < H; F += 3) w(e.getX(F + 0)), w(e.getX(F + 1)), w(e.getX(F + 2));
          }
        }
        computeVertexNormals() {
          const e = this.index, t = this.getAttribute("position");
          if (t !== void 0) {
            let i = this.getAttribute("normal");
            if (i === void 0) i = new li(new Float32Array(t.count * 3), 3), this.setAttribute("normal", i);
            else for (let d = 0, p = i.count; d < p; d++) i.setXYZ(d, 0, 0, 0);
            const r = new D(), s = new D(), a = new D(), o = new D(), l = new D(), c = new D(), u = new D(), h = new D();
            if (e) for (let d = 0, p = e.count; d < p; d += 3) {
              const f = e.getX(d + 0), _ = e.getX(d + 1), g = e.getX(d + 2);
              r.fromBufferAttribute(t, f), s.fromBufferAttribute(t, _), a.fromBufferAttribute(t, g), u.subVectors(a, s), h.subVectors(r, s), u.cross(h), o.fromBufferAttribute(i, f), l.fromBufferAttribute(i, _), c.fromBufferAttribute(i, g), o.add(u), l.add(u), c.add(u), i.setXYZ(f, o.x, o.y, o.z), i.setXYZ(_, l.x, l.y, l.z), i.setXYZ(g, c.x, c.y, c.z);
            }
            else for (let d = 0, p = t.count; d < p; d += 3) r.fromBufferAttribute(t, d + 0), s.fromBufferAttribute(t, d + 1), a.fromBufferAttribute(t, d + 2), u.subVectors(a, s), h.subVectors(r, s), u.cross(h), i.setXYZ(d + 0, u.x, u.y, u.z), i.setXYZ(d + 1, u.x, u.y, u.z), i.setXYZ(d + 2, u.x, u.y, u.z);
            this.normalizeNormals(), i.needsUpdate = true;
          }
        }
        normalizeNormals() {
          const e = this.attributes.normal;
          for (let t = 0, i = e.count; t < i; t++) qt.fromBufferAttribute(e, t), qt.normalize(), e.setXYZ(t, qt.x, qt.y, qt.z);
        }
        toNonIndexed() {
          function e(o, l) {
            const c = o.array, u = o.itemSize, h = o.normalized, d = new c.constructor(l.length * u);
            let p = 0, f = 0;
            for (let _ = 0, g = l.length; _ < g; _++) {
              o.isInterleavedBufferAttribute ? p = l[_] * o.data.stride + o.offset : p = l[_] * u;
              for (let m = 0; m < u; m++) d[f++] = c[p++];
            }
            return new li(d, u, h);
          }
          if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
          const t = new mi(), i = this.index.array, r = this.attributes;
          for (const o in r) {
            const l = r[o], c = e(l, i);
            t.setAttribute(o, c);
          }
          const s = this.morphAttributes;
          for (const o in s) {
            const l = [], c = s[o];
            for (let u = 0, h = c.length; u < h; u++) {
              const d = c[u], p = e(d, i);
              l.push(p);
            }
            t.morphAttributes[o] = l;
          }
          t.morphTargetsRelative = this.morphTargetsRelative;
          const a = this.groups;
          for (let o = 0, l = a.length; o < l; o++) {
            const c = a[o];
            t.addGroup(c.start, c.count, c.materialIndex);
          }
          return t;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.6,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON"
            }
          };
          if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
            const l = this.parameters;
            for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
            return e;
          }
          e.data = {
            attributes: {}
          };
          const t = this.index;
          t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
          });
          const i = this.attributes;
          for (const l in i) {
            const c = i[l];
            e.data.attributes[l] = c.toJSON(e.data);
          }
          const r = {};
          let s = false;
          for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l], u = [];
            for (let h = 0, d = c.length; h < d; h++) {
              const p = c[h];
              u.push(p.toJSON(e.data));
            }
            u.length > 0 && (r[l] = u, s = true);
          }
          s && (e.data.morphAttributes = r, e.data.morphTargetsRelative = this.morphTargetsRelative);
          const a = this.groups;
          a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
          const o = this.boundingSphere;
          return o !== null && (e.data.boundingSphere = {
            center: o.center.toArray(),
            radius: o.radius
          }), e;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
          const t = {};
          this.name = e.name;
          const i = e.index;
          i !== null && this.setIndex(i.clone(t));
          const r = e.attributes;
          for (const c in r) {
            const u = r[c];
            this.setAttribute(c, u.clone(t));
          }
          const s = e.morphAttributes;
          for (const c in s) {
            const u = [], h = s[c];
            for (let d = 0, p = h.length; d < p; d++) u.push(h[d].clone(t));
            this.morphAttributes[c] = u;
          }
          this.morphTargetsRelative = e.morphTargetsRelative;
          const a = e.groups;
          for (let c = 0, u = a.length; c < u; c++) {
            const h = a[c];
            this.addGroup(h.start, h.count, h.materialIndex);
          }
          const o = e.boundingBox;
          o !== null && (this.boundingBox = o.clone());
          const l = e.boundingSphere;
          return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
        }
        dispose() {
          this.dispatchEvent({
            type: "dispose"
          });
        }
      }
      const wd = new Fe(), dr = new va(), Ao = new $i(), Ad = new D(), Ro = new D(), Co = new D(), Po = new D(), zc = new D(), Lo = new D(), Rd = new D(), Do = new D();
      class Dt extends Tt {
        constructor(e = new mi(), t = new tn()) {
          super(), this.isMesh = true, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
        }
        copy(e, t) {
          return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
        }
        updateMorphTargets() {
          const e = this.geometry.morphAttributes, t = Object.keys(e);
          if (t.length > 0) {
            const i = e[t[0]];
            if (i !== void 0) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let r = 0, s = i.length; r < s; r++) {
                const a = i[r].name || String(r);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
              }
            }
          }
        }
        getVertexPosition(e, t) {
          const i = this.geometry, r = i.attributes.position, s = i.morphAttributes.position, a = i.morphTargetsRelative;
          t.fromBufferAttribute(r, e);
          const o = this.morphTargetInfluences;
          if (s && o) {
            Lo.set(0, 0, 0);
            for (let l = 0, c = s.length; l < c; l++) {
              const u = o[l], h = s[l];
              u !== 0 && (zc.fromBufferAttribute(h, e), a ? Lo.addScaledVector(zc, u) : Lo.addScaledVector(zc.sub(t), u));
            }
            t.add(Lo);
          }
          return t;
        }
        raycast(e, t) {
          const i = this.geometry, r = this.material, s = this.matrixWorld;
          r !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), Ao.copy(i.boundingSphere), Ao.applyMatrix4(s), dr.copy(e.ray).recast(e.near), !(Ao.containsPoint(dr.origin) === false && (dr.intersectSphere(Ao, Ad) === null || dr.origin.distanceToSquared(Ad) > (e.far - e.near) ** 2)) && (wd.copy(s).invert(), dr.copy(e.ray).applyMatrix4(wd), !(i.boundingBox !== null && dr.intersectsBox(i.boundingBox) === false) && this._computeIntersections(e, t, dr)));
        }
        _computeIntersections(e, t, i) {
          let r;
          const s = this.geometry, a = this.material, o = s.index, l = s.attributes.position, c = s.attributes.uv, u = s.attributes.uv1, h = s.attributes.normal, d = s.groups, p = s.drawRange;
          if (o !== null) if (Array.isArray(a)) for (let f = 0, _ = d.length; f < _; f++) {
            const g = d[f], m = a[g.materialIndex], y = Math.max(g.start, p.start), x = Math.min(o.count, Math.min(g.start + g.count, p.start + p.count));
            for (let v = y, A = x; v < A; v += 3) {
              const E = o.getX(v), w = o.getX(v + 1), R = o.getX(v + 2);
              r = Io(this, m, e, i, c, u, h, E, w, R), r && (r.faceIndex = Math.floor(v / 3), r.face.materialIndex = g.materialIndex, t.push(r));
            }
          }
          else {
            const f = Math.max(0, p.start), _ = Math.min(o.count, p.start + p.count);
            for (let g = f, m = _; g < m; g += 3) {
              const y = o.getX(g), x = o.getX(g + 1), v = o.getX(g + 2);
              r = Io(this, a, e, i, c, u, h, y, x, v), r && (r.faceIndex = Math.floor(g / 3), t.push(r));
            }
          }
          else if (l !== void 0) if (Array.isArray(a)) for (let f = 0, _ = d.length; f < _; f++) {
            const g = d[f], m = a[g.materialIndex], y = Math.max(g.start, p.start), x = Math.min(l.count, Math.min(g.start + g.count, p.start + p.count));
            for (let v = y, A = x; v < A; v += 3) {
              const E = v, w = v + 1, R = v + 2;
              r = Io(this, m, e, i, c, u, h, E, w, R), r && (r.faceIndex = Math.floor(v / 3), r.face.materialIndex = g.materialIndex, t.push(r));
            }
          }
          else {
            const f = Math.max(0, p.start), _ = Math.min(l.count, p.start + p.count);
            for (let g = f, m = _; g < m; g += 3) {
              const y = g, x = g + 1, v = g + 2;
              r = Io(this, a, e, i, c, u, h, y, x, v), r && (r.faceIndex = Math.floor(g / 3), t.push(r));
            }
          }
        }
      }
      function E_(n, e, t, i, r, s, a, o) {
        let l;
        if (e.side === Lt ? l = i.intersectTriangle(a, s, r, true, o) : l = i.intersectTriangle(r, s, a, e.side === ft, o), l === null) return null;
        Do.copy(o), Do.applyMatrix4(n.matrixWorld);
        const c = t.ray.origin.distanceTo(Do);
        return c < t.near || c > t.far ? null : {
          distance: c,
          point: Do.clone(),
          object: n
        };
      }
      function Io(n, e, t, i, r, s, a, o, l, c) {
        n.getVertexPosition(o, Ro), n.getVertexPosition(l, Co), n.getVertexPosition(c, Po);
        const u = E_(n, e, t, i, Ro, Co, Po, Rd);
        if (u) {
          const h = new D();
          qi.getBarycoord(Rd, Ro, Co, Po, h), r && (u.uv = qi.getInterpolatedAttribute(r, o, l, c, h, new ee())), s && (u.uv1 = qi.getInterpolatedAttribute(s, o, l, c, h, new ee())), a && (u.normal = qi.getInterpolatedAttribute(a, o, l, c, h, new D()), u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
          const d = {
            a: o,
            b: l,
            c,
            normal: new D(),
            materialIndex: 0
          };
          qi.getNormal(Ro, Co, Po, d.normal), u.face = d, u.barycoord = h;
        }
        return u;
      }
      class pr extends mi {
        constructor(e = 1, t = 1, i = 1, r = 1, s = 1, a = 1) {
          super(), this.type = "BoxGeometry", this.parameters = {
            width: e,
            height: t,
            depth: i,
            widthSegments: r,
            heightSegments: s,
            depthSegments: a
          };
          const o = this;
          r = Math.floor(r), s = Math.floor(s), a = Math.floor(a);
          const l = [], c = [], u = [], h = [];
          let d = 0, p = 0;
          f("z", "y", "x", -1, -1, i, t, e, a, s, 0), f("z", "y", "x", 1, -1, i, t, -e, a, s, 1), f("x", "z", "y", 1, 1, e, i, t, r, a, 2), f("x", "z", "y", 1, -1, e, i, -t, r, a, 3), f("x", "y", "z", 1, -1, e, t, i, r, s, 4), f("x", "y", "z", -1, -1, e, t, -i, r, s, 5), this.setIndex(l), this.setAttribute("position", new Zt(c, 3)), this.setAttribute("normal", new Zt(u, 3)), this.setAttribute("uv", new Zt(h, 2));
          function f(_, g, m, y, x, v, A, E, w, R, S) {
            const T = v / w, L = A / R, B = v / 2, F = A / 2, H = E / 2, X = w + 1, k = R + 1;
            let K = 0, G = 0;
            const ie = new D();
            for (let ue = 0; ue < k; ue++) {
              const we = ue * L - F;
              for (let Be = 0; Be < X; Be++) {
                const We = Be * T - B;
                ie[_] = We * y, ie[g] = we * x, ie[m] = H, c.push(ie.x, ie.y, ie.z), ie[_] = 0, ie[g] = 0, ie[m] = E > 0 ? 1 : -1, u.push(ie.x, ie.y, ie.z), h.push(Be / w), h.push(1 - ue / R), K += 1;
              }
            }
            for (let ue = 0; ue < R; ue++) for (let we = 0; we < w; we++) {
              const Be = d + we + X * ue, We = d + we + X * (ue + 1), j = d + (we + 1) + X * (ue + 1), ne = d + (we + 1) + X * ue;
              l.push(Be, We, ne), l.push(We, j, ne), G += 6;
            }
            o.addGroup(p, G, S), p += G, d += K;
          }
        }
        copy(e) {
          return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
          return new pr(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
        }
      }
      function gs(n) {
        const e = {};
        for (const t in n) {
          e[t] = {};
          for (const i in n[t]) {
            const r = n[t][i];
            r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? r.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][i] = null) : e[t][i] = r.clone() : Array.isArray(r) ? e[t][i] = r.slice() : e[t][i] = r;
          }
        }
        return e;
      }
      function ci(n) {
        const e = {};
        for (let t = 0; t < n.length; t++) {
          const i = gs(n[t]);
          for (const r in i) e[r] = i[r];
        }
        return e;
      }
      function w_(n) {
        const e = [];
        for (let t = 0; t < n.length; t++) e.push(n[t].clone());
        return e;
      }
      function Cd(n) {
        const e = n.getRenderTarget();
        return e === null ? n.outputColorSpace : e.isXRRenderTarget === true ? e.texture.colorSpace : Ke.workingColorSpace;
      }
      const No = {
        clone: gs,
        merge: ci
      };
      var A_ = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, R_ = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
      class ti extends en {
        constructor(e) {
          super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = A_, this.fragmentShader = R_, this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.forceSinglePass = true, this.extensions = {
            clipCullDistance: false,
            multiDraw: false
          }, this.defaultAttributeValues = {
            color: [
              1,
              1,
              1
            ],
            uv: [
              0,
              0
            ],
            uv1: [
              0,
              0
            ]
          }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, e !== void 0 && this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = gs(e.uniforms), this.uniformsGroups = w_(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          t.glslVersion = this.glslVersion, t.uniforms = {};
          for (const r in this.uniforms) {
            const s = this.uniforms[r].value;
            s && s.isTexture ? t.uniforms[r] = {
              type: "t",
              value: s.toJSON(e).uuid
            } : s && s.isColor ? t.uniforms[r] = {
              type: "c",
              value: s.getHex()
            } : s && s.isVector2 ? t.uniforms[r] = {
              type: "v2",
              value: s.toArray()
            } : s && s.isVector3 ? t.uniforms[r] = {
              type: "v3",
              value: s.toArray()
            } : s && s.isVector4 ? t.uniforms[r] = {
              type: "v4",
              value: s.toArray()
            } : s && s.isMatrix3 ? t.uniforms[r] = {
              type: "m3",
              value: s.toArray()
            } : s && s.isMatrix4 ? t.uniforms[r] = {
              type: "m4",
              value: s.toArray()
            } : t.uniforms[r] = {
              value: s
            };
          }
          Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
          const i = {};
          for (const r in this.extensions) this.extensions[r] === true && (i[r] = true);
          return Object.keys(i).length > 0 && (t.extensions = i), t;
        }
      }
      class Pd extends Tt {
        constructor() {
          super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new Fe(), this.projectionMatrix = new Fe(), this.projectionMatrixInverse = new Fe(), this.coordinateSystem = gn;
        }
        copy(e, t) {
          return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
        }
        getWorldDirection(e) {
          return super.getWorldDirection(e).negate();
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(e, t) {
          super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const qn = new D(), Ld = new ee(), Dd = new ee();
      class ui extends Pd {
        constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
          super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = r, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
        }
        copy(e, t) {
          return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
        }
        setFocalLength(e) {
          const t = 0.5 * this.getFilmHeight() / e;
          this.fov = ns * 2 * Math.atan(t), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const e = Math.tan(pa * 0.5 * this.fov);
          return 0.5 * this.getFilmHeight() / e;
        }
        getEffectiveFOV() {
          return ns * 2 * Math.atan(Math.tan(pa * 0.5 * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        getViewBounds(e, t, i) {
          qn.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(qn.x, qn.y).multiplyScalar(-e / qn.z), qn.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(qn.x, qn.y).multiplyScalar(-e / qn.z);
        }
        getViewSize(e, t) {
          return this.getViewBounds(e, Ld, Dd), t.subVectors(Dd, Ld);
        }
        setViewOffset(e, t, i, r, s, a) {
          this.aspect = e / t, this.view === null && (this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = this.near;
          let t = e * Math.tan(pa * 0.5 * this.fov) / this.zoom, i = 2 * t, r = this.aspect * i, s = -0.5 * r;
          const a = this.view;
          if (this.view !== null && this.view.enabled) {
            const l = a.fullWidth, c = a.fullHeight;
            s += a.offsetX * r / l, t -= a.offsetY * i / c, r *= a.width / l, i *= a.height / c;
          }
          const o = this.filmOffset;
          o !== 0 && (s += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
        }
      }
      const _s = -90, vs = 1;
      class C_ extends Tt {
        constructor(e, t, i) {
          super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
          const r = new ui(_s, vs, e, t);
          r.layers = this.layers, this.add(r);
          const s = new ui(_s, vs, e, t);
          s.layers = this.layers, this.add(s);
          const a = new ui(_s, vs, e, t);
          a.layers = this.layers, this.add(a);
          const o = new ui(_s, vs, e, t);
          o.layers = this.layers, this.add(o);
          const l = new ui(_s, vs, e, t);
          l.layers = this.layers, this.add(l);
          const c = new ui(_s, vs, e, t);
          c.layers = this.layers, this.add(c);
        }
        updateCoordinateSystem() {
          const e = this.coordinateSystem, t = this.children.concat(), [i, r, s, a, o, l] = t;
          for (const c of t) this.remove(c);
          if (e === gn) i.up.set(0, 1, 0), i.lookAt(1, 0, 0), r.up.set(0, 1, 0), r.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
          else if (e === _o) i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), r.up.set(0, -1, 0), r.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
          else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
          for (const c of t) this.add(c), c.updateMatrixWorld();
        }
        update(e, t) {
          this.parent === null && this.updateMatrixWorld();
          const { renderTarget: i, activeMipmapLevel: r } = this;
          this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
          const [s, a, o, l, c, u] = this.children, h = e.getRenderTarget(), d = e.getActiveCubeFace(), p = e.getActiveMipmapLevel(), f = e.xr.enabled;
          e.xr.enabled = false;
          const _ = i.texture.generateMipmaps;
          i.texture.generateMipmaps = false, e.setRenderTarget(i, 0, r), e.render(t, s), e.setRenderTarget(i, 1, r), e.render(t, a), e.setRenderTarget(i, 2, r), e.render(t, o), e.setRenderTarget(i, 3, r), e.render(t, l), e.setRenderTarget(i, 4, r), e.render(t, c), i.texture.generateMipmaps = _, e.setRenderTarget(i, 5, r), e.render(t, u), e.setRenderTarget(h, d, p), e.xr.enabled = f, i.texture.needsPMREMUpdate = true;
        }
      }
      class Id extends kt {
        constructor(e, t, i, r, s, a, o, l, c, u) {
          e = e !== void 0 ? e : [], t = t !== void 0 ? t : Kr, super(e, t, i, r, s, a, o, l, c, u), this.isCubeTexture = true, this.flipY = false;
        }
        get images() {
          return this.image;
        }
        set images(e) {
          this.image = e;
        }
      }
      class P_ extends Gi {
        constructor(e = 1, t = {}) {
          super(e, e, t), this.isWebGLCubeRenderTarget = true;
          const i = {
            width: e,
            height: e,
            depth: 1
          }, r = [
            i,
            i,
            i,
            i,
            i,
            i
          ];
          this.texture = new Id(r, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : false, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Mi;
        }
        fromEquirectangularTexture(e, t) {
          this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
          const i = {
            uniforms: {
              tEquirect: {
                value: null
              }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
          }, r = new pr(5, 5, 5), s = new ti({
            name: "CubemapFromEquirect",
            uniforms: gs(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: Lt,
            blending: jt
          });
          s.uniforms.tEquirect.value = t;
          const a = new Dt(r, s), o = t.minFilter;
          return t.minFilter === pn && (t.minFilter = Mi), new C_(1, 10, this).update(e, a), t.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
        }
        clear(e, t, i, r) {
          const s = e.getRenderTarget();
          for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, i, r);
          e.setRenderTarget(s);
        }
      }
      class Yn extends Tt {
        constructor() {
          super(), this.isGroup = true, this.type = "Group";
        }
      }
      const L_ = {
        type: "move"
      };
      class kc {
        constructor() {
          this._targetRay = null, this._grip = null, this._hand = null;
        }
        getHandSpace() {
          return this._hand === null && (this._hand = new Yn(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = {
            pinching: false
          }), this._hand;
        }
        getTargetRaySpace() {
          return this._targetRay === null && (this._targetRay = new Yn(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new D(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new D()), this._targetRay;
        }
        getGripSpace() {
          return this._grip === null && (this._grip = new Yn(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new D(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new D()), this._grip;
        }
        dispatchEvent(e) {
          return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
        }
        connect(e) {
          if (e && e.hand) {
            const t = this._hand;
            if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
          }
          return this.dispatchEvent({
            type: "connected",
            data: e
          }), this;
        }
        disconnect(e) {
          return this.dispatchEvent({
            type: "disconnected",
            data: e
          }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
        }
        update(e, t, i) {
          let r = null, s = null, a = null;
          const o = this._targetRay, l = this._grip, c = this._hand;
          if (e && t.session.visibilityState !== "visible-blurred") {
            if (c && e.hand) {
              a = true;
              for (const _ of e.hand.values()) {
                const g = t.getJointPose(_, i), m = this._getHandJoint(c, _);
                g !== null && (m.matrix.fromArray(g.transform.matrix), m.matrix.decompose(m.position, m.rotation, m.scale), m.matrixWorldNeedsUpdate = true, m.jointRadius = g.radius), m.visible = g !== null;
              }
              const u = c.joints["index-finger-tip"], h = c.joints["thumb-tip"], d = u.position.distanceTo(h.position), p = 0.02, f = 5e-3;
              c.inputState.pinching && d > p + f ? (c.inputState.pinching = false, this.dispatchEvent({
                type: "pinchend",
                handedness: e.handedness,
                target: this
              })) : !c.inputState.pinching && d <= p - f && (c.inputState.pinching = true, this.dispatchEvent({
                type: "pinchstart",
                handedness: e.handedness,
                target: this
              }));
            } else l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, i), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = true, s.linearVelocity ? (l.hasLinearVelocity = true, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = false, s.angularVelocity ? (l.hasAngularVelocity = true, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = false));
            o !== null && (r = t.getPose(e.targetRaySpace, i), r === null && s !== null && (r = s), r !== null && (o.matrix.fromArray(r.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = true, r.linearVelocity ? (o.hasLinearVelocity = true, o.linearVelocity.copy(r.linearVelocity)) : o.hasLinearVelocity = false, r.angularVelocity ? (o.hasAngularVelocity = true, o.angularVelocity.copy(r.angularVelocity)) : o.hasAngularVelocity = false, this.dispatchEvent(L_)));
          }
          return o !== null && (o.visible = r !== null), l !== null && (l.visible = s !== null), c !== null && (c.visible = a !== null), this;
        }
        _getHandJoint(e, t) {
          if (e.joints[t.jointName] === void 0) {
            const i = new Yn();
            i.matrixAutoUpdate = false, i.visible = false, e.joints[t.jointName] = i, e.add(i);
          }
          return e.joints[t.jointName];
        }
      }
      class D_ extends Tt {
        constructor() {
          super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Qi(), this.environmentIntensity = 1, this.environmentRotation = new Qi(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
          }));
        }
        copy(e, t) {
          return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
        }
      }
      class I_ {
        constructor(e, t) {
          this.isInterleavedBuffer = true, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = vc, this.updateRanges = [], this.version = 0, this.uuid = Ii();
        }
        onUploadCallback() {
        }
        set needsUpdate(e) {
          e === true && this.version++;
        }
        setUsage(e) {
          return this.usage = e, this;
        }
        addUpdateRange(e, t) {
          this.updateRanges.push({
            start: e,
            count: t
          });
        }
        clearUpdateRanges() {
          this.updateRanges.length = 0;
        }
        copy(e) {
          return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
        }
        copyAt(e, t, i) {
          e *= this.stride, i *= t.stride;
          for (let r = 0, s = this.stride; r < s; r++) this.array[e + r] = t.array[i + r];
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        clone(e) {
          e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ii()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
          const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(t, this.stride);
          return i.setUsage(this.usage), i;
        }
        onUpload(e) {
          return this.onUploadCallback = e, this;
        }
        toJSON(e) {
          return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ii()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
          };
        }
      }
      const hi = new D();
      class Vc {
        constructor(e, t, i, r = false) {
          this.isInterleavedBufferAttribute = true, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = r;
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(e) {
          this.data.needsUpdate = e;
        }
        applyMatrix4(e) {
          for (let t = 0, i = this.data.count; t < i; t++) hi.fromBufferAttribute(this, t), hi.applyMatrix4(e), this.setXYZ(t, hi.x, hi.y, hi.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, i = this.count; t < i; t++) hi.fromBufferAttribute(this, t), hi.applyNormalMatrix(e), this.setXYZ(t, hi.x, hi.y, hi.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, i = this.count; t < i; t++) hi.fromBufferAttribute(this, t), hi.transformDirection(e), this.setXYZ(t, hi.x, hi.y, hi.z);
          return this;
        }
        getComponent(e, t) {
          let i = this.array[e * this.data.stride + this.offset + t];
          return this.normalized && (i = Hi(i, this.array)), i;
        }
        setComponent(e, t, i) {
          return this.normalized && (i = at(i, this.array)), this.data.array[e * this.data.stride + this.offset + t] = i, this;
        }
        setX(e, t) {
          return this.normalized && (t = at(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
        }
        setY(e, t) {
          return this.normalized && (t = at(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
        }
        setZ(e, t) {
          return this.normalized && (t = at(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
        }
        setW(e, t) {
          return this.normalized && (t = at(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
        }
        getX(e) {
          let t = this.data.array[e * this.data.stride + this.offset];
          return this.normalized && (t = Hi(t, this.array)), t;
        }
        getY(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 1];
          return this.normalized && (t = Hi(t, this.array)), t;
        }
        getZ(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 2];
          return this.normalized && (t = Hi(t, this.array)), t;
        }
        getW(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 3];
          return this.normalized && (t = Hi(t, this.array)), t;
        }
        setXY(e, t, i) {
          return e = e * this.data.stride + this.offset, this.normalized && (t = at(t, this.array), i = at(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this;
        }
        setXYZ(e, t, i, r) {
          return e = e * this.data.stride + this.offset, this.normalized && (t = at(t, this.array), i = at(i, this.array), r = at(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this;
        }
        setXYZW(e, t, i, r, s) {
          return e = e * this.data.stride + this.offset, this.normalized && (t = at(t, this.array), i = at(i, this.array), r = at(r, this.array), s = at(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = r, this.data.array[e + 3] = s, this;
        }
        clone(e) {
          if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
              const r = i * this.data.stride + this.offset;
              for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
            }
            return new li(new this.array.constructor(t), this.itemSize, this.normalized);
          } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Vc(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
        toJSON(e) {
          if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let i = 0; i < this.count; i++) {
              const r = i * this.data.stride + this.offset;
              for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: t,
              normalized: this.normalized
            };
          } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
            isInterleavedBufferAttribute: true,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
          };
        }
      }
      const Nd = new D(), Ud = new it(), Od = new it(), N_ = new D(), Fd = new Fe(), Uo = new D(), Hc = new $i(), Bd = new Fe(), Gc = new va();
      class U_ extends Dt {
        constructor(e, t) {
          super(e, t), this.isSkinnedMesh = true, this.type = "SkinnedMesh", this.bindMode = Vh, this.bindMatrix = new Fe(), this.bindMatrixInverse = new Fe(), this.boundingBox = null, this.boundingSphere = null;
        }
        computeBoundingBox() {
          const e = this.geometry;
          this.boundingBox === null && (this.boundingBox = new vn()), this.boundingBox.makeEmpty();
          const t = e.getAttribute("position");
          for (let i = 0; i < t.count; i++) this.getVertexPosition(i, Uo), this.boundingBox.expandByPoint(Uo);
        }
        computeBoundingSphere() {
          const e = this.geometry;
          this.boundingSphere === null && (this.boundingSphere = new $i()), this.boundingSphere.makeEmpty();
          const t = e.getAttribute("position");
          for (let i = 0; i < t.count; i++) this.getVertexPosition(i, Uo), this.boundingSphere.expandByPoint(Uo);
        }
        copy(e, t) {
          return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
        }
        raycast(e, t) {
          const i = this.material, r = this.matrixWorld;
          i !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Hc.copy(this.boundingSphere), Hc.applyMatrix4(r), e.ray.intersectsSphere(Hc) !== false && (Bd.copy(r).invert(), Gc.copy(e.ray).applyMatrix4(Bd), !(this.boundingBox !== null && Gc.intersectsBox(this.boundingBox) === false) && this._computeIntersections(e, t, Gc)));
        }
        getVertexPosition(e, t) {
          return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
        }
        bind(e, t) {
          this.skeleton = e, t === void 0 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const e = new it(), t = this.geometry.attributes.skinWeight;
          for (let i = 0, r = t.count; i < r; i++) {
            e.fromBufferAttribute(t, i);
            const s = 1 / e.manhattanLength();
            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w);
          }
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e), this.bindMode === Vh ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === Cg ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
        }
        applyBoneTransform(e, t) {
          const i = this.skeleton, r = this.geometry;
          Ud.fromBufferAttribute(r.attributes.skinIndex, e), Od.fromBufferAttribute(r.attributes.skinWeight, e), Nd.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
          for (let s = 0; s < 4; s++) {
            const a = Od.getComponent(s);
            if (a !== 0) {
              const o = Ud.getComponent(s);
              Fd.multiplyMatrices(i.bones[o].matrixWorld, i.boneInverses[o]), t.addScaledVector(N_.copy(Nd).applyMatrix4(Fd), a);
            }
          }
          return t.applyMatrix4(this.bindMatrixInverse);
        }
      }
      class zd extends Tt {
        constructor() {
          super(), this.isBone = true, this.type = "Bone";
        }
      }
      class kd extends kt {
        constructor(e = null, t = 1, i = 1, r, s, a, o, l, c = ai, u = ai, h, d) {
          super(null, a, o, l, c, u, r, s, h, d), this.isDataTexture = true, this.image = {
            data: e,
            width: t,
            height: i
          }, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
        }
      }
      const Vd = new Fe(), O_ = new Fe();
      class Wc {
        constructor(e = [], t = []) {
          this.uuid = Ii(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
        }
        init() {
          const e = this.bones, t = this.boneInverses;
          if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
          else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
            for (let i = 0, r = this.bones.length; i < r; i++) this.boneInverses.push(new Fe());
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = new Fe();
            this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i);
          }
        }
        pose() {
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && i.matrixWorld.copy(this.boneInverses[e]).invert();
          }
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const i = this.bones[e];
            i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld), i.matrix.decompose(i.position, i.quaternion, i.scale));
          }
        }
        update() {
          const e = this.bones, t = this.boneInverses, i = this.boneMatrices, r = this.boneTexture;
          for (let s = 0, a = e.length; s < a; s++) {
            const o = e[s] ? e[s].matrixWorld : O_;
            Vd.multiplyMatrices(o, t[s]), Vd.toArray(i, s * 16);
          }
          r !== null && (r.needsUpdate = true);
        }
        clone() {
          return new Wc(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let e = Math.sqrt(this.bones.length * 4);
          e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
          const t = new Float32Array(e * e * 4);
          t.set(this.boneMatrices);
          const i = new kd(t, e, e, Di, Vi);
          return i.needsUpdate = true, this.boneMatrices = t, this.boneTexture = i, this;
        }
        getBoneByName(e) {
          for (let t = 0, i = this.bones.length; t < i; t++) {
            const r = this.bones[t];
            if (r.name === e) return r;
          }
        }
        dispose() {
          this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
        }
        fromJSON(e, t) {
          this.uuid = e.uuid;
          for (let i = 0, r = e.bones.length; i < r; i++) {
            const s = e.bones[i];
            let a = t[s];
            a === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), a = new zd()), this.bones.push(a), this.boneInverses.push(new Fe().fromArray(e.boneInverses[i]));
          }
          return this.init(), this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.6,
              type: "Skeleton",
              generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
          };
          e.uuid = this.uuid;
          const t = this.bones, i = this.boneInverses;
          for (let r = 0, s = t.length; r < s; r++) {
            const a = t[r];
            e.bones.push(a.uuid);
            const o = i[r];
            e.boneInverses.push(o.toArray());
          }
          return e;
        }
      }
      class Xc extends li {
        constructor(e, t, i, r = 1) {
          super(e, t, i), this.isInstancedBufferAttribute = true, this.meshPerAttribute = r;
        }
        copy(e) {
          return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = true, e;
        }
      }
      const xs = new Fe(), Hd = new Fe(), Oo = [], Gd = new vn(), F_ = new Fe(), Ma = new Dt(), Ta = new $i();
      class B_ extends Dt {
        constructor(e, t, i) {
          super(e, t), this.isInstancedMesh = true, this.instanceMatrix = new Xc(new Float32Array(i * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = i, this.boundingBox = null, this.boundingSphere = null;
          for (let r = 0; r < i; r++) this.setMatrixAt(r, F_);
        }
        computeBoundingBox() {
          const e = this.geometry, t = this.count;
          this.boundingBox === null && (this.boundingBox = new vn()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
          for (let i = 0; i < t; i++) this.getMatrixAt(i, xs), Gd.copy(e.boundingBox).applyMatrix4(xs), this.boundingBox.union(Gd);
        }
        computeBoundingSphere() {
          const e = this.geometry, t = this.count;
          this.boundingSphere === null && (this.boundingSphere = new $i()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
          for (let i = 0; i < t; i++) this.getMatrixAt(i, xs), Ta.copy(e.boundingSphere).applyMatrix4(xs), this.boundingSphere.union(Ta);
        }
        copy(e, t) {
          return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
        }
        getColorAt(e, t) {
          t.fromArray(this.instanceColor.array, e * 3);
        }
        getMatrixAt(e, t) {
          t.fromArray(this.instanceMatrix.array, e * 16);
        }
        getMorphAt(e, t) {
          const i = t.morphTargetInfluences, r = this.morphTexture.source.data.data, s = i.length + 1, a = e * s + 1;
          for (let o = 0; o < i.length; o++) i[o] = r[a + o];
        }
        raycast(e, t) {
          const i = this.matrixWorld, r = this.count;
          if (Ma.geometry = this.geometry, Ma.material = this.material, Ma.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Ta.copy(this.boundingSphere), Ta.applyMatrix4(i), e.ray.intersectsSphere(Ta) !== false)) for (let s = 0; s < r; s++) {
            this.getMatrixAt(s, xs), Hd.multiplyMatrices(i, xs), Ma.matrixWorld = Hd, Ma.raycast(e, Oo);
            for (let a = 0, o = Oo.length; a < o; a++) {
              const l = Oo[a];
              l.instanceId = s, l.object = this, t.push(l);
            }
            Oo.length = 0;
          }
        }
        setColorAt(e, t) {
          this.instanceColor === null && (this.instanceColor = new Xc(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), t.toArray(this.instanceColor.array, e * 3);
        }
        setMatrixAt(e, t) {
          t.toArray(this.instanceMatrix.array, e * 16);
        }
        setMorphAt(e, t) {
          const i = t.morphTargetInfluences, r = i.length + 1;
          this.morphTexture === null && (this.morphTexture = new kd(new Float32Array(r * this.count), r, this.count, kl, Vi));
          const s = this.morphTexture.source.data.data;
          let a = 0;
          for (let c = 0; c < i.length; c++) a += i[c];
          const o = this.geometry.morphTargetsRelative ? 1 : 1 - a, l = r * e;
          s[l] = o, s.set(i, l + 1);
        }
        updateMorphTargets() {
        }
        dispose() {
          return this.dispatchEvent({
            type: "dispose"
          }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this;
        }
      }
      const jc = new D(), z_ = new D(), k_ = new ze();
      class fr {
        constructor(e = new D(1, 0, 0), t = 0) {
          this.isPlane = true, this.normal = e, this.constant = t;
        }
        set(e, t) {
          return this.normal.copy(e), this.constant = t, this;
        }
        setComponents(e, t, i, r) {
          return this.normal.set(e, t, i), this.constant = r, this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
          return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
        }
        setFromCoplanarPoints(e, t, i) {
          const r = jc.subVectors(i, t).cross(z_.subVectors(e, t)).normalize();
          return this.setFromNormalAndCoplanarPoint(r, e), this;
        }
        copy(e) {
          return this.normal.copy(e.normal), this.constant = e.constant, this;
        }
        normalize() {
          const e = 1 / this.normal.length();
          return this.normal.multiplyScalar(e), this.constant *= e, this;
        }
        negate() {
          return this.constant *= -1, this.normal.negate(), this;
        }
        distanceToPoint(e) {
          return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
          return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
          return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
        }
        intersectLine(e, t) {
          const i = e.delta(jc), r = this.normal.dot(i);
          if (r === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
          const s = -(e.start.dot(this.normal) + this.constant) / r;
          return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s);
        }
        intersectsLine(e) {
          const t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
          return t < 0 && i > 0 || i < 0 && t > 0;
        }
        intersectsBox(e) {
          return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
          return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
          return e.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(e, t) {
          const i = t || k_.getNormalMatrix(e), r = this.coplanarPoint(jc).applyMatrix4(e), s = this.normal.applyMatrix3(i).normalize();
          return this.constant = -r.dot(s), this;
        }
        translate(e) {
          return this.constant -= e.dot(this.normal), this;
        }
        equals(e) {
          return e.normal.equals(this.normal) && e.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const mr = new $i(), Fo = new D();
      class qc {
        constructor(e = new fr(), t = new fr(), i = new fr(), r = new fr(), s = new fr(), a = new fr()) {
          this.planes = [
            e,
            t,
            i,
            r,
            s,
            a
          ];
        }
        set(e, t, i, r, s, a) {
          const o = this.planes;
          return o[0].copy(e), o[1].copy(t), o[2].copy(i), o[3].copy(r), o[4].copy(s), o[5].copy(a), this;
        }
        copy(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
          return this;
        }
        setFromProjectionMatrix(e, t = gn) {
          const i = this.planes, r = e.elements, s = r[0], a = r[1], o = r[2], l = r[3], c = r[4], u = r[5], h = r[6], d = r[7], p = r[8], f = r[9], _ = r[10], g = r[11], m = r[12], y = r[13], x = r[14], v = r[15];
          if (i[0].setComponents(l - s, d - c, g - p, v - m).normalize(), i[1].setComponents(l + s, d + c, g + p, v + m).normalize(), i[2].setComponents(l + a, d + u, g + f, v + y).normalize(), i[3].setComponents(l - a, d - u, g - f, v - y).normalize(), i[4].setComponents(l - o, d - h, g - _, v - x).normalize(), t === gn) i[5].setComponents(l + o, d + h, g + _, v + x).normalize();
          else if (t === _o) i[5].setComponents(o, h, _, x).normalize();
          else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
          return this;
        }
        intersectsObject(e) {
          if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), mr.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
          else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(), mr.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
          }
          return this.intersectsSphere(mr);
        }
        intersectsSprite(e) {
          return mr.center.set(0, 0, 0), mr.radius = 0.7071067811865476, mr.applyMatrix4(e.matrixWorld), this.intersectsSphere(mr);
        }
        intersectsSphere(e) {
          const t = this.planes, i = e.center, r = -e.radius;
          for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(i) < r) return false;
          return true;
        }
        intersectsBox(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++) {
            const r = t[i];
            if (Fo.x = r.normal.x > 0 ? e.max.x : e.min.x, Fo.y = r.normal.y > 0 ? e.max.y : e.min.y, Fo.z = r.normal.z > 0 ? e.max.z : e.min.z, r.distanceToPoint(Fo) < 0) return false;
          }
          return true;
        }
        containsPoint(e) {
          const t = this.planes;
          for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return false;
          return true;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Wd extends en {
        constructor(e) {
          super(), this.isLineBasicMaterial = true, this.type = "LineBasicMaterial", this.color = new Ae(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = true, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
        }
      }
      const Bo = new D(), zo = new D(), Xd = new Fe(), ba = new va(), ko = new $i(), Yc = new D(), jd = new D();
      class Kc extends Tt {
        constructor(e = new mi(), t = new Wd()) {
          super(), this.isLine = true, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
        }
        copy(e, t) {
          return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
        }
        computeLineDistances() {
          const e = this.geometry;
          if (e.index === null) {
            const t = e.attributes.position, i = [
              0
            ];
            for (let r = 1, s = t.count; r < s; r++) Bo.fromBufferAttribute(t, r - 1), zo.fromBufferAttribute(t, r), i[r] = i[r - 1], i[r] += Bo.distanceTo(zo);
            e.setAttribute("lineDistance", new Zt(i, 1));
          } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          return this;
        }
        raycast(e, t) {
          const i = this.geometry, r = this.matrixWorld, s = e.params.Line.threshold, a = i.drawRange;
          if (i.boundingSphere === null && i.computeBoundingSphere(), ko.copy(i.boundingSphere), ko.applyMatrix4(r), ko.radius += s, e.ray.intersectsSphere(ko) === false) return;
          Xd.copy(r).invert(), ba.copy(e.ray).applyMatrix4(Xd);
          const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, c = this.isLineSegments ? 2 : 1, u = i.index, h = i.attributes.position;
          if (u !== null) {
            const d = Math.max(0, a.start), p = Math.min(u.count, a.start + a.count);
            for (let f = d, _ = p - 1; f < _; f += c) {
              const g = u.getX(f), m = u.getX(f + 1), y = Vo(this, e, ba, l, g, m, f);
              y && t.push(y);
            }
            if (this.isLineLoop) {
              const f = u.getX(p - 1), _ = u.getX(d), g = Vo(this, e, ba, l, f, _, p - 1);
              g && t.push(g);
            }
          } else {
            const d = Math.max(0, a.start), p = Math.min(h.count, a.start + a.count);
            for (let f = d, _ = p - 1; f < _; f += c) {
              const g = Vo(this, e, ba, l, f, f + 1, f);
              g && t.push(g);
            }
            if (this.isLineLoop) {
              const f = Vo(this, e, ba, l, p - 1, d, p - 1);
              f && t.push(f);
            }
          }
        }
        updateMorphTargets() {
          const e = this.geometry.morphAttributes, t = Object.keys(e);
          if (t.length > 0) {
            const i = e[t[0]];
            if (i !== void 0) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let r = 0, s = i.length; r < s; r++) {
                const a = i[r].name || String(r);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
              }
            }
          }
        }
      }
      function Vo(n, e, t, i, r, s, a) {
        const o = n.geometry.attributes.position;
        if (Bo.fromBufferAttribute(o, r), zo.fromBufferAttribute(o, s), t.distanceSqToSegment(Bo, zo, Yc, jd) > i) return;
        Yc.applyMatrix4(n.matrixWorld);
        const l = e.ray.origin.distanceTo(Yc);
        if (!(l < e.near || l > e.far)) return {
          distance: l,
          point: jd.clone().applyMatrix4(n.matrixWorld),
          index: a,
          face: null,
          faceIndex: null,
          barycoord: null,
          object: n
        };
      }
      const qd = new D(), Yd = new D();
      class V_ extends Kc {
        constructor(e, t) {
          super(e, t), this.isLineSegments = true, this.type = "LineSegments";
        }
        computeLineDistances() {
          const e = this.geometry;
          if (e.index === null) {
            const t = e.attributes.position, i = [];
            for (let r = 0, s = t.count; r < s; r += 2) qd.fromBufferAttribute(t, r), Yd.fromBufferAttribute(t, r + 1), i[r] = r === 0 ? 0 : i[r - 1], i[r + 1] = i[r] + qd.distanceTo(Yd);
            e.setAttribute("lineDistance", new Zt(i, 1));
          } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          return this;
        }
      }
      class H_ extends Kc {
        constructor(e, t) {
          super(e, t), this.isLineLoop = true, this.type = "LineLoop";
        }
      }
      class Zc extends en {
        constructor(e) {
          super(), this.isPointsMaterial = true, this.type = "PointsMaterial", this.color = new Ae(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.fog = true, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
        }
      }
      const Kd = new Fe(), Jc = new va(), Ho = new $i(), Go = new D();
      class Zd extends Tt {
        constructor(e = new mi(), t = new Zc()) {
          super(), this.isPoints = true, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
        }
        copy(e, t) {
          return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
        }
        raycast(e, t) {
          const i = this.geometry, r = this.matrixWorld, s = e.params.Points.threshold, a = i.drawRange;
          if (i.boundingSphere === null && i.computeBoundingSphere(), Ho.copy(i.boundingSphere), Ho.applyMatrix4(r), Ho.radius += s, e.ray.intersectsSphere(Ho) === false) return;
          Kd.copy(r).invert(), Jc.copy(e.ray).applyMatrix4(Kd);
          const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, c = i.index, u = i.attributes.position;
          if (c !== null) {
            const h = Math.max(0, a.start), d = Math.min(c.count, a.start + a.count);
            for (let p = h, f = d; p < f; p++) {
              const _ = c.getX(p);
              Go.fromBufferAttribute(u, _), Jd(Go, _, l, r, e, t, this);
            }
          } else {
            const h = Math.max(0, a.start), d = Math.min(u.count, a.start + a.count);
            for (let p = h, f = d; p < f; p++) Go.fromBufferAttribute(u, p), Jd(Go, p, l, r, e, t, this);
          }
        }
        updateMorphTargets() {
          const e = this.geometry.morphAttributes, t = Object.keys(e);
          if (t.length > 0) {
            const i = e[t[0]];
            if (i !== void 0) {
              this.morphTargetInfluences = [], this.morphTargetDictionary = {};
              for (let r = 0, s = i.length; r < s; r++) {
                const a = i[r].name || String(r);
                this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = r;
              }
            }
          }
        }
      }
      function Jd(n, e, t, i, r, s, a) {
        const o = Jc.distanceSqToPoint(n);
        if (o < t) {
          const l = new D();
          Jc.closestPointToPoint(n, l), l.applyMatrix4(i);
          const c = r.ray.origin.distanceTo(l);
          if (c < r.near || c > r.far) return;
          s.push({
            distance: c,
            distanceToRay: Math.sqrt(o),
            point: l,
            index: e,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: a
          });
        }
      }
      class G_ extends kt {
        constructor(e, t, i, r, s, a, o, l, c) {
          super(e, t, i, r, s, a, o, l, c), this.isCanvasTexture = true, this.needsUpdate = true;
        }
      }
      class $d extends kt {
        constructor(e, t, i, r, s, a, o, l, c, u = Qr) {
          if (u !== Qr && u !== es) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
          i === void 0 && u === Qr && (i = cr), i === void 0 && u === es && (i = $r), super(null, r, s, a, o, l, u, i, c), this.isDepthTexture = true, this.image = {
            width: e,
            height: t
          }, this.magFilter = o !== void 0 ? o : ai, this.minFilter = l !== void 0 ? l : ai, this.flipY = false, this.generateMipmaps = false, this.compareFunction = null;
        }
        copy(e) {
          return super.copy(e), this.compareFunction = e.compareFunction, this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
        }
      }
      class nn {
        constructor() {
          this.type = "Curve", this.arcLengthDivisions = 200;
        }
        getPoint() {
          return console.warn("THREE.Curve: .getPoint() not implemented."), null;
        }
        getPointAt(e, t) {
          const i = this.getUtoTmapping(e);
          return this.getPoint(i, t);
        }
        getPoints(e = 5) {
          const t = [];
          for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
          return t;
        }
        getSpacedPoints(e = 5) {
          const t = [];
          for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
          return t;
        }
        getLength() {
          const e = this.getLengths();
          return e[e.length - 1];
        }
        getLengths(e = this.arcLengthDivisions) {
          if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
          this.needsUpdate = false;
          const t = [];
          let i, r = this.getPoint(0), s = 0;
          t.push(0);
          for (let a = 1; a <= e; a++) i = this.getPoint(a / e), s += i.distanceTo(r), t.push(s), r = i;
          return this.cacheArcLengths = t, t;
        }
        updateArcLengths() {
          this.needsUpdate = true, this.getLengths();
        }
        getUtoTmapping(e, t) {
          const i = this.getLengths();
          let r = 0;
          const s = i.length;
          let a;
          t ? a = t : a = e * i[s - 1];
          let o = 0, l = s - 1, c;
          for (; o <= l; ) if (r = Math.floor(o + (l - o) / 2), c = i[r] - a, c < 0) o = r + 1;
          else if (c > 0) l = r - 1;
          else {
            l = r;
            break;
          }
          if (r = l, i[r] === a) return r / (s - 1);
          const u = i[r], h = i[r + 1] - u, d = (a - u) / h;
          return (r + d) / (s - 1);
        }
        getTangent(e, t) {
          let i = e - 1e-4, r = e + 1e-4;
          i < 0 && (i = 0), r > 1 && (r = 1);
          const s = this.getPoint(i), a = this.getPoint(r), o = t || (s.isVector2 ? new ee() : new D());
          return o.copy(a).sub(s).normalize(), o;
        }
        getTangentAt(e, t) {
          const i = this.getUtoTmapping(e);
          return this.getTangent(i, t);
        }
        computeFrenetFrames(e, t) {
          const i = new D(), r = [], s = [], a = [], o = new D(), l = new Fe();
          for (let p = 0; p <= e; p++) {
            const f = p / e;
            r[p] = this.getTangentAt(f, new D());
          }
          s[0] = new D(), a[0] = new D();
          let c = Number.MAX_VALUE;
          const u = Math.abs(r[0].x), h = Math.abs(r[0].y), d = Math.abs(r[0].z);
          u <= c && (c = u, i.set(1, 0, 0)), h <= c && (c = h, i.set(0, 1, 0)), d <= c && i.set(0, 0, 1), o.crossVectors(r[0], i).normalize(), s[0].crossVectors(r[0], o), a[0].crossVectors(r[0], s[0]);
          for (let p = 1; p <= e; p++) {
            if (s[p] = s[p - 1].clone(), a[p] = a[p - 1].clone(), o.crossVectors(r[p - 1], r[p]), o.length() > Number.EPSILON) {
              o.normalize();
              const f = Math.acos(Ge(r[p - 1].dot(r[p]), -1, 1));
              s[p].applyMatrix4(l.makeRotationAxis(o, f));
            }
            a[p].crossVectors(r[p], s[p]);
          }
          if (t === true) {
            let p = Math.acos(Ge(s[0].dot(s[e]), -1, 1));
            p /= e, r[0].dot(o.crossVectors(s[0], s[e])) > 0 && (p = -p);
            for (let f = 1; f <= e; f++) s[f].applyMatrix4(l.makeRotationAxis(r[f], p * f)), a[f].crossVectors(r[f], s[f]);
          }
          return {
            tangents: r,
            normals: s,
            binormals: a
          };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.arcLengthDivisions = e.arcLengthDivisions, this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.6,
              type: "Curve",
              generator: "Curve.toJSON"
            }
          };
          return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
        }
        fromJSON(e) {
          return this.arcLengthDivisions = e.arcLengthDivisions, this;
        }
      }
      class $c extends nn {
        constructor(e = 0, t = 0, i = 1, r = 1, s = 0, a = Math.PI * 2, o = false, l = 0) {
          super(), this.isEllipseCurve = true, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = r, this.aStartAngle = s, this.aEndAngle = a, this.aClockwise = o, this.aRotation = l;
        }
        getPoint(e, t = new ee()) {
          const i = t, r = Math.PI * 2;
          let s = this.aEndAngle - this.aStartAngle;
          const a = Math.abs(s) < Number.EPSILON;
          for (; s < 0; ) s += r;
          for (; s > r; ) s -= r;
          s < Number.EPSILON && (a ? s = 0 : s = r), this.aClockwise === true && !a && (s === r ? s = -r : s = s - r);
          const o = this.aStartAngle + e * s;
          let l = this.aX + this.xRadius * Math.cos(o), c = this.aY + this.yRadius * Math.sin(o);
          if (this.aRotation !== 0) {
            const u = Math.cos(this.aRotation), h = Math.sin(this.aRotation), d = l - this.aX, p = c - this.aY;
            l = d * u - p * h + this.aX, c = d * h + p * u + this.aY;
          }
          return i.set(l, c);
        }
        copy(e) {
          return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
        }
      }
      class W_ extends $c {
        constructor(e, t, i, r, s, a) {
          super(e, t, i, i, r, s, a), this.isArcCurve = true, this.type = "ArcCurve";
        }
      }
      function Qc() {
        let n = 0, e = 0, t = 0, i = 0;
        function r(s, a, o, l) {
          n = s, e = o, t = -3 * s + 3 * a - 2 * o - l, i = 2 * s - 2 * a + o + l;
        }
        return {
          initCatmullRom: function(s, a, o, l, c) {
            r(a, o, c * (o - s), c * (l - a));
          },
          initNonuniformCatmullRom: function(s, a, o, l, c, u, h) {
            let d = (a - s) / c - (o - s) / (c + u) + (o - a) / u, p = (o - a) / u - (l - a) / (u + h) + (l - o) / h;
            d *= u, p *= u, r(a, o, d, p);
          },
          calc: function(s) {
            const a = s * s, o = a * s;
            return n + e * s + t * a + i * o;
          }
        };
      }
      const Wo = new D(), eu = new Qc(), tu = new Qc(), iu = new Qc();
      class X_ extends nn {
        constructor(e = [], t = false, i = "centripetal", r = 0.5) {
          super(), this.isCatmullRomCurve3 = true, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = r;
        }
        getPoint(e, t = new D()) {
          const i = t, r = this.points, s = r.length, a = (s - (this.closed ? 0 : 1)) * e;
          let o = Math.floor(a), l = a - o;
          this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / s) + 1) * s : l === 0 && o === s - 1 && (o = s - 2, l = 1);
          let c, u;
          this.closed || o > 0 ? c = r[(o - 1) % s] : (Wo.subVectors(r[0], r[1]).add(r[0]), c = Wo);
          const h = r[o % s], d = r[(o + 1) % s];
          if (this.closed || o + 2 < s ? u = r[(o + 2) % s] : (Wo.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), u = Wo), this.curveType === "centripetal" || this.curveType === "chordal") {
            const p = this.curveType === "chordal" ? 0.5 : 0.25;
            let f = Math.pow(c.distanceToSquared(h), p), _ = Math.pow(h.distanceToSquared(d), p), g = Math.pow(d.distanceToSquared(u), p);
            _ < 1e-4 && (_ = 1), f < 1e-4 && (f = _), g < 1e-4 && (g = _), eu.initNonuniformCatmullRom(c.x, h.x, d.x, u.x, f, _, g), tu.initNonuniformCatmullRom(c.y, h.y, d.y, u.y, f, _, g), iu.initNonuniformCatmullRom(c.z, h.z, d.z, u.z, f, _, g);
          } else this.curveType === "catmullrom" && (eu.initCatmullRom(c.x, h.x, d.x, u.x, this.tension), tu.initCatmullRom(c.y, h.y, d.y, u.y, this.tension), iu.initCatmullRom(c.z, h.z, d.z, u.z, this.tension));
          return i.set(eu.calc(l), tu.calc(l), iu.calc(l)), i;
        }
        copy(e) {
          super.copy(e), this.points = [];
          for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone());
          }
          return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
        }
        toJSON() {
          const e = super.toJSON();
          e.points = [];
          for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray());
          }
          return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
        }
        fromJSON(e) {
          super.fromJSON(e), this.points = [];
          for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new D().fromArray(r));
          }
          return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
        }
      }
      function Qd(n, e, t, i, r) {
        const s = (i - e) * 0.5, a = (r - t) * 0.5, o = n * n, l = n * o;
        return (2 * t - 2 * i + s + a) * l + (-3 * t + 3 * i - 2 * s - a) * o + s * n + t;
      }
      function j_(n, e) {
        const t = 1 - n;
        return t * t * e;
      }
      function q_(n, e) {
        return 2 * (1 - n) * n * e;
      }
      function Y_(n, e) {
        return n * n * e;
      }
      function Sa(n, e, t, i) {
        return j_(n, e) + q_(n, t) + Y_(n, i);
      }
      function K_(n, e) {
        const t = 1 - n;
        return t * t * t * e;
      }
      function Z_(n, e) {
        const t = 1 - n;
        return 3 * t * t * n * e;
      }
      function J_(n, e) {
        return 3 * (1 - n) * n * n * e;
      }
      function $_(n, e) {
        return n * n * n * e;
      }
      function Ea(n, e, t, i, r) {
        return K_(n, e) + Z_(n, t) + J_(n, i) + $_(n, r);
      }
      class ep extends nn {
        constructor(e = new ee(), t = new ee(), i = new ee(), r = new ee()) {
          super(), this.isCubicBezierCurve = true, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r;
        }
        getPoint(e, t = new ee()) {
          const i = t, r = this.v0, s = this.v1, a = this.v2, o = this.v3;
          return i.set(Ea(e, r.x, s.x, a.x, o.x), Ea(e, r.y, s.y, a.y, o.y)), i;
        }
        copy(e) {
          return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
        }
      }
      class Q_ extends nn {
        constructor(e = new D(), t = new D(), i = new D(), r = new D()) {
          super(), this.isCubicBezierCurve3 = true, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = r;
        }
        getPoint(e, t = new D()) {
          const i = t, r = this.v0, s = this.v1, a = this.v2, o = this.v3;
          return i.set(Ea(e, r.x, s.x, a.x, o.x), Ea(e, r.y, s.y, a.y, o.y), Ea(e, r.z, s.z, a.z, o.z)), i;
        }
        copy(e) {
          return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
        }
      }
      class tp extends nn {
        constructor(e = new ee(), t = new ee()) {
          super(), this.isLineCurve = true, this.type = "LineCurve", this.v1 = e, this.v2 = t;
        }
        getPoint(e, t = new ee()) {
          const i = t;
          return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
        }
        getPointAt(e, t) {
          return this.getPoint(e, t);
        }
        getTangent(e, t = new ee()) {
          return t.subVectors(this.v2, this.v1).normalize();
        }
        getTangentAt(e, t) {
          return this.getTangent(e, t);
        }
        copy(e) {
          return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
        }
      }
      class ev extends nn {
        constructor(e = new D(), t = new D()) {
          super(), this.isLineCurve3 = true, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
        }
        getPoint(e, t = new D()) {
          const i = t;
          return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
        }
        getPointAt(e, t) {
          return this.getPoint(e, t);
        }
        getTangent(e, t = new D()) {
          return t.subVectors(this.v2, this.v1).normalize();
        }
        getTangentAt(e, t) {
          return this.getTangent(e, t);
        }
        copy(e) {
          return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
        }
      }
      class ip extends nn {
        constructor(e = new ee(), t = new ee(), i = new ee()) {
          super(), this.isQuadraticBezierCurve = true, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i;
        }
        getPoint(e, t = new ee()) {
          const i = t, r = this.v0, s = this.v1, a = this.v2;
          return i.set(Sa(e, r.x, s.x, a.x), Sa(e, r.y, s.y, a.y)), i;
        }
        copy(e) {
          return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
        }
      }
      class tv extends nn {
        constructor(e = new D(), t = new D(), i = new D()) {
          super(), this.isQuadraticBezierCurve3 = true, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i;
        }
        getPoint(e, t = new D()) {
          const i = t, r = this.v0, s = this.v1, a = this.v2;
          return i.set(Sa(e, r.x, s.x, a.x), Sa(e, r.y, s.y, a.y), Sa(e, r.z, s.z, a.z)), i;
        }
        copy(e) {
          return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
        }
      }
      class np extends nn {
        constructor(e = []) {
          super(), this.isSplineCurve = true, this.type = "SplineCurve", this.points = e;
        }
        getPoint(e, t = new ee()) {
          const i = t, r = this.points, s = (r.length - 1) * e, a = Math.floor(s), o = s - a, l = r[a === 0 ? a : a - 1], c = r[a], u = r[a > r.length - 2 ? r.length - 1 : a + 1], h = r[a > r.length - 3 ? r.length - 1 : a + 2];
          return i.set(Qd(o, l.x, c.x, u.x, h.x), Qd(o, l.y, c.y, u.y, h.y)), i;
        }
        copy(e) {
          super.copy(e), this.points = [];
          for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(r.clone());
          }
          return this;
        }
        toJSON() {
          const e = super.toJSON();
          e.points = [];
          for (let t = 0, i = this.points.length; t < i; t++) {
            const r = this.points[t];
            e.points.push(r.toArray());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), this.points = [];
          for (let t = 0, i = e.points.length; t < i; t++) {
            const r = e.points[t];
            this.points.push(new ee().fromArray(r));
          }
          return this;
        }
      }
      var nu = Object.freeze({
        __proto__: null,
        ArcCurve: W_,
        CatmullRomCurve3: X_,
        CubicBezierCurve: ep,
        CubicBezierCurve3: Q_,
        EllipseCurve: $c,
        LineCurve: tp,
        LineCurve3: ev,
        QuadraticBezierCurve: ip,
        QuadraticBezierCurve3: tv,
        SplineCurve: np
      });
      class iv extends nn {
        constructor() {
          super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
        }
        add(e) {
          this.curves.push(e);
        }
        closePath() {
          const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
          if (!e.equals(t)) {
            const i = e.isVector2 === true ? "LineCurve" : "LineCurve3";
            this.curves.push(new nu[i](t, e));
          }
          return this;
        }
        getPoint(e, t) {
          const i = e * this.getLength(), r = this.getCurveLengths();
          let s = 0;
          for (; s < r.length; ) {
            if (r[s] >= i) {
              const a = r[s] - i, o = this.curves[s], l = o.getLength(), c = l === 0 ? 0 : 1 - a / l;
              return o.getPointAt(c, t);
            }
            s++;
          }
          return null;
        }
        getLength() {
          const e = this.getCurveLengths();
          return e[e.length - 1];
        }
        updateArcLengths() {
          this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
        }
        getCurveLengths() {
          if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
          const e = [];
          let t = 0;
          for (let i = 0, r = this.curves.length; i < r; i++) t += this.curves[i].getLength(), e.push(t);
          return this.cacheLengths = e, e;
        }
        getSpacedPoints(e = 40) {
          const t = [];
          for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
          return this.autoClose && t.push(t[0]), t;
        }
        getPoints(e = 12) {
          const t = [];
          let i;
          for (let r = 0, s = this.curves; r < s.length; r++) {
            const a = s[r], o = a.isEllipseCurve ? e * 2 : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e, l = a.getPoints(o);
            for (let c = 0; c < l.length; c++) {
              const u = l[c];
              i && i.equals(u) || (t.push(u), i = u);
            }
          }
          return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
        }
        copy(e) {
          super.copy(e), this.curves = [];
          for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(r.clone());
          }
          return this.autoClose = e.autoClose, this;
        }
        toJSON() {
          const e = super.toJSON();
          e.autoClose = this.autoClose, e.curves = [];
          for (let t = 0, i = this.curves.length; t < i; t++) {
            const r = this.curves[t];
            e.curves.push(r.toJSON());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
          for (let t = 0, i = e.curves.length; t < i; t++) {
            const r = e.curves[t];
            this.curves.push(new nu[r.type]().fromJSON(r));
          }
          return this;
        }
      }
      class ru extends iv {
        constructor(e) {
          super(), this.type = "Path", this.currentPoint = new ee(), e && this.setFromPoints(e);
        }
        setFromPoints(e) {
          this.moveTo(e[0].x, e[0].y);
          for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
          return this;
        }
        moveTo(e, t) {
          return this.currentPoint.set(e, t), this;
        }
        lineTo(e, t) {
          const i = new tp(this.currentPoint.clone(), new ee(e, t));
          return this.curves.push(i), this.currentPoint.set(e, t), this;
        }
        quadraticCurveTo(e, t, i, r) {
          const s = new ip(this.currentPoint.clone(), new ee(e, t), new ee(i, r));
          return this.curves.push(s), this.currentPoint.set(i, r), this;
        }
        bezierCurveTo(e, t, i, r, s, a) {
          const o = new ep(this.currentPoint.clone(), new ee(e, t), new ee(i, r), new ee(s, a));
          return this.curves.push(o), this.currentPoint.set(s, a), this;
        }
        splineThru(e) {
          const t = [
            this.currentPoint.clone()
          ].concat(e), i = new np(t);
          return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
        }
        arc(e, t, i, r, s, a) {
          const o = this.currentPoint.x, l = this.currentPoint.y;
          return this.absarc(e + o, t + l, i, r, s, a), this;
        }
        absarc(e, t, i, r, s, a) {
          return this.absellipse(e, t, i, i, r, s, a), this;
        }
        ellipse(e, t, i, r, s, a, o, l) {
          const c = this.currentPoint.x, u = this.currentPoint.y;
          return this.absellipse(e + c, t + u, i, r, s, a, o, l), this;
        }
        absellipse(e, t, i, r, s, a, o, l) {
          const c = new $c(e, t, i, r, s, a, o, l);
          if (this.curves.length > 0) {
            const h = c.getPoint(0);
            h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
          }
          this.curves.push(c);
          const u = c.getPoint(1);
          return this.currentPoint.copy(u), this;
        }
        copy(e) {
          return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
        }
        toJSON() {
          const e = super.toJSON();
          return e.currentPoint = this.currentPoint.toArray(), e;
        }
        fromJSON(e) {
          return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
        }
      }
      class Xo extends ru {
        constructor(e) {
          super(e), this.uuid = Ii(), this.type = "Shape", this.holes = [];
        }
        getPointsHoles(e) {
          const t = [];
          for (let i = 0, r = this.holes.length; i < r; i++) t[i] = this.holes[i].getPoints(e);
          return t;
        }
        extractPoints(e) {
          return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
          };
        }
        copy(e) {
          super.copy(e), this.holes = [];
          for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(r.clone());
          }
          return this;
        }
        toJSON() {
          const e = super.toJSON();
          e.uuid = this.uuid, e.holes = [];
          for (let t = 0, i = this.holes.length; t < i; t++) {
            const r = this.holes[t];
            e.holes.push(r.toJSON());
          }
          return e;
        }
        fromJSON(e) {
          super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
          for (let t = 0, i = e.holes.length; t < i; t++) {
            const r = e.holes[t];
            this.holes.push(new ru().fromJSON(r));
          }
          return this;
        }
      }
      const nv = {
        triangulate: function(n, e, t = 2) {
          const i = e && e.length, r = i ? e[0] * t : n.length;
          let s = rp(n, 0, r, t, true);
          const a = [];
          if (!s || s.next === s.prev) return a;
          let o, l, c, u, h, d, p;
          if (i && (s = lv(n, e, s, t)), n.length > 80 * t) {
            o = c = n[0], l = u = n[1];
            for (let f = t; f < r; f += t) h = n[f], d = n[f + 1], h < o && (o = h), d < l && (l = d), h > c && (c = h), d > u && (u = d);
            p = Math.max(c - o, u - l), p = p !== 0 ? 32767 / p : 0;
          }
          return wa(s, a, t, o, l, p, 0), a;
        }
      };
      function rp(n, e, t, i, r) {
        let s, a;
        if (r === xv(n, e, t, i) > 0) for (s = e; s < t; s += i) a = op(s, n[s], n[s + 1], a);
        else for (s = t - i; s >= e; s -= i) a = op(s, n[s], n[s + 1], a);
        return a && jo(a, a.next) && (Ra(a), a = a.next), a;
      }
      function gr(n, e) {
        if (!n) return n;
        e || (e = n);
        let t = n, i;
        do
          if (i = false, !t.steiner && (jo(t, t.next) || bt(t.prev, t, t.next) === 0)) {
            if (Ra(t), t = e = t.prev, t === t.next) break;
            i = true;
          } else t = t.next;
        while (i || t !== e);
        return e;
      }
      function wa(n, e, t, i, r, s, a) {
        if (!n) return;
        !a && s && pv(n, i, r, s);
        let o = n, l, c;
        for (; n.prev !== n.next; ) {
          if (l = n.prev, c = n.next, s ? sv(n, i, r, s) : rv(n)) {
            e.push(l.i / t | 0), e.push(n.i / t | 0), e.push(c.i / t | 0), Ra(n), n = c.next, o = c.next;
            continue;
          }
          if (n = c, n === o) {
            a ? a === 1 ? (n = av(gr(n), e, t), wa(n, e, t, i, r, s, 2)) : a === 2 && ov(n, e, t, i, r, s) : wa(gr(n), e, t, i, r, s, 1);
            break;
          }
        }
      }
      function rv(n) {
        const e = n.prev, t = n, i = n.next;
        if (bt(e, t, i) >= 0) return false;
        const r = e.x, s = t.x, a = i.x, o = e.y, l = t.y, c = i.y, u = r < s ? r < a ? r : a : s < a ? s : a, h = o < l ? o < c ? o : c : l < c ? l : c, d = r > s ? r > a ? r : a : s > a ? s : a, p = o > l ? o > c ? o : c : l > c ? l : c;
        let f = i.next;
        for (; f !== e; ) {
          if (f.x >= u && f.x <= d && f.y >= h && f.y <= p && ys(r, o, s, l, a, c, f.x, f.y) && bt(f.prev, f, f.next) >= 0) return false;
          f = f.next;
        }
        return true;
      }
      function sv(n, e, t, i) {
        const r = n.prev, s = n, a = n.next;
        if (bt(r, s, a) >= 0) return false;
        const o = r.x, l = s.x, c = a.x, u = r.y, h = s.y, d = a.y, p = o < l ? o < c ? o : c : l < c ? l : c, f = u < h ? u < d ? u : d : h < d ? h : d, _ = o > l ? o > c ? o : c : l > c ? l : c, g = u > h ? u > d ? u : d : h > d ? h : d, m = su(p, f, e, t, i), y = su(_, g, e, t, i);
        let x = n.prevZ, v = n.nextZ;
        for (; x && x.z >= m && v && v.z <= y; ) {
          if (x.x >= p && x.x <= _ && x.y >= f && x.y <= g && x !== r && x !== a && ys(o, u, l, h, c, d, x.x, x.y) && bt(x.prev, x, x.next) >= 0 || (x = x.prevZ, v.x >= p && v.x <= _ && v.y >= f && v.y <= g && v !== r && v !== a && ys(o, u, l, h, c, d, v.x, v.y) && bt(v.prev, v, v.next) >= 0)) return false;
          v = v.nextZ;
        }
        for (; x && x.z >= m; ) {
          if (x.x >= p && x.x <= _ && x.y >= f && x.y <= g && x !== r && x !== a && ys(o, u, l, h, c, d, x.x, x.y) && bt(x.prev, x, x.next) >= 0) return false;
          x = x.prevZ;
        }
        for (; v && v.z <= y; ) {
          if (v.x >= p && v.x <= _ && v.y >= f && v.y <= g && v !== r && v !== a && ys(o, u, l, h, c, d, v.x, v.y) && bt(v.prev, v, v.next) >= 0) return false;
          v = v.nextZ;
        }
        return true;
      }
      function av(n, e, t) {
        let i = n;
        do {
          const r = i.prev, s = i.next.next;
          !jo(r, s) && sp(r, i, i.next, s) && Aa(r, s) && Aa(s, r) && (e.push(r.i / t | 0), e.push(i.i / t | 0), e.push(s.i / t | 0), Ra(i), Ra(i.next), i = n = s), i = i.next;
        } while (i !== n);
        return gr(i);
      }
      function ov(n, e, t, i, r, s) {
        let a = n;
        do {
          let o = a.next.next;
          for (; o !== a.prev; ) {
            if (a.i !== o.i && gv(a, o)) {
              let l = ap(a, o);
              a = gr(a, a.next), l = gr(l, l.next), wa(a, e, t, i, r, s, 0), wa(l, e, t, i, r, s, 0);
              return;
            }
            o = o.next;
          }
          a = a.next;
        } while (a !== n);
      }
      function lv(n, e, t, i) {
        const r = [];
        let s, a, o, l, c;
        for (s = 0, a = e.length; s < a; s++) o = e[s] * i, l = s < a - 1 ? e[s + 1] * i : n.length, c = rp(n, o, l, i, false), c === c.next && (c.steiner = true), r.push(mv(c));
        for (r.sort(cv), s = 0; s < r.length; s++) t = uv(r[s], t);
        return t;
      }
      function cv(n, e) {
        return n.x - e.x;
      }
      function uv(n, e) {
        const t = hv(n, e);
        if (!t) return e;
        const i = ap(t, n);
        return gr(i, i.next), gr(t, t.next);
      }
      function hv(n, e) {
        let t = e, i = -1 / 0, r;
        const s = n.x, a = n.y;
        do {
          if (a <= t.y && a >= t.next.y && t.next.y !== t.y) {
            const d = t.x + (a - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
            if (d <= s && d > i && (i = d, r = t.x < t.next.x ? t : t.next, d === s)) return r;
          }
          t = t.next;
        } while (t !== e);
        if (!r) return null;
        const o = r, l = r.x, c = r.y;
        let u = 1 / 0, h;
        t = r;
        do
          s >= t.x && t.x >= l && s !== t.x && ys(a < c ? s : i, a, l, c, a < c ? i : s, a, t.x, t.y) && (h = Math.abs(a - t.y) / (s - t.x), Aa(t, n) && (h < u || h === u && (t.x > r.x || t.x === r.x && dv(r, t))) && (r = t, u = h)), t = t.next;
        while (t !== o);
        return r;
      }
      function dv(n, e) {
        return bt(n.prev, n, e.prev) < 0 && bt(e.next, n, n.next) < 0;
      }
      function pv(n, e, t, i) {
        let r = n;
        do
          r.z === 0 && (r.z = su(r.x, r.y, e, t, i)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next;
        while (r !== n);
        r.prevZ.nextZ = null, r.prevZ = null, fv(r);
      }
      function fv(n) {
        let e, t, i, r, s, a, o, l, c = 1;
        do {
          for (t = n, n = null, s = null, a = 0; t; ) {
            for (a++, i = t, o = 0, e = 0; e < c && (o++, i = i.nextZ, !!i); e++) ;
            for (l = c; o > 0 || l > 0 && i; ) o !== 0 && (l === 0 || !i || t.z <= i.z) ? (r = t, t = t.nextZ, o--) : (r = i, i = i.nextZ, l--), s ? s.nextZ = r : n = r, r.prevZ = s, s = r;
            t = i;
          }
          s.nextZ = null, c *= 2;
        } while (a > 1);
        return n;
      }
      function su(n, e, t, i, r) {
        return n = (n - t) * r | 0, e = (e - i) * r | 0, n = (n | n << 8) & 16711935, n = (n | n << 4) & 252645135, n = (n | n << 2) & 858993459, n = (n | n << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, n | e << 1;
      }
      function mv(n) {
        let e = n, t = n;
        do
          (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
        while (e !== n);
        return t;
      }
      function ys(n, e, t, i, r, s, a, o) {
        return (r - a) * (e - o) >= (n - a) * (s - o) && (n - a) * (i - o) >= (t - a) * (e - o) && (t - a) * (s - o) >= (r - a) * (i - o);
      }
      function gv(n, e) {
        return n.next.i !== e.i && n.prev.i !== e.i && !_v(n, e) && (Aa(n, e) && Aa(e, n) && vv(n, e) && (bt(n.prev, n, e.prev) || bt(n, e.prev, e)) || jo(n, e) && bt(n.prev, n, n.next) > 0 && bt(e.prev, e, e.next) > 0);
      }
      function bt(n, e, t) {
        return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
      }
      function jo(n, e) {
        return n.x === e.x && n.y === e.y;
      }
      function sp(n, e, t, i) {
        const r = Yo(bt(n, e, t)), s = Yo(bt(n, e, i)), a = Yo(bt(t, i, n)), o = Yo(bt(t, i, e));
        return !!(r !== s && a !== o || r === 0 && qo(n, t, e) || s === 0 && qo(n, i, e) || a === 0 && qo(t, n, i) || o === 0 && qo(t, e, i));
      }
      function qo(n, e, t) {
        return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y);
      }
      function Yo(n) {
        return n > 0 ? 1 : n < 0 ? -1 : 0;
      }
      function _v(n, e) {
        let t = n;
        do {
          if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && sp(t, t.next, n, e)) return true;
          t = t.next;
        } while (t !== n);
        return false;
      }
      function Aa(n, e) {
        return bt(n.prev, n, n.next) < 0 ? bt(n, e, n.next) >= 0 && bt(n, n.prev, e) >= 0 : bt(n, e, n.prev) < 0 || bt(n, n.next, e) < 0;
      }
      function vv(n, e) {
        let t = n, i = false;
        const r = (n.x + e.x) / 2, s = (n.y + e.y) / 2;
        do
          t.y > s != t.next.y > s && t.next.y !== t.y && r < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next;
        while (t !== n);
        return i;
      }
      function ap(n, e) {
        const t = new au(n.i, n.x, n.y), i = new au(e.i, e.x, e.y), r = n.next, s = e.prev;
        return n.next = e, e.prev = n, t.next = r, r.prev = t, i.next = t, t.prev = i, s.next = i, i.prev = s, i;
      }
      function op(n, e, t, i) {
        const r = new au(n, e, t);
        return i ? (r.next = i.next, r.prev = i, i.next.prev = r, i.next = r) : (r.prev = r, r.next = r), r;
      }
      function Ra(n) {
        n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ);
      }
      function au(n, e, t) {
        this.i = n, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
      }
      function xv(n, e, t, i) {
        let r = 0;
        for (let s = e, a = t - i; s < t; s += i) r += (n[a] - n[s]) * (n[s + 1] + n[a + 1]), a = s;
        return r;
      }
      class Ms {
        static area(e) {
          const t = e.length;
          let i = 0;
          for (let r = t - 1, s = 0; s < t; r = s++) i += e[r].x * e[s].y - e[s].x * e[r].y;
          return i * 0.5;
        }
        static isClockWise(e) {
          return Ms.area(e) < 0;
        }
        static triangulateShape(e, t) {
          const i = [], r = [], s = [];
          lp(e), cp(i, e);
          let a = e.length;
          t.forEach(lp);
          for (let l = 0; l < t.length; l++) r.push(a), a += t[l].length, cp(i, t[l]);
          const o = nv.triangulate(i, r);
          for (let l = 0; l < o.length; l += 3) s.push(o.slice(l, l + 3));
          return s;
        }
      }
      function lp(n) {
        const e = n.length;
        e > 2 && n[e - 1].equals(n[0]) && n.pop();
      }
      function cp(n, e) {
        for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y);
      }
      class ou extends mi {
        constructor(e = new Xo([
          new ee(0.5, 0.5),
          new ee(-0.5, 0.5),
          new ee(-0.5, -0.5),
          new ee(0.5, -0.5)
        ]), t = {}) {
          super(), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: e,
            options: t
          }, e = Array.isArray(e) ? e : [
            e
          ];
          const i = this, r = [], s = [];
          for (let o = 0, l = e.length; o < l; o++) {
            const c = e[o];
            a(c);
          }
          this.setAttribute("position", new Zt(r, 3)), this.setAttribute("uv", new Zt(s, 2)), this.computeVertexNormals();
          function a(o) {
            const l = [], c = t.curveSegments !== void 0 ? t.curveSegments : 12, u = t.steps !== void 0 ? t.steps : 1, h = t.depth !== void 0 ? t.depth : 1;
            let d = t.bevelEnabled !== void 0 ? t.bevelEnabled : true, p = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, f = t.bevelSize !== void 0 ? t.bevelSize : p - 0.1, _ = t.bevelOffset !== void 0 ? t.bevelOffset : 0, g = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const m = t.extrudePath, y = t.UVGenerator !== void 0 ? t.UVGenerator : yv;
            let x, v = false, A, E, w, R;
            m && (x = m.getSpacedPoints(u), v = true, d = false, A = m.computeFrenetFrames(u, false), E = new D(), w = new D(), R = new D()), d || (g = 0, p = 0, f = 0, _ = 0);
            const S = o.extractPoints(c);
            let T = S.shape;
            const L = S.holes;
            if (!Ms.isClockWise(T)) {
              T = T.reverse();
              for (let te = 0, $ = L.length; te < $; te++) {
                const se = L[te];
                Ms.isClockWise(se) && (L[te] = se.reverse());
              }
            }
            const B = Ms.triangulateShape(T, L), F = T;
            for (let te = 0, $ = L.length; te < $; te++) {
              const se = L[te];
              T = T.concat(se);
            }
            function H(te, $, se) {
              return $ || console.error("THREE.ExtrudeGeometry: vec does not exist"), te.clone().addScaledVector($, se);
            }
            const X = T.length, k = B.length;
            function K(te, $, se) {
              let P, fe, xe;
              const Me = te.x - $.x, oe = te.y - $.y, ke = se.x - te.x, de = se.y - te.y, C = Me * Me + oe * oe, M = Me * de - oe * ke;
              if (Math.abs(M) > Number.EPSILON) {
                const O = Math.sqrt(C), Y = Math.sqrt(ke * ke + de * de), J = $.x - oe / O, q = $.y + Me / O, Ee = se.x - de / Y, he = se.y + ke / Y, ye = ((Ee - J) * de - (he - q) * ke) / (Me * de - oe * ke);
                P = J + Me * ye - te.x, fe = q + oe * ye - te.y;
                const je = P * P + fe * fe;
                if (je <= 2) return new ee(P, fe);
                xe = Math.sqrt(je / 2);
              } else {
                let O = false;
                Me > Number.EPSILON ? ke > Number.EPSILON && (O = true) : Me < -Number.EPSILON ? ke < -Number.EPSILON && (O = true) : Math.sign(oe) === Math.sign(de) && (O = true), O ? (P = -oe, fe = Me, xe = Math.sqrt(C)) : (P = Me, fe = oe, xe = Math.sqrt(C / 2));
              }
              return new ee(P / xe, fe / xe);
            }
            const G = [];
            for (let te = 0, $ = F.length, se = $ - 1, P = te + 1; te < $; te++, se++, P++) se === $ && (se = 0), P === $ && (P = 0), G[te] = K(F[te], F[se], F[P]);
            const ie = [];
            let ue, we = G.concat();
            for (let te = 0, $ = L.length; te < $; te++) {
              const se = L[te];
              ue = [];
              for (let P = 0, fe = se.length, xe = fe - 1, Me = P + 1; P < fe; P++, xe++, Me++) xe === fe && (xe = 0), Me === fe && (Me = 0), ue[P] = K(se[P], se[xe], se[Me]);
              ie.push(ue), we = we.concat(ue);
            }
            for (let te = 0; te < g; te++) {
              const $ = te / g, se = p * Math.cos($ * Math.PI / 2), P = f * Math.sin($ * Math.PI / 2) + _;
              for (let fe = 0, xe = F.length; fe < xe; fe++) {
                const Me = H(F[fe], G[fe], P);
                _e(Me.x, Me.y, -se);
              }
              for (let fe = 0, xe = L.length; fe < xe; fe++) {
                const Me = L[fe];
                ue = ie[fe];
                for (let oe = 0, ke = Me.length; oe < ke; oe++) {
                  const de = H(Me[oe], ue[oe], P);
                  _e(de.x, de.y, -se);
                }
              }
            }
            const Be = f + _;
            for (let te = 0; te < X; te++) {
              const $ = d ? H(T[te], we[te], Be) : T[te];
              v ? (w.copy(A.normals[0]).multiplyScalar($.x), E.copy(A.binormals[0]).multiplyScalar($.y), R.copy(x[0]).add(w).add(E), _e(R.x, R.y, R.z)) : _e($.x, $.y, 0);
            }
            for (let te = 1; te <= u; te++) for (let $ = 0; $ < X; $++) {
              const se = d ? H(T[$], we[$], Be) : T[$];
              v ? (w.copy(A.normals[te]).multiplyScalar(se.x), E.copy(A.binormals[te]).multiplyScalar(se.y), R.copy(x[te]).add(w).add(E), _e(R.x, R.y, R.z)) : _e(se.x, se.y, h / u * te);
            }
            for (let te = g - 1; te >= 0; te--) {
              const $ = te / g, se = p * Math.cos($ * Math.PI / 2), P = f * Math.sin($ * Math.PI / 2) + _;
              for (let fe = 0, xe = F.length; fe < xe; fe++) {
                const Me = H(F[fe], G[fe], P);
                _e(Me.x, Me.y, h + se);
              }
              for (let fe = 0, xe = L.length; fe < xe; fe++) {
                const Me = L[fe];
                ue = ie[fe];
                for (let oe = 0, ke = Me.length; oe < ke; oe++) {
                  const de = H(Me[oe], ue[oe], P);
                  v ? _e(de.x, de.y + x[u - 1].y, x[u - 1].x + se) : _e(de.x, de.y, h + se);
                }
              }
            }
            We(), j();
            function We() {
              const te = r.length / 3;
              if (d) {
                let $ = 0, se = X * $;
                for (let P = 0; P < k; P++) {
                  const fe = B[P];
                  ae(fe[2] + se, fe[1] + se, fe[0] + se);
                }
                $ = u + g * 2, se = X * $;
                for (let P = 0; P < k; P++) {
                  const fe = B[P];
                  ae(fe[0] + se, fe[1] + se, fe[2] + se);
                }
              } else {
                for (let $ = 0; $ < k; $++) {
                  const se = B[$];
                  ae(se[2], se[1], se[0]);
                }
                for (let $ = 0; $ < k; $++) {
                  const se = B[$];
                  ae(se[0] + X * u, se[1] + X * u, se[2] + X * u);
                }
              }
              i.addGroup(te, r.length / 3 - te, 0);
            }
            function j() {
              const te = r.length / 3;
              let $ = 0;
              ne(F, $), $ += F.length;
              for (let se = 0, P = L.length; se < P; se++) {
                const fe = L[se];
                ne(fe, $), $ += fe.length;
              }
              i.addGroup(te, r.length / 3 - te, 1);
            }
            function ne(te, $) {
              let se = te.length;
              for (; --se >= 0; ) {
                const P = se;
                let fe = se - 1;
                fe < 0 && (fe = te.length - 1);
                for (let xe = 0, Me = u + g * 2; xe < Me; xe++) {
                  const oe = X * xe, ke = X * (xe + 1), de = $ + P + oe, C = $ + fe + oe, M = $ + fe + ke, O = $ + P + ke;
                  Pe(de, C, M, O);
                }
              }
            }
            function _e(te, $, se) {
              l.push(te), l.push($), l.push(se);
            }
            function ae(te, $, se) {
              Re(te), Re($), Re(se);
              const P = r.length / 3, fe = y.generateTopUV(i, r, P - 3, P - 2, P - 1);
              De(fe[0]), De(fe[1]), De(fe[2]);
            }
            function Pe(te, $, se, P) {
              Re(te), Re($), Re(P), Re($), Re(se), Re(P);
              const fe = r.length / 3, xe = y.generateSideWallUV(i, r, fe - 6, fe - 3, fe - 2, fe - 1);
              De(xe[0]), De(xe[1]), De(xe[3]), De(xe[1]), De(xe[2]), De(xe[3]);
            }
            function Re(te) {
              r.push(l[te * 3 + 0]), r.push(l[te * 3 + 1]), r.push(l[te * 3 + 2]);
            }
            function De(te) {
              s.push(te.x), s.push(te.y);
            }
          }
        }
        copy(e) {
          return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        toJSON() {
          const e = super.toJSON(), t = this.parameters.shapes, i = this.parameters.options;
          return Mv(t, i, e);
        }
        static fromJSON(e, t) {
          const i = [];
          for (let s = 0, a = e.shapes.length; s < a; s++) {
            const o = t[e.shapes[s]];
            i.push(o);
          }
          const r = e.options.extrudePath;
          return r !== void 0 && (e.options.extrudePath = new nu[r.type]().fromJSON(r)), new ou(i, e.options);
        }
      }
      const yv = {
        generateTopUV: function(n, e, t, i, r) {
          const s = e[t * 3], a = e[t * 3 + 1], o = e[i * 3], l = e[i * 3 + 1], c = e[r * 3], u = e[r * 3 + 1];
          return [
            new ee(s, a),
            new ee(o, l),
            new ee(c, u)
          ];
        },
        generateSideWallUV: function(n, e, t, i, r, s) {
          const a = e[t * 3], o = e[t * 3 + 1], l = e[t * 3 + 2], c = e[i * 3], u = e[i * 3 + 1], h = e[i * 3 + 2], d = e[r * 3], p = e[r * 3 + 1], f = e[r * 3 + 2], _ = e[s * 3], g = e[s * 3 + 1], m = e[s * 3 + 2];
          return Math.abs(o - u) < Math.abs(a - c) ? [
            new ee(a, 1 - l),
            new ee(c, 1 - h),
            new ee(d, 1 - f),
            new ee(_, 1 - m)
          ] : [
            new ee(o, 1 - l),
            new ee(u, 1 - h),
            new ee(p, 1 - f),
            new ee(g, 1 - m)
          ];
        }
      };
      function Mv(n, e, t) {
        if (t.shapes = [], Array.isArray(n)) for (let i = 0, r = n.length; i < r; i++) {
          const s = n[i];
          t.shapes.push(s.uuid);
        }
        else t.shapes.push(n.uuid);
        return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
      }
      class Ca extends mi {
        constructor(e = 1, t = 1, i = 1, r = 1) {
          super(), this.type = "PlaneGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: i,
            heightSegments: r
          };
          const s = e / 2, a = t / 2, o = Math.floor(i), l = Math.floor(r), c = o + 1, u = l + 1, h = e / o, d = t / l, p = [], f = [], _ = [], g = [];
          for (let m = 0; m < u; m++) {
            const y = m * d - a;
            for (let x = 0; x < c; x++) {
              const v = x * h - s;
              f.push(v, -y, 0), _.push(0, 0, 1), g.push(x / o), g.push(1 - m / l);
            }
          }
          for (let m = 0; m < l; m++) for (let y = 0; y < o; y++) {
            const x = y + c * m, v = y + c * (m + 1), A = y + 1 + c * (m + 1), E = y + 1 + c * m;
            p.push(x, v, E), p.push(v, A, E);
          }
          this.setIndex(p), this.setAttribute("position", new Zt(f, 3)), this.setAttribute("normal", new Zt(_, 3)), this.setAttribute("uv", new Zt(g, 2));
        }
        copy(e) {
          return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
          return new Ca(e.width, e.height, e.widthSegments, e.heightSegments);
        }
      }
      class lu extends mi {
        constructor(e = 1, t = 32, i = 16, r = 0, s = Math.PI * 2, a = 0, o = Math.PI) {
          super(), this.type = "SphereGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: i,
            phiStart: r,
            phiLength: s,
            thetaStart: a,
            thetaLength: o
          }, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i));
          const l = Math.min(a + o, Math.PI);
          let c = 0;
          const u = [], h = new D(), d = new D(), p = [], f = [], _ = [], g = [];
          for (let m = 0; m <= i; m++) {
            const y = [], x = m / i;
            let v = 0;
            m === 0 && a === 0 ? v = 0.5 / t : m === i && l === Math.PI && (v = -0.5 / t);
            for (let A = 0; A <= t; A++) {
              const E = A / t;
              h.x = -e * Math.cos(r + E * s) * Math.sin(a + x * o), h.y = e * Math.cos(a + x * o), h.z = e * Math.sin(r + E * s) * Math.sin(a + x * o), f.push(h.x, h.y, h.z), d.copy(h).normalize(), _.push(d.x, d.y, d.z), g.push(E + v, 1 - x), y.push(c++);
            }
            u.push(y);
          }
          for (let m = 0; m < i; m++) for (let y = 0; y < t; y++) {
            const x = u[m][y + 1], v = u[m][y], A = u[m + 1][y], E = u[m + 1][y + 1];
            (m !== 0 || a > 0) && p.push(x, v, E), (m !== i - 1 || l < Math.PI) && p.push(v, A, E);
          }
          this.setIndex(p), this.setAttribute("position", new Zt(f, 3)), this.setAttribute("normal", new Zt(_, 3)), this.setAttribute("uv", new Zt(g, 2));
        }
        copy(e) {
          return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
        }
        static fromJSON(e) {
          return new lu(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
        }
      }
      class Ts extends en {
        constructor(e) {
          super(), this.isMeshStandardMaterial = true, this.type = "MeshStandardMaterial", this.defines = {
            STANDARD: ""
          }, this.color = new Ae(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ae(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = nd, this.normalScale = new ee(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Qi(), this.envMapIntensity = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.defines = {
            STANDARD: ""
          }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
        }
      }
      class rn extends Ts {
        constructor(e) {
          super(), this.isMeshPhysicalMaterial = true, this.defines = {
            STANDARD: "",
            PHYSICAL: ""
          }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ee(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
            get: function() {
              return Ge(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
            },
            set: function(t) {
              this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
            }
          }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [
            100,
            400
          ], this.iridescenceThicknessMap = null, this.sheenColor = new Ae(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Ae(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Ae(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
        }
        get anisotropy() {
          return this._anisotropy;
        }
        set anisotropy(e) {
          this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(e) {
          this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
        }
        get iridescence() {
          return this._iridescence;
        }
        set iridescence(e) {
          this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
        }
        get dispersion() {
          return this._dispersion;
        }
        set dispersion(e) {
          this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(e) {
          this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(e) {
          this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
        }
        copy(e) {
          return super.copy(e), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
          }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [
            ...e.iridescenceThicknessRange
          ], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
        }
      }
      class Tv extends en {
        constructor(e) {
          super(), this.isMeshDepthMaterial = true, this.type = "MeshDepthMaterial", this.depthPacking = Dg, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
        }
      }
      class bv extends en {
        constructor(e) {
          super(), this.isMeshDistanceMaterial = true, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
        }
        copy(e) {
          return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
        }
      }
      function Ko(n, e, t) {
        return !n || n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n);
      }
      function Sv(n) {
        return ArrayBuffer.isView(n) && !(n instanceof DataView);
      }
      function Ev(n) {
        function e(r, s) {
          return n[r] - n[s];
        }
        const t = n.length, i = new Array(t);
        for (let r = 0; r !== t; ++r) i[r] = r;
        return i.sort(e), i;
      }
      function up(n, e, t) {
        const i = n.length, r = new n.constructor(i);
        for (let s = 0, a = 0; a !== i; ++s) {
          const o = t[s] * e;
          for (let l = 0; l !== e; ++l) r[a++] = n[o + l];
        }
        return r;
      }
      function hp(n, e, t, i) {
        let r = 1, s = n[0];
        for (; s !== void 0 && s[i] === void 0; ) s = n[r++];
        if (s === void 0) return;
        let a = s[i];
        if (a !== void 0) if (Array.isArray(a)) do
          a = s[i], a !== void 0 && (e.push(s.time), t.push.apply(t, a)), s = n[r++];
        while (s !== void 0);
        else if (a.toArray !== void 0) do
          a = s[i], a !== void 0 && (e.push(s.time), a.toArray(t, t.length)), s = n[r++];
        while (s !== void 0);
        else do
          a = s[i], a !== void 0 && (e.push(s.time), t.push(a)), s = n[r++];
        while (s !== void 0);
      }
      class Pa {
        constructor(e, t, i, r) {
          this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {};
        }
        evaluate(e) {
          const t = this.parameterPositions;
          let i = this._cachedIndex, r = t[i], s = t[i - 1];
          i: {
            e: {
              let a;
              t: {
                n: if (!(e < r)) {
                  for (let o = i + 2; ; ) {
                    if (r === void 0) {
                      if (e < s) break n;
                      return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
                    }
                    if (i === o) break;
                    if (s = r, r = t[++i], e < r) break e;
                  }
                  a = t.length;
                  break t;
                }
                if (!(e >= s)) {
                  const o = t[1];
                  e < o && (i = 2, s = o);
                  for (let l = i - 2; ; ) {
                    if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                    if (i === l) break;
                    if (r = s, s = t[--i - 1], e >= s) break e;
                  }
                  a = i, i = 0;
                  break t;
                }
                break i;
              }
              for (; i < a; ) {
                const o = i + a >>> 1;
                e < t[o] ? a = o : i = o + 1;
              }
              if (r = t[i], s = t[i - 1], s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
              if (r === void 0) return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
            }
            this._cachedIndex = i, this.intervalChanged_(i, s, r);
          }
          return this.interpolate_(i, s, e, r);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(e) {
          const t = this.resultBuffer, i = this.sampleValues, r = this.valueSize, s = e * r;
          for (let a = 0; a !== r; ++a) t[a] = i[s + a];
          return t;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {
        }
      }
      class wv extends Pa {
        constructor(e, t, i, r) {
          super(e, t, i, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
            endingStart: Qh,
            endingEnd: Qh
          };
        }
        intervalChanged_(e, t, i) {
          const r = this.parameterPositions;
          let s = e - 2, a = e + 1, o = r[s], l = r[a];
          if (o === void 0) switch (this.getSettings_().endingStart) {
            case ed:
              s = e, o = 2 * t - i;
              break;
            case td:
              s = r.length - 2, o = t + r[s] - r[s + 1];
              break;
            default:
              s = e, o = i;
          }
          if (l === void 0) switch (this.getSettings_().endingEnd) {
            case ed:
              a = e, l = 2 * i - t;
              break;
            case td:
              a = 1, l = i + r[1] - r[0];
              break;
            default:
              a = e - 1, l = t;
          }
          const c = (i - t) * 0.5, u = this.valueSize;
          this._weightPrev = c / (t - o), this._weightNext = c / (l - i), this._offsetPrev = s * u, this._offsetNext = a * u;
        }
        interpolate_(e, t, i, r) {
          const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = e * o, c = l - o, u = this._offsetPrev, h = this._offsetNext, d = this._weightPrev, p = this._weightNext, f = (i - t) / (r - t), _ = f * f, g = _ * f, m = -d * g + 2 * d * _ - d * f, y = (1 + d) * g + (-1.5 - 2 * d) * _ + (-0.5 + d) * f + 1, x = (-1 - p) * g + (1.5 + p) * _ + 0.5 * f, v = p * g - p * _;
          for (let A = 0; A !== o; ++A) s[A] = m * a[u + A] + y * a[c + A] + x * a[l + A] + v * a[h + A];
          return s;
        }
      }
      class Av extends Pa {
        constructor(e, t, i, r) {
          super(e, t, i, r);
        }
        interpolate_(e, t, i, r) {
          const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = e * o, c = l - o, u = (i - t) / (r - t), h = 1 - u;
          for (let d = 0; d !== o; ++d) s[d] = a[c + d] * h + a[l + d] * u;
          return s;
        }
      }
      class Rv extends Pa {
        constructor(e, t, i, r) {
          super(e, t, i, r);
        }
        interpolate_(e) {
          return this.copySampleValue_(e - 1);
        }
      }
      class sn {
        constructor(e, t, i, r) {
          if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
          this.name = e, this.times = Ko(t, this.TimeBufferType), this.values = Ko(i, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation);
        }
        static toJSON(e) {
          const t = e.constructor;
          let i;
          if (t.toJSON !== this.toJSON) i = t.toJSON(e);
          else {
            i = {
              name: e.name,
              times: Ko(e.times, Array),
              values: Ko(e.values, Array)
            };
            const r = e.getInterpolation();
            r !== e.DefaultInterpolation && (i.interpolation = r);
          }
          return i.type = e.ValueTypeName, i;
        }
        InterpolantFactoryMethodDiscrete(e) {
          return new Rv(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodLinear(e) {
          return new Av(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodSmooth(e) {
          return new wv(this.times, this.values, this.getValueSize(), e);
        }
        setInterpolation(e) {
          let t;
          switch (e) {
            case ha:
              t = this.InterpolantFactoryMethodDiscrete;
              break;
            case da:
              t = this.InterpolantFactoryMethodLinear;
              break;
            case gc:
              t = this.InterpolantFactoryMethodSmooth;
              break;
          }
          if (t === void 0) {
            const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0) if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
            else throw new Error(i);
            return console.warn("THREE.KeyframeTrack:", i), this;
          }
          return this.createInterpolant = t, this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return ha;
            case this.InterpolantFactoryMethodLinear:
              return da;
            case this.InterpolantFactoryMethodSmooth:
              return gc;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(e) {
          if (e !== 0) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i) t[i] += e;
          }
          return this;
        }
        scale(e) {
          if (e !== 1) {
            const t = this.times;
            for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e;
          }
          return this;
        }
        trim(e, t) {
          const i = this.times, r = i.length;
          let s = 0, a = r - 1;
          for (; s !== r && i[s] < e; ) ++s;
          for (; a !== -1 && i[a] > t; ) --a;
          if (++a, s !== 0 || a !== r) {
            s >= a && (a = Math.max(a, 1), s = a - 1);
            const o = this.getValueSize();
            this.times = i.slice(s, a), this.values = this.values.slice(s * o, a * o);
          }
          return this;
        }
        validate() {
          let e = true;
          const t = this.getValueSize();
          t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = false);
          const i = this.times, r = this.values, s = i.length;
          s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = false);
          let a = null;
          for (let o = 0; o !== s; o++) {
            const l = i[o];
            if (typeof l == "number" && isNaN(l)) {
              console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, l), e = false;
              break;
            }
            if (a !== null && a > l) {
              console.error("THREE.KeyframeTrack: Out of order keys.", this, o, l, a), e = false;
              break;
            }
            a = l;
          }
          if (r !== void 0 && Sv(r)) for (let o = 0, l = r.length; o !== l; ++o) {
            const c = r[o];
            if (isNaN(c)) {
              console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, c), e = false;
              break;
            }
          }
          return e;
        }
        optimize() {
          const e = this.times.slice(), t = this.values.slice(), i = this.getValueSize(), r = this.getInterpolation() === gc, s = e.length - 1;
          let a = 1;
          for (let o = 1; o < s; ++o) {
            let l = false;
            const c = e[o], u = e[o + 1];
            if (c !== u && (o !== 1 || c !== e[0])) if (r) l = true;
            else {
              const h = o * i, d = h - i, p = h + i;
              for (let f = 0; f !== i; ++f) {
                const _ = t[h + f];
                if (_ !== t[d + f] || _ !== t[p + f]) {
                  l = true;
                  break;
                }
              }
            }
            if (l) {
              if (o !== a) {
                e[a] = e[o];
                const h = o * i, d = a * i;
                for (let p = 0; p !== i; ++p) t[d + p] = t[h + p];
              }
              ++a;
            }
          }
          if (s > 0) {
            e[a] = e[s];
            for (let o = s * i, l = a * i, c = 0; c !== i; ++c) t[l + c] = t[o + c];
            ++a;
          }
          return a !== e.length ? (this.times = e.slice(0, a), this.values = t.slice(0, a * i)) : (this.times = e, this.values = t), this;
        }
        clone() {
          const e = this.times.slice(), t = this.values.slice(), i = this.constructor, r = new i(this.name, e, t);
          return r.createInterpolant = this.createInterpolant, r;
        }
      }
      sn.prototype.TimeBufferType = Float32Array, sn.prototype.ValueBufferType = Float32Array, sn.prototype.DefaultInterpolation = da;
      class bs extends sn {
        constructor(e, t, i) {
          super(e, t, i);
        }
      }
      bs.prototype.ValueTypeName = "bool", bs.prototype.ValueBufferType = Array, bs.prototype.DefaultInterpolation = ha, bs.prototype.InterpolantFactoryMethodLinear = void 0, bs.prototype.InterpolantFactoryMethodSmooth = void 0;
      class dp extends sn {
      }
      dp.prototype.ValueTypeName = "color";
      class Ss extends sn {
      }
      Ss.prototype.ValueTypeName = "number";
      class Cv extends Pa {
        constructor(e, t, i, r) {
          super(e, t, i, r);
        }
        interpolate_(e, t, i, r) {
          const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = (i - t) / (r - t);
          let c = e * o;
          for (let u = c + o; c !== u; c += 4) Vn.slerpFlat(s, 0, a, c - o, a, c, l);
          return s;
        }
      }
      class Es extends sn {
        InterpolantFactoryMethodLinear(e) {
          return new Cv(this.times, this.values, this.getValueSize(), e);
        }
      }
      Es.prototype.ValueTypeName = "quaternion", Es.prototype.InterpolantFactoryMethodSmooth = void 0;
      class ws extends sn {
        constructor(e, t, i) {
          super(e, t, i);
        }
      }
      ws.prototype.ValueTypeName = "string", ws.prototype.ValueBufferType = Array, ws.prototype.DefaultInterpolation = ha, ws.prototype.InterpolantFactoryMethodLinear = void 0, ws.prototype.InterpolantFactoryMethodSmooth = void 0;
      class As extends sn {
      }
      As.prototype.ValueTypeName = "vector";
      class Pv {
        constructor(e = "", t = -1, i = [], r = Pg) {
          this.name = e, this.tracks = i, this.duration = t, this.blendMode = r, this.uuid = Ii(), this.duration < 0 && this.resetDuration();
        }
        static parse(e) {
          const t = [], i = e.tracks, r = 1 / (e.fps || 1);
          for (let a = 0, o = i.length; a !== o; ++a) t.push(Dv(i[a]).scale(r));
          const s = new this(e.name, e.duration, t, e.blendMode);
          return s.uuid = e.uuid, s;
        }
        static toJSON(e) {
          const t = [], i = e.tracks, r = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode
          };
          for (let s = 0, a = i.length; s !== a; ++s) t.push(sn.toJSON(i[s]));
          return r;
        }
        static CreateFromMorphTargetSequence(e, t, i, r) {
          const s = t.length, a = [];
          for (let o = 0; o < s; o++) {
            let l = [], c = [];
            l.push((o + s - 1) % s, o, (o + 1) % s), c.push(0, 1, 0);
            const u = Ev(l);
            l = up(l, 1, u), c = up(c, 1, u), !r && l[0] === 0 && (l.push(s), c.push(c[0])), a.push(new Ss(".morphTargetInfluences[" + t[o].name + "]", l, c).scale(1 / i));
          }
          return new this(e, -1, a);
        }
        static findByName(e, t) {
          let i = e;
          if (!Array.isArray(e)) {
            const r = e;
            i = r.geometry && r.geometry.animations || r.animations;
          }
          for (let r = 0; r < i.length; r++) if (i[r].name === t) return i[r];
          return null;
        }
        static CreateClipsFromMorphTargetSequences(e, t, i) {
          const r = {}, s = /^([\w-]*?)([\d]+)$/;
          for (let o = 0, l = e.length; o < l; o++) {
            const c = e[o], u = c.name.match(s);
            if (u && u.length > 1) {
              const h = u[1];
              let d = r[h];
              d || (r[h] = d = []), d.push(c);
            }
          }
          const a = [];
          for (const o in r) a.push(this.CreateFromMorphTargetSequence(o, r[o], t, i));
          return a;
        }
        static parseAnimation(e, t) {
          if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
          const i = function(u, h, d, p, f) {
            if (d.length !== 0) {
              const _ = [], g = [];
              hp(d, _, g, p), _.length !== 0 && f.push(new u(h, _, g));
            }
          }, r = [], s = e.name || "default", a = e.fps || 30, o = e.blendMode;
          let l = e.length || -1;
          const c = e.hierarchy || [];
          for (let u = 0; u < c.length; u++) {
            const h = c[u].keys;
            if (!(!h || h.length === 0)) if (h[0].morphTargets) {
              const d = {};
              let p;
              for (p = 0; p < h.length; p++) if (h[p].morphTargets) for (let f = 0; f < h[p].morphTargets.length; f++) d[h[p].morphTargets[f]] = -1;
              for (const f in d) {
                const _ = [], g = [];
                for (let m = 0; m !== h[p].morphTargets.length; ++m) {
                  const y = h[p];
                  _.push(y.time), g.push(y.morphTarget === f ? 1 : 0);
                }
                r.push(new Ss(".morphTargetInfluence[" + f + "]", _, g));
              }
              l = d.length * a;
            } else {
              const d = ".bones[" + t[u].name + "]";
              i(As, d + ".position", h, "pos", r), i(Es, d + ".quaternion", h, "rot", r), i(As, d + ".scale", h, "scl", r);
            }
          }
          return r.length === 0 ? null : new this(s, l, r, o);
        }
        resetDuration() {
          const e = this.tracks;
          let t = 0;
          for (let i = 0, r = e.length; i !== r; ++i) {
            const s = this.tracks[i];
            t = Math.max(t, s.times[s.times.length - 1]);
          }
          return this.duration = t, this;
        }
        trim() {
          for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
          return this;
        }
        validate() {
          let e = true;
          for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
          return e;
        }
        optimize() {
          for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
          return this;
        }
        clone() {
          const e = [];
          for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
          return new this.constructor(this.name, this.duration, e, this.blendMode);
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function Lv(n) {
        switch (n.toLowerCase()) {
          case "scalar":
          case "double":
          case "float":
          case "number":
          case "integer":
            return Ss;
          case "vector":
          case "vector2":
          case "vector3":
          case "vector4":
            return As;
          case "color":
            return dp;
          case "quaternion":
            return Es;
          case "bool":
          case "boolean":
            return bs;
          case "string":
            return ws;
        }
        throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
      }
      function Dv(n) {
        if (n.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
        const e = Lv(n.type);
        if (n.times === void 0) {
          const t = [], i = [];
          hp(n.keys, t, i, "value"), n.times = t, n.values = i;
        }
        return e.parse !== void 0 ? e.parse(n) : new e(n.name, n.times, n.values, n.interpolation);
      }
      const Kn = {
        enabled: false,
        files: {},
        add: function(n, e) {
          this.enabled !== false && (this.files[n] = e);
        },
        get: function(n) {
          if (this.enabled !== false) return this.files[n];
        },
        remove: function(n) {
          delete this.files[n];
        },
        clear: function() {
          this.files = {};
        }
      };
      class Iv {
        constructor(e, t, i) {
          const r = this;
          let s = false, a = 0, o = 0, l;
          const c = [];
          this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(u) {
            o++, s === false && r.onStart !== void 0 && r.onStart(u, a, o), s = true;
          }, this.itemEnd = function(u) {
            a++, r.onProgress !== void 0 && r.onProgress(u, a, o), a === o && (s = false, r.onLoad !== void 0 && r.onLoad());
          }, this.itemError = function(u) {
            r.onError !== void 0 && r.onError(u);
          }, this.resolveURL = function(u) {
            return l ? l(u) : u;
          }, this.setURLModifier = function(u) {
            return l = u, this;
          }, this.addHandler = function(u, h) {
            return c.push(u, h), this;
          }, this.removeHandler = function(u) {
            const h = c.indexOf(u);
            return h !== -1 && c.splice(h, 2), this;
          }, this.getHandler = function(u) {
            for (let h = 0, d = c.length; h < d; h += 2) {
              const p = c[h], f = c[h + 1];
              if (p.global && (p.lastIndex = 0), p.test(u)) return f;
            }
            return null;
          };
        }
      }
      const Nv = new Iv();
      class _r {
        constructor(e) {
          this.manager = e !== void 0 ? e : Nv, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
        }
        load() {
        }
        loadAsync(e, t) {
          const i = this;
          return new Promise(function(r, s) {
            i.load(e, r, t, s);
          });
        }
        parse() {
        }
        setCrossOrigin(e) {
          return this.crossOrigin = e, this;
        }
        setWithCredentials(e) {
          return this.withCredentials = e, this;
        }
        setPath(e) {
          return this.path = e, this;
        }
        setResourcePath(e) {
          return this.resourcePath = e, this;
        }
        setRequestHeader(e) {
          return this.requestHeader = e, this;
        }
      }
      _r.DEFAULT_MATERIAL_NAME = "__DEFAULT";
      const Sn = {};
      class Uv extends Error {
        constructor(e, t) {
          super(e), this.response = t;
        }
      }
      class cu extends _r {
        constructor(e) {
          super(e);
        }
        load(e, t, i, r) {
          e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
          const s = Kn.get(e);
          if (s !== void 0) return this.manager.itemStart(e), setTimeout(() => {
            t && t(s), this.manager.itemEnd(e);
          }, 0), s;
          if (Sn[e] !== void 0) {
            Sn[e].push({
              onLoad: t,
              onProgress: i,
              onError: r
            });
            return;
          }
          Sn[e] = [], Sn[e].push({
            onLoad: t,
            onProgress: i,
            onError: r
          });
          const a = new Request(e, {
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
          }), o = this.mimeType, l = this.responseType;
          fetch(a).then((c) => {
            if (c.status === 200 || c.status === 0) {
              if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0) return c;
              const u = Sn[e], h = c.body.getReader(), d = c.headers.get("X-File-Size") || c.headers.get("Content-Length"), p = d ? parseInt(d) : 0, f = p !== 0;
              let _ = 0;
              const g = new ReadableStream({
                start(m) {
                  y();
                  function y() {
                    h.read().then(({ done: x, value: v }) => {
                      if (x) m.close();
                      else {
                        _ += v.byteLength;
                        const A = new ProgressEvent("progress", {
                          lengthComputable: f,
                          loaded: _,
                          total: p
                        });
                        for (let E = 0, w = u.length; E < w; E++) {
                          const R = u[E];
                          R.onProgress && R.onProgress(A);
                        }
                        m.enqueue(v), y();
                      }
                    }, (x) => {
                      m.error(x);
                    });
                  }
                }
              });
              return new Response(g);
            } else throw new Uv(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c);
          }).then((c) => {
            switch (l) {
              case "arraybuffer":
                return c.arrayBuffer();
              case "blob":
                return c.blob();
              case "document":
                return c.text().then((u) => new DOMParser().parseFromString(u, o));
              case "json":
                return c.json();
              default:
                if (o === void 0) return c.text();
                {
                  const u = /charset="?([^;"\s]*)"?/i.exec(o), h = u && u[1] ? u[1].toLowerCase() : void 0, d = new TextDecoder(h);
                  return c.arrayBuffer().then((p) => d.decode(p));
                }
            }
          }).then((c) => {
            Kn.add(e, c);
            const u = Sn[e];
            delete Sn[e];
            for (let h = 0, d = u.length; h < d; h++) {
              const p = u[h];
              p.onLoad && p.onLoad(c);
            }
          }).catch((c) => {
            const u = Sn[e];
            if (u === void 0) throw this.manager.itemError(e), c;
            delete Sn[e];
            for (let h = 0, d = u.length; h < d; h++) {
              const p = u[h];
              p.onError && p.onError(c);
            }
            this.manager.itemError(e);
          }).finally(() => {
            this.manager.itemEnd(e);
          }), this.manager.itemStart(e);
        }
        setResponseType(e) {
          return this.responseType = e, this;
        }
        setMimeType(e) {
          return this.mimeType = e, this;
        }
      }
      class Ov extends _r {
        constructor(e) {
          super(e);
        }
        load(e, t, i, r) {
          this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
          const s = this, a = Kn.get(e);
          if (a !== void 0) return s.manager.itemStart(e), setTimeout(function() {
            t && t(a), s.manager.itemEnd(e);
          }, 0), a;
          const o = ma("img");
          function l() {
            u(), Kn.add(e, this), t && t(this), s.manager.itemEnd(e);
          }
          function c(h) {
            u(), r && r(h), s.manager.itemError(e), s.manager.itemEnd(e);
          }
          function u() {
            o.removeEventListener("load", l, false), o.removeEventListener("error", c, false);
          }
          return o.addEventListener("load", l, false), o.addEventListener("error", c, false), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), s.manager.itemStart(e), o.src = e, o;
        }
      }
      class Fv extends _r {
        constructor(e) {
          super(e);
        }
        load(e, t, i, r) {
          const s = new kt(), a = new Ov(this.manager);
          return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(o) {
            s.image = o, s.needsUpdate = true, t !== void 0 && t(s);
          }, i, r), s;
        }
      }
      class Zo extends Tt {
        constructor(e, t = 1) {
          super(), this.isLight = true, this.type = "Light", this.color = new Ae(e), this.intensity = t;
        }
        dispose() {
        }
        copy(e, t) {
          return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (t.object.target = this.target.uuid), t;
        }
      }
      const uu = new Fe(), pp = new D(), fp = new D();
      class hu {
        constructor(e) {
          this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new ee(512, 512), this.map = null, this.mapPass = null, this.matrix = new Fe(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new qc(), this._frameExtents = new ee(1, 1), this._viewportCount = 1, this._viewports = [
            new it(0, 0, 1, 1)
          ];
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(e) {
          const t = this.camera, i = this.matrix;
          pp.setFromMatrixPosition(e.matrixWorld), t.position.copy(pp), fp.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(fp), t.updateMatrixWorld(), uu.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(uu), i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i.multiply(uu);
        }
        getViewport(e) {
          return this._viewports[e];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
        }
        copy(e) {
          return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = {};
          return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(false).object, delete e.camera.matrix, e;
        }
      }
      class Bv extends hu {
        constructor() {
          super(new ui(50, 1, 0.5, 500)), this.isSpotLightShadow = true, this.focus = 1;
        }
        updateMatrices(e) {
          const t = this.camera, i = ns * 2 * e.angle * this.focus, r = this.mapSize.width / this.mapSize.height, s = e.distance || t.far;
          (i !== t.fov || r !== t.aspect || s !== t.far) && (t.fov = i, t.aspect = r, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e);
        }
        copy(e) {
          return super.copy(e), this.focus = e.focus, this;
        }
      }
      class zv extends Zo {
        constructor(e, t, i = 0, r = Math.PI / 3, s = 0, a = 2) {
          super(e, t), this.isSpotLight = true, this.type = "SpotLight", this.position.copy(Tt.DEFAULT_UP), this.updateMatrix(), this.target = new Tt(), this.distance = i, this.angle = r, this.penumbra = s, this.decay = a, this.map = null, this.shadow = new Bv();
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(e) {
          this.intensity = e / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e, t) {
          return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
        }
      }
      const mp = new Fe(), La = new D(), du = new D();
      class kv extends hu {
        constructor() {
          super(new ui(90, 1, 0.5, 500)), this.isPointLightShadow = true, this._frameExtents = new ee(4, 2), this._viewportCount = 6, this._viewports = [
            new it(2, 1, 1, 1),
            new it(0, 1, 1, 1),
            new it(3, 1, 1, 1),
            new it(1, 1, 1, 1),
            new it(3, 0, 1, 1),
            new it(1, 0, 1, 1)
          ], this._cubeDirections = [
            new D(1, 0, 0),
            new D(-1, 0, 0),
            new D(0, 0, 1),
            new D(0, 0, -1),
            new D(0, 1, 0),
            new D(0, -1, 0)
          ], this._cubeUps = [
            new D(0, 1, 0),
            new D(0, 1, 0),
            new D(0, 1, 0),
            new D(0, 1, 0),
            new D(0, 0, 1),
            new D(0, 0, -1)
          ];
        }
        updateMatrices(e, t = 0) {
          const i = this.camera, r = this.matrix, s = e.distance || i.far;
          s !== i.far && (i.far = s, i.updateProjectionMatrix()), La.setFromMatrixPosition(e.matrixWorld), i.position.copy(La), du.copy(i.position), du.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(du), i.updateMatrixWorld(), r.makeTranslation(-La.x, -La.y, -La.z), mp.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(mp);
        }
      }
      class pu extends Zo {
        constructor(e, t, i = 0, r = 2) {
          super(e, t), this.isPointLight = true, this.type = "PointLight", this.distance = i, this.decay = r, this.shadow = new kv();
        }
        get power() {
          return this.intensity * 4 * Math.PI;
        }
        set power(e) {
          this.intensity = e / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e, t) {
          return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
        }
      }
      class Jo extends Pd {
        constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, a = 2e3) {
          super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = r, this.near = s, this.far = a, this.updateProjectionMatrix();
        }
        copy(e, t) {
          return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
        }
        setViewOffset(e, t, i, r, s, a) {
          this.view === null && (this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = r, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
        }
        clearViewOffset() {
          this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2;
          let s = i - e, a = i + e, o = r + t, l = r - t;
          if (this.view !== null && this.view.enabled) {
            const c = (this.right - this.left) / this.view.fullWidth / this.zoom, u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += c * this.view.offsetX, a = s + c * this.view.width, o -= u * this.view.offsetY, l = o - u * this.view.height;
          }
          this.projectionMatrix.makeOrthographic(s, a, o, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
        }
      }
      class Vv extends hu {
        constructor() {
          super(new Jo(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = true;
        }
      }
      class gp extends Zo {
        constructor(e, t) {
          super(e, t), this.isDirectionalLight = true, this.type = "DirectionalLight", this.position.copy(Tt.DEFAULT_UP), this.updateMatrix(), this.target = new Tt(), this.shadow = new Vv();
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
        }
      }
      class _p extends Zo {
        constructor(e, t) {
          super(e, t), this.isAmbientLight = true, this.type = "AmbientLight";
        }
      }
      class Da {
        static decodeText(e) {
          if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."), typeof TextDecoder < "u") return new TextDecoder().decode(e);
          let t = "";
          for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i]);
          try {
            return decodeURIComponent(escape(t));
          } catch {
            return t;
          }
        }
        static extractUrlBase(e) {
          const t = e.lastIndexOf("/");
          return t === -1 ? "./" : e.slice(0, t + 1);
        }
        static resolveURL(e, t) {
          return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
        }
      }
      class Hv extends _r {
        constructor(e) {
          super(e), this.isImageBitmapLoader = true, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
            premultiplyAlpha: "none"
          };
        }
        setOptions(e) {
          return this.options = e, this;
        }
        load(e, t, i, r) {
          e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
          const s = this, a = Kn.get(e);
          if (a !== void 0) {
            if (s.manager.itemStart(e), a.then) {
              a.then((c) => {
                t && t(c), s.manager.itemEnd(e);
              }).catch((c) => {
                r && r(c);
              });
              return;
            }
            return setTimeout(function() {
              t && t(a), s.manager.itemEnd(e);
            }, 0), a;
          }
          const o = {};
          o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o.headers = this.requestHeader;
          const l = fetch(e, o).then(function(c) {
            return c.blob();
          }).then(function(c) {
            return createImageBitmap(c, Object.assign(s.options, {
              colorSpaceConversion: "none"
            }));
          }).then(function(c) {
            return Kn.add(e, c), t && t(c), s.manager.itemEnd(e), c;
          }).catch(function(c) {
            r && r(c), Kn.remove(e), s.manager.itemError(e), s.manager.itemEnd(e);
          });
          Kn.add(e, l), s.manager.itemStart(e);
        }
      }
      class Gv extends ui {
        constructor(e = []) {
          super(), this.isArrayCamera = true, this.cameras = e, this.index = 0;
        }
      }
      class Wv {
        constructor(e = true) {
          this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
        }
        start() {
          this.startTime = vp(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
        }
        stop() {
          this.getElapsedTime(), this.running = false, this.autoStart = false;
        }
        getElapsedTime() {
          return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
          let e = 0;
          if (this.autoStart && !this.running) return this.start(), 0;
          if (this.running) {
            const t = vp();
            e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
          }
          return e;
        }
      }
      function vp() {
        return performance.now();
      }
      const fu = "\\[\\]\\.:\\/", Xv = new RegExp("[" + fu + "]", "g"), mu = "[^" + fu + "]", jv = "[^" + fu.replace("\\.", "") + "]", qv = /((?:WC+[\/:])*)/.source.replace("WC", mu), Yv = /(WCOD+)?/.source.replace("WCOD", jv), Kv = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", mu), Zv = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", mu), Jv = new RegExp("^" + qv + Yv + Kv + Zv + "$"), $v = [
        "material",
        "materials",
        "bones",
        "map"
      ];
      class Qv {
        constructor(e, t, i) {
          const r = i || ot.parseTrackName(t);
          this._targetGroup = e, this._bindings = e.subscribe_(t, r);
        }
        getValue(e, t) {
          this.bind();
          const i = this._targetGroup.nCachedObjects_, r = this._bindings[i];
          r !== void 0 && r.getValue(e, t);
        }
        setValue(e, t) {
          const i = this._bindings;
          for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r) i[r].setValue(e, t);
        }
        bind() {
          const e = this._bindings;
          for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind();
        }
        unbind() {
          const e = this._bindings;
          for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind();
        }
      }
      class ot {
        constructor(e, t, i) {
          this.path = t, this.parsedPath = i || ot.parseTrackName(t), this.node = ot.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
        static create(e, t, i) {
          return e && e.isAnimationObjectGroup ? new ot.Composite(e, t, i) : new ot(e, t, i);
        }
        static sanitizeNodeName(e) {
          return e.replace(/\s/g, "_").replace(Xv, "");
        }
        static parseTrackName(e) {
          const t = Jv.exec(e);
          if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
          const i = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
          }, r = i.nodeName && i.nodeName.lastIndexOf(".");
          if (r !== void 0 && r !== -1) {
            const s = i.nodeName.substring(r + 1);
            $v.indexOf(s) !== -1 && (i.nodeName = i.nodeName.substring(0, r), i.objectName = s);
          }
          if (i.propertyName === null || i.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
          return i;
        }
        static findNode(e, t) {
          if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
          if (e.skeleton) {
            const i = e.skeleton.getBoneByName(t);
            if (i !== void 0) return i;
          }
          if (e.children) {
            const i = function(s) {
              for (let a = 0; a < s.length; a++) {
                const o = s[a];
                if (o.name === t || o.uuid === t) return o;
                const l = i(o.children);
                if (l) return l;
              }
              return null;
            }, r = i(e.children);
            if (r) return r;
          }
          return null;
        }
        _getValue_unavailable() {
        }
        _setValue_unavailable() {
        }
        _getValue_direct(e, t) {
          e[t] = this.targetObject[this.propertyName];
        }
        _getValue_array(e, t) {
          const i = this.resolvedProperty;
          for (let r = 0, s = i.length; r !== s; ++r) e[t++] = i[r];
        }
        _getValue_arrayElement(e, t) {
          e[t] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(e, t) {
          this.resolvedProperty.toArray(e, t);
        }
        _setValue_direct(e, t) {
          this.targetObject[this.propertyName] = e[t];
        }
        _setValue_direct_setNeedsUpdate(e, t) {
          this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = true;
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
          this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_array(e, t) {
          const i = this.resolvedProperty;
          for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
        }
        _setValue_array_setNeedsUpdate(e, t) {
          const i = this.resolvedProperty;
          for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
          this.targetObject.needsUpdate = true;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
          const i = this.resolvedProperty;
          for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_arrayElement(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t];
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = true;
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _setValue_fromArray(e, t) {
          this.resolvedProperty.fromArray(e, t);
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = true;
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = true;
        }
        _getValue_unbound(e, t) {
          this.bind(), this.getValue(e, t);
        }
        _setValue_unbound(e, t) {
          this.bind(), this.setValue(e, t);
        }
        bind() {
          let e = this.node;
          const t = this.parsedPath, i = t.objectName, r = t.propertyName;
          let s = t.propertyIndex;
          if (e || (e = ot.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return;
          }
          if (i) {
            let c = t.objectIndex;
            switch (i) {
              case "materials":
                if (!e.material) {
                  console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  return;
                }
                if (!e.material.materials) {
                  console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                  return;
                }
                e = e.material.materials;
                break;
              case "bones":
                if (!e.skeleton) {
                  console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                  return;
                }
                e = e.skeleton.bones;
                for (let u = 0; u < e.length; u++) if (e[u].name === c) {
                  c = u;
                  break;
                }
                break;
              case "map":
                if ("map" in e) {
                  e = e.map;
                  break;
                }
                if (!e.material) {
                  console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  return;
                }
                if (!e.material.map) {
                  console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                  return;
                }
                e = e.material.map;
                break;
              default:
                if (e[i] === void 0) {
                  console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                  return;
                }
                e = e[i];
            }
            if (c !== void 0) {
              if (e[c] === void 0) {
                console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                return;
              }
              e = e[c];
            }
          }
          const a = e[r];
          if (a === void 0) {
            const c = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + r + " but it wasn't found.", e);
            return;
          }
          let o = this.Versioning.None;
          this.targetObject = e, e.isMaterial === true ? o = this.Versioning.NeedsUpdate : e.isObject3D === true && (o = this.Versioning.MatrixWorldNeedsUpdate);
          let l = this.BindingType.Direct;
          if (s !== void 0) {
            if (r === "morphTargetInfluences") {
              if (!e.geometry) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                return;
              }
              if (!e.geometry.morphAttributes) {
                console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                return;
              }
              e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s]);
            }
            l = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = s;
          } else a.fromArray !== void 0 && a.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (l = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = r;
          this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][o];
        }
        unbind() {
          this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
        }
      }
      ot.Composite = Qv, ot.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
      }, ot.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
      }, ot.prototype.GetterByBindingType = [
        ot.prototype._getValue_direct,
        ot.prototype._getValue_array,
        ot.prototype._getValue_arrayElement,
        ot.prototype._getValue_toArray
      ], ot.prototype.SetterByBindingTypeAndVersioning = [
        [
          ot.prototype._setValue_direct,
          ot.prototype._setValue_direct_setNeedsUpdate,
          ot.prototype._setValue_direct_setMatrixWorldNeedsUpdate
        ],
        [
          ot.prototype._setValue_array,
          ot.prototype._setValue_array_setNeedsUpdate,
          ot.prototype._setValue_array_setMatrixWorldNeedsUpdate
        ],
        [
          ot.prototype._setValue_arrayElement,
          ot.prototype._setValue_arrayElement_setNeedsUpdate,
          ot.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
        ],
        [
          ot.prototype._setValue_fromArray,
          ot.prototype._setValue_fromArray_setNeedsUpdate,
          ot.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
        ]
      ];
      const xp = new Fe();
      class vr {
        constructor(e, t, i = 0, r = 1 / 0) {
          this.ray = new va(e, t), this.near = i, this.far = r, this.camera = null, this.layers = new Rc(), this.params = {
            Mesh: {},
            Line: {
              threshold: 1
            },
            LOD: {},
            Points: {
              threshold: 1
            },
            Sprite: {}
          };
        }
        set(e, t) {
          this.ray.set(e, t);
        }
        setFromCamera(e, t) {
          t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
        }
        setFromXRController(e) {
          return xp.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(xp), this;
        }
        intersectObject(e, t = true, i = []) {
          return gu(e, this, i, t), i.sort(yp), i;
        }
        intersectObjects(e, t = true, i = []) {
          for (let r = 0, s = e.length; r < s; r++) gu(e[r], this, i, t);
          return i.sort(yp), i;
        }
      }
      function yp(n, e) {
        return n.distance - e.distance;
      }
      function gu(n, e, t, i) {
        let r = true;
        if (n.layers.test(e.layers) && n.raycast(e, t) === false && (r = false), r === true && i === true) {
          const s = n.children;
          for (let a = 0, o = s.length; a < o; a++) gu(s[a], e, t, true);
        }
      }
      class e0 {
        constructor() {
          this.type = "ShapePath", this.color = new Ae(), this.subPaths = [], this.currentPath = null;
        }
        moveTo(e, t) {
          return this.currentPath = new ru(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
        }
        lineTo(e, t) {
          return this.currentPath.lineTo(e, t), this;
        }
        quadraticCurveTo(e, t, i, r) {
          return this.currentPath.quadraticCurveTo(e, t, i, r), this;
        }
        bezierCurveTo(e, t, i, r, s, a) {
          return this.currentPath.bezierCurveTo(e, t, i, r, s, a), this;
        }
        splineThru(e) {
          return this.currentPath.splineThru(e), this;
        }
        toShapes(e) {
          function t(m) {
            const y = [];
            for (let x = 0, v = m.length; x < v; x++) {
              const A = m[x], E = new Xo();
              E.curves = A.curves, y.push(E);
            }
            return y;
          }
          function i(m, y) {
            const x = y.length;
            let v = false;
            for (let A = x - 1, E = 0; E < x; A = E++) {
              let w = y[A], R = y[E], S = R.x - w.x, T = R.y - w.y;
              if (Math.abs(T) > Number.EPSILON) {
                if (T < 0 && (w = y[E], S = -S, R = y[A], T = -T), m.y < w.y || m.y > R.y) continue;
                if (m.y === w.y) {
                  if (m.x === w.x) return true;
                } else {
                  const L = T * (m.x - w.x) - S * (m.y - w.y);
                  if (L === 0) return true;
                  if (L < 0) continue;
                  v = !v;
                }
              } else {
                if (m.y !== w.y) continue;
                if (R.x <= m.x && m.x <= w.x || w.x <= m.x && m.x <= R.x) return true;
              }
            }
            return v;
          }
          const r = Ms.isClockWise, s = this.subPaths;
          if (s.length === 0) return [];
          let a, o, l;
          const c = [];
          if (s.length === 1) return o = s[0], l = new Xo(), l.curves = o.curves, c.push(l), c;
          let u = !r(s[0].getPoints());
          u = e ? !u : u;
          const h = [], d = [];
          let p = [], f = 0, _;
          d[f] = void 0, p[f] = [];
          for (let m = 0, y = s.length; m < y; m++) o = s[m], _ = o.getPoints(), a = r(_), a = e ? !a : a, a ? (!u && d[f] && f++, d[f] = {
            s: new Xo(),
            p: _
          }, d[f].s.curves = o.curves, u && f++, p[f] = []) : p[f].push({
            h: o,
            p: _[0]
          });
          if (!d[0]) return t(s);
          if (d.length > 1) {
            let m = false, y = 0;
            for (let x = 0, v = d.length; x < v; x++) h[x] = [];
            for (let x = 0, v = d.length; x < v; x++) {
              const A = p[x];
              for (let E = 0; E < A.length; E++) {
                const w = A[E];
                let R = true;
                for (let S = 0; S < d.length; S++) i(w.p, d[S].p) && (x !== S && y++, R ? (R = false, h[S].push(w)) : m = true);
                R && h[x].push(w);
              }
            }
            y > 0 && m === false && (p = h);
          }
          let g;
          for (let m = 0, y = d.length; m < y; m++) {
            l = d[m].s, c.push(l), g = p[m];
            for (let x = 0, v = g.length; x < v; x++) l.holes.push(g[x].h);
          }
          return c;
        }
      }
      function Mp(n, e, t, i) {
        const r = t0(i);
        switch (t) {
          case qh:
            return n * e;
          case Kh:
            return n * e;
          case Zh:
            return n * e * 2;
          case kl:
            return n * e / r.components * r.byteLength;
          case Vl:
            return n * e / r.components * r.byteLength;
          case Jh:
            return n * e * 2 / r.components * r.byteLength;
          case Hl:
            return n * e * 2 / r.components * r.byteLength;
          case Yh:
            return n * e * 3 / r.components * r.byteLength;
          case Di:
            return n * e * 4 / r.components * r.byteLength;
          case Gl:
            return n * e * 4 / r.components * r.byteLength;
          case uo:
          case ho:
            return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
          case po:
          case fo:
            return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
          case Xl:
          case ql:
            return Math.max(n, 16) * Math.max(e, 8) / 4;
          case Wl:
          case jl:
            return Math.max(n, 8) * Math.max(e, 8) / 2;
          case Yl:
          case Kl:
            return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
          case Zl:
            return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
          case Jl:
            return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
          case $l:
            return Math.floor((n + 4) / 5) * Math.floor((e + 3) / 4) * 16;
          case Ql:
            return Math.floor((n + 4) / 5) * Math.floor((e + 4) / 5) * 16;
          case ec:
            return Math.floor((n + 5) / 6) * Math.floor((e + 4) / 5) * 16;
          case tc:
            return Math.floor((n + 5) / 6) * Math.floor((e + 5) / 6) * 16;
          case ic:
            return Math.floor((n + 7) / 8) * Math.floor((e + 4) / 5) * 16;
          case nc:
            return Math.floor((n + 7) / 8) * Math.floor((e + 5) / 6) * 16;
          case rc:
            return Math.floor((n + 7) / 8) * Math.floor((e + 7) / 8) * 16;
          case sc:
            return Math.floor((n + 9) / 10) * Math.floor((e + 4) / 5) * 16;
          case ac:
            return Math.floor((n + 9) / 10) * Math.floor((e + 5) / 6) * 16;
          case oc:
            return Math.floor((n + 9) / 10) * Math.floor((e + 7) / 8) * 16;
          case lc:
            return Math.floor((n + 9) / 10) * Math.floor((e + 9) / 10) * 16;
          case cc:
            return Math.floor((n + 11) / 12) * Math.floor((e + 9) / 10) * 16;
          case uc:
            return Math.floor((n + 11) / 12) * Math.floor((e + 11) / 12) * 16;
          case mo:
          case hc:
          case dc:
            return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
          case $h:
          case pc:
            return Math.ceil(n / 4) * Math.ceil(e / 4) * 8;
          case fc:
          case mc:
            return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
        }
        throw new Error(`Unable to determine texture byte length for ${t} format.`);
      }
      function t0(n) {
        switch (n) {
          case fn:
          case Wh:
            return {
              byteLength: 1,
              components: 1
            };
          case ua:
          case Xh:
          case mn:
            return {
              byteLength: 2,
              components: 1
            };
          case Bl:
          case zl:
            return {
              byteLength: 2,
              components: 4
            };
          case cr:
          case Fl:
          case Vi:
            return {
              byteLength: 4,
              components: 1
            };
          case jh:
            return {
              byteLength: 4,
              components: 3
            };
        }
        throw new Error(`Unknown texture type ${n}.`);
      }
      typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
        detail: {
          revision: nt
        }
      })), typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = nt);
      function Tp() {
        let n = null, e = false, t = null, i = null;
        function r(s, a) {
          t(s, a), i = n.requestAnimationFrame(r);
        }
        return {
          start: function() {
            e !== true && t !== null && (i = n.requestAnimationFrame(r), e = true);
          },
          stop: function() {
            n.cancelAnimationFrame(i), e = false;
          },
          setAnimationLoop: function(s) {
            t = s;
          },
          setContext: function(s) {
            n = s;
          }
        };
      }
      function i0(n) {
        const e = /* @__PURE__ */ new WeakMap();
        function t(o, l) {
          const c = o.array, u = o.usage, h = c.byteLength, d = n.createBuffer();
          n.bindBuffer(l, d), n.bufferData(l, c, u), o.onUploadCallback();
          let p;
          if (c instanceof Float32Array) p = n.FLOAT;
          else if (c instanceof Uint16Array) o.isFloat16BufferAttribute ? p = n.HALF_FLOAT : p = n.UNSIGNED_SHORT;
          else if (c instanceof Int16Array) p = n.SHORT;
          else if (c instanceof Uint32Array) p = n.UNSIGNED_INT;
          else if (c instanceof Int32Array) p = n.INT;
          else if (c instanceof Int8Array) p = n.BYTE;
          else if (c instanceof Uint8Array) p = n.UNSIGNED_BYTE;
          else if (c instanceof Uint8ClampedArray) p = n.UNSIGNED_BYTE;
          else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
          return {
            buffer: d,
            type: p,
            bytesPerElement: c.BYTES_PER_ELEMENT,
            version: o.version,
            size: h
          };
        }
        function i(o, l, c) {
          const u = l.array, h = l.updateRanges;
          if (n.bindBuffer(c, o), h.length === 0) n.bufferSubData(c, 0, u);
          else {
            h.sort((p, f) => p.start - f.start);
            let d = 0;
            for (let p = 1; p < h.length; p++) {
              const f = h[d], _ = h[p];
              _.start <= f.start + f.count + 1 ? f.count = Math.max(f.count, _.start + _.count - f.start) : (++d, h[d] = _);
            }
            h.length = d + 1;
            for (let p = 0, f = h.length; p < f; p++) {
              const _ = h[p];
              n.bufferSubData(c, _.start * u.BYTES_PER_ELEMENT, u, _.start, _.count);
            }
            l.clearUpdateRanges();
          }
          l.onUploadCallback();
        }
        function r(o) {
          return o.isInterleavedBufferAttribute && (o = o.data), e.get(o);
        }
        function s(o) {
          o.isInterleavedBufferAttribute && (o = o.data);
          const l = e.get(o);
          l && (n.deleteBuffer(l.buffer), e.delete(o));
        }
        function a(o, l) {
          if (o.isInterleavedBufferAttribute && (o = o.data), o.isGLBufferAttribute) {
            const u = e.get(o);
            (!u || u.version < o.version) && e.set(o, {
              buffer: o.buffer,
              type: o.type,
              bytesPerElement: o.elementSize,
              version: o.version
            });
            return;
          }
          const c = e.get(o);
          if (c === void 0) e.set(o, t(o, l));
          else if (c.version < o.version) {
            if (c.size !== o.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            i(c.buffer, o, l), c.version = o.version;
          }
        }
        return {
          get: r,
          remove: s,
          update: a
        };
      }
      var n0 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, r0 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, s0 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, a0 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, o0 = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, l0 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, c0 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, u0 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, h0 = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, d0 = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, p0 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, f0 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, m0 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, g0 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, _0 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, v0 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, x0 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, y0 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, M0 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, T0 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, b0 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, S0 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, E0 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, w0 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, A0 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, R0 = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, C0 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, P0 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, L0 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, D0 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, I0 = "gl_FragColor = linearToOutputTexel( gl_FragColor );", N0 = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, U0 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, O0 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, F0 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, B0 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, z0 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, k0 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, V0 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, H0 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, G0 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, W0 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, X0 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, j0 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, q0 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, Y0 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, K0 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, Z0 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, J0 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, $0 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, Q0 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, ex = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, tx = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, ix = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, nx = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, rx = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, sx = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, ax = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, ox = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, lx = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, cx = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, ux = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, hx = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, dx = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, px = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, fx = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, mx = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, gx = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, _x = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, vx = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, xx = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, yx = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, Mx = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, Tx = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, bx = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, Sx = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, Ex = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, wx = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, Ax = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, Rx = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, Cx = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, Px = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, Lx = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, Dx = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, Ix = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, Nx = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, Ux = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, Ox = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, Fx = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, Bx = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, zx = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, kx = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, Vx = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, Hx = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, Gx = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, Wx = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, Xx = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, jx = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, qx = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, Yx = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, Kx = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, Zx = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, Jx = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, $x = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Qx = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, ey = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, ty = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
      const iy = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, ny = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, ry = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, sy = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, ay = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, oy = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, ly = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, cy = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, uy = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, hy = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, dy = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, py = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, fy = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, my = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, gy = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, _y = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, vy = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, xy = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, yy = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, My = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Ty = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, by = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, Sy = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Ey = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, wy = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, Ay = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Ry = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Cy = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Py = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, Ly = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, Dy = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Iy = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Ny = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Uy = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Ve = {
        alphahash_fragment: n0,
        alphahash_pars_fragment: r0,
        alphamap_fragment: s0,
        alphamap_pars_fragment: a0,
        alphatest_fragment: o0,
        alphatest_pars_fragment: l0,
        aomap_fragment: c0,
        aomap_pars_fragment: u0,
        batching_pars_vertex: h0,
        batching_vertex: d0,
        begin_vertex: p0,
        beginnormal_vertex: f0,
        bsdfs: m0,
        iridescence_fragment: g0,
        bumpmap_pars_fragment: _0,
        clipping_planes_fragment: v0,
        clipping_planes_pars_fragment: x0,
        clipping_planes_pars_vertex: y0,
        clipping_planes_vertex: M0,
        color_fragment: T0,
        color_pars_fragment: b0,
        color_pars_vertex: S0,
        color_vertex: E0,
        common: w0,
        cube_uv_reflection_fragment: A0,
        defaultnormal_vertex: R0,
        displacementmap_pars_vertex: C0,
        displacementmap_vertex: P0,
        emissivemap_fragment: L0,
        emissivemap_pars_fragment: D0,
        colorspace_fragment: I0,
        colorspace_pars_fragment: N0,
        envmap_fragment: U0,
        envmap_common_pars_fragment: O0,
        envmap_pars_fragment: F0,
        envmap_pars_vertex: B0,
        envmap_physical_pars_fragment: K0,
        envmap_vertex: z0,
        fog_vertex: k0,
        fog_pars_vertex: V0,
        fog_fragment: H0,
        fog_pars_fragment: G0,
        gradientmap_pars_fragment: W0,
        lightmap_pars_fragment: X0,
        lights_lambert_fragment: j0,
        lights_lambert_pars_fragment: q0,
        lights_pars_begin: Y0,
        lights_toon_fragment: Z0,
        lights_toon_pars_fragment: J0,
        lights_phong_fragment: $0,
        lights_phong_pars_fragment: Q0,
        lights_physical_fragment: ex,
        lights_physical_pars_fragment: tx,
        lights_fragment_begin: ix,
        lights_fragment_maps: nx,
        lights_fragment_end: rx,
        logdepthbuf_fragment: sx,
        logdepthbuf_pars_fragment: ax,
        logdepthbuf_pars_vertex: ox,
        logdepthbuf_vertex: lx,
        map_fragment: cx,
        map_pars_fragment: ux,
        map_particle_fragment: hx,
        map_particle_pars_fragment: dx,
        metalnessmap_fragment: px,
        metalnessmap_pars_fragment: fx,
        morphinstance_vertex: mx,
        morphcolor_vertex: gx,
        morphnormal_vertex: _x,
        morphtarget_pars_vertex: vx,
        morphtarget_vertex: xx,
        normal_fragment_begin: yx,
        normal_fragment_maps: Mx,
        normal_pars_fragment: Tx,
        normal_pars_vertex: bx,
        normal_vertex: Sx,
        normalmap_pars_fragment: Ex,
        clearcoat_normal_fragment_begin: wx,
        clearcoat_normal_fragment_maps: Ax,
        clearcoat_pars_fragment: Rx,
        iridescence_pars_fragment: Cx,
        opaque_fragment: Px,
        packing: Lx,
        premultiplied_alpha_fragment: Dx,
        project_vertex: Ix,
        dithering_fragment: Nx,
        dithering_pars_fragment: Ux,
        roughnessmap_fragment: Ox,
        roughnessmap_pars_fragment: Fx,
        shadowmap_pars_fragment: Bx,
        shadowmap_pars_vertex: zx,
        shadowmap_vertex: kx,
        shadowmask_pars_fragment: Vx,
        skinbase_vertex: Hx,
        skinning_pars_vertex: Gx,
        skinning_vertex: Wx,
        skinnormal_vertex: Xx,
        specularmap_fragment: jx,
        specularmap_pars_fragment: qx,
        tonemapping_fragment: Yx,
        tonemapping_pars_fragment: Kx,
        transmission_fragment: Zx,
        transmission_pars_fragment: Jx,
        uv_pars_fragment: $x,
        uv_pars_vertex: Qx,
        uv_vertex: ey,
        worldpos_vertex: ty,
        background_vert: iy,
        background_frag: ny,
        backgroundCube_vert: ry,
        backgroundCube_frag: sy,
        cube_vert: ay,
        cube_frag: oy,
        depth_vert: ly,
        depth_frag: cy,
        distanceRGBA_vert: uy,
        distanceRGBA_frag: hy,
        equirect_vert: dy,
        equirect_frag: py,
        linedashed_vert: fy,
        linedashed_frag: my,
        meshbasic_vert: gy,
        meshbasic_frag: _y,
        meshlambert_vert: vy,
        meshlambert_frag: xy,
        meshmatcap_vert: yy,
        meshmatcap_frag: My,
        meshnormal_vert: Ty,
        meshnormal_frag: by,
        meshphong_vert: Sy,
        meshphong_frag: Ey,
        meshphysical_vert: wy,
        meshphysical_frag: Ay,
        meshtoon_vert: Ry,
        meshtoon_frag: Cy,
        points_vert: Py,
        points_frag: Ly,
        shadow_vert: Dy,
        shadow_frag: Iy,
        sprite_vert: Ny,
        sprite_frag: Uy
      }, ce = {
        common: {
          diffuse: {
            value: new Ae(16777215)
          },
          opacity: {
            value: 1
          },
          map: {
            value: null
          },
          mapTransform: {
            value: new ze()
          },
          alphaMap: {
            value: null
          },
          alphaMapTransform: {
            value: new ze()
          },
          alphaTest: {
            value: 0
          }
        },
        specularmap: {
          specularMap: {
            value: null
          },
          specularMapTransform: {
            value: new ze()
          }
        },
        envmap: {
          envMap: {
            value: null
          },
          envMapRotation: {
            value: new ze()
          },
          flipEnvMap: {
            value: -1
          },
          reflectivity: {
            value: 1
          },
          ior: {
            value: 1.5
          },
          refractionRatio: {
            value: 0.98
          }
        },
        aomap: {
          aoMap: {
            value: null
          },
          aoMapIntensity: {
            value: 1
          },
          aoMapTransform: {
            value: new ze()
          }
        },
        lightmap: {
          lightMap: {
            value: null
          },
          lightMapIntensity: {
            value: 1
          },
          lightMapTransform: {
            value: new ze()
          }
        },
        bumpmap: {
          bumpMap: {
            value: null
          },
          bumpMapTransform: {
            value: new ze()
          },
          bumpScale: {
            value: 1
          }
        },
        normalmap: {
          normalMap: {
            value: null
          },
          normalMapTransform: {
            value: new ze()
          },
          normalScale: {
            value: new ee(1, 1)
          }
        },
        displacementmap: {
          displacementMap: {
            value: null
          },
          displacementMapTransform: {
            value: new ze()
          },
          displacementScale: {
            value: 1
          },
          displacementBias: {
            value: 0
          }
        },
        emissivemap: {
          emissiveMap: {
            value: null
          },
          emissiveMapTransform: {
            value: new ze()
          }
        },
        metalnessmap: {
          metalnessMap: {
            value: null
          },
          metalnessMapTransform: {
            value: new ze()
          }
        },
        roughnessmap: {
          roughnessMap: {
            value: null
          },
          roughnessMapTransform: {
            value: new ze()
          }
        },
        gradientmap: {
          gradientMap: {
            value: null
          }
        },
        fog: {
          fogDensity: {
            value: 25e-5
          },
          fogNear: {
            value: 1
          },
          fogFar: {
            value: 2e3
          },
          fogColor: {
            value: new Ae(16777215)
          }
        },
        lights: {
          ambientLightColor: {
            value: []
          },
          lightProbe: {
            value: []
          },
          directionalLights: {
            value: [],
            properties: {
              direction: {},
              color: {}
            }
          },
          directionalLightShadows: {
            value: [],
            properties: {
              shadowIntensity: 1,
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          directionalShadowMap: {
            value: []
          },
          directionalShadowMatrix: {
            value: []
          },
          spotLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              direction: {},
              distance: {},
              coneCos: {},
              penumbraCos: {},
              decay: {}
            }
          },
          spotLightShadows: {
            value: [],
            properties: {
              shadowIntensity: 1,
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {}
            }
          },
          spotLightMap: {
            value: []
          },
          spotShadowMap: {
            value: []
          },
          spotLightMatrix: {
            value: []
          },
          pointLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              decay: {},
              distance: {}
            }
          },
          pointLightShadows: {
            value: [],
            properties: {
              shadowIntensity: 1,
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
              shadowCameraNear: {},
              shadowCameraFar: {}
            }
          },
          pointShadowMap: {
            value: []
          },
          pointShadowMatrix: {
            value: []
          },
          hemisphereLights: {
            value: [],
            properties: {
              direction: {},
              skyColor: {},
              groundColor: {}
            }
          },
          rectAreaLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              width: {},
              height: {}
            }
          },
          ltc_1: {
            value: null
          },
          ltc_2: {
            value: null
          }
        },
        points: {
          diffuse: {
            value: new Ae(16777215)
          },
          opacity: {
            value: 1
          },
          size: {
            value: 1
          },
          scale: {
            value: 1
          },
          map: {
            value: null
          },
          alphaMap: {
            value: null
          },
          alphaMapTransform: {
            value: new ze()
          },
          alphaTest: {
            value: 0
          },
          uvTransform: {
            value: new ze()
          }
        },
        sprite: {
          diffuse: {
            value: new Ae(16777215)
          },
          opacity: {
            value: 1
          },
          center: {
            value: new ee(0.5, 0.5)
          },
          rotation: {
            value: 0
          },
          map: {
            value: null
          },
          mapTransform: {
            value: new ze()
          },
          alphaMap: {
            value: null
          },
          alphaMapTransform: {
            value: new ze()
          },
          alphaTest: {
            value: 0
          }
        }
      }, an = {
        basic: {
          uniforms: ci([
            ce.common,
            ce.specularmap,
            ce.envmap,
            ce.aomap,
            ce.lightmap,
            ce.fog
          ]),
          vertexShader: Ve.meshbasic_vert,
          fragmentShader: Ve.meshbasic_frag
        },
        lambert: {
          uniforms: ci([
            ce.common,
            ce.specularmap,
            ce.envmap,
            ce.aomap,
            ce.lightmap,
            ce.emissivemap,
            ce.bumpmap,
            ce.normalmap,
            ce.displacementmap,
            ce.fog,
            ce.lights,
            {
              emissive: {
                value: new Ae(0)
              }
            }
          ]),
          vertexShader: Ve.meshlambert_vert,
          fragmentShader: Ve.meshlambert_frag
        },
        phong: {
          uniforms: ci([
            ce.common,
            ce.specularmap,
            ce.envmap,
            ce.aomap,
            ce.lightmap,
            ce.emissivemap,
            ce.bumpmap,
            ce.normalmap,
            ce.displacementmap,
            ce.fog,
            ce.lights,
            {
              emissive: {
                value: new Ae(0)
              },
              specular: {
                value: new Ae(1118481)
              },
              shininess: {
                value: 30
              }
            }
          ]),
          vertexShader: Ve.meshphong_vert,
          fragmentShader: Ve.meshphong_frag
        },
        standard: {
          uniforms: ci([
            ce.common,
            ce.envmap,
            ce.aomap,
            ce.lightmap,
            ce.emissivemap,
            ce.bumpmap,
            ce.normalmap,
            ce.displacementmap,
            ce.roughnessmap,
            ce.metalnessmap,
            ce.fog,
            ce.lights,
            {
              emissive: {
                value: new Ae(0)
              },
              roughness: {
                value: 1
              },
              metalness: {
                value: 0
              },
              envMapIntensity: {
                value: 1
              }
            }
          ]),
          vertexShader: Ve.meshphysical_vert,
          fragmentShader: Ve.meshphysical_frag
        },
        toon: {
          uniforms: ci([
            ce.common,
            ce.aomap,
            ce.lightmap,
            ce.emissivemap,
            ce.bumpmap,
            ce.normalmap,
            ce.displacementmap,
            ce.gradientmap,
            ce.fog,
            ce.lights,
            {
              emissive: {
                value: new Ae(0)
              }
            }
          ]),
          vertexShader: Ve.meshtoon_vert,
          fragmentShader: Ve.meshtoon_frag
        },
        matcap: {
          uniforms: ci([
            ce.common,
            ce.bumpmap,
            ce.normalmap,
            ce.displacementmap,
            ce.fog,
            {
              matcap: {
                value: null
              }
            }
          ]),
          vertexShader: Ve.meshmatcap_vert,
          fragmentShader: Ve.meshmatcap_frag
        },
        points: {
          uniforms: ci([
            ce.points,
            ce.fog
          ]),
          vertexShader: Ve.points_vert,
          fragmentShader: Ve.points_frag
        },
        dashed: {
          uniforms: ci([
            ce.common,
            ce.fog,
            {
              scale: {
                value: 1
              },
              dashSize: {
                value: 1
              },
              totalSize: {
                value: 2
              }
            }
          ]),
          vertexShader: Ve.linedashed_vert,
          fragmentShader: Ve.linedashed_frag
        },
        depth: {
          uniforms: ci([
            ce.common,
            ce.displacementmap
          ]),
          vertexShader: Ve.depth_vert,
          fragmentShader: Ve.depth_frag
        },
        normal: {
          uniforms: ci([
            ce.common,
            ce.bumpmap,
            ce.normalmap,
            ce.displacementmap,
            {
              opacity: {
                value: 1
              }
            }
          ]),
          vertexShader: Ve.meshnormal_vert,
          fragmentShader: Ve.meshnormal_frag
        },
        sprite: {
          uniforms: ci([
            ce.sprite,
            ce.fog
          ]),
          vertexShader: Ve.sprite_vert,
          fragmentShader: Ve.sprite_frag
        },
        background: {
          uniforms: {
            uvTransform: {
              value: new ze()
            },
            t2D: {
              value: null
            },
            backgroundIntensity: {
              value: 1
            }
          },
          vertexShader: Ve.background_vert,
          fragmentShader: Ve.background_frag
        },
        backgroundCube: {
          uniforms: {
            envMap: {
              value: null
            },
            flipEnvMap: {
              value: -1
            },
            backgroundBlurriness: {
              value: 0
            },
            backgroundIntensity: {
              value: 1
            },
            backgroundRotation: {
              value: new ze()
            }
          },
          vertexShader: Ve.backgroundCube_vert,
          fragmentShader: Ve.backgroundCube_frag
        },
        cube: {
          uniforms: {
            tCube: {
              value: null
            },
            tFlip: {
              value: -1
            },
            opacity: {
              value: 1
            }
          },
          vertexShader: Ve.cube_vert,
          fragmentShader: Ve.cube_frag
        },
        equirect: {
          uniforms: {
            tEquirect: {
              value: null
            }
          },
          vertexShader: Ve.equirect_vert,
          fragmentShader: Ve.equirect_frag
        },
        distanceRGBA: {
          uniforms: ci([
            ce.common,
            ce.displacementmap,
            {
              referencePosition: {
                value: new D()
              },
              nearDistance: {
                value: 1
              },
              farDistance: {
                value: 1e3
              }
            }
          ]),
          vertexShader: Ve.distanceRGBA_vert,
          fragmentShader: Ve.distanceRGBA_frag
        },
        shadow: {
          uniforms: ci([
            ce.lights,
            ce.fog,
            {
              color: {
                value: new Ae(0)
              },
              opacity: {
                value: 1
              }
            }
          ]),
          vertexShader: Ve.shadow_vert,
          fragmentShader: Ve.shadow_frag
        }
      };
      an.physical = {
        uniforms: ci([
          an.standard.uniforms,
          {
            clearcoat: {
              value: 0
            },
            clearcoatMap: {
              value: null
            },
            clearcoatMapTransform: {
              value: new ze()
            },
            clearcoatNormalMap: {
              value: null
            },
            clearcoatNormalMapTransform: {
              value: new ze()
            },
            clearcoatNormalScale: {
              value: new ee(1, 1)
            },
            clearcoatRoughness: {
              value: 0
            },
            clearcoatRoughnessMap: {
              value: null
            },
            clearcoatRoughnessMapTransform: {
              value: new ze()
            },
            dispersion: {
              value: 0
            },
            iridescence: {
              value: 0
            },
            iridescenceMap: {
              value: null
            },
            iridescenceMapTransform: {
              value: new ze()
            },
            iridescenceIOR: {
              value: 1.3
            },
            iridescenceThicknessMinimum: {
              value: 100
            },
            iridescenceThicknessMaximum: {
              value: 400
            },
            iridescenceThicknessMap: {
              value: null
            },
            iridescenceThicknessMapTransform: {
              value: new ze()
            },
            sheen: {
              value: 0
            },
            sheenColor: {
              value: new Ae(0)
            },
            sheenColorMap: {
              value: null
            },
            sheenColorMapTransform: {
              value: new ze()
            },
            sheenRoughness: {
              value: 1
            },
            sheenRoughnessMap: {
              value: null
            },
            sheenRoughnessMapTransform: {
              value: new ze()
            },
            transmission: {
              value: 0
            },
            transmissionMap: {
              value: null
            },
            transmissionMapTransform: {
              value: new ze()
            },
            transmissionSamplerSize: {
              value: new ee()
            },
            transmissionSamplerMap: {
              value: null
            },
            thickness: {
              value: 0
            },
            thicknessMap: {
              value: null
            },
            thicknessMapTransform: {
              value: new ze()
            },
            attenuationDistance: {
              value: 0
            },
            attenuationColor: {
              value: new Ae(0)
            },
            specularColor: {
              value: new Ae(1, 1, 1)
            },
            specularColorMap: {
              value: null
            },
            specularColorMapTransform: {
              value: new ze()
            },
            specularIntensity: {
              value: 1
            },
            specularIntensityMap: {
              value: null
            },
            specularIntensityMapTransform: {
              value: new ze()
            },
            anisotropyVector: {
              value: new ee()
            },
            anisotropyMap: {
              value: null
            },
            anisotropyMapTransform: {
              value: new ze()
            }
          }
        ]),
        vertexShader: Ve.meshphysical_vert,
        fragmentShader: Ve.meshphysical_frag
      };
      const $o = {
        r: 0,
        b: 0,
        g: 0
      }, xr = new Qi(), Oy = new Fe();
      function Fy(n, e, t, i, r, s, a) {
        const o = new Ae(0);
        let l = s === true ? 0 : 1, c, u, h = null, d = 0, p = null;
        function f(x) {
          let v = x.isScene === true ? x.background : null;
          return v && v.isTexture && (v = (x.backgroundBlurriness > 0 ? t : e).get(v)), v;
        }
        function _(x) {
          let v = false;
          const A = f(x);
          A === null ? m(o, l) : A && A.isColor && (m(A, 1), v = true);
          const E = n.xr.getEnvironmentBlendMode();
          E === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, a) : E === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, a), (n.autoClear || v) && (i.buffers.depth.setTest(true), i.buffers.depth.setMask(true), i.buffers.color.setMask(true), n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil));
        }
        function g(x, v) {
          const A = f(v);
          A && (A.isCubeTexture || A.mapping === oo) ? (u === void 0 && (u = new Dt(new pr(1, 1, 1), new ti({
            name: "BackgroundCubeMaterial",
            uniforms: gs(an.backgroundCube.uniforms),
            vertexShader: an.backgroundCube.vertexShader,
            fragmentShader: an.backgroundCube.fragmentShader,
            side: Lt,
            depthTest: false,
            depthWrite: false,
            fog: false
          })), u.geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function(E, w, R) {
            this.matrixWorld.copyPosition(R.matrixWorld);
          }, Object.defineProperty(u.material, "envMap", {
            get: function() {
              return this.uniforms.envMap.value;
            }
          }), r.update(u)), xr.copy(v.backgroundRotation), xr.x *= -1, xr.y *= -1, xr.z *= -1, A.isCubeTexture && A.isRenderTargetTexture === false && (xr.y *= -1, xr.z *= -1), u.material.uniforms.envMap.value = A, u.material.uniforms.flipEnvMap.value = A.isCubeTexture && A.isRenderTargetTexture === false ? -1 : 1, u.material.uniforms.backgroundBlurriness.value = v.backgroundBlurriness, u.material.uniforms.backgroundIntensity.value = v.backgroundIntensity, u.material.uniforms.backgroundRotation.value.setFromMatrix4(Oy.makeRotationFromEuler(xr)), u.material.toneMapped = Ke.getTransfer(A.colorSpace) !== ct, (h !== A || d !== A.version || p !== n.toneMapping) && (u.material.needsUpdate = true, h = A, d = A.version, p = n.toneMapping), u.layers.enableAll(), x.unshift(u, u.geometry, u.material, 0, 0, null)) : A && A.isTexture && (c === void 0 && (c = new Dt(new Ca(2, 2), new ti({
            name: "BackgroundMaterial",
            uniforms: gs(an.background.uniforms),
            vertexShader: an.background.vertexShader,
            fragmentShader: an.background.fragmentShader,
            side: ft,
            depthTest: false,
            depthWrite: false,
            fog: false
          })), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
            get: function() {
              return this.uniforms.t2D.value;
            }
          }), r.update(c)), c.material.uniforms.t2D.value = A, c.material.uniforms.backgroundIntensity.value = v.backgroundIntensity, c.material.toneMapped = Ke.getTransfer(A.colorSpace) !== ct, A.matrixAutoUpdate === true && A.updateMatrix(), c.material.uniforms.uvTransform.value.copy(A.matrix), (h !== A || d !== A.version || p !== n.toneMapping) && (c.material.needsUpdate = true, h = A, d = A.version, p = n.toneMapping), c.layers.enableAll(), x.unshift(c, c.geometry, c.material, 0, 0, null));
        }
        function m(x, v) {
          x.getRGB($o, Cd(n)), i.buffers.color.setClear($o.r, $o.g, $o.b, v, a);
        }
        function y() {
          u !== void 0 && (u.geometry.dispose(), u.material.dispose(), u = void 0), c !== void 0 && (c.geometry.dispose(), c.material.dispose(), c = void 0);
        }
        return {
          getClearColor: function() {
            return o;
          },
          setClearColor: function(x, v = 1) {
            o.set(x), l = v, m(o, l);
          },
          getClearAlpha: function() {
            return l;
          },
          setClearAlpha: function(x) {
            l = x, m(o, l);
          },
          render: _,
          addToRenderList: g,
          dispose: y
        };
      }
      function By(n, e) {
        const t = n.getParameter(n.MAX_VERTEX_ATTRIBS), i = {}, r = d(null);
        let s = r, a = false;
        function o(T, L, B, F, H) {
          let X = false;
          const k = h(F, B, L);
          s !== k && (s = k, c(s.object)), X = p(T, F, B, H), X && f(T, F, B, H), H !== null && e.update(H, n.ELEMENT_ARRAY_BUFFER), (X || a) && (a = false, v(T, L, B, F), H !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(H).buffer));
        }
        function l() {
          return n.createVertexArray();
        }
        function c(T) {
          return n.bindVertexArray(T);
        }
        function u(T) {
          return n.deleteVertexArray(T);
        }
        function h(T, L, B) {
          const F = B.wireframe === true;
          let H = i[T.id];
          H === void 0 && (H = {}, i[T.id] = H);
          let X = H[L.id];
          X === void 0 && (X = {}, H[L.id] = X);
          let k = X[F];
          return k === void 0 && (k = d(l()), X[F] = k), k;
        }
        function d(T) {
          const L = [], B = [], F = [];
          for (let H = 0; H < t; H++) L[H] = 0, B[H] = 0, F[H] = 0;
          return {
            geometry: null,
            program: null,
            wireframe: false,
            newAttributes: L,
            enabledAttributes: B,
            attributeDivisors: F,
            object: T,
            attributes: {},
            index: null
          };
        }
        function p(T, L, B, F) {
          const H = s.attributes, X = L.attributes;
          let k = 0;
          const K = B.getAttributes();
          for (const G in K) if (K[G].location >= 0) {
            const ie = H[G];
            let ue = X[G];
            if (ue === void 0 && (G === "instanceMatrix" && T.instanceMatrix && (ue = T.instanceMatrix), G === "instanceColor" && T.instanceColor && (ue = T.instanceColor)), ie === void 0 || ie.attribute !== ue || ue && ie.data !== ue.data) return true;
            k++;
          }
          return s.attributesNum !== k || s.index !== F;
        }
        function f(T, L, B, F) {
          const H = {}, X = L.attributes;
          let k = 0;
          const K = B.getAttributes();
          for (const G in K) if (K[G].location >= 0) {
            let ie = X[G];
            ie === void 0 && (G === "instanceMatrix" && T.instanceMatrix && (ie = T.instanceMatrix), G === "instanceColor" && T.instanceColor && (ie = T.instanceColor));
            const ue = {};
            ue.attribute = ie, ie && ie.data && (ue.data = ie.data), H[G] = ue, k++;
          }
          s.attributes = H, s.attributesNum = k, s.index = F;
        }
        function _() {
          const T = s.newAttributes;
          for (let L = 0, B = T.length; L < B; L++) T[L] = 0;
        }
        function g(T) {
          m(T, 0);
        }
        function m(T, L) {
          const B = s.newAttributes, F = s.enabledAttributes, H = s.attributeDivisors;
          B[T] = 1, F[T] === 0 && (n.enableVertexAttribArray(T), F[T] = 1), H[T] !== L && (n.vertexAttribDivisor(T, L), H[T] = L);
        }
        function y() {
          const T = s.newAttributes, L = s.enabledAttributes;
          for (let B = 0, F = L.length; B < F; B++) L[B] !== T[B] && (n.disableVertexAttribArray(B), L[B] = 0);
        }
        function x(T, L, B, F, H, X, k) {
          k === true ? n.vertexAttribIPointer(T, L, B, H, X) : n.vertexAttribPointer(T, L, B, F, H, X);
        }
        function v(T, L, B, F) {
          _();
          const H = F.attributes, X = B.getAttributes(), k = L.defaultAttributeValues;
          for (const K in X) {
            const G = X[K];
            if (G.location >= 0) {
              let ie = H[K];
              if (ie === void 0 && (K === "instanceMatrix" && T.instanceMatrix && (ie = T.instanceMatrix), K === "instanceColor" && T.instanceColor && (ie = T.instanceColor)), ie !== void 0) {
                const ue = ie.normalized, we = ie.itemSize, Be = e.get(ie);
                if (Be === void 0) continue;
                const We = Be.buffer, j = Be.type, ne = Be.bytesPerElement, _e = j === n.INT || j === n.UNSIGNED_INT || ie.gpuType === Fl;
                if (ie.isInterleavedBufferAttribute) {
                  const ae = ie.data, Pe = ae.stride, Re = ie.offset;
                  if (ae.isInstancedInterleavedBuffer) {
                    for (let De = 0; De < G.locationSize; De++) m(G.location + De, ae.meshPerAttribute);
                    T.isInstancedMesh !== true && F._maxInstanceCount === void 0 && (F._maxInstanceCount = ae.meshPerAttribute * ae.count);
                  } else for (let De = 0; De < G.locationSize; De++) g(G.location + De);
                  n.bindBuffer(n.ARRAY_BUFFER, We);
                  for (let De = 0; De < G.locationSize; De++) x(G.location + De, we / G.locationSize, j, ue, Pe * ne, (Re + we / G.locationSize * De) * ne, _e);
                } else {
                  if (ie.isInstancedBufferAttribute) {
                    for (let ae = 0; ae < G.locationSize; ae++) m(G.location + ae, ie.meshPerAttribute);
                    T.isInstancedMesh !== true && F._maxInstanceCount === void 0 && (F._maxInstanceCount = ie.meshPerAttribute * ie.count);
                  } else for (let ae = 0; ae < G.locationSize; ae++) g(G.location + ae);
                  n.bindBuffer(n.ARRAY_BUFFER, We);
                  for (let ae = 0; ae < G.locationSize; ae++) x(G.location + ae, we / G.locationSize, j, ue, we * ne, we / G.locationSize * ae * ne, _e);
                }
              } else if (k !== void 0) {
                const ue = k[K];
                if (ue !== void 0) switch (ue.length) {
                  case 2:
                    n.vertexAttrib2fv(G.location, ue);
                    break;
                  case 3:
                    n.vertexAttrib3fv(G.location, ue);
                    break;
                  case 4:
                    n.vertexAttrib4fv(G.location, ue);
                    break;
                  default:
                    n.vertexAttrib1fv(G.location, ue);
                }
              }
            }
          }
          y();
        }
        function A() {
          R();
          for (const T in i) {
            const L = i[T];
            for (const B in L) {
              const F = L[B];
              for (const H in F) u(F[H].object), delete F[H];
              delete L[B];
            }
            delete i[T];
          }
        }
        function E(T) {
          if (i[T.id] === void 0) return;
          const L = i[T.id];
          for (const B in L) {
            const F = L[B];
            for (const H in F) u(F[H].object), delete F[H];
            delete L[B];
          }
          delete i[T.id];
        }
        function w(T) {
          for (const L in i) {
            const B = i[L];
            if (B[T.id] === void 0) continue;
            const F = B[T.id];
            for (const H in F) u(F[H].object), delete F[H];
            delete B[T.id];
          }
        }
        function R() {
          S(), a = true, s !== r && (s = r, c(s.object));
        }
        function S() {
          r.geometry = null, r.program = null, r.wireframe = false;
        }
        return {
          setup: o,
          reset: R,
          resetDefaultState: S,
          dispose: A,
          releaseStatesOfGeometry: E,
          releaseStatesOfProgram: w,
          initAttributes: _,
          enableAttribute: g,
          disableUnusedAttributes: y
        };
      }
      function zy(n, e, t) {
        let i;
        function r(c) {
          i = c;
        }
        function s(c, u) {
          n.drawArrays(i, c, u), t.update(u, i, 1);
        }
        function a(c, u, h) {
          h !== 0 && (n.drawArraysInstanced(i, c, u, h), t.update(u, i, h));
        }
        function o(c, u, h) {
          if (h === 0) return;
          e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, c, 0, u, 0, h);
          let d = 0;
          for (let p = 0; p < h; p++) d += u[p];
          t.update(d, i, 1);
        }
        function l(c, u, h, d) {
          if (h === 0) return;
          const p = e.get("WEBGL_multi_draw");
          if (p === null) for (let f = 0; f < c.length; f++) a(c[f], u[f], d[f]);
          else {
            p.multiDrawArraysInstancedWEBGL(i, c, 0, u, 0, d, 0, h);
            let f = 0;
            for (let _ = 0; _ < h; _++) f += u[_] * d[_];
            t.update(f, i, 1);
          }
        }
        this.setMode = r, this.render = s, this.renderInstances = a, this.renderMultiDraw = o, this.renderMultiDrawInstances = l;
      }
      function ky(n, e, t, i) {
        let r;
        function s() {
          if (r !== void 0) return r;
          if (e.has("EXT_texture_filter_anisotropic") === true) {
            const w = e.get("EXT_texture_filter_anisotropic");
            r = n.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else r = 0;
          return r;
        }
        function a(w) {
          return !(w !== Di && i.convert(w) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT));
        }
        function o(w) {
          const R = w === mn && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
          return !(w !== fn && i.convert(w) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) && w !== Vi && !R);
        }
        function l(w) {
          if (w === "highp") {
            if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0) return "highp";
            w = "mediump";
          }
          return w === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
        }
        let c = t.precision !== void 0 ? t.precision : "highp";
        const u = l(c);
        u !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", u, "instead."), c = u);
        const h = t.logarithmicDepthBuffer === true, d = t.reverseDepthBuffer === true && e.has("EXT_clip_control"), p = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS), f = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS), _ = n.getParameter(n.MAX_TEXTURE_SIZE), g = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE), m = n.getParameter(n.MAX_VERTEX_ATTRIBS), y = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS), x = n.getParameter(n.MAX_VARYING_VECTORS), v = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS), A = f > 0, E = n.getParameter(n.MAX_SAMPLES);
        return {
          isWebGL2: true,
          getMaxAnisotropy: s,
          getMaxPrecision: l,
          textureFormatReadable: a,
          textureTypeReadable: o,
          precision: c,
          logarithmicDepthBuffer: h,
          reverseDepthBuffer: d,
          maxTextures: p,
          maxVertexTextures: f,
          maxTextureSize: _,
          maxCubemapSize: g,
          maxAttributes: m,
          maxVertexUniforms: y,
          maxVaryings: x,
          maxFragmentUniforms: v,
          vertexTextures: A,
          maxSamples: E
        };
      }
      function Vy(n) {
        const e = this;
        let t = null, i = 0, r = false, s = false;
        const a = new fr(), o = new ze(), l = {
          value: null,
          needsUpdate: false
        };
        this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(h, d) {
          const p = h.length !== 0 || d || i !== 0 || r;
          return r = d, i = h.length, p;
        }, this.beginShadows = function() {
          s = true, u(null);
        }, this.endShadows = function() {
          s = false;
        }, this.setGlobalState = function(h, d) {
          t = u(h, d, 0);
        }, this.setState = function(h, d, p) {
          const f = h.clippingPlanes, _ = h.clipIntersection, g = h.clipShadows, m = n.get(h);
          if (!r || f === null || f.length === 0 || s && !g) s ? u(null) : c();
          else {
            const y = s ? 0 : i, x = y * 4;
            let v = m.clippingState || null;
            l.value = v, v = u(f, d, x, p);
            for (let A = 0; A !== x; ++A) v[A] = t[A];
            m.clippingState = v, this.numIntersection = _ ? this.numPlanes : 0, this.numPlanes += y;
          }
        };
        function c() {
          l.value !== t && (l.value = t, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0;
        }
        function u(h, d, p, f) {
          const _ = h !== null ? h.length : 0;
          let g = null;
          if (_ !== 0) {
            if (g = l.value, f !== true || g === null) {
              const m = p + _ * 4, y = d.matrixWorldInverse;
              o.getNormalMatrix(y), (g === null || g.length < m) && (g = new Float32Array(m));
              for (let x = 0, v = p; x !== _; ++x, v += 4) a.copy(h[x]).applyMatrix4(y, o), a.normal.toArray(g, v), g[v + 3] = a.constant;
            }
            l.value = g, l.needsUpdate = true;
          }
          return e.numPlanes = _, e.numIntersection = 0, g;
        }
      }
      function Hy(n) {
        let e = /* @__PURE__ */ new WeakMap();
        function t(a, o) {
          return o === Ul ? a.mapping = Kr : o === Ol && (a.mapping = Zr), a;
        }
        function i(a) {
          if (a && a.isTexture) {
            const o = a.mapping;
            if (o === Ul || o === Ol) if (e.has(a)) {
              const l = e.get(a).texture;
              return t(l, a.mapping);
            } else {
              const l = a.image;
              if (l && l.height > 0) {
                const c = new P_(l.height);
                return c.fromEquirectangularTexture(n, a), e.set(a, c), a.addEventListener("dispose", r), t(c.texture, a.mapping);
              } else return null;
            }
          }
          return a;
        }
        function r(a) {
          const o = a.target;
          o.removeEventListener("dispose", r);
          const l = e.get(o);
          l !== void 0 && (e.delete(o), l.dispose());
        }
        function s() {
          e = /* @__PURE__ */ new WeakMap();
        }
        return {
          get: i,
          dispose: s
        };
      }
      const Rs = 4, bp = [
        0.125,
        0.215,
        0.35,
        0.446,
        0.526,
        0.582
      ], yr = 20, _u = new Jo(), Sp = new Ae();
      let vu = null, xu = 0, yu = 0, Mu = false;
      const Mr = (1 + Math.sqrt(5)) / 2, Cs = 1 / Mr, Ep = [
        new D(-Mr, Cs, 0),
        new D(Mr, Cs, 0),
        new D(-Cs, 0, Mr),
        new D(Cs, 0, Mr),
        new D(0, Mr, -Cs),
        new D(0, Mr, Cs),
        new D(-1, 1, -1),
        new D(1, 1, -1),
        new D(-1, 1, 1),
        new D(1, 1, 1)
      ];
      class wp {
        constructor(e) {
          this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
        }
        fromScene(e, t = 0, i = 0.1, r = 100) {
          vu = this._renderer.getRenderTarget(), xu = this._renderer.getActiveCubeFace(), yu = this._renderer.getActiveMipmapLevel(), Mu = this._renderer.xr.enabled, this._renderer.xr.enabled = false, this._setSize(256);
          const s = this._allocateTargets();
          return s.depthBuffer = true, this._sceneToCubeUV(e, i, r, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s;
        }
        fromEquirectangular(e, t = null) {
          return this._fromTexture(e, t);
        }
        fromCubemap(e, t = null) {
          return this._fromTexture(e, t);
        }
        compileCubemapShader() {
          this._cubemapMaterial === null && (this._cubemapMaterial = Cp(), this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
          this._equirectMaterial === null && (this._equirectMaterial = Rp(), this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
          this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
        }
        _setSize(e) {
          this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
        }
        _dispose() {
          this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
          for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose();
        }
        _cleanup(e) {
          this._renderer.setRenderTarget(vu, xu, yu), this._renderer.xr.enabled = Mu, e.scissorTest = false, Qo(e, 0, 0, e.width, e.height);
        }
        _fromTexture(e, t) {
          e.mapping === Kr || e.mapping === Zr ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), vu = this._renderer.getRenderTarget(), xu = this._renderer.getActiveCubeFace(), yu = this._renderer.getActiveMipmapLevel(), Mu = this._renderer.xr.enabled, this._renderer.xr.enabled = false;
          const i = t || this._allocateTargets();
          return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
        }
        _allocateTargets() {
          const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, i = {
            magFilter: Mi,
            minFilter: Mi,
            generateMipmaps: false,
            type: mn,
            format: Di,
            colorSpace: oi,
            depthBuffer: false
          }, r = Ap(e, t, i);
          if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Ap(e, t, i);
            const { _lodMax: s } = this;
            ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = Gy(s)), this._blurMaterial = Wy(s, e, t);
          }
          return r;
        }
        _compileMaterial(e) {
          const t = new Dt(this._lodPlanes[0], e);
          this._renderer.compile(t, _u);
        }
        _sceneToCubeUV(e, t, i, r) {
          const s = new ui(90, 1, t, i), a = [
            1,
            -1,
            1,
            1,
            1,
            1
          ], o = [
            1,
            1,
            1,
            -1,
            -1,
            -1
          ], l = this._renderer, c = l.autoClear, u = l.toneMapping;
          l.getClearColor(Sp), l.toneMapping = Bn, l.autoClear = false;
          const h = new tn({
            name: "PMREM.Background",
            side: Lt,
            depthWrite: false,
            depthTest: false
          }), d = new Dt(new pr(), h);
          let p = false;
          const f = e.background;
          f ? f.isColor && (h.color.copy(f), e.background = null, p = true) : (h.color.copy(Sp), p = true);
          for (let _ = 0; _ < 6; _++) {
            const g = _ % 3;
            g === 0 ? (s.up.set(0, a[_], 0), s.lookAt(o[_], 0, 0)) : g === 1 ? (s.up.set(0, 0, a[_]), s.lookAt(0, o[_], 0)) : (s.up.set(0, a[_], 0), s.lookAt(0, 0, o[_]));
            const m = this._cubeSize;
            Qo(r, g * m, _ > 2 ? m : 0, m, m), l.setRenderTarget(r), p && l.render(d, s), l.render(e, s);
          }
          d.geometry.dispose(), d.material.dispose(), l.toneMapping = u, l.autoClear = c, e.background = f;
        }
        _textureToCubeUV(e, t) {
          const i = this._renderer, r = e.mapping === Kr || e.mapping === Zr;
          r ? (this._cubemapMaterial === null && (this._cubemapMaterial = Cp()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === false ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Rp());
          const s = r ? this._cubemapMaterial : this._equirectMaterial, a = new Dt(this._lodPlanes[0], s), o = s.uniforms;
          o.envMap.value = e;
          const l = this._cubeSize;
          Qo(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(a, _u);
        }
        _applyPMREM(e) {
          const t = this._renderer, i = t.autoClear;
          t.autoClear = false;
          const r = this._lodPlanes.length;
          for (let s = 1; s < r; s++) {
            const a = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1]), o = Ep[(r - s - 1) % Ep.length];
            this._blur(e, s - 1, s, a, o);
          }
          t.autoClear = i;
        }
        _blur(e, t, i, r, s) {
          const a = this._pingPongRenderTarget;
          this._halfBlur(e, a, t, i, r, "latitudinal", s), this._halfBlur(a, e, i, i, r, "longitudinal", s);
        }
        _halfBlur(e, t, i, r, s, a, o) {
          const l = this._renderer, c = this._blurMaterial;
          a !== "latitudinal" && a !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
          const u = 3, h = new Dt(this._lodPlanes[r], c), d = c.uniforms, p = this._sizeLods[i] - 1, f = isFinite(s) ? Math.PI / (2 * p) : 2 * Math.PI / (2 * yr - 1), _ = s / f, g = isFinite(s) ? 1 + Math.floor(u * _) : yr;
          g > yr && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${yr}`);
          const m = [];
          let y = 0;
          for (let w = 0; w < yr; ++w) {
            const R = w / _, S = Math.exp(-R * R / 2);
            m.push(S), w === 0 ? y += S : w < g && (y += 2 * S);
          }
          for (let w = 0; w < m.length; w++) m[w] = m[w] / y;
          d.envMap.value = e.texture, d.samples.value = g, d.weights.value = m, d.latitudinal.value = a === "latitudinal", o && (d.poleAxis.value = o);
          const { _lodMax: x } = this;
          d.dTheta.value = f, d.mipInt.value = x - i;
          const v = this._sizeLods[r], A = 3 * v * (r > x - Rs ? r - x + Rs : 0), E = 4 * (this._cubeSize - v);
          Qo(t, A, E, 3 * v, 2 * v), l.setRenderTarget(t), l.render(h, _u);
        }
      }
      function Gy(n) {
        const e = [], t = [], i = [];
        let r = n;
        const s = n - Rs + 1 + bp.length;
        for (let a = 0; a < s; a++) {
          const o = Math.pow(2, r);
          t.push(o);
          let l = 1 / o;
          a > n - Rs ? l = bp[a - n + Rs - 1] : a === 0 && (l = 0), i.push(l);
          const c = 1 / (o - 2), u = -c, h = 1 + c, d = [
            u,
            u,
            h,
            u,
            h,
            h,
            u,
            u,
            h,
            h,
            u,
            h
          ], p = 6, f = 6, _ = 3, g = 2, m = 1, y = new Float32Array(_ * f * p), x = new Float32Array(g * f * p), v = new Float32Array(m * f * p);
          for (let E = 0; E < p; E++) {
            const w = E % 3 * 2 / 3 - 1, R = E > 2 ? 0 : -1, S = [
              w,
              R,
              0,
              w + 2 / 3,
              R,
              0,
              w + 2 / 3,
              R + 1,
              0,
              w,
              R,
              0,
              w + 2 / 3,
              R + 1,
              0,
              w,
              R + 1,
              0
            ];
            y.set(S, _ * f * E), x.set(d, g * f * E);
            const T = [
              E,
              E,
              E,
              E,
              E,
              E
            ];
            v.set(T, m * f * E);
          }
          const A = new mi();
          A.setAttribute("position", new li(y, _)), A.setAttribute("uv", new li(x, g)), A.setAttribute("faceIndex", new li(v, m)), e.push(A), r > Rs && r--;
        }
        return {
          lodPlanes: e,
          sizeLods: t,
          sigmas: i
        };
      }
      function Ap(n, e, t) {
        const i = new Gi(n, e, t);
        return i.texture.mapping = oo, i.texture.name = "PMREM.cubeUv", i.scissorTest = true, i;
      }
      function Qo(n, e, t, i, r) {
        n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r);
      }
      function Wy(n, e, t) {
        const i = new Float32Array(yr), r = new D(0, 1, 0);
        return new ti({
          name: "SphericalGaussianBlur",
          defines: {
            n: yr,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${n}.0`
          },
          uniforms: {
            envMap: {
              value: null
            },
            samples: {
              value: 1
            },
            weights: {
              value: i
            },
            latitudinal: {
              value: false
            },
            dTheta: {
              value: 0
            },
            mipInt: {
              value: 0
            },
            poleAxis: {
              value: r
            }
          },
          vertexShader: Tu(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
          blending: jt,
          depthTest: false,
          depthWrite: false
        });
      }
      function Rp() {
        return new ti({
          name: "EquirectangularToCubeUV",
          uniforms: {
            envMap: {
              value: null
            }
          },
          vertexShader: Tu(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
          blending: jt,
          depthTest: false,
          depthWrite: false
        });
      }
      function Cp() {
        return new ti({
          name: "CubemapToCubeUV",
          uniforms: {
            envMap: {
              value: null
            },
            flipEnvMap: {
              value: -1
            }
          },
          vertexShader: Tu(),
          fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
          blending: jt,
          depthTest: false,
          depthWrite: false
        });
      }
      function Tu() {
        return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
      }
      function Xy(n) {
        let e = /* @__PURE__ */ new WeakMap(), t = null;
        function i(o) {
          if (o && o.isTexture) {
            const l = o.mapping, c = l === Ul || l === Ol, u = l === Kr || l === Zr;
            if (c || u) {
              let h = e.get(o);
              const d = h !== void 0 ? h.texture.pmremVersion : 0;
              if (o.isRenderTargetTexture && o.pmremVersion !== d) return t === null && (t = new wp(n)), h = c ? t.fromEquirectangular(o, h) : t.fromCubemap(o, h), h.texture.pmremVersion = o.pmremVersion, e.set(o, h), h.texture;
              if (h !== void 0) return h.texture;
              {
                const p = o.image;
                return c && p && p.height > 0 || u && p && r(p) ? (t === null && (t = new wp(n)), h = c ? t.fromEquirectangular(o) : t.fromCubemap(o), h.texture.pmremVersion = o.pmremVersion, e.set(o, h), o.addEventListener("dispose", s), h.texture) : null;
              }
            }
          }
          return o;
        }
        function r(o) {
          let l = 0;
          const c = 6;
          for (let u = 0; u < c; u++) o[u] !== void 0 && l++;
          return l === c;
        }
        function s(o) {
          const l = o.target;
          l.removeEventListener("dispose", s);
          const c = e.get(l);
          c !== void 0 && (e.delete(l), c.dispose());
        }
        function a() {
          e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
        }
        return {
          get: i,
          dispose: a
        };
      }
      function jy(n) {
        const e = {};
        function t(i) {
          if (e[i] !== void 0) return e[i];
          let r;
          switch (i) {
            case "WEBGL_depth_texture":
              r = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              r = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              r = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              r = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              r = n.getExtension(i);
          }
          return e[i] = r, r;
        }
        return {
          has: function(i) {
            return t(i) !== null;
          },
          init: function() {
            t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent");
          },
          get: function(i) {
            const r = t(i);
            return r === null && rs("THREE.WebGLRenderer: " + i + " extension not supported."), r;
          }
        };
      }
      function qy(n, e, t, i) {
        const r = {}, s = /* @__PURE__ */ new WeakMap();
        function a(h) {
          const d = h.target;
          d.index !== null && e.remove(d.index);
          for (const f in d.attributes) e.remove(d.attributes[f]);
          d.removeEventListener("dispose", a), delete r[d.id];
          const p = s.get(d);
          p && (e.remove(p), s.delete(d)), i.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === true && delete d._maxInstanceCount, t.memory.geometries--;
        }
        function o(h, d) {
          return r[d.id] === true || (d.addEventListener("dispose", a), r[d.id] = true, t.memory.geometries++), d;
        }
        function l(h) {
          const d = h.attributes;
          for (const p in d) e.update(d[p], n.ARRAY_BUFFER);
        }
        function c(h) {
          const d = [], p = h.index, f = h.attributes.position;
          let _ = 0;
          if (p !== null) {
            const y = p.array;
            _ = p.version;
            for (let x = 0, v = y.length; x < v; x += 3) {
              const A = y[x + 0], E = y[x + 1], w = y[x + 2];
              d.push(A, E, E, w, w, A);
            }
          } else if (f !== void 0) {
            const y = f.array;
            _ = f.version;
            for (let x = 0, v = y.length / 3 - 1; x < v; x += 3) {
              const A = x + 0, E = x + 1, w = x + 2;
              d.push(A, E, E, w, w, A);
            }
          } else return;
          const g = new (ld(d) ? Ed : Sd)(d, 1);
          g.version = _;
          const m = s.get(h);
          m && e.remove(m), s.set(h, g);
        }
        function u(h) {
          const d = s.get(h);
          if (d) {
            const p = h.index;
            p !== null && d.version < p.version && c(h);
          } else c(h);
          return s.get(h);
        }
        return {
          get: o,
          update: l,
          getWireframeAttribute: u
        };
      }
      function Yy(n, e, t) {
        let i;
        function r(d) {
          i = d;
        }
        let s, a;
        function o(d) {
          s = d.type, a = d.bytesPerElement;
        }
        function l(d, p) {
          n.drawElements(i, p, s, d * a), t.update(p, i, 1);
        }
        function c(d, p, f) {
          f !== 0 && (n.drawElementsInstanced(i, p, s, d * a, f), t.update(p, i, f));
        }
        function u(d, p, f) {
          if (f === 0) return;
          e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, p, 0, s, d, 0, f);
          let _ = 0;
          for (let g = 0; g < f; g++) _ += p[g];
          t.update(_, i, 1);
        }
        function h(d, p, f, _) {
          if (f === 0) return;
          const g = e.get("WEBGL_multi_draw");
          if (g === null) for (let m = 0; m < d.length; m++) c(d[m] / a, p[m], _[m]);
          else {
            g.multiDrawElementsInstancedWEBGL(i, p, 0, s, d, 0, _, 0, f);
            let m = 0;
            for (let y = 0; y < f; y++) m += p[y] * _[y];
            t.update(m, i, 1);
          }
        }
        this.setMode = r, this.setIndex = o, this.render = l, this.renderInstances = c, this.renderMultiDraw = u, this.renderMultiDrawInstances = h;
      }
      function Ky(n) {
        const e = {
          geometries: 0,
          textures: 0
        }, t = {
          frame: 0,
          calls: 0,
          triangles: 0,
          points: 0,
          lines: 0
        };
        function i(s, a, o) {
          switch (t.calls++, a) {
            case n.TRIANGLES:
              t.triangles += o * (s / 3);
              break;
            case n.LINES:
              t.lines += o * (s / 2);
              break;
            case n.LINE_STRIP:
              t.lines += o * (s - 1);
              break;
            case n.LINE_LOOP:
              t.lines += o * s;
              break;
            case n.POINTS:
              t.points += o * s;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", a);
              break;
          }
        }
        function r() {
          t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
        }
        return {
          memory: e,
          render: t,
          programs: null,
          autoReset: true,
          reset: r,
          update: i
        };
      }
      function Zy(n, e, t) {
        const i = /* @__PURE__ */ new WeakMap(), r = new it();
        function s(a, o, l) {
          const c = a.morphTargetInfluences, u = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color, h = u !== void 0 ? u.length : 0;
          let d = i.get(o);
          if (d === void 0 || d.count !== h) {
            let p = function() {
              R.dispose(), i.delete(o), o.removeEventListener("dispose", p);
            };
            d !== void 0 && d.texture.dispose();
            const f = o.morphAttributes.position !== void 0, _ = o.morphAttributes.normal !== void 0, g = o.morphAttributes.color !== void 0, m = o.morphAttributes.position || [], y = o.morphAttributes.normal || [], x = o.morphAttributes.color || [];
            let v = 0;
            f === true && (v = 1), _ === true && (v = 2), g === true && (v = 3);
            let A = o.attributes.position.count * v, E = 1;
            A > e.maxTextureSize && (E = Math.ceil(A / e.maxTextureSize), A = e.maxTextureSize);
            const w = new Float32Array(A * E * 4 * h), R = new pd(w, A, E, h);
            R.type = Vi, R.needsUpdate = true;
            const S = v * 4;
            for (let T = 0; T < h; T++) {
              const L = m[T], B = y[T], F = x[T], H = A * E * 4 * T;
              for (let X = 0; X < L.count; X++) {
                const k = X * S;
                f === true && (r.fromBufferAttribute(L, X), w[H + k + 0] = r.x, w[H + k + 1] = r.y, w[H + k + 2] = r.z, w[H + k + 3] = 0), _ === true && (r.fromBufferAttribute(B, X), w[H + k + 4] = r.x, w[H + k + 5] = r.y, w[H + k + 6] = r.z, w[H + k + 7] = 0), g === true && (r.fromBufferAttribute(F, X), w[H + k + 8] = r.x, w[H + k + 9] = r.y, w[H + k + 10] = r.z, w[H + k + 11] = F.itemSize === 4 ? r.w : 1);
              }
            }
            d = {
              count: h,
              texture: R,
              size: new ee(A, E)
            }, i.set(o, d), o.addEventListener("dispose", p);
          }
          if (a.isInstancedMesh === true && a.morphTexture !== null) l.getUniforms().setValue(n, "morphTexture", a.morphTexture, t);
          else {
            let p = 0;
            for (let _ = 0; _ < c.length; _++) p += c[_];
            const f = o.morphTargetsRelative ? 1 : 1 - p;
            l.getUniforms().setValue(n, "morphTargetBaseInfluence", f), l.getUniforms().setValue(n, "morphTargetInfluences", c);
          }
          l.getUniforms().setValue(n, "morphTargetsTexture", d.texture, t), l.getUniforms().setValue(n, "morphTargetsTextureSize", d.size);
        }
        return {
          update: s
        };
      }
      function Jy(n, e, t, i) {
        let r = /* @__PURE__ */ new WeakMap();
        function s(l) {
          const c = i.render.frame, u = l.geometry, h = e.get(l, u);
          if (r.get(h) !== c && (e.update(h), r.set(h, c)), l.isInstancedMesh && (l.hasEventListener("dispose", o) === false && l.addEventListener("dispose", o), r.get(l) !== c && (t.update(l.instanceMatrix, n.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, n.ARRAY_BUFFER), r.set(l, c))), l.isSkinnedMesh) {
            const d = l.skeleton;
            r.get(d) !== c && (d.update(), r.set(d, c));
          }
          return h;
        }
        function a() {
          r = /* @__PURE__ */ new WeakMap();
        }
        function o(l) {
          const c = l.target;
          c.removeEventListener("dispose", o), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor);
        }
        return {
          update: s,
          dispose: a
        };
      }
      const Pp = new kt(), Lp = new $d(1, 1), Dp = new pd(), Ip = new f_(), Np = new Id(), Up = [], Op = [], Fp = new Float32Array(16), Bp = new Float32Array(9), zp = new Float32Array(4);
      function Ps(n, e, t) {
        const i = n[0];
        if (i <= 0 || i > 0) return n;
        const r = e * t;
        let s = Up[r];
        if (s === void 0 && (s = new Float32Array(r), Up[r] = s), e !== 0) {
          i.toArray(s, 0);
          for (let a = 1, o = 0; a !== e; ++a) o += t, n[a].toArray(s, o);
        }
        return s;
      }
      function Vt(n, e) {
        if (n.length !== e.length) return false;
        for (let t = 0, i = n.length; t < i; t++) if (n[t] !== e[t]) return false;
        return true;
      }
      function Ht(n, e) {
        for (let t = 0, i = e.length; t < i; t++) n[t] = e[t];
      }
      function el(n, e) {
        let t = Op[e];
        t === void 0 && (t = new Int32Array(e), Op[e] = t);
        for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
        return t;
      }
      function $y(n, e) {
        const t = this.cache;
        t[0] !== e && (n.uniform1f(this.addr, e), t[0] = e);
      }
      function Qy(n, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
        else {
          if (Vt(t, e)) return;
          n.uniform2fv(this.addr, e), Ht(t, e);
        }
      }
      function eM(n, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
        else if (e.r !== void 0) (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
        else {
          if (Vt(t, e)) return;
          n.uniform3fv(this.addr, e), Ht(t, e);
        }
      }
      function tM(n, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
        else {
          if (Vt(t, e)) return;
          n.uniform4fv(this.addr, e), Ht(t, e);
        }
      }
      function iM(n, e) {
        const t = this.cache, i = e.elements;
        if (i === void 0) {
          if (Vt(t, e)) return;
          n.uniformMatrix2fv(this.addr, false, e), Ht(t, e);
        } else {
          if (Vt(t, i)) return;
          zp.set(i), n.uniformMatrix2fv(this.addr, false, zp), Ht(t, i);
        }
      }
      function nM(n, e) {
        const t = this.cache, i = e.elements;
        if (i === void 0) {
          if (Vt(t, e)) return;
          n.uniformMatrix3fv(this.addr, false, e), Ht(t, e);
        } else {
          if (Vt(t, i)) return;
          Bp.set(i), n.uniformMatrix3fv(this.addr, false, Bp), Ht(t, i);
        }
      }
      function rM(n, e) {
        const t = this.cache, i = e.elements;
        if (i === void 0) {
          if (Vt(t, e)) return;
          n.uniformMatrix4fv(this.addr, false, e), Ht(t, e);
        } else {
          if (Vt(t, i)) return;
          Fp.set(i), n.uniformMatrix4fv(this.addr, false, Fp), Ht(t, i);
        }
      }
      function sM(n, e) {
        const t = this.cache;
        t[0] !== e && (n.uniform1i(this.addr, e), t[0] = e);
      }
      function aM(n, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
        else {
          if (Vt(t, e)) return;
          n.uniform2iv(this.addr, e), Ht(t, e);
        }
      }
      function oM(n, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
        else {
          if (Vt(t, e)) return;
          n.uniform3iv(this.addr, e), Ht(t, e);
        }
      }
      function lM(n, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
        else {
          if (Vt(t, e)) return;
          n.uniform4iv(this.addr, e), Ht(t, e);
        }
      }
      function cM(n, e) {
        const t = this.cache;
        t[0] !== e && (n.uniform1ui(this.addr, e), t[0] = e);
      }
      function uM(n, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
        else {
          if (Vt(t, e)) return;
          n.uniform2uiv(this.addr, e), Ht(t, e);
        }
      }
      function hM(n, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
        else {
          if (Vt(t, e)) return;
          n.uniform3uiv(this.addr, e), Ht(t, e);
        }
      }
      function dM(n, e) {
        const t = this.cache;
        if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
        else {
          if (Vt(t, e)) return;
          n.uniform4uiv(this.addr, e), Ht(t, e);
        }
      }
      function pM(n, e, t) {
        const i = this.cache, r = t.allocateTextureUnit();
        i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r);
        let s;
        this.type === n.SAMPLER_2D_SHADOW ? (Lp.compareFunction = sd, s = Lp) : s = Pp, t.setTexture2D(e || s, r);
      }
      function fM(n, e, t) {
        const i = this.cache, r = t.allocateTextureUnit();
        i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture3D(e || Ip, r);
      }
      function mM(n, e, t) {
        const i = this.cache, r = t.allocateTextureUnit();
        i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTextureCube(e || Np, r);
      }
      function gM(n, e, t) {
        const i = this.cache, r = t.allocateTextureUnit();
        i[0] !== r && (n.uniform1i(this.addr, r), i[0] = r), t.setTexture2DArray(e || Dp, r);
      }
      function _M(n) {
        switch (n) {
          case 5126:
            return $y;
          case 35664:
            return Qy;
          case 35665:
            return eM;
          case 35666:
            return tM;
          case 35674:
            return iM;
          case 35675:
            return nM;
          case 35676:
            return rM;
          case 5124:
          case 35670:
            return sM;
          case 35667:
          case 35671:
            return aM;
          case 35668:
          case 35672:
            return oM;
          case 35669:
          case 35673:
            return lM;
          case 5125:
            return cM;
          case 36294:
            return uM;
          case 36295:
            return hM;
          case 36296:
            return dM;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return pM;
          case 35679:
          case 36299:
          case 36307:
            return fM;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return mM;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return gM;
        }
      }
      function vM(n, e) {
        n.uniform1fv(this.addr, e);
      }
      function xM(n, e) {
        const t = Ps(e, this.size, 2);
        n.uniform2fv(this.addr, t);
      }
      function yM(n, e) {
        const t = Ps(e, this.size, 3);
        n.uniform3fv(this.addr, t);
      }
      function MM(n, e) {
        const t = Ps(e, this.size, 4);
        n.uniform4fv(this.addr, t);
      }
      function TM(n, e) {
        const t = Ps(e, this.size, 4);
        n.uniformMatrix2fv(this.addr, false, t);
      }
      function bM(n, e) {
        const t = Ps(e, this.size, 9);
        n.uniformMatrix3fv(this.addr, false, t);
      }
      function SM(n, e) {
        const t = Ps(e, this.size, 16);
        n.uniformMatrix4fv(this.addr, false, t);
      }
      function EM(n, e) {
        n.uniform1iv(this.addr, e);
      }
      function wM(n, e) {
        n.uniform2iv(this.addr, e);
      }
      function AM(n, e) {
        n.uniform3iv(this.addr, e);
      }
      function RM(n, e) {
        n.uniform4iv(this.addr, e);
      }
      function CM(n, e) {
        n.uniform1uiv(this.addr, e);
      }
      function PM(n, e) {
        n.uniform2uiv(this.addr, e);
      }
      function LM(n, e) {
        n.uniform3uiv(this.addr, e);
      }
      function DM(n, e) {
        n.uniform4uiv(this.addr, e);
      }
      function IM(n, e, t) {
        const i = this.cache, r = e.length, s = el(t, r);
        Vt(i, s) || (n.uniform1iv(this.addr, s), Ht(i, s));
        for (let a = 0; a !== r; ++a) t.setTexture2D(e[a] || Pp, s[a]);
      }
      function NM(n, e, t) {
        const i = this.cache, r = e.length, s = el(t, r);
        Vt(i, s) || (n.uniform1iv(this.addr, s), Ht(i, s));
        for (let a = 0; a !== r; ++a) t.setTexture3D(e[a] || Ip, s[a]);
      }
      function UM(n, e, t) {
        const i = this.cache, r = e.length, s = el(t, r);
        Vt(i, s) || (n.uniform1iv(this.addr, s), Ht(i, s));
        for (let a = 0; a !== r; ++a) t.setTextureCube(e[a] || Np, s[a]);
      }
      function OM(n, e, t) {
        const i = this.cache, r = e.length, s = el(t, r);
        Vt(i, s) || (n.uniform1iv(this.addr, s), Ht(i, s));
        for (let a = 0; a !== r; ++a) t.setTexture2DArray(e[a] || Dp, s[a]);
      }
      function FM(n) {
        switch (n) {
          case 5126:
            return vM;
          case 35664:
            return xM;
          case 35665:
            return yM;
          case 35666:
            return MM;
          case 35674:
            return TM;
          case 35675:
            return bM;
          case 35676:
            return SM;
          case 5124:
          case 35670:
            return EM;
          case 35667:
          case 35671:
            return wM;
          case 35668:
          case 35672:
            return AM;
          case 35669:
          case 35673:
            return RM;
          case 5125:
            return CM;
          case 36294:
            return PM;
          case 36295:
            return LM;
          case 36296:
            return DM;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return IM;
          case 35679:
          case 36299:
          case 36307:
            return NM;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return UM;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return OM;
        }
      }
      class BM {
        constructor(e, t, i) {
          this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.setValue = _M(t.type);
        }
      }
      class zM {
        constructor(e, t, i) {
          this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = FM(t.type);
        }
      }
      class kM {
        constructor(e) {
          this.id = e, this.seq = [], this.map = {};
        }
        setValue(e, t, i) {
          const r = this.seq;
          for (let s = 0, a = r.length; s !== a; ++s) {
            const o = r[s];
            o.setValue(e, t[o.id], i);
          }
        }
      }
      const bu = /(\w+)(\])?(\[|\.)?/g;
      function kp(n, e) {
        n.seq.push(e), n.map[e.id] = e;
      }
      function VM(n, e, t) {
        const i = n.name, r = i.length;
        for (bu.lastIndex = 0; ; ) {
          const s = bu.exec(i), a = bu.lastIndex;
          let o = s[1];
          const l = s[2] === "]", c = s[3];
          if (l && (o = o | 0), c === void 0 || c === "[" && a + 2 === r) {
            kp(t, c === void 0 ? new BM(o, n, e) : new zM(o, n, e));
            break;
          } else {
            let u = t.map[o];
            u === void 0 && (u = new kM(o), kp(t, u)), t = u;
          }
        }
      }
      class tl {
        constructor(e, t) {
          this.seq = [], this.map = {};
          const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
          for (let r = 0; r < i; ++r) {
            const s = e.getActiveUniform(t, r), a = e.getUniformLocation(t, s.name);
            VM(s, a, this);
          }
        }
        setValue(e, t, i, r) {
          const s = this.map[t];
          s !== void 0 && s.setValue(e, i, r);
        }
        setOptional(e, t, i) {
          const r = t[i];
          r !== void 0 && this.setValue(e, i, r);
        }
        static upload(e, t, i, r) {
          for (let s = 0, a = t.length; s !== a; ++s) {
            const o = t[s], l = i[o.id];
            l.needsUpdate !== false && o.setValue(e, l.value, r);
          }
        }
        static seqWithValue(e, t) {
          const i = [];
          for (let r = 0, s = e.length; r !== s; ++r) {
            const a = e[r];
            a.id in t && i.push(a);
          }
          return i;
        }
      }
      function Vp(n, e, t) {
        const i = n.createShader(e);
        return n.shaderSource(i, t), n.compileShader(i), i;
      }
      const HM = 37297;
      let GM = 0;
      function WM(n, e) {
        const t = n.split(`
`), i = [], r = Math.max(e - 6, 0), s = Math.min(e + 6, t.length);
        for (let a = r; a < s; a++) {
          const o = a + 1;
          i.push(`${o === e ? ">" : " "} ${o}: ${t[a]}`);
        }
        return i.join(`
`);
      }
      const Hp = new ze();
      function XM(n) {
        Ke._getMatrix(Hp, Ke.workingColorSpace, n);
        const e = `mat3( ${Hp.elements.map((t) => t.toFixed(4))} )`;
        switch (Ke.getTransfer(n)) {
          case go:
            return [
              e,
              "LinearTransferOETF"
            ];
          case ct:
            return [
              e,
              "sRGBTransferOETF"
            ];
          default:
            return console.warn("THREE.WebGLProgram: Unsupported color space: ", n), [
              e,
              "LinearTransferOETF"
            ];
        }
      }
      function Gp(n, e, t) {
        const i = n.getShaderParameter(e, n.COMPILE_STATUS), r = n.getShaderInfoLog(e).trim();
        if (i && r === "") return "";
        const s = /ERROR: 0:(\d+)/.exec(r);
        if (s) {
          const a = parseInt(s[1]);
          return t.toUpperCase() + `

` + r + `

` + WM(n.getShaderSource(e), a);
        } else return r;
      }
      function jM(n, e) {
        const t = XM(e);
        return [
          `vec4 ${n}( vec4 value ) {`,
          `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
          "}"
        ].join(`
`);
      }
      function qM(n, e) {
        let t;
        switch (e) {
          case Tg:
            t = "Linear";
            break;
          case bg:
            t = "Reinhard";
            break;
          case Sg:
            t = "Cineon";
            break;
          case Eg:
            t = "ACESFilmic";
            break;
          case Ag:
            t = "AgX";
            break;
          case Rg:
            t = "Neutral";
            break;
          case wg:
            t = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
        }
        return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
      }
      const il = new D();
      function YM() {
        Ke.getLuminanceCoefficients(il);
        const n = il.x.toFixed(4), e = il.y.toFixed(4), t = il.z.toFixed(4);
        return [
          "float luminance( const in vec3 rgb ) {",
          `	const vec3 weights = vec3( ${n}, ${e}, ${t} );`,
          "	return dot( weights, rgb );",
          "}"
        ].join(`
`);
      }
      function KM(n) {
        return [
          n.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
          n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
        ].filter(Ia).join(`
`);
      }
      function ZM(n) {
        const e = [];
        for (const t in n) {
          const i = n[t];
          i !== false && e.push("#define " + t + " " + i);
        }
        return e.join(`
`);
      }
      function JM(n, e) {
        const t = {}, i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
        for (let r = 0; r < i; r++) {
          const s = n.getActiveAttrib(e, r), a = s.name;
          let o = 1;
          s.type === n.FLOAT_MAT2 && (o = 2), s.type === n.FLOAT_MAT3 && (o = 3), s.type === n.FLOAT_MAT4 && (o = 4), t[a] = {
            type: s.type,
            location: n.getAttribLocation(e, a),
            locationSize: o
          };
        }
        return t;
      }
      function Ia(n) {
        return n !== "";
      }
      function Wp(n, e) {
        const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
        return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
      }
      function Xp(n, e) {
        return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
      }
      const $M = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function Su(n) {
        return n.replace($M, eT);
      }
      const QM = /* @__PURE__ */ new Map();
      function eT(n, e) {
        let t = Ve[e];
        if (t === void 0) {
          const i = QM.get(e);
          if (i !== void 0) t = Ve[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
          else throw new Error("Can not resolve #include <" + e + ">");
        }
        return Su(t);
      }
      const tT = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function jp(n) {
        return n.replace(tT, iT);
      }
      function iT(n, e, t, i) {
        let r = "";
        for (let s = parseInt(e); s < parseInt(t); s++) r += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
        return r;
      }
      function qp(n) {
        let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
        return n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
      }
      function nT(n) {
        let e = "SHADOWMAP_TYPE_BASIC";
        return n.shadowMapType === gt ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === Ut ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === Pt && (e = "SHADOWMAP_TYPE_VSM"), e;
      }
      function rT(n) {
        let e = "ENVMAP_TYPE_CUBE";
        if (n.envMap) switch (n.envMapMode) {
          case Kr:
          case Zr:
            e = "ENVMAP_TYPE_CUBE";
            break;
          case oo:
            e = "ENVMAP_TYPE_CUBE_UV";
            break;
        }
        return e;
      }
      function sT(n) {
        let e = "ENVMAP_MODE_REFLECTION";
        if (n.envMap) switch (n.envMapMode) {
          case Zr:
            e = "ENVMAP_MODE_REFRACTION";
            break;
        }
        return e;
      }
      function aT(n) {
        let e = "ENVMAP_BLENDING_NONE";
        if (n.envMap) switch (n.combine) {
          case kh:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
          case yg:
            e = "ENVMAP_BLENDING_MIX";
            break;
          case Mg:
            e = "ENVMAP_BLENDING_ADD";
            break;
        }
        return e;
      }
      function oT(n) {
        const e = n.envMapCubeUVHeight;
        if (e === null) return null;
        const t = Math.log2(e) - 2, i = 1 / e;
        return {
          texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
          texelHeight: i,
          maxMip: t
        };
      }
      function lT(n, e, t, i) {
        const r = n.getContext(), s = t.defines;
        let a = t.vertexShader, o = t.fragmentShader;
        const l = nT(t), c = rT(t), u = sT(t), h = aT(t), d = oT(t), p = KM(t), f = ZM(s), _ = r.createProgram();
        let g, m, y = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
        t.isRawShaderMaterial ? (g = [
          "#define SHADER_TYPE " + t.shaderType,
          "#define SHADER_NAME " + t.shaderName,
          f
        ].filter(Ia).join(`
`), g.length > 0 && (g += `
`), m = [
          "#define SHADER_TYPE " + t.shaderType,
          "#define SHADER_NAME " + t.shaderName,
          f
        ].filter(Ia).join(`
`), m.length > 0 && (m += `
`)) : (g = [
          qp(t),
          "#define SHADER_TYPE " + t.shaderType,
          "#define SHADER_NAME " + t.shaderName,
          f,
          t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
          t.batching ? "#define USE_BATCHING" : "",
          t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
          t.instancing ? "#define USE_INSTANCING" : "",
          t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
          t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
          t.useFog && t.fog ? "#define USE_FOG" : "",
          t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
          t.map ? "#define USE_MAP" : "",
          t.envMap ? "#define USE_ENVMAP" : "",
          t.envMap ? "#define " + u : "",
          t.lightMap ? "#define USE_LIGHTMAP" : "",
          t.aoMap ? "#define USE_AOMAP" : "",
          t.bumpMap ? "#define USE_BUMPMAP" : "",
          t.normalMap ? "#define USE_NORMALMAP" : "",
          t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
          t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
          t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
          t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          t.anisotropy ? "#define USE_ANISOTROPY" : "",
          t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
          t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
          t.specularMap ? "#define USE_SPECULARMAP" : "",
          t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
          t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
          t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          t.metalnessMap ? "#define USE_METALNESSMAP" : "",
          t.alphaMap ? "#define USE_ALPHAMAP" : "",
          t.alphaHash ? "#define USE_ALPHAHASH" : "",
          t.transmission ? "#define USE_TRANSMISSION" : "",
          t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
          t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
          t.mapUv ? "#define MAP_UV " + t.mapUv : "",
          t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
          t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
          t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
          t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
          t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
          t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
          t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
          t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
          t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
          t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
          t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
          t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
          t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
          t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
          t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
          t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
          t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
          t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
          t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
          t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
          t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
          t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
          t.vertexTangents && t.flatShading === false ? "#define USE_TANGENT" : "",
          t.vertexColors ? "#define USE_COLOR" : "",
          t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          t.vertexUv1s ? "#define USE_UV1" : "",
          t.vertexUv2s ? "#define USE_UV2" : "",
          t.vertexUv3s ? "#define USE_UV3" : "",
          t.pointsUvs ? "#define USE_POINTS_UV" : "",
          t.flatShading ? "#define FLAT_SHADED" : "",
          t.skinning ? "#define USE_SKINNING" : "",
          t.morphTargets ? "#define USE_MORPHTARGETS" : "",
          t.morphNormals && t.flatShading === false ? "#define USE_MORPHNORMALS" : "",
          t.morphColors ? "#define USE_MORPHCOLORS" : "",
          t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
          t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
          t.doubleSided ? "#define DOUBLE_SIDED" : "",
          t.flipSided ? "#define FLIP_SIDED" : "",
          t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          t.shadowMapEnabled ? "#define " + l : "",
          t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
          t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
          t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
          "uniform mat4 modelMatrix;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",
          "uniform mat4 viewMatrix;",
          "uniform mat3 normalMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          "#ifdef USE_INSTANCING",
          "	attribute mat4 instanceMatrix;",
          "#endif",
          "#ifdef USE_INSTANCING_COLOR",
          "	attribute vec3 instanceColor;",
          "#endif",
          "#ifdef USE_INSTANCING_MORPH",
          "	uniform sampler2D morphTexture;",
          "#endif",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec2 uv;",
          "#ifdef USE_UV1",
          "	attribute vec2 uv1;",
          "#endif",
          "#ifdef USE_UV2",
          "	attribute vec2 uv2;",
          "#endif",
          "#ifdef USE_UV3",
          "	attribute vec2 uv3;",
          "#endif",
          "#ifdef USE_TANGENT",
          "	attribute vec4 tangent;",
          "#endif",
          "#if defined( USE_COLOR_ALPHA )",
          "	attribute vec4 color;",
          "#elif defined( USE_COLOR )",
          "	attribute vec3 color;",
          "#endif",
          "#ifdef USE_SKINNING",
          "	attribute vec4 skinIndex;",
          "	attribute vec4 skinWeight;",
          "#endif",
          `
`
        ].filter(Ia).join(`
`), m = [
          qp(t),
          "#define SHADER_TYPE " + t.shaderType,
          "#define SHADER_NAME " + t.shaderName,
          f,
          t.useFog && t.fog ? "#define USE_FOG" : "",
          t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
          t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
          t.map ? "#define USE_MAP" : "",
          t.matcap ? "#define USE_MATCAP" : "",
          t.envMap ? "#define USE_ENVMAP" : "",
          t.envMap ? "#define " + c : "",
          t.envMap ? "#define " + u : "",
          t.envMap ? "#define " + h : "",
          d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
          d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
          d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
          t.lightMap ? "#define USE_LIGHTMAP" : "",
          t.aoMap ? "#define USE_AOMAP" : "",
          t.bumpMap ? "#define USE_BUMPMAP" : "",
          t.normalMap ? "#define USE_NORMALMAP" : "",
          t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
          t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
          t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          t.anisotropy ? "#define USE_ANISOTROPY" : "",
          t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
          t.clearcoat ? "#define USE_CLEARCOAT" : "",
          t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          t.dispersion ? "#define USE_DISPERSION" : "",
          t.iridescence ? "#define USE_IRIDESCENCE" : "",
          t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
          t.specularMap ? "#define USE_SPECULARMAP" : "",
          t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
          t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
          t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          t.metalnessMap ? "#define USE_METALNESSMAP" : "",
          t.alphaMap ? "#define USE_ALPHAMAP" : "",
          t.alphaTest ? "#define USE_ALPHATEST" : "",
          t.alphaHash ? "#define USE_ALPHAHASH" : "",
          t.sheen ? "#define USE_SHEEN" : "",
          t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
          t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
          t.transmission ? "#define USE_TRANSMISSION" : "",
          t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          t.vertexTangents && t.flatShading === false ? "#define USE_TANGENT" : "",
          t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "",
          t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          t.vertexUv1s ? "#define USE_UV1" : "",
          t.vertexUv2s ? "#define USE_UV2" : "",
          t.vertexUv3s ? "#define USE_UV3" : "",
          t.pointsUvs ? "#define USE_POINTS_UV" : "",
          t.gradientMap ? "#define USE_GRADIENTMAP" : "",
          t.flatShading ? "#define FLAT_SHADED" : "",
          t.doubleSided ? "#define DOUBLE_SIDED" : "",
          t.flipSided ? "#define FLIP_SIDED" : "",
          t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          t.shadowMapEnabled ? "#define " + l : "",
          t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
          t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
          t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
          t.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
          t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
          "uniform mat4 viewMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          t.toneMapping !== Bn ? "#define TONE_MAPPING" : "",
          t.toneMapping !== Bn ? Ve.tonemapping_pars_fragment : "",
          t.toneMapping !== Bn ? qM("toneMapping", t.toneMapping) : "",
          t.dithering ? "#define DITHERING" : "",
          t.opaque ? "#define OPAQUE" : "",
          Ve.colorspace_pars_fragment,
          jM("linearToOutputTexel", t.outputColorSpace),
          YM(),
          t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
          `
`
        ].filter(Ia).join(`
`)), a = Su(a), a = Wp(a, t), a = Xp(a, t), o = Su(o), o = Wp(o, t), o = Xp(o, t), a = jp(a), o = jp(o), t.isRawShaderMaterial !== true && (y = `#version 300 es
`, g = [
          p,
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture"
        ].join(`
`) + `
` + g, m = [
          "#define varying in",
          t.glslVersion === ad ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === ad ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad"
        ].join(`
`) + `
` + m);
        const x = y + g + a, v = y + m + o, A = Vp(r, r.VERTEX_SHADER, x), E = Vp(r, r.FRAGMENT_SHADER, v);
        r.attachShader(_, A), r.attachShader(_, E), t.index0AttributeName !== void 0 ? r.bindAttribLocation(_, 0, t.index0AttributeName) : t.morphTargets === true && r.bindAttribLocation(_, 0, "position"), r.linkProgram(_);
        function w(L) {
          if (n.debug.checkShaderErrors) {
            const B = r.getProgramInfoLog(_).trim(), F = r.getShaderInfoLog(A).trim(), H = r.getShaderInfoLog(E).trim();
            let X = true, k = true;
            if (r.getProgramParameter(_, r.LINK_STATUS) === false) if (X = false, typeof n.debug.onShaderError == "function") n.debug.onShaderError(r, _, A, E);
            else {
              const K = Gp(r, A, "vertex"), G = Gp(r, E, "fragment");
              console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(_, r.VALIDATE_STATUS) + `

Material Name: ` + L.name + `
Material Type: ` + L.type + `

Program Info Log: ` + B + `
` + K + `
` + G);
            }
            else B !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", B) : (F === "" || H === "") && (k = false);
            k && (L.diagnostics = {
              runnable: X,
              programLog: B,
              vertexShader: {
                log: F,
                prefix: g
              },
              fragmentShader: {
                log: H,
                prefix: m
              }
            });
          }
          r.deleteShader(A), r.deleteShader(E), R = new tl(r, _), S = JM(r, _);
        }
        let R;
        this.getUniforms = function() {
          return R === void 0 && w(this), R;
        };
        let S;
        this.getAttributes = function() {
          return S === void 0 && w(this), S;
        };
        let T = t.rendererExtensionParallelShaderCompile === false;
        return this.isReady = function() {
          return T === false && (T = r.getProgramParameter(_, HM)), T;
        }, this.destroy = function() {
          i.releaseStatesOfProgram(this), r.deleteProgram(_), this.program = void 0;
        }, this.type = t.shaderType, this.name = t.shaderName, this.id = GM++, this.cacheKey = e, this.usedTimes = 1, this.program = _, this.vertexShader = A, this.fragmentShader = E, this;
      }
      let cT = 0;
      class uT {
        constructor() {
          this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
        }
        update(e) {
          const t = e.vertexShader, i = e.fragmentShader, r = this._getShaderStage(t), s = this._getShaderStage(i), a = this._getShaderCacheForMaterial(e);
          return a.has(r) === false && (a.add(r), r.usedTimes++), a.has(s) === false && (a.add(s), s.usedTimes++), this;
        }
        remove(e) {
          const t = this.materialCache.get(e);
          for (const i of t) i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
          return this.materialCache.delete(e), this;
        }
        getVertexShaderID(e) {
          return this._getShaderStage(e.vertexShader).id;
        }
        getFragmentShaderID(e) {
          return this._getShaderStage(e.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(e) {
          const t = this.materialCache;
          let i = t.get(e);
          return i === void 0 && (i = /* @__PURE__ */ new Set(), t.set(e, i)), i;
        }
        _getShaderStage(e) {
          const t = this.shaderCache;
          let i = t.get(e);
          return i === void 0 && (i = new hT(e), t.set(e, i)), i;
        }
      }
      class hT {
        constructor(e) {
          this.id = cT++, this.code = e, this.usedTimes = 0;
        }
      }
      function dT(n, e, t, i, r, s, a) {
        const o = new Rc(), l = new uT(), c = /* @__PURE__ */ new Set(), u = [], h = r.logarithmicDepthBuffer, d = r.vertexTextures;
        let p = r.precision;
        const f = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite"
        };
        function _(S) {
          return c.add(S), S === 0 ? "uv" : `uv${S}`;
        }
        function g(S, T, L, B, F) {
          const H = B.fog, X = F.geometry, k = S.isMeshStandardMaterial ? B.environment : null, K = (S.isMeshStandardMaterial ? t : e).get(S.envMap || k), G = K && K.mapping === oo ? K.image.height : null, ie = f[S.type];
          S.precision !== null && (p = r.getMaxPrecision(S.precision), p !== S.precision && console.warn("THREE.WebGLProgram.getParameters:", S.precision, "not supported, using", p, "instead."));
          const ue = X.morphAttributes.position || X.morphAttributes.normal || X.morphAttributes.color, we = ue !== void 0 ? ue.length : 0;
          let Be = 0;
          X.morphAttributes.position !== void 0 && (Be = 1), X.morphAttributes.normal !== void 0 && (Be = 2), X.morphAttributes.color !== void 0 && (Be = 3);
          let We, j, ne, _e;
          if (ie) {
            const lt = an[ie];
            We = lt.vertexShader, j = lt.fragmentShader;
          } else We = S.vertexShader, j = S.fragmentShader, l.update(S), ne = l.getVertexShaderID(S), _e = l.getFragmentShaderID(S);
          const ae = n.getRenderTarget(), Pe = n.state.buffers.depth.getReversed(), Re = F.isInstancedMesh === true, De = F.isBatchedMesh === true, te = !!S.map, $ = !!S.matcap, se = !!K, P = !!S.aoMap, fe = !!S.lightMap, xe = !!S.bumpMap, Me = !!S.normalMap, oe = !!S.displacementMap, ke = !!S.emissiveMap, de = !!S.metalnessMap, C = !!S.roughnessMap, M = S.anisotropy > 0, O = S.clearcoat > 0, Y = S.dispersion > 0, J = S.iridescence > 0, q = S.sheen > 0, Ee = S.transmission > 0, he = M && !!S.anisotropyMap, ye = O && !!S.clearcoatMap, je = O && !!S.clearcoatNormalMap, re = O && !!S.clearcoatRoughnessMap, Te = J && !!S.iridescenceMap, Le = J && !!S.iridescenceThicknessMap, Ie = q && !!S.sheenColorMap, be = q && !!S.sheenRoughnessMap, Ze = !!S.specularMap, He = !!S.specularColorMap, _t = !!S.specularIntensityMap, I = Ee && !!S.transmissionMap, pe = Ee && !!S.thicknessMap, W = !!S.gradientMap, Z = !!S.alphaMap, me = S.alphaTest > 0, le = !!S.alphaHash, Je = !!S.extensions;
          let Ct = Bn;
          S.toneMapped && (ae === null || ae.isXRRenderTarget === true) && (Ct = n.toneMapping);
          const si = {
            shaderID: ie,
            shaderType: S.type,
            shaderName: S.name,
            vertexShader: We,
            fragmentShader: j,
            defines: S.defines,
            customVertexShaderID: ne,
            customFragmentShaderID: _e,
            isRawShaderMaterial: S.isRawShaderMaterial === true,
            glslVersion: S.glslVersion,
            precision: p,
            batching: De,
            batchingColor: De && F._colorsTexture !== null,
            instancing: Re,
            instancingColor: Re && F.instanceColor !== null,
            instancingMorph: Re && F.morphTexture !== null,
            supportsVertexTextures: d,
            outputColorSpace: ae === null ? n.outputColorSpace : ae.isXRRenderTarget === true ? ae.texture.colorSpace : oi,
            alphaToCoverage: !!S.alphaToCoverage,
            map: te,
            matcap: $,
            envMap: se,
            envMapMode: se && K.mapping,
            envMapCubeUVHeight: G,
            aoMap: P,
            lightMap: fe,
            bumpMap: xe,
            normalMap: Me,
            displacementMap: d && oe,
            emissiveMap: ke,
            normalMapObjectSpace: Me && S.normalMapType === Ng,
            normalMapTangentSpace: Me && S.normalMapType === nd,
            metalnessMap: de,
            roughnessMap: C,
            anisotropy: M,
            anisotropyMap: he,
            clearcoat: O,
            clearcoatMap: ye,
            clearcoatNormalMap: je,
            clearcoatRoughnessMap: re,
            dispersion: Y,
            iridescence: J,
            iridescenceMap: Te,
            iridescenceThicknessMap: Le,
            sheen: q,
            sheenColorMap: Ie,
            sheenRoughnessMap: be,
            specularMap: Ze,
            specularColorMap: He,
            specularIntensityMap: _t,
            transmission: Ee,
            transmissionMap: I,
            thicknessMap: pe,
            gradientMap: W,
            opaque: S.transparent === false && S.blending === Fn && S.alphaToCoverage === false,
            alphaMap: Z,
            alphaTest: me,
            alphaHash: le,
            combine: S.combine,
            mapUv: te && _(S.map.channel),
            aoMapUv: P && _(S.aoMap.channel),
            lightMapUv: fe && _(S.lightMap.channel),
            bumpMapUv: xe && _(S.bumpMap.channel),
            normalMapUv: Me && _(S.normalMap.channel),
            displacementMapUv: oe && _(S.displacementMap.channel),
            emissiveMapUv: ke && _(S.emissiveMap.channel),
            metalnessMapUv: de && _(S.metalnessMap.channel),
            roughnessMapUv: C && _(S.roughnessMap.channel),
            anisotropyMapUv: he && _(S.anisotropyMap.channel),
            clearcoatMapUv: ye && _(S.clearcoatMap.channel),
            clearcoatNormalMapUv: je && _(S.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: re && _(S.clearcoatRoughnessMap.channel),
            iridescenceMapUv: Te && _(S.iridescenceMap.channel),
            iridescenceThicknessMapUv: Le && _(S.iridescenceThicknessMap.channel),
            sheenColorMapUv: Ie && _(S.sheenColorMap.channel),
            sheenRoughnessMapUv: be && _(S.sheenRoughnessMap.channel),
            specularMapUv: Ze && _(S.specularMap.channel),
            specularColorMapUv: He && _(S.specularColorMap.channel),
            specularIntensityMapUv: _t && _(S.specularIntensityMap.channel),
            transmissionMapUv: I && _(S.transmissionMap.channel),
            thicknessMapUv: pe && _(S.thicknessMap.channel),
            alphaMapUv: Z && _(S.alphaMap.channel),
            vertexTangents: !!X.attributes.tangent && (Me || M),
            vertexColors: S.vertexColors,
            vertexAlphas: S.vertexColors === true && !!X.attributes.color && X.attributes.color.itemSize === 4,
            pointsUvs: F.isPoints === true && !!X.attributes.uv && (te || Z),
            fog: !!H,
            useFog: S.fog === true,
            fogExp2: !!H && H.isFogExp2,
            flatShading: S.flatShading === true,
            sizeAttenuation: S.sizeAttenuation === true,
            logarithmicDepthBuffer: h,
            reverseDepthBuffer: Pe,
            skinning: F.isSkinnedMesh === true,
            morphTargets: X.morphAttributes.position !== void 0,
            morphNormals: X.morphAttributes.normal !== void 0,
            morphColors: X.morphAttributes.color !== void 0,
            morphTargetsCount: we,
            morphTextureStride: Be,
            numDirLights: T.directional.length,
            numPointLights: T.point.length,
            numSpotLights: T.spot.length,
            numSpotLightMaps: T.spotLightMap.length,
            numRectAreaLights: T.rectArea.length,
            numHemiLights: T.hemi.length,
            numDirLightShadows: T.directionalShadowMap.length,
            numPointLightShadows: T.pointShadowMap.length,
            numSpotLightShadows: T.spotShadowMap.length,
            numSpotLightShadowsWithMaps: T.numSpotLightShadowsWithMaps,
            numLightProbes: T.numLightProbes,
            numClippingPlanes: a.numPlanes,
            numClipIntersection: a.numIntersection,
            dithering: S.dithering,
            shadowMapEnabled: n.shadowMap.enabled && L.length > 0,
            shadowMapType: n.shadowMap.type,
            toneMapping: Ct,
            decodeVideoTexture: te && S.map.isVideoTexture === true && Ke.getTransfer(S.map.colorSpace) === ct,
            decodeVideoTextureEmissive: ke && S.emissiveMap.isVideoTexture === true && Ke.getTransfer(S.emissiveMap.colorSpace) === ct,
            premultipliedAlpha: S.premultipliedAlpha,
            doubleSided: S.side === fi,
            flipSided: S.side === Lt,
            useDepthPacking: S.depthPacking >= 0,
            depthPacking: S.depthPacking || 0,
            index0AttributeName: S.index0AttributeName,
            extensionClipCullDistance: Je && S.extensions.clipCullDistance === true && i.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: (Je && S.extensions.multiDraw === true || De) && i.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: S.customProgramCacheKey()
          };
          return si.vertexUv1s = c.has(1), si.vertexUv2s = c.has(2), si.vertexUv3s = c.has(3), c.clear(), si;
        }
        function m(S) {
          const T = [];
          if (S.shaderID ? T.push(S.shaderID) : (T.push(S.customVertexShaderID), T.push(S.customFragmentShaderID)), S.defines !== void 0) for (const L in S.defines) T.push(L), T.push(S.defines[L]);
          return S.isRawShaderMaterial === false && (y(T, S), x(T, S), T.push(n.outputColorSpace)), T.push(S.customProgramCacheKey), T.join();
        }
        function y(S, T) {
          S.push(T.precision), S.push(T.outputColorSpace), S.push(T.envMapMode), S.push(T.envMapCubeUVHeight), S.push(T.mapUv), S.push(T.alphaMapUv), S.push(T.lightMapUv), S.push(T.aoMapUv), S.push(T.bumpMapUv), S.push(T.normalMapUv), S.push(T.displacementMapUv), S.push(T.emissiveMapUv), S.push(T.metalnessMapUv), S.push(T.roughnessMapUv), S.push(T.anisotropyMapUv), S.push(T.clearcoatMapUv), S.push(T.clearcoatNormalMapUv), S.push(T.clearcoatRoughnessMapUv), S.push(T.iridescenceMapUv), S.push(T.iridescenceThicknessMapUv), S.push(T.sheenColorMapUv), S.push(T.sheenRoughnessMapUv), S.push(T.specularMapUv), S.push(T.specularColorMapUv), S.push(T.specularIntensityMapUv), S.push(T.transmissionMapUv), S.push(T.thicknessMapUv), S.push(T.combine), S.push(T.fogExp2), S.push(T.sizeAttenuation), S.push(T.morphTargetsCount), S.push(T.morphAttributeCount), S.push(T.numDirLights), S.push(T.numPointLights), S.push(T.numSpotLights), S.push(T.numSpotLightMaps), S.push(T.numHemiLights), S.push(T.numRectAreaLights), S.push(T.numDirLightShadows), S.push(T.numPointLightShadows), S.push(T.numSpotLightShadows), S.push(T.numSpotLightShadowsWithMaps), S.push(T.numLightProbes), S.push(T.shadowMapType), S.push(T.toneMapping), S.push(T.numClippingPlanes), S.push(T.numClipIntersection), S.push(T.depthPacking);
        }
        function x(S, T) {
          o.disableAll(), T.supportsVertexTextures && o.enable(0), T.instancing && o.enable(1), T.instancingColor && o.enable(2), T.instancingMorph && o.enable(3), T.matcap && o.enable(4), T.envMap && o.enable(5), T.normalMapObjectSpace && o.enable(6), T.normalMapTangentSpace && o.enable(7), T.clearcoat && o.enable(8), T.iridescence && o.enable(9), T.alphaTest && o.enable(10), T.vertexColors && o.enable(11), T.vertexAlphas && o.enable(12), T.vertexUv1s && o.enable(13), T.vertexUv2s && o.enable(14), T.vertexUv3s && o.enable(15), T.vertexTangents && o.enable(16), T.anisotropy && o.enable(17), T.alphaHash && o.enable(18), T.batching && o.enable(19), T.dispersion && o.enable(20), T.batchingColor && o.enable(21), S.push(o.mask), o.disableAll(), T.fog && o.enable(0), T.useFog && o.enable(1), T.flatShading && o.enable(2), T.logarithmicDepthBuffer && o.enable(3), T.reverseDepthBuffer && o.enable(4), T.skinning && o.enable(5), T.morphTargets && o.enable(6), T.morphNormals && o.enable(7), T.morphColors && o.enable(8), T.premultipliedAlpha && o.enable(9), T.shadowMapEnabled && o.enable(10), T.doubleSided && o.enable(11), T.flipSided && o.enable(12), T.useDepthPacking && o.enable(13), T.dithering && o.enable(14), T.transmission && o.enable(15), T.sheen && o.enable(16), T.opaque && o.enable(17), T.pointsUvs && o.enable(18), T.decodeVideoTexture && o.enable(19), T.decodeVideoTextureEmissive && o.enable(20), T.alphaToCoverage && o.enable(21), S.push(o.mask);
        }
        function v(S) {
          const T = f[S.type];
          let L;
          if (T) {
            const B = an[T];
            L = No.clone(B.uniforms);
          } else L = S.uniforms;
          return L;
        }
        function A(S, T) {
          let L;
          for (let B = 0, F = u.length; B < F; B++) {
            const H = u[B];
            if (H.cacheKey === T) {
              L = H, ++L.usedTimes;
              break;
            }
          }
          return L === void 0 && (L = new lT(n, T, S, s), u.push(L)), L;
        }
        function E(S) {
          if (--S.usedTimes === 0) {
            const T = u.indexOf(S);
            u[T] = u[u.length - 1], u.pop(), S.destroy();
          }
        }
        function w(S) {
          l.remove(S);
        }
        function R() {
          l.dispose();
        }
        return {
          getParameters: g,
          getProgramCacheKey: m,
          getUniforms: v,
          acquireProgram: A,
          releaseProgram: E,
          releaseShaderCache: w,
          programs: u,
          dispose: R
        };
      }
      function pT() {
        let n = /* @__PURE__ */ new WeakMap();
        function e(a) {
          return n.has(a);
        }
        function t(a) {
          let o = n.get(a);
          return o === void 0 && (o = {}, n.set(a, o)), o;
        }
        function i(a) {
          n.delete(a);
        }
        function r(a, o, l) {
          n.get(a)[o] = l;
        }
        function s() {
          n = /* @__PURE__ */ new WeakMap();
        }
        return {
          has: e,
          get: t,
          remove: i,
          update: r,
          dispose: s
        };
      }
      function fT(n, e) {
        return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id;
      }
      function Yp(n, e) {
        return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id;
      }
      function Kp() {
        const n = [];
        let e = 0;
        const t = [], i = [], r = [];
        function s() {
          e = 0, t.length = 0, i.length = 0, r.length = 0;
        }
        function a(h, d, p, f, _, g) {
          let m = n[e];
          return m === void 0 ? (m = {
            id: h.id,
            object: h,
            geometry: d,
            material: p,
            groupOrder: f,
            renderOrder: h.renderOrder,
            z: _,
            group: g
          }, n[e] = m) : (m.id = h.id, m.object = h, m.geometry = d, m.material = p, m.groupOrder = f, m.renderOrder = h.renderOrder, m.z = _, m.group = g), e++, m;
        }
        function o(h, d, p, f, _, g) {
          const m = a(h, d, p, f, _, g);
          p.transmission > 0 ? i.push(m) : p.transparent === true ? r.push(m) : t.push(m);
        }
        function l(h, d, p, f, _, g) {
          const m = a(h, d, p, f, _, g);
          p.transmission > 0 ? i.unshift(m) : p.transparent === true ? r.unshift(m) : t.unshift(m);
        }
        function c(h, d) {
          t.length > 1 && t.sort(h || fT), i.length > 1 && i.sort(d || Yp), r.length > 1 && r.sort(d || Yp);
        }
        function u() {
          for (let h = e, d = n.length; h < d; h++) {
            const p = n[h];
            if (p.id === null) break;
            p.id = null, p.object = null, p.geometry = null, p.material = null, p.group = null;
          }
        }
        return {
          opaque: t,
          transmissive: i,
          transparent: r,
          init: s,
          push: o,
          unshift: l,
          finish: u,
          sort: c
        };
      }
      function mT() {
        let n = /* @__PURE__ */ new WeakMap();
        function e(i, r) {
          const s = n.get(i);
          let a;
          return s === void 0 ? (a = new Kp(), n.set(i, [
            a
          ])) : r >= s.length ? (a = new Kp(), s.push(a)) : a = s[r], a;
        }
        function t() {
          n = /* @__PURE__ */ new WeakMap();
        }
        return {
          get: e,
          dispose: t
        };
      }
      function gT() {
        const n = {};
        return {
          get: function(e) {
            if (n[e.id] !== void 0) return n[e.id];
            let t;
            switch (e.type) {
              case "DirectionalLight":
                t = {
                  direction: new D(),
                  color: new Ae()
                };
                break;
              case "SpotLight":
                t = {
                  position: new D(),
                  direction: new D(),
                  color: new Ae(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0
                };
                break;
              case "PointLight":
                t = {
                  position: new D(),
                  color: new Ae(),
                  distance: 0,
                  decay: 0
                };
                break;
              case "HemisphereLight":
                t = {
                  direction: new D(),
                  skyColor: new Ae(),
                  groundColor: new Ae()
                };
                break;
              case "RectAreaLight":
                t = {
                  color: new Ae(),
                  position: new D(),
                  halfWidth: new D(),
                  halfHeight: new D()
                };
                break;
            }
            return n[e.id] = t, t;
          }
        };
      }
      function _T() {
        const n = {};
        return {
          get: function(e) {
            if (n[e.id] !== void 0) return n[e.id];
            let t;
            switch (e.type) {
              case "DirectionalLight":
                t = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new ee()
                };
                break;
              case "SpotLight":
                t = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new ee()
                };
                break;
              case "PointLight":
                t = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new ee(),
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3
                };
                break;
            }
            return n[e.id] = t, t;
          }
        };
      }
      let vT = 0;
      function xT(n, e) {
        return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0);
      }
      function yT(n) {
        const e = new gT(), t = _T(), i = {
          version: 0,
          hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
          },
          ambient: [
            0,
            0,
            0
          ],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotLightMap: [],
          spotShadow: [],
          spotShadowMap: [],
          spotLightMatrix: [],
          rectArea: [],
          rectAreaLTC1: null,
          rectAreaLTC2: null,
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: [],
          numSpotLightShadowsWithMaps: 0,
          numLightProbes: 0
        };
        for (let c = 0; c < 9; c++) i.probe.push(new D());
        const r = new D(), s = new Fe(), a = new Fe();
        function o(c) {
          let u = 0, h = 0, d = 0;
          for (let S = 0; S < 9; S++) i.probe[S].set(0, 0, 0);
          let p = 0, f = 0, _ = 0, g = 0, m = 0, y = 0, x = 0, v = 0, A = 0, E = 0, w = 0;
          c.sort(xT);
          for (let S = 0, T = c.length; S < T; S++) {
            const L = c[S], B = L.color, F = L.intensity, H = L.distance, X = L.shadow && L.shadow.map ? L.shadow.map.texture : null;
            if (L.isAmbientLight) u += B.r * F, h += B.g * F, d += B.b * F;
            else if (L.isLightProbe) {
              for (let k = 0; k < 9; k++) i.probe[k].addScaledVector(L.sh.coefficients[k], F);
              w++;
            } else if (L.isDirectionalLight) {
              const k = e.get(L);
              if (k.color.copy(L.color).multiplyScalar(L.intensity), L.castShadow) {
                const K = L.shadow, G = t.get(L);
                G.shadowIntensity = K.intensity, G.shadowBias = K.bias, G.shadowNormalBias = K.normalBias, G.shadowRadius = K.radius, G.shadowMapSize = K.mapSize, i.directionalShadow[p] = G, i.directionalShadowMap[p] = X, i.directionalShadowMatrix[p] = L.shadow.matrix, y++;
              }
              i.directional[p] = k, p++;
            } else if (L.isSpotLight) {
              const k = e.get(L);
              k.position.setFromMatrixPosition(L.matrixWorld), k.color.copy(B).multiplyScalar(F), k.distance = H, k.coneCos = Math.cos(L.angle), k.penumbraCos = Math.cos(L.angle * (1 - L.penumbra)), k.decay = L.decay, i.spot[_] = k;
              const K = L.shadow;
              if (L.map && (i.spotLightMap[A] = L.map, A++, K.updateMatrices(L), L.castShadow && E++), i.spotLightMatrix[_] = K.matrix, L.castShadow) {
                const G = t.get(L);
                G.shadowIntensity = K.intensity, G.shadowBias = K.bias, G.shadowNormalBias = K.normalBias, G.shadowRadius = K.radius, G.shadowMapSize = K.mapSize, i.spotShadow[_] = G, i.spotShadowMap[_] = X, v++;
              }
              _++;
            } else if (L.isRectAreaLight) {
              const k = e.get(L);
              k.color.copy(B).multiplyScalar(F), k.halfWidth.set(L.width * 0.5, 0, 0), k.halfHeight.set(0, L.height * 0.5, 0), i.rectArea[g] = k, g++;
            } else if (L.isPointLight) {
              const k = e.get(L);
              if (k.color.copy(L.color).multiplyScalar(L.intensity), k.distance = L.distance, k.decay = L.decay, L.castShadow) {
                const K = L.shadow, G = t.get(L);
                G.shadowIntensity = K.intensity, G.shadowBias = K.bias, G.shadowNormalBias = K.normalBias, G.shadowRadius = K.radius, G.shadowMapSize = K.mapSize, G.shadowCameraNear = K.camera.near, G.shadowCameraFar = K.camera.far, i.pointShadow[f] = G, i.pointShadowMap[f] = X, i.pointShadowMatrix[f] = L.shadow.matrix, x++;
              }
              i.point[f] = k, f++;
            } else if (L.isHemisphereLight) {
              const k = e.get(L);
              k.skyColor.copy(L.color).multiplyScalar(F), k.groundColor.copy(L.groundColor).multiplyScalar(F), i.hemi[m] = k, m++;
            }
          }
          g > 0 && (n.has("OES_texture_float_linear") === true ? (i.rectAreaLTC1 = ce.LTC_FLOAT_1, i.rectAreaLTC2 = ce.LTC_FLOAT_2) : (i.rectAreaLTC1 = ce.LTC_HALF_1, i.rectAreaLTC2 = ce.LTC_HALF_2)), i.ambient[0] = u, i.ambient[1] = h, i.ambient[2] = d;
          const R = i.hash;
          (R.directionalLength !== p || R.pointLength !== f || R.spotLength !== _ || R.rectAreaLength !== g || R.hemiLength !== m || R.numDirectionalShadows !== y || R.numPointShadows !== x || R.numSpotShadows !== v || R.numSpotMaps !== A || R.numLightProbes !== w) && (i.directional.length = p, i.spot.length = _, i.rectArea.length = g, i.point.length = f, i.hemi.length = m, i.directionalShadow.length = y, i.directionalShadowMap.length = y, i.pointShadow.length = x, i.pointShadowMap.length = x, i.spotShadow.length = v, i.spotShadowMap.length = v, i.directionalShadowMatrix.length = y, i.pointShadowMatrix.length = x, i.spotLightMatrix.length = v + A - E, i.spotLightMap.length = A, i.numSpotLightShadowsWithMaps = E, i.numLightProbes = w, R.directionalLength = p, R.pointLength = f, R.spotLength = _, R.rectAreaLength = g, R.hemiLength = m, R.numDirectionalShadows = y, R.numPointShadows = x, R.numSpotShadows = v, R.numSpotMaps = A, R.numLightProbes = w, i.version = vT++);
        }
        function l(c, u) {
          let h = 0, d = 0, p = 0, f = 0, _ = 0;
          const g = u.matrixWorldInverse;
          for (let m = 0, y = c.length; m < y; m++) {
            const x = c[m];
            if (x.isDirectionalLight) {
              const v = i.directional[h];
              v.direction.setFromMatrixPosition(x.matrixWorld), r.setFromMatrixPosition(x.target.matrixWorld), v.direction.sub(r), v.direction.transformDirection(g), h++;
            } else if (x.isSpotLight) {
              const v = i.spot[p];
              v.position.setFromMatrixPosition(x.matrixWorld), v.position.applyMatrix4(g), v.direction.setFromMatrixPosition(x.matrixWorld), r.setFromMatrixPosition(x.target.matrixWorld), v.direction.sub(r), v.direction.transformDirection(g), p++;
            } else if (x.isRectAreaLight) {
              const v = i.rectArea[f];
              v.position.setFromMatrixPosition(x.matrixWorld), v.position.applyMatrix4(g), a.identity(), s.copy(x.matrixWorld), s.premultiply(g), a.extractRotation(s), v.halfWidth.set(x.width * 0.5, 0, 0), v.halfHeight.set(0, x.height * 0.5, 0), v.halfWidth.applyMatrix4(a), v.halfHeight.applyMatrix4(a), f++;
            } else if (x.isPointLight) {
              const v = i.point[d];
              v.position.setFromMatrixPosition(x.matrixWorld), v.position.applyMatrix4(g), d++;
            } else if (x.isHemisphereLight) {
              const v = i.hemi[_];
              v.direction.setFromMatrixPosition(x.matrixWorld), v.direction.transformDirection(g), _++;
            }
          }
        }
        return {
          setup: o,
          setupView: l,
          state: i
        };
      }
      function Zp(n) {
        const e = new yT(n), t = [], i = [];
        function r(u) {
          c.camera = u, t.length = 0, i.length = 0;
        }
        function s(u) {
          t.push(u);
        }
        function a(u) {
          i.push(u);
        }
        function o() {
          e.setup(t);
        }
        function l(u) {
          e.setupView(t, u);
        }
        const c = {
          lightsArray: t,
          shadowsArray: i,
          camera: null,
          lights: e,
          transmissionRenderTarget: {}
        };
        return {
          init: r,
          state: c,
          setupLights: o,
          setupLightsView: l,
          pushLight: s,
          pushShadow: a
        };
      }
      function MT(n) {
        let e = /* @__PURE__ */ new WeakMap();
        function t(r, s = 0) {
          const a = e.get(r);
          let o;
          return a === void 0 ? (o = new Zp(n), e.set(r, [
            o
          ])) : s >= a.length ? (o = new Zp(n), a.push(o)) : o = a[s], o;
        }
        function i() {
          e = /* @__PURE__ */ new WeakMap();
        }
        return {
          get: t,
          dispose: i
        };
      }
      const TT = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, bT = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
      function ST(n, e, t) {
        let i = new qc();
        const r = new ee(), s = new ee(), a = new it(), o = new Tv({
          depthPacking: Ig
        }), l = new bv(), c = {}, u = t.maxTextureSize, h = {
          [ft]: Lt,
          [Lt]: ft,
          [fi]: fi
        }, d = new ti({
          defines: {
            VSM_SAMPLES: 8
          },
          uniforms: {
            shadow_pass: {
              value: null
            },
            resolution: {
              value: new ee()
            },
            radius: {
              value: 4
            }
          },
          vertexShader: TT,
          fragmentShader: bT
        }), p = d.clone();
        p.defines.HORIZONTAL_PASS = 1;
        const f = new mi();
        f.setAttribute("position", new li(new Float32Array([
          -1,
          -1,
          0.5,
          3,
          -1,
          0.5,
          -1,
          3,
          0.5
        ]), 3));
        const _ = new Dt(f, d), g = this;
        this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = gt;
        let m = this.type;
        this.render = function(E, w, R) {
          if (g.enabled === false || g.autoUpdate === false && g.needsUpdate === false || E.length === 0) return;
          const S = n.getRenderTarget(), T = n.getActiveCubeFace(), L = n.getActiveMipmapLevel(), B = n.state;
          B.setBlending(jt), B.buffers.color.setClear(1, 1, 1, 1), B.buffers.depth.setTest(true), B.setScissorTest(false);
          const F = m !== Pt && this.type === Pt, H = m === Pt && this.type !== Pt;
          for (let X = 0, k = E.length; X < k; X++) {
            const K = E[X], G = K.shadow;
            if (G === void 0) {
              console.warn("THREE.WebGLShadowMap:", K, "has no shadow.");
              continue;
            }
            if (G.autoUpdate === false && G.needsUpdate === false) continue;
            r.copy(G.mapSize);
            const ie = G.getFrameExtents();
            if (r.multiply(ie), s.copy(G.mapSize), (r.x > u || r.y > u) && (r.x > u && (s.x = Math.floor(u / ie.x), r.x = s.x * ie.x, G.mapSize.x = s.x), r.y > u && (s.y = Math.floor(u / ie.y), r.y = s.y * ie.y, G.mapSize.y = s.y)), G.map === null || F === true || H === true) {
              const we = this.type !== Pt ? {
                minFilter: ai,
                magFilter: ai
              } : {};
              G.map !== null && G.map.dispose(), G.map = new Gi(r.x, r.y, we), G.map.texture.name = K.name + ".shadowMap", G.camera.updateProjectionMatrix();
            }
            n.setRenderTarget(G.map), n.clear();
            const ue = G.getViewportCount();
            for (let we = 0; we < ue; we++) {
              const Be = G.getViewport(we);
              a.set(s.x * Be.x, s.y * Be.y, s.x * Be.z, s.y * Be.w), B.viewport(a), G.updateMatrices(K, we), i = G.getFrustum(), v(w, R, G.camera, K, this.type);
            }
            G.isPointLightShadow !== true && this.type === Pt && y(G, R), G.needsUpdate = false;
          }
          m = this.type, g.needsUpdate = false, n.setRenderTarget(S, T, L);
        };
        function y(E, w) {
          const R = e.update(_);
          d.defines.VSM_SAMPLES !== E.blurSamples && (d.defines.VSM_SAMPLES = E.blurSamples, p.defines.VSM_SAMPLES = E.blurSamples, d.needsUpdate = true, p.needsUpdate = true), E.mapPass === null && (E.mapPass = new Gi(r.x, r.y)), d.uniforms.shadow_pass.value = E.map.texture, d.uniforms.resolution.value = E.mapSize, d.uniforms.radius.value = E.radius, n.setRenderTarget(E.mapPass), n.clear(), n.renderBufferDirect(w, null, R, d, _, null), p.uniforms.shadow_pass.value = E.mapPass.texture, p.uniforms.resolution.value = E.mapSize, p.uniforms.radius.value = E.radius, n.setRenderTarget(E.map), n.clear(), n.renderBufferDirect(w, null, R, p, _, null);
        }
        function x(E, w, R, S) {
          let T = null;
          const L = R.isPointLight === true ? E.customDistanceMaterial : E.customDepthMaterial;
          if (L !== void 0) T = L;
          else if (T = R.isPointLight === true ? l : o, n.localClippingEnabled && w.clipShadows === true && Array.isArray(w.clippingPlanes) && w.clippingPlanes.length !== 0 || w.displacementMap && w.displacementScale !== 0 || w.alphaMap && w.alphaTest > 0 || w.map && w.alphaTest > 0) {
            const B = T.uuid, F = w.uuid;
            let H = c[B];
            H === void 0 && (H = {}, c[B] = H);
            let X = H[F];
            X === void 0 && (X = T.clone(), H[F] = X, w.addEventListener("dispose", A)), T = X;
          }
          if (T.visible = w.visible, T.wireframe = w.wireframe, S === Pt ? T.side = w.shadowSide !== null ? w.shadowSide : w.side : T.side = w.shadowSide !== null ? w.shadowSide : h[w.side], T.alphaMap = w.alphaMap, T.alphaTest = w.alphaTest, T.map = w.map, T.clipShadows = w.clipShadows, T.clippingPlanes = w.clippingPlanes, T.clipIntersection = w.clipIntersection, T.displacementMap = w.displacementMap, T.displacementScale = w.displacementScale, T.displacementBias = w.displacementBias, T.wireframeLinewidth = w.wireframeLinewidth, T.linewidth = w.linewidth, R.isPointLight === true && T.isMeshDistanceMaterial === true) {
            const B = n.properties.get(T);
            B.light = R;
          }
          return T;
        }
        function v(E, w, R, S, T) {
          if (E.visible === false) return;
          if (E.layers.test(w.layers) && (E.isMesh || E.isLine || E.isPoints) && (E.castShadow || E.receiveShadow && T === Pt) && (!E.frustumCulled || i.intersectsObject(E))) {
            E.modelViewMatrix.multiplyMatrices(R.matrixWorldInverse, E.matrixWorld);
            const B = e.update(E), F = E.material;
            if (Array.isArray(F)) {
              const H = B.groups;
              for (let X = 0, k = H.length; X < k; X++) {
                const K = H[X], G = F[K.materialIndex];
                if (G && G.visible) {
                  const ie = x(E, G, S, T);
                  E.onBeforeShadow(n, E, w, R, B, ie, K), n.renderBufferDirect(R, null, B, ie, E, K), E.onAfterShadow(n, E, w, R, B, ie, K);
                }
              }
            } else if (F.visible) {
              const H = x(E, F, S, T);
              E.onBeforeShadow(n, E, w, R, B, H, null), n.renderBufferDirect(R, null, B, H, E, null), E.onAfterShadow(n, E, w, R, B, H, null);
            }
          }
          const L = E.children;
          for (let B = 0, F = L.length; B < F; B++) v(L[B], w, R, S, T);
        }
        function A(E) {
          E.target.removeEventListener("dispose", A);
          for (const w in c) {
            const R = c[w], S = E.target.uuid;
            S in R && (R[S].dispose(), delete R[S]);
          }
        }
      }
      const ET = {
        [Rl]: Cl,
        [Pl]: Il,
        [Ll]: Nl,
        [Yr]: Dl,
        [Cl]: Rl,
        [Il]: Pl,
        [Nl]: Ll,
        [Dl]: Yr
      };
      function wT(n, e) {
        function t() {
          let I = false;
          const pe = new it();
          let W = null;
          const Z = new it(0, 0, 0, 0);
          return {
            setMask: function(me) {
              W !== me && !I && (n.colorMask(me, me, me, me), W = me);
            },
            setLocked: function(me) {
              I = me;
            },
            setClear: function(me, le, Je, Ct, si) {
              si === true && (me *= Ct, le *= Ct, Je *= Ct), pe.set(me, le, Je, Ct), Z.equals(pe) === false && (n.clearColor(me, le, Je, Ct), Z.copy(pe));
            },
            reset: function() {
              I = false, W = null, Z.set(-1, 0, 0, 0);
            }
          };
        }
        function i() {
          let I = false, pe = false, W = null, Z = null, me = null;
          return {
            setReversed: function(le) {
              if (pe !== le) {
                const Je = e.get("EXT_clip_control");
                pe ? Je.clipControlEXT(Je.LOWER_LEFT_EXT, Je.ZERO_TO_ONE_EXT) : Je.clipControlEXT(Je.LOWER_LEFT_EXT, Je.NEGATIVE_ONE_TO_ONE_EXT);
                const Ct = me;
                me = null, this.setClear(Ct);
              }
              pe = le;
            },
            getReversed: function() {
              return pe;
            },
            setTest: function(le) {
              le ? ae(n.DEPTH_TEST) : Pe(n.DEPTH_TEST);
            },
            setMask: function(le) {
              W !== le && !I && (n.depthMask(le), W = le);
            },
            setFunc: function(le) {
              if (pe && (le = ET[le]), Z !== le) {
                switch (le) {
                  case Rl:
                    n.depthFunc(n.NEVER);
                    break;
                  case Cl:
                    n.depthFunc(n.ALWAYS);
                    break;
                  case Pl:
                    n.depthFunc(n.LESS);
                    break;
                  case Yr:
                    n.depthFunc(n.LEQUAL);
                    break;
                  case Ll:
                    n.depthFunc(n.EQUAL);
                    break;
                  case Dl:
                    n.depthFunc(n.GEQUAL);
                    break;
                  case Il:
                    n.depthFunc(n.GREATER);
                    break;
                  case Nl:
                    n.depthFunc(n.NOTEQUAL);
                    break;
                  default:
                    n.depthFunc(n.LEQUAL);
                }
                Z = le;
              }
            },
            setLocked: function(le) {
              I = le;
            },
            setClear: function(le) {
              me !== le && (pe && (le = 1 - le), n.clearDepth(le), me = le);
            },
            reset: function() {
              I = false, W = null, Z = null, me = null, pe = false;
            }
          };
        }
        function r() {
          let I = false, pe = null, W = null, Z = null, me = null, le = null, Je = null, Ct = null, si = null;
          return {
            setTest: function(lt) {
              I || (lt ? ae(n.STENCIL_TEST) : Pe(n.STENCIL_TEST));
            },
            setMask: function(lt) {
              pe !== lt && !I && (n.stencilMask(lt), pe = lt);
            },
            setFunc: function(lt, Ki, Un) {
              (W !== lt || Z !== Ki || me !== Un) && (n.stencilFunc(lt, Ki, Un), W = lt, Z = Ki, me = Un);
            },
            setOp: function(lt, Ki, Un) {
              (le !== lt || Je !== Ki || Ct !== Un) && (n.stencilOp(lt, Ki, Un), le = lt, Je = Ki, Ct = Un);
            },
            setLocked: function(lt) {
              I = lt;
            },
            setClear: function(lt) {
              si !== lt && (n.clearStencil(lt), si = lt);
            },
            reset: function() {
              I = false, pe = null, W = null, Z = null, me = null, le = null, Je = null, Ct = null, si = null;
            }
          };
        }
        const s = new t(), a = new i(), o = new r(), l = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap();
        let u = {}, h = {}, d = /* @__PURE__ */ new WeakMap(), p = [], f = null, _ = false, g = null, m = null, y = null, x = null, v = null, A = null, E = null, w = new Ae(0, 0, 0), R = 0, S = false, T = null, L = null, B = null, F = null, H = null;
        const X = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let k = false, K = 0;
        const G = n.getParameter(n.VERSION);
        G.indexOf("WebGL") !== -1 ? (K = parseFloat(/^WebGL (\d)/.exec(G)[1]), k = K >= 1) : G.indexOf("OpenGL ES") !== -1 && (K = parseFloat(/^OpenGL ES (\d)/.exec(G)[1]), k = K >= 2);
        let ie = null, ue = {};
        const we = n.getParameter(n.SCISSOR_BOX), Be = n.getParameter(n.VIEWPORT), We = new it().fromArray(we), j = new it().fromArray(Be);
        function ne(I, pe, W, Z) {
          const me = new Uint8Array(4), le = n.createTexture();
          n.bindTexture(I, le), n.texParameteri(I, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(I, n.TEXTURE_MAG_FILTER, n.NEAREST);
          for (let Je = 0; Je < W; Je++) I === n.TEXTURE_3D || I === n.TEXTURE_2D_ARRAY ? n.texImage3D(pe, 0, n.RGBA, 1, 1, Z, 0, n.RGBA, n.UNSIGNED_BYTE, me) : n.texImage2D(pe + Je, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, me);
          return le;
        }
        const _e = {};
        _e[n.TEXTURE_2D] = ne(n.TEXTURE_2D, n.TEXTURE_2D, 1), _e[n.TEXTURE_CUBE_MAP] = ne(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6), _e[n.TEXTURE_2D_ARRAY] = ne(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1), _e[n.TEXTURE_3D] = ne(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1), s.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), ae(n.DEPTH_TEST), a.setFunc(Yr), xe(false), Me(Xt), ae(n.CULL_FACE), P(jt);
        function ae(I) {
          u[I] !== true && (n.enable(I), u[I] = true);
        }
        function Pe(I) {
          u[I] !== false && (n.disable(I), u[I] = false);
        }
        function Re(I, pe) {
          return h[I] !== pe ? (n.bindFramebuffer(I, pe), h[I] = pe, I === n.DRAW_FRAMEBUFFER && (h[n.FRAMEBUFFER] = pe), I === n.FRAMEBUFFER && (h[n.DRAW_FRAMEBUFFER] = pe), true) : false;
        }
        function De(I, pe) {
          let W = p, Z = false;
          if (I) {
            W = d.get(pe), W === void 0 && (W = [], d.set(pe, W));
            const me = I.textures;
            if (W.length !== me.length || W[0] !== n.COLOR_ATTACHMENT0) {
              for (let le = 0, Je = me.length; le < Je; le++) W[le] = n.COLOR_ATTACHMENT0 + le;
              W.length = me.length, Z = true;
            }
          } else W[0] !== n.BACK && (W[0] = n.BACK, Z = true);
          Z && n.drawBuffers(W);
        }
        function te(I) {
          return f !== I ? (n.useProgram(I), f = I, true) : false;
        }
        const $ = {
          [lr]: n.FUNC_ADD,
          [ng]: n.FUNC_SUBTRACT,
          [rg]: n.FUNC_REVERSE_SUBTRACT
        };
        $[sg] = n.MIN, $[ag] = n.MAX;
        const se = {
          [og]: n.ZERO,
          [lg]: n.ONE,
          [cg]: n.SRC_COLOR,
          [wl]: n.SRC_ALPHA,
          [mg]: n.SRC_ALPHA_SATURATE,
          [pg]: n.DST_COLOR,
          [hg]: n.DST_ALPHA,
          [ug]: n.ONE_MINUS_SRC_COLOR,
          [Al]: n.ONE_MINUS_SRC_ALPHA,
          [fg]: n.ONE_MINUS_DST_COLOR,
          [dg]: n.ONE_MINUS_DST_ALPHA,
          [gg]: n.CONSTANT_COLOR,
          [_g]: n.ONE_MINUS_CONSTANT_COLOR,
          [vg]: n.CONSTANT_ALPHA,
          [xg]: n.ONE_MINUS_CONSTANT_ALPHA
        };
        function P(I, pe, W, Z, me, le, Je, Ct, si, lt) {
          if (I === jt) {
            _ === true && (Pe(n.BLEND), _ = false);
            return;
          }
          if (_ === false && (ae(n.BLEND), _ = true), I !== ig) {
            if (I !== g || lt !== S) {
              if ((m !== lr || v !== lr) && (n.blendEquation(n.FUNC_ADD), m = lr, v = lr), lt) switch (I) {
                case Fn:
                  n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                  break;
                case qr:
                  n.blendFunc(n.ONE, n.ONE);
                  break;
                case Bh:
                  n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                  break;
                case zh:
                  n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", I);
                  break;
              }
              else switch (I) {
                case Fn:
                  n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                  break;
                case qr:
                  n.blendFunc(n.SRC_ALPHA, n.ONE);
                  break;
                case Bh:
                  n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                  break;
                case zh:
                  n.blendFunc(n.ZERO, n.SRC_COLOR);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", I);
                  break;
              }
              y = null, x = null, A = null, E = null, w.set(0, 0, 0), R = 0, g = I, S = lt;
            }
            return;
          }
          me = me || pe, le = le || W, Je = Je || Z, (pe !== m || me !== v) && (n.blendEquationSeparate($[pe], $[me]), m = pe, v = me), (W !== y || Z !== x || le !== A || Je !== E) && (n.blendFuncSeparate(se[W], se[Z], se[le], se[Je]), y = W, x = Z, A = le, E = Je), (Ct.equals(w) === false || si !== R) && (n.blendColor(Ct.r, Ct.g, Ct.b, si), w.copy(Ct), R = si), g = I, S = false;
        }
        function fe(I, pe) {
          I.side === fi ? Pe(n.CULL_FACE) : ae(n.CULL_FACE);
          let W = I.side === Lt;
          pe && (W = !W), xe(W), I.blending === Fn && I.transparent === false ? P(jt) : P(I.blending, I.blendEquation, I.blendSrc, I.blendDst, I.blendEquationAlpha, I.blendSrcAlpha, I.blendDstAlpha, I.blendColor, I.blendAlpha, I.premultipliedAlpha), a.setFunc(I.depthFunc), a.setTest(I.depthTest), a.setMask(I.depthWrite), s.setMask(I.colorWrite);
          const Z = I.stencilWrite;
          o.setTest(Z), Z && (o.setMask(I.stencilWriteMask), o.setFunc(I.stencilFunc, I.stencilRef, I.stencilFuncMask), o.setOp(I.stencilFail, I.stencilZFail, I.stencilZPass)), ke(I.polygonOffset, I.polygonOffsetFactor, I.polygonOffsetUnits), I.alphaToCoverage === true ? ae(n.SAMPLE_ALPHA_TO_COVERAGE) : Pe(n.SAMPLE_ALPHA_TO_COVERAGE);
        }
        function xe(I) {
          T !== I && (I ? n.frontFace(n.CW) : n.frontFace(n.CCW), T = I);
        }
        function Me(I) {
          I !== At ? (ae(n.CULL_FACE), I !== L && (I === Xt ? n.cullFace(n.BACK) : I === rt ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : Pe(n.CULL_FACE), L = I;
        }
        function oe(I) {
          I !== B && (k && n.lineWidth(I), B = I);
        }
        function ke(I, pe, W) {
          I ? (ae(n.POLYGON_OFFSET_FILL), (F !== pe || H !== W) && (n.polygonOffset(pe, W), F = pe, H = W)) : Pe(n.POLYGON_OFFSET_FILL);
        }
        function de(I) {
          I ? ae(n.SCISSOR_TEST) : Pe(n.SCISSOR_TEST);
        }
        function C(I) {
          I === void 0 && (I = n.TEXTURE0 + X - 1), ie !== I && (n.activeTexture(I), ie = I);
        }
        function M(I, pe, W) {
          W === void 0 && (ie === null ? W = n.TEXTURE0 + X - 1 : W = ie);
          let Z = ue[W];
          Z === void 0 && (Z = {
            type: void 0,
            texture: void 0
          }, ue[W] = Z), (Z.type !== I || Z.texture !== pe) && (ie !== W && (n.activeTexture(W), ie = W), n.bindTexture(I, pe || _e[I]), Z.type = I, Z.texture = pe);
        }
        function O() {
          const I = ue[ie];
          I !== void 0 && I.type !== void 0 && (n.bindTexture(I.type, null), I.type = void 0, I.texture = void 0);
        }
        function Y() {
          try {
            n.compressedTexImage2D.apply(n, arguments);
          } catch (I) {
            console.error("THREE.WebGLState:", I);
          }
        }
        function J() {
          try {
            n.compressedTexImage3D.apply(n, arguments);
          } catch (I) {
            console.error("THREE.WebGLState:", I);
          }
        }
        function q() {
          try {
            n.texSubImage2D.apply(n, arguments);
          } catch (I) {
            console.error("THREE.WebGLState:", I);
          }
        }
        function Ee() {
          try {
            n.texSubImage3D.apply(n, arguments);
          } catch (I) {
            console.error("THREE.WebGLState:", I);
          }
        }
        function he() {
          try {
            n.compressedTexSubImage2D.apply(n, arguments);
          } catch (I) {
            console.error("THREE.WebGLState:", I);
          }
        }
        function ye() {
          try {
            n.compressedTexSubImage3D.apply(n, arguments);
          } catch (I) {
            console.error("THREE.WebGLState:", I);
          }
        }
        function je() {
          try {
            n.texStorage2D.apply(n, arguments);
          } catch (I) {
            console.error("THREE.WebGLState:", I);
          }
        }
        function re() {
          try {
            n.texStorage3D.apply(n, arguments);
          } catch (I) {
            console.error("THREE.WebGLState:", I);
          }
        }
        function Te() {
          try {
            n.texImage2D.apply(n, arguments);
          } catch (I) {
            console.error("THREE.WebGLState:", I);
          }
        }
        function Le() {
          try {
            n.texImage3D.apply(n, arguments);
          } catch (I) {
            console.error("THREE.WebGLState:", I);
          }
        }
        function Ie(I) {
          We.equals(I) === false && (n.scissor(I.x, I.y, I.z, I.w), We.copy(I));
        }
        function be(I) {
          j.equals(I) === false && (n.viewport(I.x, I.y, I.z, I.w), j.copy(I));
        }
        function Ze(I, pe) {
          let W = c.get(pe);
          W === void 0 && (W = /* @__PURE__ */ new WeakMap(), c.set(pe, W));
          let Z = W.get(I);
          Z === void 0 && (Z = n.getUniformBlockIndex(pe, I.name), W.set(I, Z));
        }
        function He(I, pe) {
          const W = c.get(pe).get(I);
          l.get(pe) !== W && (n.uniformBlockBinding(pe, W, I.__bindingPointIndex), l.set(pe, W));
        }
        function _t() {
          n.disable(n.BLEND), n.disable(n.CULL_FACE), n.disable(n.DEPTH_TEST), n.disable(n.POLYGON_OFFSET_FILL), n.disable(n.SCISSOR_TEST), n.disable(n.STENCIL_TEST), n.disable(n.SAMPLE_ALPHA_TO_COVERAGE), n.blendEquation(n.FUNC_ADD), n.blendFunc(n.ONE, n.ZERO), n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO), n.blendColor(0, 0, 0, 0), n.colorMask(true, true, true, true), n.clearColor(0, 0, 0, 0), n.depthMask(true), n.depthFunc(n.LESS), a.setReversed(false), n.clearDepth(1), n.stencilMask(4294967295), n.stencilFunc(n.ALWAYS, 0, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.KEEP), n.clearStencil(0), n.cullFace(n.BACK), n.frontFace(n.CCW), n.polygonOffset(0, 0), n.activeTexture(n.TEXTURE0), n.bindFramebuffer(n.FRAMEBUFFER, null), n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), n.bindFramebuffer(n.READ_FRAMEBUFFER, null), n.useProgram(null), n.lineWidth(1), n.scissor(0, 0, n.canvas.width, n.canvas.height), n.viewport(0, 0, n.canvas.width, n.canvas.height), u = {}, ie = null, ue = {}, h = {}, d = /* @__PURE__ */ new WeakMap(), p = [], f = null, _ = false, g = null, m = null, y = null, x = null, v = null, A = null, E = null, w = new Ae(0, 0, 0), R = 0, S = false, T = null, L = null, B = null, F = null, H = null, We.set(0, 0, n.canvas.width, n.canvas.height), j.set(0, 0, n.canvas.width, n.canvas.height), s.reset(), a.reset(), o.reset();
        }
        return {
          buffers: {
            color: s,
            depth: a,
            stencil: o
          },
          enable: ae,
          disable: Pe,
          bindFramebuffer: Re,
          drawBuffers: De,
          useProgram: te,
          setBlending: P,
          setMaterial: fe,
          setFlipSided: xe,
          setCullFace: Me,
          setLineWidth: oe,
          setPolygonOffset: ke,
          setScissorTest: de,
          activeTexture: C,
          bindTexture: M,
          unbindTexture: O,
          compressedTexImage2D: Y,
          compressedTexImage3D: J,
          texImage2D: Te,
          texImage3D: Le,
          updateUBOMapping: Ze,
          uniformBlockBinding: He,
          texStorage2D: je,
          texStorage3D: re,
          texSubImage2D: q,
          texSubImage3D: Ee,
          compressedTexSubImage2D: he,
          compressedTexSubImage3D: ye,
          scissor: Ie,
          viewport: be,
          reset: _t
        };
      }
      function AT(n, e, t, i, r, s, a) {
        const o = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, l = typeof navigator > "u" ? false : /OculusBrowser/g.test(navigator.userAgent), c = new ee(), u = /* @__PURE__ */ new WeakMap();
        let h;
        const d = /* @__PURE__ */ new WeakMap();
        let p = false;
        try {
          p = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
        } catch {
        }
        function f(C, M) {
          return p ? new OffscreenCanvas(C, M) : ma("canvas");
        }
        function _(C, M, O) {
          let Y = 1;
          const J = de(C);
          if ((J.width > O || J.height > O) && (Y = O / Math.max(J.width, J.height)), Y < 1) if (typeof HTMLImageElement < "u" && C instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && C instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && C instanceof ImageBitmap || typeof VideoFrame < "u" && C instanceof VideoFrame) {
            const q = Math.floor(Y * J.width), Ee = Math.floor(Y * J.height);
            h === void 0 && (h = f(q, Ee));
            const he = M ? f(q, Ee) : h;
            return he.width = q, he.height = Ee, he.getContext("2d").drawImage(C, 0, 0, q, Ee), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + J.width + "x" + J.height + ") to (" + q + "x" + Ee + ")."), he;
          } else return "data" in C && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + J.width + "x" + J.height + ")."), C;
          return C;
        }
        function g(C) {
          return C.generateMipmaps;
        }
        function m(C) {
          n.generateMipmap(C);
        }
        function y(C) {
          return C.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : C.isWebGL3DRenderTarget ? n.TEXTURE_3D : C.isWebGLArrayRenderTarget || C.isCompressedArrayTexture ? n.TEXTURE_2D_ARRAY : n.TEXTURE_2D;
        }
        function x(C, M, O, Y, J = false) {
          if (C !== null) {
            if (n[C] !== void 0) return n[C];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + C + "'");
          }
          let q = M;
          if (M === n.RED && (O === n.FLOAT && (q = n.R32F), O === n.HALF_FLOAT && (q = n.R16F), O === n.UNSIGNED_BYTE && (q = n.R8)), M === n.RED_INTEGER && (O === n.UNSIGNED_BYTE && (q = n.R8UI), O === n.UNSIGNED_SHORT && (q = n.R16UI), O === n.UNSIGNED_INT && (q = n.R32UI), O === n.BYTE && (q = n.R8I), O === n.SHORT && (q = n.R16I), O === n.INT && (q = n.R32I)), M === n.RG && (O === n.FLOAT && (q = n.RG32F), O === n.HALF_FLOAT && (q = n.RG16F), O === n.UNSIGNED_BYTE && (q = n.RG8)), M === n.RG_INTEGER && (O === n.UNSIGNED_BYTE && (q = n.RG8UI), O === n.UNSIGNED_SHORT && (q = n.RG16UI), O === n.UNSIGNED_INT && (q = n.RG32UI), O === n.BYTE && (q = n.RG8I), O === n.SHORT && (q = n.RG16I), O === n.INT && (q = n.RG32I)), M === n.RGB_INTEGER && (O === n.UNSIGNED_BYTE && (q = n.RGB8UI), O === n.UNSIGNED_SHORT && (q = n.RGB16UI), O === n.UNSIGNED_INT && (q = n.RGB32UI), O === n.BYTE && (q = n.RGB8I), O === n.SHORT && (q = n.RGB16I), O === n.INT && (q = n.RGB32I)), M === n.RGBA_INTEGER && (O === n.UNSIGNED_BYTE && (q = n.RGBA8UI), O === n.UNSIGNED_SHORT && (q = n.RGBA16UI), O === n.UNSIGNED_INT && (q = n.RGBA32UI), O === n.BYTE && (q = n.RGBA8I), O === n.SHORT && (q = n.RGBA16I), O === n.INT && (q = n.RGBA32I)), M === n.RGB && O === n.UNSIGNED_INT_5_9_9_9_REV && (q = n.RGB9_E5), M === n.RGBA) {
            const Ee = J ? go : Ke.getTransfer(Y);
            O === n.FLOAT && (q = n.RGBA32F), O === n.HALF_FLOAT && (q = n.RGBA16F), O === n.UNSIGNED_BYTE && (q = Ee === ct ? n.SRGB8_ALPHA8 : n.RGBA8), O === n.UNSIGNED_SHORT_4_4_4_4 && (q = n.RGBA4), O === n.UNSIGNED_SHORT_5_5_5_1 && (q = n.RGB5_A1);
          }
          return (q === n.R16F || q === n.R32F || q === n.RG16F || q === n.RG32F || q === n.RGBA16F || q === n.RGBA32F) && e.get("EXT_color_buffer_float"), q;
        }
        function v(C, M) {
          let O;
          return C ? M === null || M === cr || M === $r ? O = n.DEPTH24_STENCIL8 : M === Vi ? O = n.DEPTH32F_STENCIL8 : M === ua && (O = n.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : M === null || M === cr || M === $r ? O = n.DEPTH_COMPONENT24 : M === Vi ? O = n.DEPTH_COMPONENT32F : M === ua && (O = n.DEPTH_COMPONENT16), O;
        }
        function A(C, M) {
          return g(C) === true || C.isFramebufferTexture && C.minFilter !== ai && C.minFilter !== Mi ? Math.log2(Math.max(M.width, M.height)) + 1 : C.mipmaps !== void 0 && C.mipmaps.length > 0 ? C.mipmaps.length : C.isCompressedTexture && Array.isArray(C.image) ? M.mipmaps.length : 1;
        }
        function E(C) {
          const M = C.target;
          M.removeEventListener("dispose", E), R(M), M.isVideoTexture && u.delete(M);
        }
        function w(C) {
          const M = C.target;
          M.removeEventListener("dispose", w), T(M);
        }
        function R(C) {
          const M = i.get(C);
          if (M.__webglInit === void 0) return;
          const O = C.source, Y = d.get(O);
          if (Y) {
            const J = Y[M.__cacheKey];
            J.usedTimes--, J.usedTimes === 0 && S(C), Object.keys(Y).length === 0 && d.delete(O);
          }
          i.remove(C);
        }
        function S(C) {
          const M = i.get(C);
          n.deleteTexture(M.__webglTexture);
          const O = C.source, Y = d.get(O);
          delete Y[M.__cacheKey], a.memory.textures--;
        }
        function T(C) {
          const M = i.get(C);
          if (C.depthTexture && (C.depthTexture.dispose(), i.remove(C.depthTexture)), C.isWebGLCubeRenderTarget) for (let Y = 0; Y < 6; Y++) {
            if (Array.isArray(M.__webglFramebuffer[Y])) for (let J = 0; J < M.__webglFramebuffer[Y].length; J++) n.deleteFramebuffer(M.__webglFramebuffer[Y][J]);
            else n.deleteFramebuffer(M.__webglFramebuffer[Y]);
            M.__webglDepthbuffer && n.deleteRenderbuffer(M.__webglDepthbuffer[Y]);
          }
          else {
            if (Array.isArray(M.__webglFramebuffer)) for (let Y = 0; Y < M.__webglFramebuffer.length; Y++) n.deleteFramebuffer(M.__webglFramebuffer[Y]);
            else n.deleteFramebuffer(M.__webglFramebuffer);
            if (M.__webglDepthbuffer && n.deleteRenderbuffer(M.__webglDepthbuffer), M.__webglMultisampledFramebuffer && n.deleteFramebuffer(M.__webglMultisampledFramebuffer), M.__webglColorRenderbuffer) for (let Y = 0; Y < M.__webglColorRenderbuffer.length; Y++) M.__webglColorRenderbuffer[Y] && n.deleteRenderbuffer(M.__webglColorRenderbuffer[Y]);
            M.__webglDepthRenderbuffer && n.deleteRenderbuffer(M.__webglDepthRenderbuffer);
          }
          const O = C.textures;
          for (let Y = 0, J = O.length; Y < J; Y++) {
            const q = i.get(O[Y]);
            q.__webglTexture && (n.deleteTexture(q.__webglTexture), a.memory.textures--), i.remove(O[Y]);
          }
          i.remove(C);
        }
        let L = 0;
        function B() {
          L = 0;
        }
        function F() {
          const C = L;
          return C >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + C + " texture units while this GPU supports only " + r.maxTextures), L += 1, C;
        }
        function H(C) {
          const M = [];
          return M.push(C.wrapS), M.push(C.wrapT), M.push(C.wrapR || 0), M.push(C.magFilter), M.push(C.minFilter), M.push(C.anisotropy), M.push(C.internalFormat), M.push(C.format), M.push(C.type), M.push(C.generateMipmaps), M.push(C.premultiplyAlpha), M.push(C.flipY), M.push(C.unpackAlignment), M.push(C.colorSpace), M.join();
        }
        function X(C, M) {
          const O = i.get(C);
          if (C.isVideoTexture && oe(C), C.isRenderTargetTexture === false && C.version > 0 && O.__version !== C.version) {
            const Y = C.image;
            if (Y === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (Y.complete === false) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
              j(O, C, M);
              return;
            }
          }
          t.bindTexture(n.TEXTURE_2D, O.__webglTexture, n.TEXTURE0 + M);
        }
        function k(C, M) {
          const O = i.get(C);
          if (C.version > 0 && O.__version !== C.version) {
            j(O, C, M);
            return;
          }
          t.bindTexture(n.TEXTURE_2D_ARRAY, O.__webglTexture, n.TEXTURE0 + M);
        }
        function K(C, M) {
          const O = i.get(C);
          if (C.version > 0 && O.__version !== C.version) {
            j(O, C, M);
            return;
          }
          t.bindTexture(n.TEXTURE_3D, O.__webglTexture, n.TEXTURE0 + M);
        }
        function G(C, M) {
          const O = i.get(C);
          if (C.version > 0 && O.__version !== C.version) {
            ne(O, C, M);
            return;
          }
          t.bindTexture(n.TEXTURE_CUBE_MAP, O.__webglTexture, n.TEXTURE0 + M);
        }
        const ie = {
          [Jr]: n.REPEAT,
          [zn]: n.CLAMP_TO_EDGE,
          [lo]: n.MIRRORED_REPEAT
        }, ue = {
          [ai]: n.NEAREST,
          [Gh]: n.NEAREST_MIPMAP_NEAREST,
          [ca]: n.NEAREST_MIPMAP_LINEAR,
          [Mi]: n.LINEAR,
          [co]: n.LINEAR_MIPMAP_NEAREST,
          [pn]: n.LINEAR_MIPMAP_LINEAR
        }, we = {
          [Ug]: n.NEVER,
          [Vg]: n.ALWAYS,
          [Og]: n.LESS,
          [sd]: n.LEQUAL,
          [Fg]: n.EQUAL,
          [kg]: n.GEQUAL,
          [Bg]: n.GREATER,
          [zg]: n.NOTEQUAL
        };
        function Be(C, M) {
          if (M.type === Vi && e.has("OES_texture_float_linear") === false && (M.magFilter === Mi || M.magFilter === co || M.magFilter === ca || M.magFilter === pn || M.minFilter === Mi || M.minFilter === co || M.minFilter === ca || M.minFilter === pn) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), n.texParameteri(C, n.TEXTURE_WRAP_S, ie[M.wrapS]), n.texParameteri(C, n.TEXTURE_WRAP_T, ie[M.wrapT]), (C === n.TEXTURE_3D || C === n.TEXTURE_2D_ARRAY) && n.texParameteri(C, n.TEXTURE_WRAP_R, ie[M.wrapR]), n.texParameteri(C, n.TEXTURE_MAG_FILTER, ue[M.magFilter]), n.texParameteri(C, n.TEXTURE_MIN_FILTER, ue[M.minFilter]), M.compareFunction && (n.texParameteri(C, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(C, n.TEXTURE_COMPARE_FUNC, we[M.compareFunction])), e.has("EXT_texture_filter_anisotropic") === true) {
            if (M.magFilter === ai || M.minFilter !== ca && M.minFilter !== pn || M.type === Vi && e.has("OES_texture_float_linear") === false) return;
            if (M.anisotropy > 1 || i.get(M).__currentAnisotropy) {
              const O = e.get("EXT_texture_filter_anisotropic");
              n.texParameterf(C, O.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(M.anisotropy, r.getMaxAnisotropy())), i.get(M).__currentAnisotropy = M.anisotropy;
            }
          }
        }
        function We(C, M) {
          let O = false;
          C.__webglInit === void 0 && (C.__webglInit = true, M.addEventListener("dispose", E));
          const Y = M.source;
          let J = d.get(Y);
          J === void 0 && (J = {}, d.set(Y, J));
          const q = H(M);
          if (q !== C.__cacheKey) {
            J[q] === void 0 && (J[q] = {
              texture: n.createTexture(),
              usedTimes: 0
            }, a.memory.textures++, O = true), J[q].usedTimes++;
            const Ee = J[C.__cacheKey];
            Ee !== void 0 && (J[C.__cacheKey].usedTimes--, Ee.usedTimes === 0 && S(M)), C.__cacheKey = q, C.__webglTexture = J[q].texture;
          }
          return O;
        }
        function j(C, M, O) {
          let Y = n.TEXTURE_2D;
          (M.isDataArrayTexture || M.isCompressedArrayTexture) && (Y = n.TEXTURE_2D_ARRAY), M.isData3DTexture && (Y = n.TEXTURE_3D);
          const J = We(C, M), q = M.source;
          t.bindTexture(Y, C.__webglTexture, n.TEXTURE0 + O);
          const Ee = i.get(q);
          if (q.version !== Ee.__version || J === true) {
            t.activeTexture(n.TEXTURE0 + O);
            const he = Ke.getPrimaries(Ke.workingColorSpace), ye = M.colorSpace === kn ? null : Ke.getPrimaries(M.colorSpace), je = M.colorSpace === kn || he === ye ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, M.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, M.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, je);
            let re = _(M.image, false, r.maxTextureSize);
            re = ke(M, re);
            const Te = s.convert(M.format, M.colorSpace), Le = s.convert(M.type);
            let Ie = x(M.internalFormat, Te, Le, M.colorSpace, M.isVideoTexture);
            Be(Y, M);
            let be;
            const Ze = M.mipmaps, He = M.isVideoTexture !== true, _t = Ee.__version === void 0 || J === true, I = q.dataReady, pe = A(M, re);
            if (M.isDepthTexture) Ie = v(M.format === es, M.type), _t && (He ? t.texStorage2D(n.TEXTURE_2D, 1, Ie, re.width, re.height) : t.texImage2D(n.TEXTURE_2D, 0, Ie, re.width, re.height, 0, Te, Le, null));
            else if (M.isDataTexture) if (Ze.length > 0) {
              He && _t && t.texStorage2D(n.TEXTURE_2D, pe, Ie, Ze[0].width, Ze[0].height);
              for (let W = 0, Z = Ze.length; W < Z; W++) be = Ze[W], He ? I && t.texSubImage2D(n.TEXTURE_2D, W, 0, 0, be.width, be.height, Te, Le, be.data) : t.texImage2D(n.TEXTURE_2D, W, Ie, be.width, be.height, 0, Te, Le, be.data);
              M.generateMipmaps = false;
            } else He ? (_t && t.texStorage2D(n.TEXTURE_2D, pe, Ie, re.width, re.height), I && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, re.width, re.height, Te, Le, re.data)) : t.texImage2D(n.TEXTURE_2D, 0, Ie, re.width, re.height, 0, Te, Le, re.data);
            else if (M.isCompressedTexture) if (M.isCompressedArrayTexture) {
              He && _t && t.texStorage3D(n.TEXTURE_2D_ARRAY, pe, Ie, Ze[0].width, Ze[0].height, re.depth);
              for (let W = 0, Z = Ze.length; W < Z; W++) if (be = Ze[W], M.format !== Di) if (Te !== null) if (He) {
                if (I) if (M.layerUpdates.size > 0) {
                  const me = Mp(be.width, be.height, M.format, M.type);
                  for (const le of M.layerUpdates) {
                    const Je = be.data.subarray(le * me / be.data.BYTES_PER_ELEMENT, (le + 1) * me / be.data.BYTES_PER_ELEMENT);
                    t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, W, 0, 0, le, be.width, be.height, 1, Te, Je);
                  }
                  M.clearLayerUpdates();
                } else t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, W, 0, 0, 0, be.width, be.height, re.depth, Te, be.data);
              } else t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, W, Ie, be.width, be.height, re.depth, 0, be.data, 0, 0);
              else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              else He ? I && t.texSubImage3D(n.TEXTURE_2D_ARRAY, W, 0, 0, 0, be.width, be.height, re.depth, Te, Le, be.data) : t.texImage3D(n.TEXTURE_2D_ARRAY, W, Ie, be.width, be.height, re.depth, 0, Te, Le, be.data);
            } else {
              He && _t && t.texStorage2D(n.TEXTURE_2D, pe, Ie, Ze[0].width, Ze[0].height);
              for (let W = 0, Z = Ze.length; W < Z; W++) be = Ze[W], M.format !== Di ? Te !== null ? He ? I && t.compressedTexSubImage2D(n.TEXTURE_2D, W, 0, 0, be.width, be.height, Te, be.data) : t.compressedTexImage2D(n.TEXTURE_2D, W, Ie, be.width, be.height, 0, be.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : He ? I && t.texSubImage2D(n.TEXTURE_2D, W, 0, 0, be.width, be.height, Te, Le, be.data) : t.texImage2D(n.TEXTURE_2D, W, Ie, be.width, be.height, 0, Te, Le, be.data);
            }
            else if (M.isDataArrayTexture) if (He) {
              if (_t && t.texStorage3D(n.TEXTURE_2D_ARRAY, pe, Ie, re.width, re.height, re.depth), I) if (M.layerUpdates.size > 0) {
                const W = Mp(re.width, re.height, M.format, M.type);
                for (const Z of M.layerUpdates) {
                  const me = re.data.subarray(Z * W / re.data.BYTES_PER_ELEMENT, (Z + 1) * W / re.data.BYTES_PER_ELEMENT);
                  t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, Z, re.width, re.height, 1, Te, Le, me);
                }
                M.clearLayerUpdates();
              } else t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, re.width, re.height, re.depth, Te, Le, re.data);
            } else t.texImage3D(n.TEXTURE_2D_ARRAY, 0, Ie, re.width, re.height, re.depth, 0, Te, Le, re.data);
            else if (M.isData3DTexture) He ? (_t && t.texStorage3D(n.TEXTURE_3D, pe, Ie, re.width, re.height, re.depth), I && t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, re.width, re.height, re.depth, Te, Le, re.data)) : t.texImage3D(n.TEXTURE_3D, 0, Ie, re.width, re.height, re.depth, 0, Te, Le, re.data);
            else if (M.isFramebufferTexture) {
              if (_t) if (He) t.texStorage2D(n.TEXTURE_2D, pe, Ie, re.width, re.height);
              else {
                let W = re.width, Z = re.height;
                for (let me = 0; me < pe; me++) t.texImage2D(n.TEXTURE_2D, me, Ie, W, Z, 0, Te, Le, null), W >>= 1, Z >>= 1;
              }
            } else if (Ze.length > 0) {
              if (He && _t) {
                const W = de(Ze[0]);
                t.texStorage2D(n.TEXTURE_2D, pe, Ie, W.width, W.height);
              }
              for (let W = 0, Z = Ze.length; W < Z; W++) be = Ze[W], He ? I && t.texSubImage2D(n.TEXTURE_2D, W, 0, 0, Te, Le, be) : t.texImage2D(n.TEXTURE_2D, W, Ie, Te, Le, be);
              M.generateMipmaps = false;
            } else if (He) {
              if (_t) {
                const W = de(re);
                t.texStorage2D(n.TEXTURE_2D, pe, Ie, W.width, W.height);
              }
              I && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, Te, Le, re);
            } else t.texImage2D(n.TEXTURE_2D, 0, Ie, Te, Le, re);
            g(M) && m(Y), Ee.__version = q.version, M.onUpdate && M.onUpdate(M);
          }
          C.__version = M.version;
        }
        function ne(C, M, O) {
          if (M.image.length !== 6) return;
          const Y = We(C, M), J = M.source;
          t.bindTexture(n.TEXTURE_CUBE_MAP, C.__webglTexture, n.TEXTURE0 + O);
          const q = i.get(J);
          if (J.version !== q.__version || Y === true) {
            t.activeTexture(n.TEXTURE0 + O);
            const Ee = Ke.getPrimaries(Ke.workingColorSpace), he = M.colorSpace === kn ? null : Ke.getPrimaries(M.colorSpace), ye = M.colorSpace === kn || Ee === he ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
            n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, M.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, M.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, ye);
            const je = M.isCompressedTexture || M.image[0].isCompressedTexture, re = M.image[0] && M.image[0].isDataTexture, Te = [];
            for (let Z = 0; Z < 6; Z++) !je && !re ? Te[Z] = _(M.image[Z], true, r.maxCubemapSize) : Te[Z] = re ? M.image[Z].image : M.image[Z], Te[Z] = ke(M, Te[Z]);
            const Le = Te[0], Ie = s.convert(M.format, M.colorSpace), be = s.convert(M.type), Ze = x(M.internalFormat, Ie, be, M.colorSpace), He = M.isVideoTexture !== true, _t = q.__version === void 0 || Y === true, I = J.dataReady;
            let pe = A(M, Le);
            Be(n.TEXTURE_CUBE_MAP, M);
            let W;
            if (je) {
              He && _t && t.texStorage2D(n.TEXTURE_CUBE_MAP, pe, Ze, Le.width, Le.height);
              for (let Z = 0; Z < 6; Z++) {
                W = Te[Z].mipmaps;
                for (let me = 0; me < W.length; me++) {
                  const le = W[me];
                  M.format !== Di ? Ie !== null ? He ? I && t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Z, me, 0, 0, le.width, le.height, Ie, le.data) : t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Z, me, Ze, le.width, le.height, 0, le.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : He ? I && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Z, me, 0, 0, le.width, le.height, Ie, be, le.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Z, me, Ze, le.width, le.height, 0, Ie, be, le.data);
                }
              }
            } else {
              if (W = M.mipmaps, He && _t) {
                W.length > 0 && pe++;
                const Z = de(Te[0]);
                t.texStorage2D(n.TEXTURE_CUBE_MAP, pe, Ze, Z.width, Z.height);
              }
              for (let Z = 0; Z < 6; Z++) if (re) {
                He ? I && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Z, 0, 0, 0, Te[Z].width, Te[Z].height, Ie, be, Te[Z].data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Z, 0, Ze, Te[Z].width, Te[Z].height, 0, Ie, be, Te[Z].data);
                for (let me = 0; me < W.length; me++) {
                  const le = W[me].image[Z].image;
                  He ? I && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Z, me + 1, 0, 0, le.width, le.height, Ie, be, le.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Z, me + 1, Ze, le.width, le.height, 0, Ie, be, le.data);
                }
              } else {
                He ? I && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Z, 0, 0, 0, Ie, be, Te[Z]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Z, 0, Ze, Ie, be, Te[Z]);
                for (let me = 0; me < W.length; me++) {
                  const le = W[me];
                  He ? I && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Z, me + 1, 0, 0, Ie, be, le.image[Z]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Z, me + 1, Ze, Ie, be, le.image[Z]);
                }
              }
            }
            g(M) && m(n.TEXTURE_CUBE_MAP), q.__version = J.version, M.onUpdate && M.onUpdate(M);
          }
          C.__version = M.version;
        }
        function _e(C, M, O, Y, J, q) {
          const Ee = s.convert(O.format, O.colorSpace), he = s.convert(O.type), ye = x(O.internalFormat, Ee, he, O.colorSpace), je = i.get(M), re = i.get(O);
          if (re.__renderTarget = M, !je.__hasExternalTextures) {
            const Te = Math.max(1, M.width >> q), Le = Math.max(1, M.height >> q);
            J === n.TEXTURE_3D || J === n.TEXTURE_2D_ARRAY ? t.texImage3D(J, q, ye, Te, Le, M.depth, 0, Ee, he, null) : t.texImage2D(J, q, ye, Te, Le, 0, Ee, he, null);
          }
          t.bindFramebuffer(n.FRAMEBUFFER, C), Me(M) ? o.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, Y, J, re.__webglTexture, 0, xe(M)) : (J === n.TEXTURE_2D || J >= n.TEXTURE_CUBE_MAP_POSITIVE_X && J <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, Y, J, re.__webglTexture, q), t.bindFramebuffer(n.FRAMEBUFFER, null);
        }
        function ae(C, M, O) {
          if (n.bindRenderbuffer(n.RENDERBUFFER, C), M.depthBuffer) {
            const Y = M.depthTexture, J = Y && Y.isDepthTexture ? Y.type : null, q = v(M.stencilBuffer, J), Ee = M.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, he = xe(M);
            Me(M) ? o.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, he, q, M.width, M.height) : O ? n.renderbufferStorageMultisample(n.RENDERBUFFER, he, q, M.width, M.height) : n.renderbufferStorage(n.RENDERBUFFER, q, M.width, M.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, Ee, n.RENDERBUFFER, C);
          } else {
            const Y = M.textures;
            for (let J = 0; J < Y.length; J++) {
              const q = Y[J], Ee = s.convert(q.format, q.colorSpace), he = s.convert(q.type), ye = x(q.internalFormat, Ee, he, q.colorSpace), je = xe(M);
              O && Me(M) === false ? n.renderbufferStorageMultisample(n.RENDERBUFFER, je, ye, M.width, M.height) : Me(M) ? o.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, je, ye, M.width, M.height) : n.renderbufferStorage(n.RENDERBUFFER, ye, M.width, M.height);
            }
          }
          n.bindRenderbuffer(n.RENDERBUFFER, null);
        }
        function Pe(C, M) {
          if (M && M.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
          if (t.bindFramebuffer(n.FRAMEBUFFER, C), !(M.depthTexture && M.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
          const O = i.get(M.depthTexture);
          O.__renderTarget = M, (!O.__webglTexture || M.depthTexture.image.width !== M.width || M.depthTexture.image.height !== M.height) && (M.depthTexture.image.width = M.width, M.depthTexture.image.height = M.height, M.depthTexture.needsUpdate = true), X(M.depthTexture, 0);
          const Y = O.__webglTexture, J = xe(M);
          if (M.depthTexture.format === Qr) Me(M) ? o.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, Y, 0, J) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, Y, 0);
          else if (M.depthTexture.format === es) Me(M) ? o.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, Y, 0, J) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, Y, 0);
          else throw new Error("Unknown depthTexture format");
        }
        function Re(C) {
          const M = i.get(C), O = C.isWebGLCubeRenderTarget === true;
          if (M.__boundDepthTexture !== C.depthTexture) {
            const Y = C.depthTexture;
            if (M.__depthDisposeCallback && M.__depthDisposeCallback(), Y) {
              const J = () => {
                delete M.__boundDepthTexture, delete M.__depthDisposeCallback, Y.removeEventListener("dispose", J);
              };
              Y.addEventListener("dispose", J), M.__depthDisposeCallback = J;
            }
            M.__boundDepthTexture = Y;
          }
          if (C.depthTexture && !M.__autoAllocateDepthBuffer) {
            if (O) throw new Error("target.depthTexture not supported in Cube render targets");
            Pe(M.__webglFramebuffer, C);
          } else if (O) {
            M.__webglDepthbuffer = [];
            for (let Y = 0; Y < 6; Y++) if (t.bindFramebuffer(n.FRAMEBUFFER, M.__webglFramebuffer[Y]), M.__webglDepthbuffer[Y] === void 0) M.__webglDepthbuffer[Y] = n.createRenderbuffer(), ae(M.__webglDepthbuffer[Y], C, false);
            else {
              const J = C.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, q = M.__webglDepthbuffer[Y];
              n.bindRenderbuffer(n.RENDERBUFFER, q), n.framebufferRenderbuffer(n.FRAMEBUFFER, J, n.RENDERBUFFER, q);
            }
          } else if (t.bindFramebuffer(n.FRAMEBUFFER, M.__webglFramebuffer), M.__webglDepthbuffer === void 0) M.__webglDepthbuffer = n.createRenderbuffer(), ae(M.__webglDepthbuffer, C, false);
          else {
            const Y = C.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, J = M.__webglDepthbuffer;
            n.bindRenderbuffer(n.RENDERBUFFER, J), n.framebufferRenderbuffer(n.FRAMEBUFFER, Y, n.RENDERBUFFER, J);
          }
          t.bindFramebuffer(n.FRAMEBUFFER, null);
        }
        function De(C, M, O) {
          const Y = i.get(C);
          M !== void 0 && _e(Y.__webglFramebuffer, C, C.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0), O !== void 0 && Re(C);
        }
        function te(C) {
          const M = C.texture, O = i.get(C), Y = i.get(M);
          C.addEventListener("dispose", w);
          const J = C.textures, q = C.isWebGLCubeRenderTarget === true, Ee = J.length > 1;
          if (Ee || (Y.__webglTexture === void 0 && (Y.__webglTexture = n.createTexture()), Y.__version = M.version, a.memory.textures++), q) {
            O.__webglFramebuffer = [];
            for (let he = 0; he < 6; he++) if (M.mipmaps && M.mipmaps.length > 0) {
              O.__webglFramebuffer[he] = [];
              for (let ye = 0; ye < M.mipmaps.length; ye++) O.__webglFramebuffer[he][ye] = n.createFramebuffer();
            } else O.__webglFramebuffer[he] = n.createFramebuffer();
          } else {
            if (M.mipmaps && M.mipmaps.length > 0) {
              O.__webglFramebuffer = [];
              for (let he = 0; he < M.mipmaps.length; he++) O.__webglFramebuffer[he] = n.createFramebuffer();
            } else O.__webglFramebuffer = n.createFramebuffer();
            if (Ee) for (let he = 0, ye = J.length; he < ye; he++) {
              const je = i.get(J[he]);
              je.__webglTexture === void 0 && (je.__webglTexture = n.createTexture(), a.memory.textures++);
            }
            if (C.samples > 0 && Me(C) === false) {
              O.__webglMultisampledFramebuffer = n.createFramebuffer(), O.__webglColorRenderbuffer = [], t.bindFramebuffer(n.FRAMEBUFFER, O.__webglMultisampledFramebuffer);
              for (let he = 0; he < J.length; he++) {
                const ye = J[he];
                O.__webglColorRenderbuffer[he] = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, O.__webglColorRenderbuffer[he]);
                const je = s.convert(ye.format, ye.colorSpace), re = s.convert(ye.type), Te = x(ye.internalFormat, je, re, ye.colorSpace, C.isXRRenderTarget === true), Le = xe(C);
                n.renderbufferStorageMultisample(n.RENDERBUFFER, Le, Te, C.width, C.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + he, n.RENDERBUFFER, O.__webglColorRenderbuffer[he]);
              }
              n.bindRenderbuffer(n.RENDERBUFFER, null), C.depthBuffer && (O.__webglDepthRenderbuffer = n.createRenderbuffer(), ae(O.__webglDepthRenderbuffer, C, true)), t.bindFramebuffer(n.FRAMEBUFFER, null);
            }
          }
          if (q) {
            t.bindTexture(n.TEXTURE_CUBE_MAP, Y.__webglTexture), Be(n.TEXTURE_CUBE_MAP, M);
            for (let he = 0; he < 6; he++) if (M.mipmaps && M.mipmaps.length > 0) for (let ye = 0; ye < M.mipmaps.length; ye++) _e(O.__webglFramebuffer[he][ye], C, M, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + he, ye);
            else _e(O.__webglFramebuffer[he], C, M, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + he, 0);
            g(M) && m(n.TEXTURE_CUBE_MAP), t.unbindTexture();
          } else if (Ee) {
            for (let he = 0, ye = J.length; he < ye; he++) {
              const je = J[he], re = i.get(je);
              t.bindTexture(n.TEXTURE_2D, re.__webglTexture), Be(n.TEXTURE_2D, je), _e(O.__webglFramebuffer, C, je, n.COLOR_ATTACHMENT0 + he, n.TEXTURE_2D, 0), g(je) && m(n.TEXTURE_2D);
            }
            t.unbindTexture();
          } else {
            let he = n.TEXTURE_2D;
            if ((C.isWebGL3DRenderTarget || C.isWebGLArrayRenderTarget) && (he = C.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY), t.bindTexture(he, Y.__webglTexture), Be(he, M), M.mipmaps && M.mipmaps.length > 0) for (let ye = 0; ye < M.mipmaps.length; ye++) _e(O.__webglFramebuffer[ye], C, M, n.COLOR_ATTACHMENT0, he, ye);
            else _e(O.__webglFramebuffer, C, M, n.COLOR_ATTACHMENT0, he, 0);
            g(M) && m(he), t.unbindTexture();
          }
          C.depthBuffer && Re(C);
        }
        function $(C) {
          const M = C.textures;
          for (let O = 0, Y = M.length; O < Y; O++) {
            const J = M[O];
            if (g(J)) {
              const q = y(C), Ee = i.get(J).__webglTexture;
              t.bindTexture(q, Ee), m(q), t.unbindTexture();
            }
          }
        }
        const se = [], P = [];
        function fe(C) {
          if (C.samples > 0) {
            if (Me(C) === false) {
              const M = C.textures, O = C.width, Y = C.height;
              let J = n.COLOR_BUFFER_BIT;
              const q = C.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT, Ee = i.get(C), he = M.length > 1;
              if (he) for (let ye = 0; ye < M.length; ye++) t.bindFramebuffer(n.FRAMEBUFFER, Ee.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + ye, n.RENDERBUFFER, null), t.bindFramebuffer(n.FRAMEBUFFER, Ee.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + ye, n.TEXTURE_2D, null, 0);
              t.bindFramebuffer(n.READ_FRAMEBUFFER, Ee.__webglMultisampledFramebuffer), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Ee.__webglFramebuffer);
              for (let ye = 0; ye < M.length; ye++) {
                if (C.resolveDepthBuffer && (C.depthBuffer && (J |= n.DEPTH_BUFFER_BIT), C.stencilBuffer && C.resolveStencilBuffer && (J |= n.STENCIL_BUFFER_BIT)), he) {
                  n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, Ee.__webglColorRenderbuffer[ye]);
                  const je = i.get(M[ye]).__webglTexture;
                  n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, je, 0);
                }
                n.blitFramebuffer(0, 0, O, Y, 0, 0, O, Y, J, n.NEAREST), l === true && (se.length = 0, P.length = 0, se.push(n.COLOR_ATTACHMENT0 + ye), C.depthBuffer && C.resolveDepthBuffer === false && (se.push(q), P.push(q), n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, P)), n.invalidateFramebuffer(n.READ_FRAMEBUFFER, se));
              }
              if (t.bindFramebuffer(n.READ_FRAMEBUFFER, null), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), he) for (let ye = 0; ye < M.length; ye++) {
                t.bindFramebuffer(n.FRAMEBUFFER, Ee.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + ye, n.RENDERBUFFER, Ee.__webglColorRenderbuffer[ye]);
                const je = i.get(M[ye]).__webglTexture;
                t.bindFramebuffer(n.FRAMEBUFFER, Ee.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + ye, n.TEXTURE_2D, je, 0);
              }
              t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Ee.__webglMultisampledFramebuffer);
            } else if (C.depthBuffer && C.resolveDepthBuffer === false && l) {
              const M = C.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT;
              n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [
                M
              ]);
            }
          }
        }
        function xe(C) {
          return Math.min(r.maxSamples, C.samples);
        }
        function Me(C) {
          const M = i.get(C);
          return C.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === true && M.__useRenderToTexture !== false;
        }
        function oe(C) {
          const M = a.render.frame;
          u.get(C) !== M && (u.set(C, M), C.update());
        }
        function ke(C, M) {
          const O = C.colorSpace, Y = C.format, J = C.type;
          return C.isCompressedTexture === true || C.isVideoTexture === true || O !== oi && O !== kn && (Ke.getTransfer(O) === ct ? (Y !== Di || J !== fn) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", O)), M;
        }
        function de(C) {
          return typeof HTMLImageElement < "u" && C instanceof HTMLImageElement ? (c.width = C.naturalWidth || C.width, c.height = C.naturalHeight || C.height) : typeof VideoFrame < "u" && C instanceof VideoFrame ? (c.width = C.displayWidth, c.height = C.displayHeight) : (c.width = C.width, c.height = C.height), c;
        }
        this.allocateTextureUnit = F, this.resetTextureUnits = B, this.setTexture2D = X, this.setTexture2DArray = k, this.setTexture3D = K, this.setTextureCube = G, this.rebindTextures = De, this.setupRenderTarget = te, this.updateRenderTargetMipmap = $, this.updateMultisampleRenderTarget = fe, this.setupDepthRenderbuffer = Re, this.setupFrameBufferTexture = _e, this.useMultisampledRTT = Me;
      }
      function RT(n, e) {
        function t(i, r = kn) {
          let s;
          const a = Ke.getTransfer(r);
          if (i === fn) return n.UNSIGNED_BYTE;
          if (i === Bl) return n.UNSIGNED_SHORT_4_4_4_4;
          if (i === zl) return n.UNSIGNED_SHORT_5_5_5_1;
          if (i === jh) return n.UNSIGNED_INT_5_9_9_9_REV;
          if (i === Wh) return n.BYTE;
          if (i === Xh) return n.SHORT;
          if (i === ua) return n.UNSIGNED_SHORT;
          if (i === Fl) return n.INT;
          if (i === cr) return n.UNSIGNED_INT;
          if (i === Vi) return n.FLOAT;
          if (i === mn) return n.HALF_FLOAT;
          if (i === qh) return n.ALPHA;
          if (i === Yh) return n.RGB;
          if (i === Di) return n.RGBA;
          if (i === Kh) return n.LUMINANCE;
          if (i === Zh) return n.LUMINANCE_ALPHA;
          if (i === Qr) return n.DEPTH_COMPONENT;
          if (i === es) return n.DEPTH_STENCIL;
          if (i === kl) return n.RED;
          if (i === Vl) return n.RED_INTEGER;
          if (i === Jh) return n.RG;
          if (i === Hl) return n.RG_INTEGER;
          if (i === Gl) return n.RGBA_INTEGER;
          if (i === uo || i === ho || i === po || i === fo) if (a === ct) if (s = e.get("WEBGL_compressed_texture_s3tc_srgb"), s !== null) {
            if (i === uo) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
            if (i === ho) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
            if (i === po) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
            if (i === fo) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else return null;
          else if (s = e.get("WEBGL_compressed_texture_s3tc"), s !== null) {
            if (i === uo) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (i === ho) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (i === po) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (i === fo) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
          } else return null;
          if (i === Wl || i === Xl || i === jl || i === ql) if (s = e.get("WEBGL_compressed_texture_pvrtc"), s !== null) {
            if (i === Wl) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (i === Xl) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (i === jl) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (i === ql) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          } else return null;
          if (i === Yl || i === Kl || i === Zl) if (s = e.get("WEBGL_compressed_texture_etc"), s !== null) {
            if (i === Yl || i === Kl) return a === ct ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
            if (i === Zl) return a === ct ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC;
          } else return null;
          if (i === Jl || i === $l || i === Ql || i === ec || i === tc || i === ic || i === nc || i === rc || i === sc || i === ac || i === oc || i === lc || i === cc || i === uc) if (s = e.get("WEBGL_compressed_texture_astc"), s !== null) {
            if (i === Jl) return a === ct ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
            if (i === $l) return a === ct ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
            if (i === Ql) return a === ct ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
            if (i === ec) return a === ct ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
            if (i === tc) return a === ct ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
            if (i === ic) return a === ct ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
            if (i === nc) return a === ct ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
            if (i === rc) return a === ct ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
            if (i === sc) return a === ct ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
            if (i === ac) return a === ct ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
            if (i === oc) return a === ct ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
            if (i === lc) return a === ct ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
            if (i === cc) return a === ct ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
            if (i === uc) return a === ct ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
          } else return null;
          if (i === mo || i === hc || i === dc) if (s = e.get("EXT_texture_compression_bptc"), s !== null) {
            if (i === mo) return a === ct ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            if (i === hc) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
            if (i === dc) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
          } else return null;
          if (i === $h || i === pc || i === fc || i === mc) if (s = e.get("EXT_texture_compression_rgtc"), s !== null) {
            if (i === mo) return s.COMPRESSED_RED_RGTC1_EXT;
            if (i === pc) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
            if (i === fc) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
            if (i === mc) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
          } else return null;
          return i === $r ? n.UNSIGNED_INT_24_8 : n[i] !== void 0 ? n[i] : null;
        }
        return {
          convert: t
        };
      }
      const CT = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, PT = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
      class LT {
        constructor() {
          this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
        }
        init(e, t, i) {
          if (this.texture === null) {
            const r = new kt(), s = e.properties.get(r);
            s.__webglTexture = t.texture, (t.depthNear !== i.depthNear || t.depthFar !== i.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = r;
          }
        }
        getMesh(e) {
          if (this.texture !== null && this.mesh === null) {
            const t = e.cameras[0].viewport, i = new ti({
              vertexShader: CT,
              fragmentShader: PT,
              uniforms: {
                depthColor: {
                  value: this.texture
                },
                depthWidth: {
                  value: t.z
                },
                depthHeight: {
                  value: t.w
                }
              }
            });
            this.mesh = new Dt(new Ca(20, 20), i);
          }
          return this.mesh;
        }
        reset() {
          this.texture = null, this.mesh = null;
        }
        getDepthTexture() {
          return this.texture;
        }
      }
      class DT extends is {
        constructor(e, t) {
          super();
          const i = this;
          let r = null, s = 1, a = null, o = "local-floor", l = 1, c = null, u = null, h = null, d = null, p = null, f = null;
          const _ = new LT(), g = t.getContextAttributes();
          let m = null, y = null;
          const x = [], v = [], A = new ee();
          let E = null;
          const w = new ui();
          w.viewport = new it();
          const R = new ui();
          R.viewport = new it();
          const S = [
            w,
            R
          ], T = new Gv();
          let L = null, B = null;
          this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(j) {
            let ne = x[j];
            return ne === void 0 && (ne = new kc(), x[j] = ne), ne.getTargetRaySpace();
          }, this.getControllerGrip = function(j) {
            let ne = x[j];
            return ne === void 0 && (ne = new kc(), x[j] = ne), ne.getGripSpace();
          }, this.getHand = function(j) {
            let ne = x[j];
            return ne === void 0 && (ne = new kc(), x[j] = ne), ne.getHandSpace();
          };
          function F(j) {
            const ne = v.indexOf(j.inputSource);
            if (ne === -1) return;
            const _e = x[ne];
            _e !== void 0 && (_e.update(j.inputSource, j.frame, c || a), _e.dispatchEvent({
              type: j.type,
              data: j.inputSource
            }));
          }
          function H() {
            r.removeEventListener("select", F), r.removeEventListener("selectstart", F), r.removeEventListener("selectend", F), r.removeEventListener("squeeze", F), r.removeEventListener("squeezestart", F), r.removeEventListener("squeezeend", F), r.removeEventListener("end", H), r.removeEventListener("inputsourceschange", X);
            for (let j = 0; j < x.length; j++) {
              const ne = v[j];
              ne !== null && (v[j] = null, x[j].disconnect(ne));
            }
            L = null, B = null, _.reset(), e.setRenderTarget(m), p = null, d = null, h = null, r = null, y = null, We.stop(), i.isPresenting = false, e.setPixelRatio(E), e.setSize(A.width, A.height, false), i.dispatchEvent({
              type: "sessionend"
            });
          }
          this.setFramebufferScaleFactor = function(j) {
            s = j, i.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
          }, this.setReferenceSpaceType = function(j) {
            o = j, i.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
          }, this.getReferenceSpace = function() {
            return c || a;
          }, this.setReferenceSpace = function(j) {
            c = j;
          }, this.getBaseLayer = function() {
            return d !== null ? d : p;
          }, this.getBinding = function() {
            return h;
          }, this.getFrame = function() {
            return f;
          }, this.getSession = function() {
            return r;
          }, this.setSession = async function(j) {
            if (r = j, r !== null) {
              if (m = e.getRenderTarget(), r.addEventListener("select", F), r.addEventListener("selectstart", F), r.addEventListener("selectend", F), r.addEventListener("squeeze", F), r.addEventListener("squeezestart", F), r.addEventListener("squeezeend", F), r.addEventListener("end", H), r.addEventListener("inputsourceschange", X), g.xrCompatible !== true && await t.makeXRCompatible(), E = e.getPixelRatio(), e.getSize(A), typeof XRWebGLBinding < "u" && "createProjectionLayer" in XRWebGLBinding.prototype) {
                let ne = null, _e = null, ae = null;
                g.depth && (ae = g.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, ne = g.stencil ? es : Qr, _e = g.stencil ? $r : cr);
                const Pe = {
                  colorFormat: t.RGBA8,
                  depthFormat: ae,
                  scaleFactor: s
                };
                h = new XRWebGLBinding(r, t), d = h.createProjectionLayer(Pe), r.updateRenderState({
                  layers: [
                    d
                  ]
                }), e.setPixelRatio(1), e.setSize(d.textureWidth, d.textureHeight, false), y = new Gi(d.textureWidth, d.textureHeight, {
                  format: Di,
                  type: fn,
                  depthTexture: new $d(d.textureWidth, d.textureHeight, _e, void 0, void 0, void 0, void 0, void 0, void 0, ne),
                  stencilBuffer: g.stencil,
                  colorSpace: e.outputColorSpace,
                  samples: g.antialias ? 4 : 0,
                  resolveDepthBuffer: d.ignoreDepthValues === false
                });
              } else {
                const ne = {
                  antialias: g.antialias,
                  alpha: true,
                  depth: g.depth,
                  stencil: g.stencil,
                  framebufferScaleFactor: s
                };
                p = new XRWebGLLayer(r, t, ne), r.updateRenderState({
                  baseLayer: p
                }), e.setPixelRatio(1), e.setSize(p.framebufferWidth, p.framebufferHeight, false), y = new Gi(p.framebufferWidth, p.framebufferHeight, {
                  format: Di,
                  type: fn,
                  colorSpace: e.outputColorSpace,
                  stencilBuffer: g.stencil
                });
              }
              y.isXRRenderTarget = true, this.setFoveation(l), c = null, a = await r.requestReferenceSpace(o), We.setContext(r), We.start(), i.isPresenting = true, i.dispatchEvent({
                type: "sessionstart"
              });
            }
          }, this.getEnvironmentBlendMode = function() {
            if (r !== null) return r.environmentBlendMode;
          }, this.getDepthTexture = function() {
            return _.getDepthTexture();
          };
          function X(j) {
            for (let ne = 0; ne < j.removed.length; ne++) {
              const _e = j.removed[ne], ae = v.indexOf(_e);
              ae >= 0 && (v[ae] = null, x[ae].disconnect(_e));
            }
            for (let ne = 0; ne < j.added.length; ne++) {
              const _e = j.added[ne];
              let ae = v.indexOf(_e);
              if (ae === -1) {
                for (let Re = 0; Re < x.length; Re++) if (Re >= v.length) {
                  v.push(_e), ae = Re;
                  break;
                } else if (v[Re] === null) {
                  v[Re] = _e, ae = Re;
                  break;
                }
                if (ae === -1) break;
              }
              const Pe = x[ae];
              Pe && Pe.connect(_e);
            }
          }
          const k = new D(), K = new D();
          function G(j, ne, _e) {
            k.setFromMatrixPosition(ne.matrixWorld), K.setFromMatrixPosition(_e.matrixWorld);
            const ae = k.distanceTo(K), Pe = ne.projectionMatrix.elements, Re = _e.projectionMatrix.elements, De = Pe[14] / (Pe[10] - 1), te = Pe[14] / (Pe[10] + 1), $ = (Pe[9] + 1) / Pe[5], se = (Pe[9] - 1) / Pe[5], P = (Pe[8] - 1) / Pe[0], fe = (Re[8] + 1) / Re[0], xe = De * P, Me = De * fe, oe = ae / (-P + fe), ke = oe * -P;
            if (ne.matrixWorld.decompose(j.position, j.quaternion, j.scale), j.translateX(ke), j.translateZ(oe), j.matrixWorld.compose(j.position, j.quaternion, j.scale), j.matrixWorldInverse.copy(j.matrixWorld).invert(), Pe[10] === -1) j.projectionMatrix.copy(ne.projectionMatrix), j.projectionMatrixInverse.copy(ne.projectionMatrixInverse);
            else {
              const de = De + oe, C = te + oe, M = xe - ke, O = Me + (ae - ke), Y = $ * te / C * de, J = se * te / C * de;
              j.projectionMatrix.makePerspective(M, O, Y, J, de, C), j.projectionMatrixInverse.copy(j.projectionMatrix).invert();
            }
          }
          function ie(j, ne) {
            ne === null ? j.matrixWorld.copy(j.matrix) : j.matrixWorld.multiplyMatrices(ne.matrixWorld, j.matrix), j.matrixWorldInverse.copy(j.matrixWorld).invert();
          }
          this.updateCamera = function(j) {
            if (r === null) return;
            let ne = j.near, _e = j.far;
            _.texture !== null && (_.depthNear > 0 && (ne = _.depthNear), _.depthFar > 0 && (_e = _.depthFar)), T.near = R.near = w.near = ne, T.far = R.far = w.far = _e, (L !== T.near || B !== T.far) && (r.updateRenderState({
              depthNear: T.near,
              depthFar: T.far
            }), L = T.near, B = T.far), w.layers.mask = j.layers.mask | 2, R.layers.mask = j.layers.mask | 4, T.layers.mask = w.layers.mask | R.layers.mask;
            const ae = j.parent, Pe = T.cameras;
            ie(T, ae);
            for (let Re = 0; Re < Pe.length; Re++) ie(Pe[Re], ae);
            Pe.length === 2 ? G(T, w, R) : T.projectionMatrix.copy(w.projectionMatrix), ue(j, T, ae);
          };
          function ue(j, ne, _e) {
            _e === null ? j.matrix.copy(ne.matrixWorld) : (j.matrix.copy(_e.matrixWorld), j.matrix.invert(), j.matrix.multiply(ne.matrixWorld)), j.matrix.decompose(j.position, j.quaternion, j.scale), j.updateMatrixWorld(true), j.projectionMatrix.copy(ne.projectionMatrix), j.projectionMatrixInverse.copy(ne.projectionMatrixInverse), j.isPerspectiveCamera && (j.fov = ns * 2 * Math.atan(1 / j.projectionMatrix.elements[5]), j.zoom = 1);
          }
          this.getCamera = function() {
            return T;
          }, this.getFoveation = function() {
            if (!(d === null && p === null)) return l;
          }, this.setFoveation = function(j) {
            l = j, d !== null && (d.fixedFoveation = j), p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = j);
          }, this.hasDepthSensing = function() {
            return _.texture !== null;
          }, this.getDepthSensingMesh = function() {
            return _.getMesh(T);
          };
          let we = null;
          function Be(j, ne) {
            if (u = ne.getViewerPose(c || a), f = ne, u !== null) {
              const _e = u.views;
              p !== null && (e.setRenderTargetFramebuffer(y, p.framebuffer), e.setRenderTarget(y));
              let ae = false;
              _e.length !== T.cameras.length && (T.cameras.length = 0, ae = true);
              for (let Re = 0; Re < _e.length; Re++) {
                const De = _e[Re];
                let te = null;
                if (p !== null) te = p.getViewport(De);
                else {
                  const se = h.getViewSubImage(d, De);
                  te = se.viewport, Re === 0 && (e.setRenderTargetTextures(y, se.colorTexture, d.ignoreDepthValues ? void 0 : se.depthStencilTexture), e.setRenderTarget(y));
                }
                let $ = S[Re];
                $ === void 0 && ($ = new ui(), $.layers.enable(Re), $.viewport = new it(), S[Re] = $), $.matrix.fromArray(De.transform.matrix), $.matrix.decompose($.position, $.quaternion, $.scale), $.projectionMatrix.fromArray(De.projectionMatrix), $.projectionMatrixInverse.copy($.projectionMatrix).invert(), $.viewport.set(te.x, te.y, te.width, te.height), Re === 0 && (T.matrix.copy($.matrix), T.matrix.decompose(T.position, T.quaternion, T.scale)), ae === true && T.cameras.push($);
              }
              const Pe = r.enabledFeatures;
              if (Pe && Pe.includes("depth-sensing") && r.depthUsage == "gpu-optimized" && h) {
                const Re = h.getDepthInformation(_e[0]);
                Re && Re.isValid && Re.texture && _.init(e, Re, r.renderState);
              }
            }
            for (let _e = 0; _e < x.length; _e++) {
              const ae = v[_e], Pe = x[_e];
              ae !== null && Pe !== void 0 && Pe.update(ae, ne, c || a);
            }
            we && we(j, ne), ne.detectedPlanes && i.dispatchEvent({
              type: "planesdetected",
              data: ne
            }), f = null;
          }
          const We = new Tp();
          We.setAnimationLoop(Be), this.setAnimationLoop = function(j) {
            we = j;
          }, this.dispose = function() {
          };
        }
      }
      const Tr = new Qi(), IT = new Fe();
      function NT(n, e) {
        function t(g, m) {
          g.matrixAutoUpdate === true && g.updateMatrix(), m.value.copy(g.matrix);
        }
        function i(g, m) {
          m.color.getRGB(g.fogColor.value, Cd(n)), m.isFog ? (g.fogNear.value = m.near, g.fogFar.value = m.far) : m.isFogExp2 && (g.fogDensity.value = m.density);
        }
        function r(g, m, y, x, v) {
          m.isMeshBasicMaterial || m.isMeshLambertMaterial ? s(g, m) : m.isMeshToonMaterial ? (s(g, m), h(g, m)) : m.isMeshPhongMaterial ? (s(g, m), u(g, m)) : m.isMeshStandardMaterial ? (s(g, m), d(g, m), m.isMeshPhysicalMaterial && p(g, m, v)) : m.isMeshMatcapMaterial ? (s(g, m), f(g, m)) : m.isMeshDepthMaterial ? s(g, m) : m.isMeshDistanceMaterial ? (s(g, m), _(g, m)) : m.isMeshNormalMaterial ? s(g, m) : m.isLineBasicMaterial ? (a(g, m), m.isLineDashedMaterial && o(g, m)) : m.isPointsMaterial ? l(g, m, y, x) : m.isSpriteMaterial ? c(g, m) : m.isShadowMaterial ? (g.color.value.copy(m.color), g.opacity.value = m.opacity) : m.isShaderMaterial && (m.uniformsNeedUpdate = false);
        }
        function s(g, m) {
          g.opacity.value = m.opacity, m.color && g.diffuse.value.copy(m.color), m.emissive && g.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity), m.map && (g.map.value = m.map, t(m.map, g.mapTransform)), m.alphaMap && (g.alphaMap.value = m.alphaMap, t(m.alphaMap, g.alphaMapTransform)), m.bumpMap && (g.bumpMap.value = m.bumpMap, t(m.bumpMap, g.bumpMapTransform), g.bumpScale.value = m.bumpScale, m.side === Lt && (g.bumpScale.value *= -1)), m.normalMap && (g.normalMap.value = m.normalMap, t(m.normalMap, g.normalMapTransform), g.normalScale.value.copy(m.normalScale), m.side === Lt && g.normalScale.value.negate()), m.displacementMap && (g.displacementMap.value = m.displacementMap, t(m.displacementMap, g.displacementMapTransform), g.displacementScale.value = m.displacementScale, g.displacementBias.value = m.displacementBias), m.emissiveMap && (g.emissiveMap.value = m.emissiveMap, t(m.emissiveMap, g.emissiveMapTransform)), m.specularMap && (g.specularMap.value = m.specularMap, t(m.specularMap, g.specularMapTransform)), m.alphaTest > 0 && (g.alphaTest.value = m.alphaTest);
          const y = e.get(m), x = y.envMap, v = y.envMapRotation;
          x && (g.envMap.value = x, Tr.copy(v), Tr.x *= -1, Tr.y *= -1, Tr.z *= -1, x.isCubeTexture && x.isRenderTargetTexture === false && (Tr.y *= -1, Tr.z *= -1), g.envMapRotation.value.setFromMatrix4(IT.makeRotationFromEuler(Tr)), g.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === false ? -1 : 1, g.reflectivity.value = m.reflectivity, g.ior.value = m.ior, g.refractionRatio.value = m.refractionRatio), m.lightMap && (g.lightMap.value = m.lightMap, g.lightMapIntensity.value = m.lightMapIntensity, t(m.lightMap, g.lightMapTransform)), m.aoMap && (g.aoMap.value = m.aoMap, g.aoMapIntensity.value = m.aoMapIntensity, t(m.aoMap, g.aoMapTransform));
        }
        function a(g, m) {
          g.diffuse.value.copy(m.color), g.opacity.value = m.opacity, m.map && (g.map.value = m.map, t(m.map, g.mapTransform));
        }
        function o(g, m) {
          g.dashSize.value = m.dashSize, g.totalSize.value = m.dashSize + m.gapSize, g.scale.value = m.scale;
        }
        function l(g, m, y, x) {
          g.diffuse.value.copy(m.color), g.opacity.value = m.opacity, g.size.value = m.size * y, g.scale.value = x * 0.5, m.map && (g.map.value = m.map, t(m.map, g.uvTransform)), m.alphaMap && (g.alphaMap.value = m.alphaMap, t(m.alphaMap, g.alphaMapTransform)), m.alphaTest > 0 && (g.alphaTest.value = m.alphaTest);
        }
        function c(g, m) {
          g.diffuse.value.copy(m.color), g.opacity.value = m.opacity, g.rotation.value = m.rotation, m.map && (g.map.value = m.map, t(m.map, g.mapTransform)), m.alphaMap && (g.alphaMap.value = m.alphaMap, t(m.alphaMap, g.alphaMapTransform)), m.alphaTest > 0 && (g.alphaTest.value = m.alphaTest);
        }
        function u(g, m) {
          g.specular.value.copy(m.specular), g.shininess.value = Math.max(m.shininess, 1e-4);
        }
        function h(g, m) {
          m.gradientMap && (g.gradientMap.value = m.gradientMap);
        }
        function d(g, m) {
          g.metalness.value = m.metalness, m.metalnessMap && (g.metalnessMap.value = m.metalnessMap, t(m.metalnessMap, g.metalnessMapTransform)), g.roughness.value = m.roughness, m.roughnessMap && (g.roughnessMap.value = m.roughnessMap, t(m.roughnessMap, g.roughnessMapTransform)), m.envMap && (g.envMapIntensity.value = m.envMapIntensity);
        }
        function p(g, m, y) {
          g.ior.value = m.ior, m.sheen > 0 && (g.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen), g.sheenRoughness.value = m.sheenRoughness, m.sheenColorMap && (g.sheenColorMap.value = m.sheenColorMap, t(m.sheenColorMap, g.sheenColorMapTransform)), m.sheenRoughnessMap && (g.sheenRoughnessMap.value = m.sheenRoughnessMap, t(m.sheenRoughnessMap, g.sheenRoughnessMapTransform))), m.clearcoat > 0 && (g.clearcoat.value = m.clearcoat, g.clearcoatRoughness.value = m.clearcoatRoughness, m.clearcoatMap && (g.clearcoatMap.value = m.clearcoatMap, t(m.clearcoatMap, g.clearcoatMapTransform)), m.clearcoatRoughnessMap && (g.clearcoatRoughnessMap.value = m.clearcoatRoughnessMap, t(m.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)), m.clearcoatNormalMap && (g.clearcoatNormalMap.value = m.clearcoatNormalMap, t(m.clearcoatNormalMap, g.clearcoatNormalMapTransform), g.clearcoatNormalScale.value.copy(m.clearcoatNormalScale), m.side === Lt && g.clearcoatNormalScale.value.negate())), m.dispersion > 0 && (g.dispersion.value = m.dispersion), m.iridescence > 0 && (g.iridescence.value = m.iridescence, g.iridescenceIOR.value = m.iridescenceIOR, g.iridescenceThicknessMinimum.value = m.iridescenceThicknessRange[0], g.iridescenceThicknessMaximum.value = m.iridescenceThicknessRange[1], m.iridescenceMap && (g.iridescenceMap.value = m.iridescenceMap, t(m.iridescenceMap, g.iridescenceMapTransform)), m.iridescenceThicknessMap && (g.iridescenceThicknessMap.value = m.iridescenceThicknessMap, t(m.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))), m.transmission > 0 && (g.transmission.value = m.transmission, g.transmissionSamplerMap.value = y.texture, g.transmissionSamplerSize.value.set(y.width, y.height), m.transmissionMap && (g.transmissionMap.value = m.transmissionMap, t(m.transmissionMap, g.transmissionMapTransform)), g.thickness.value = m.thickness, m.thicknessMap && (g.thicknessMap.value = m.thicknessMap, t(m.thicknessMap, g.thicknessMapTransform)), g.attenuationDistance.value = m.attenuationDistance, g.attenuationColor.value.copy(m.attenuationColor)), m.anisotropy > 0 && (g.anisotropyVector.value.set(m.anisotropy * Math.cos(m.anisotropyRotation), m.anisotropy * Math.sin(m.anisotropyRotation)), m.anisotropyMap && (g.anisotropyMap.value = m.anisotropyMap, t(m.anisotropyMap, g.anisotropyMapTransform))), g.specularIntensity.value = m.specularIntensity, g.specularColor.value.copy(m.specularColor), m.specularColorMap && (g.specularColorMap.value = m.specularColorMap, t(m.specularColorMap, g.specularColorMapTransform)), m.specularIntensityMap && (g.specularIntensityMap.value = m.specularIntensityMap, t(m.specularIntensityMap, g.specularIntensityMapTransform));
        }
        function f(g, m) {
          m.matcap && (g.matcap.value = m.matcap);
        }
        function _(g, m) {
          const y = e.get(m).light;
          g.referencePosition.value.setFromMatrixPosition(y.matrixWorld), g.nearDistance.value = y.shadow.camera.near, g.farDistance.value = y.shadow.camera.far;
        }
        return {
          refreshFogUniforms: i,
          refreshMaterialUniforms: r
        };
      }
      function UT(n, e, t, i) {
        let r = {}, s = {}, a = [];
        const o = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);
        function l(y, x) {
          const v = x.program;
          i.uniformBlockBinding(y, v);
        }
        function c(y, x) {
          let v = r[y.id];
          v === void 0 && (f(y), v = u(y), r[y.id] = v, y.addEventListener("dispose", g));
          const A = x.program;
          i.updateUBOMapping(y, A);
          const E = e.render.frame;
          s[y.id] !== E && (d(y), s[y.id] = E);
        }
        function u(y) {
          const x = h();
          y.__bindingPointIndex = x;
          const v = n.createBuffer(), A = y.__size, E = y.usage;
          return n.bindBuffer(n.UNIFORM_BUFFER, v), n.bufferData(n.UNIFORM_BUFFER, A, E), n.bindBuffer(n.UNIFORM_BUFFER, null), n.bindBufferBase(n.UNIFORM_BUFFER, x, v), v;
        }
        function h() {
          for (let y = 0; y < o; y++) if (a.indexOf(y) === -1) return a.push(y), y;
          return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
        }
        function d(y) {
          const x = r[y.id], v = y.uniforms, A = y.__cache;
          n.bindBuffer(n.UNIFORM_BUFFER, x);
          for (let E = 0, w = v.length; E < w; E++) {
            const R = Array.isArray(v[E]) ? v[E] : [
              v[E]
            ];
            for (let S = 0, T = R.length; S < T; S++) {
              const L = R[S];
              if (p(L, E, S, A) === true) {
                const B = L.__offset, F = Array.isArray(L.value) ? L.value : [
                  L.value
                ];
                let H = 0;
                for (let X = 0; X < F.length; X++) {
                  const k = F[X], K = _(k);
                  typeof k == "number" || typeof k == "boolean" ? (L.__data[0] = k, n.bufferSubData(n.UNIFORM_BUFFER, B + H, L.__data)) : k.isMatrix3 ? (L.__data[0] = k.elements[0], L.__data[1] = k.elements[1], L.__data[2] = k.elements[2], L.__data[3] = 0, L.__data[4] = k.elements[3], L.__data[5] = k.elements[4], L.__data[6] = k.elements[5], L.__data[7] = 0, L.__data[8] = k.elements[6], L.__data[9] = k.elements[7], L.__data[10] = k.elements[8], L.__data[11] = 0) : (k.toArray(L.__data, H), H += K.storage / Float32Array.BYTES_PER_ELEMENT);
                }
                n.bufferSubData(n.UNIFORM_BUFFER, B, L.__data);
              }
            }
          }
          n.bindBuffer(n.UNIFORM_BUFFER, null);
        }
        function p(y, x, v, A) {
          const E = y.value, w = x + "_" + v;
          if (A[w] === void 0) return typeof E == "number" || typeof E == "boolean" ? A[w] = E : A[w] = E.clone(), true;
          {
            const R = A[w];
            if (typeof E == "number" || typeof E == "boolean") {
              if (R !== E) return A[w] = E, true;
            } else if (R.equals(E) === false) return R.copy(E), true;
          }
          return false;
        }
        function f(y) {
          const x = y.uniforms;
          let v = 0;
          const A = 16;
          for (let w = 0, R = x.length; w < R; w++) {
            const S = Array.isArray(x[w]) ? x[w] : [
              x[w]
            ];
            for (let T = 0, L = S.length; T < L; T++) {
              const B = S[T], F = Array.isArray(B.value) ? B.value : [
                B.value
              ];
              for (let H = 0, X = F.length; H < X; H++) {
                const k = F[H], K = _(k), G = v % A, ie = G % K.boundary, ue = G + ie;
                v += ie, ue !== 0 && A - ue < K.storage && (v += A - ue), B.__data = new Float32Array(K.storage / Float32Array.BYTES_PER_ELEMENT), B.__offset = v, v += K.storage;
              }
            }
          }
          const E = v % A;
          return E > 0 && (v += A - E), y.__size = v, y.__cache = {}, this;
        }
        function _(y) {
          const x = {
            boundary: 0,
            storage: 0
          };
          return typeof y == "number" || typeof y == "boolean" ? (x.boundary = 4, x.storage = 4) : y.isVector2 ? (x.boundary = 8, x.storage = 8) : y.isVector3 || y.isColor ? (x.boundary = 16, x.storage = 12) : y.isVector4 ? (x.boundary = 16, x.storage = 16) : y.isMatrix3 ? (x.boundary = 48, x.storage = 48) : y.isMatrix4 ? (x.boundary = 64, x.storage = 64) : y.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", y), x;
        }
        function g(y) {
          const x = y.target;
          x.removeEventListener("dispose", g);
          const v = a.indexOf(x.__bindingPointIndex);
          a.splice(v, 1), n.deleteBuffer(r[x.id]), delete r[x.id], delete s[x.id];
        }
        function m() {
          for (const y in r) n.deleteBuffer(r[y]);
          a = [], r = {}, s = {};
        }
        return {
          bind: l,
          update: c,
          dispose: m
        };
      }
      class OT {
        constructor(e = {}) {
          const { canvas: t = s_(), context: i = null, depth: r = true, stencil: s = false, alpha: a = false, antialias: o = false, premultipliedAlpha: l = true, preserveDrawingBuffer: c = false, powerPreference: u = "default", failIfMajorPerformanceCaveat: h = false, reverseDepthBuffer: d = false } = e;
          this.isWebGLRenderer = true;
          let p;
          if (i !== null) {
            if (typeof WebGLRenderingContext < "u" && i instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            p = i.getContextAttributes().alpha;
          } else p = a;
          const f = new Uint32Array(4), _ = new Int32Array(4);
          let g = null, m = null;
          const y = [], x = [];
          this.domElement = t, this.debug = {
            checkShaderErrors: true,
            onShaderError: null
          }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this._outputColorSpace = Kt, this.toneMapping = Bn, this.toneMappingExposure = 1;
          const v = this;
          let A = false, E = 0, w = 0, R = null, S = -1, T = null;
          const L = new it(), B = new it();
          let F = null;
          const H = new Ae(0);
          let X = 0, k = t.width, K = t.height, G = 1, ie = null, ue = null;
          const we = new it(0, 0, k, K), Be = new it(0, 0, k, K);
          let We = false;
          const j = new qc();
          let ne = false, _e = false;
          this.transmissionResolutionScale = 1;
          const ae = new Fe(), Pe = new Fe(), Re = new D(), De = new it(), te = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: true
          };
          let $ = false;
          function se() {
            return R === null ? G : 1;
          }
          let P = i;
          function fe(b, U) {
            return t.getContext(b, U);
          }
          try {
            const b = {
              alpha: true,
              depth: r,
              stencil: s,
              antialias: o,
              premultipliedAlpha: l,
              preserveDrawingBuffer: c,
              powerPreference: u,
              failIfMajorPerformanceCaveat: h
            };
            if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${nt}`), t.addEventListener("webglcontextlost", Z, false), t.addEventListener("webglcontextrestored", me, false), t.addEventListener("webglcontextcreationerror", le, false), P === null) {
              const U = "webgl2";
              if (P = fe(U, b), P === null) throw fe(U) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
            }
          } catch (b) {
            throw console.error("THREE.WebGLRenderer: " + b.message), b;
          }
          let xe, Me, oe, ke, de, C, M, O, Y, J, q, Ee, he, ye, je, re, Te, Le, Ie, be, Ze, He, _t, I;
          function pe() {
            xe = new jy(P), xe.init(), He = new RT(P, xe), Me = new ky(P, xe, e, He), oe = new wT(P, xe), Me.reverseDepthBuffer && d && oe.buffers.depth.setReversed(true), ke = new Ky(P), de = new pT(), C = new AT(P, xe, oe, de, Me, He, ke), M = new Hy(v), O = new Xy(v), Y = new i0(P), _t = new By(P, Y), J = new qy(P, Y, ke, _t), q = new Jy(P, J, Y, ke), Ie = new Zy(P, Me, C), re = new Vy(de), Ee = new dT(v, M, O, xe, Me, _t, re), he = new NT(v, de), ye = new mT(), je = new MT(xe), Le = new Fy(v, M, O, oe, q, p, l), Te = new ST(v, q, Me), I = new UT(P, ke, Me, oe), be = new zy(P, xe, ke), Ze = new Yy(P, xe, ke), ke.programs = Ee.programs, v.capabilities = Me, v.extensions = xe, v.properties = de, v.renderLists = ye, v.shadowMap = Te, v.state = oe, v.info = ke;
          }
          pe();
          const W = new DT(v, P);
          this.xr = W, this.getContext = function() {
            return P;
          }, this.getContextAttributes = function() {
            return P.getContextAttributes();
          }, this.forceContextLoss = function() {
            const b = xe.get("WEBGL_lose_context");
            b && b.loseContext();
          }, this.forceContextRestore = function() {
            const b = xe.get("WEBGL_lose_context");
            b && b.restoreContext();
          }, this.getPixelRatio = function() {
            return G;
          }, this.setPixelRatio = function(b) {
            b !== void 0 && (G = b, this.setSize(k, K, false));
          }, this.getSize = function(b) {
            return b.set(k, K);
          }, this.setSize = function(b, U, z = true) {
            if (W.isPresenting) {
              console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
              return;
            }
            k = b, K = U, t.width = Math.floor(b * G), t.height = Math.floor(U * G), z === true && (t.style.width = b + "px", t.style.height = U + "px"), this.setViewport(0, 0, b, U);
          }, this.getDrawingBufferSize = function(b) {
            return b.set(k * G, K * G).floor();
          }, this.setDrawingBufferSize = function(b, U, z) {
            k = b, K = U, G = z, t.width = Math.floor(b * z), t.height = Math.floor(U * z), this.setViewport(0, 0, b, U);
          }, this.getCurrentViewport = function(b) {
            return b.copy(L);
          }, this.getViewport = function(b) {
            return b.copy(we);
          }, this.setViewport = function(b, U, z, V) {
            b.isVector4 ? we.set(b.x, b.y, b.z, b.w) : we.set(b, U, z, V), oe.viewport(L.copy(we).multiplyScalar(G).round());
          }, this.getScissor = function(b) {
            return b.copy(Be);
          }, this.setScissor = function(b, U, z, V) {
            b.isVector4 ? Be.set(b.x, b.y, b.z, b.w) : Be.set(b, U, z, V), oe.scissor(B.copy(Be).multiplyScalar(G).round());
          }, this.getScissorTest = function() {
            return We;
          }, this.setScissorTest = function(b) {
            oe.setScissorTest(We = b);
          }, this.setOpaqueSort = function(b) {
            ie = b;
          }, this.setTransparentSort = function(b) {
            ue = b;
          }, this.getClearColor = function(b) {
            return b.copy(Le.getClearColor());
          }, this.setClearColor = function() {
            Le.setClearColor.apply(Le, arguments);
          }, this.getClearAlpha = function() {
            return Le.getClearAlpha();
          }, this.setClearAlpha = function() {
            Le.setClearAlpha.apply(Le, arguments);
          }, this.clear = function(b = true, U = true, z = true) {
            let V = 0;
            if (b) {
              let N = false;
              if (R !== null) {
                const Q = R.texture.format;
                N = Q === Gl || Q === Hl || Q === Vl;
              }
              if (N) {
                const Q = R.texture.type, ge = Q === fn || Q === cr || Q === ua || Q === $r || Q === Bl || Q === zl, ve = Le.getClearColor(), Se = Le.getClearAlpha(), Ue = ve.r, Ne = ve.g, Oe = ve.b;
                ge ? (f[0] = Ue, f[1] = Ne, f[2] = Oe, f[3] = Se, P.clearBufferuiv(P.COLOR, 0, f)) : (_[0] = Ue, _[1] = Ne, _[2] = Oe, _[3] = Se, P.clearBufferiv(P.COLOR, 0, _));
              } else V |= P.COLOR_BUFFER_BIT;
            }
            U && (V |= P.DEPTH_BUFFER_BIT), z && (V |= P.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), P.clear(V);
          }, this.clearColor = function() {
            this.clear(true, false, false);
          }, this.clearDepth = function() {
            this.clear(false, true, false);
          }, this.clearStencil = function() {
            this.clear(false, false, true);
          }, this.dispose = function() {
            t.removeEventListener("webglcontextlost", Z, false), t.removeEventListener("webglcontextrestored", me, false), t.removeEventListener("webglcontextcreationerror", le, false), Le.dispose(), ye.dispose(), je.dispose(), de.dispose(), M.dispose(), O.dispose(), q.dispose(), _t.dispose(), I.dispose(), Ee.dispose(), W.dispose(), W.removeEventListener("sessionstart", Ym), W.removeEventListener("sessionend", Km), Wr.stop();
          };
          function Z(b) {
            b.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), A = true;
          }
          function me() {
            console.log("THREE.WebGLRenderer: Context Restored."), A = false;
            const b = ke.autoReset, U = Te.enabled, z = Te.autoUpdate, V = Te.needsUpdate, N = Te.type;
            pe(), ke.autoReset = b, Te.enabled = U, Te.autoUpdate = z, Te.needsUpdate = V, Te.type = N;
          }
          function le(b) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", b.statusMessage);
          }
          function Je(b) {
            const U = b.target;
            U.removeEventListener("dispose", Je), Ct(U);
          }
          function Ct(b) {
            si(b), de.remove(b);
          }
          function si(b) {
            const U = de.get(b).programs;
            U !== void 0 && (U.forEach(function(z) {
              Ee.releaseProgram(z);
            }), b.isShaderMaterial && Ee.releaseShaderCache(b));
          }
          this.renderBufferDirect = function(b, U, z, V, N, Q) {
            U === null && (U = te);
            const ge = N.isMesh && N.matrixWorld.determinant() < 0, ve = FE(b, U, z, V, N);
            oe.setMaterial(V, ge);
            let Se = z.index, Ue = 1;
            if (V.wireframe === true) {
              if (Se = J.getWireframeAttribute(z), Se === void 0) return;
              Ue = 2;
            }
            const Ne = z.drawRange, Oe = z.attributes.position;
            let tt = Ne.start * Ue, dt = (Ne.start + Ne.count) * Ue;
            Q !== null && (tt = Math.max(tt, Q.start * Ue), dt = Math.min(dt, (Q.start + Q.count) * Ue)), Se !== null ? (tt = Math.max(tt, 0), dt = Math.min(dt, Se.count)) : Oe != null && (tt = Math.max(tt, 0), dt = Math.min(dt, Oe.count));
            const Wt = dt - tt;
            if (Wt < 0 || Wt === 1 / 0) return;
            _t.setup(N, V, ve, z, Se);
            let pt, vt = be;
            if (Se !== null && (pt = Y.get(Se), vt = Ze, vt.setIndex(pt)), N.isMesh) V.wireframe === true ? (oe.setLineWidth(V.wireframeLinewidth * se()), vt.setMode(P.LINES)) : vt.setMode(P.TRIANGLES);
            else if (N.isLine) {
              let Ce = V.linewidth;
              Ce === void 0 && (Ce = 1), oe.setLineWidth(Ce * se()), N.isLineSegments ? vt.setMode(P.LINES) : N.isLineLoop ? vt.setMode(P.LINE_LOOP) : vt.setMode(P.LINE_STRIP);
            } else N.isPoints ? vt.setMode(P.POINTS) : N.isSprite && vt.setMode(P.TRIANGLES);
            if (N.isBatchedMesh) if (N._multiDrawInstances !== null) vt.renderMultiDrawInstances(N._multiDrawStarts, N._multiDrawCounts, N._multiDrawCount, N._multiDrawInstances);
            else if (xe.get("WEBGL_multi_draw")) vt.renderMultiDraw(N._multiDrawStarts, N._multiDrawCounts, N._multiDrawCount);
            else {
              const Ce = N._multiDrawStarts, pi = N._multiDrawCounts, Xr = N._multiDrawCount, Zi = Se ? Y.get(Se).bytesPerElement : 1, sa = de.get(V).currentProgram.getUniforms();
              for (let Li = 0; Li < Xr; Li++) sa.setValue(P, "_gl_DrawID", Li), vt.render(Ce[Li] / Zi, pi[Li]);
            }
            else if (N.isInstancedMesh) vt.renderInstances(tt, Wt, N.count);
            else if (z.isInstancedBufferGeometry) {
              const Ce = z._maxInstanceCount !== void 0 ? z._maxInstanceCount : 1 / 0, pi = Math.min(z.instanceCount, Ce);
              vt.renderInstances(tt, Wt, pi);
            } else vt.render(tt, Wt);
          };
          function lt(b, U, z) {
            b.transparent === true && b.side === fi && b.forceSinglePass === false ? (b.side = Lt, b.needsUpdate = true, El(b, U, z), b.side = ft, b.needsUpdate = true, El(b, U, z), b.side = fi) : El(b, U, z);
          }
          this.compile = function(b, U, z = null) {
            z === null && (z = b), m = je.get(z), m.init(U), x.push(m), z.traverseVisible(function(N) {
              N.isLight && N.layers.test(U.layers) && (m.pushLight(N), N.castShadow && m.pushShadow(N));
            }), b !== z && b.traverseVisible(function(N) {
              N.isLight && N.layers.test(U.layers) && (m.pushLight(N), N.castShadow && m.pushShadow(N));
            }), m.setupLights();
            const V = /* @__PURE__ */ new Set();
            return b.traverse(function(N) {
              if (!(N.isMesh || N.isPoints || N.isLine || N.isSprite)) return;
              const Q = N.material;
              if (Q) if (Array.isArray(Q)) for (let ge = 0; ge < Q.length; ge++) {
                const ve = Q[ge];
                lt(ve, z, N), V.add(ve);
              }
              else lt(Q, z, N), V.add(Q);
            }), x.pop(), m = null, V;
          }, this.compileAsync = function(b, U, z = null) {
            const V = this.compile(b, U, z);
            return new Promise((N) => {
              function Q() {
                if (V.forEach(function(ge) {
                  de.get(ge).currentProgram.isReady() && V.delete(ge);
                }), V.size === 0) {
                  N(b);
                  return;
                }
                setTimeout(Q, 10);
              }
              xe.get("KHR_parallel_shader_compile") !== null ? Q() : setTimeout(Q, 10);
            });
          };
          let Ki = null;
          function Un(b) {
            Ki && Ki(b);
          }
          function Ym() {
            Wr.stop();
          }
          function Km() {
            Wr.start();
          }
          const Wr = new Tp();
          Wr.setAnimationLoop(Un), typeof self < "u" && Wr.setContext(self), this.setAnimationLoop = function(b) {
            Ki = b, W.setAnimationLoop(b), b === null ? Wr.stop() : Wr.start();
          }, W.addEventListener("sessionstart", Ym), W.addEventListener("sessionend", Km), this.render = function(b, U) {
            if (U !== void 0 && U.isCamera !== true) {
              console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
              return;
            }
            if (A === true) return;
            if (b.matrixWorldAutoUpdate === true && b.updateMatrixWorld(), U.parent === null && U.matrixWorldAutoUpdate === true && U.updateMatrixWorld(), W.enabled === true && W.isPresenting === true && (W.cameraAutoUpdate === true && W.updateCamera(U), U = W.getCamera()), b.isScene === true && b.onBeforeRender(v, b, U, R), m = je.get(b, x.length), m.init(U), x.push(m), Pe.multiplyMatrices(U.projectionMatrix, U.matrixWorldInverse), j.setFromProjectionMatrix(Pe), _e = this.localClippingEnabled, ne = re.init(this.clippingPlanes, _e), g = ye.get(b, y.length), g.init(), y.push(g), W.enabled === true && W.isPresenting === true) {
              const Q = v.xr.getDepthSensingMesh();
              Q !== null && Oh(Q, U, -1 / 0, v.sortObjects);
            }
            Oh(b, U, 0, v.sortObjects), g.finish(), v.sortObjects === true && g.sort(ie, ue), $ = W.enabled === false || W.isPresenting === false || W.hasDepthSensing() === false, $ && Le.addToRenderList(g, b), this.info.render.frame++, ne === true && re.beginShadows();
            const z = m.state.shadowsArray;
            Te.render(z, b, U), ne === true && re.endShadows(), this.info.autoReset === true && this.info.reset();
            const V = g.opaque, N = g.transmissive;
            if (m.setupLights(), U.isArrayCamera) {
              const Q = U.cameras;
              if (N.length > 0) for (let ge = 0, ve = Q.length; ge < ve; ge++) {
                const Se = Q[ge];
                Jm(V, N, b, Se);
              }
              $ && Le.render(b);
              for (let ge = 0, ve = Q.length; ge < ve; ge++) {
                const Se = Q[ge];
                Zm(g, b, Se, Se.viewport);
              }
            } else N.length > 0 && Jm(V, N, b, U), $ && Le.render(b), Zm(g, b, U);
            R !== null && w === 0 && (C.updateMultisampleRenderTarget(R), C.updateRenderTargetMipmap(R)), b.isScene === true && b.onAfterRender(v, b, U), _t.resetDefaultState(), S = -1, T = null, x.pop(), x.length > 0 ? (m = x[x.length - 1], ne === true && re.setGlobalState(v.clippingPlanes, m.state.camera)) : m = null, y.pop(), y.length > 0 ? g = y[y.length - 1] : g = null;
          };
          function Oh(b, U, z, V) {
            if (b.visible === false) return;
            if (b.layers.test(U.layers)) {
              if (b.isGroup) z = b.renderOrder;
              else if (b.isLOD) b.autoUpdate === true && b.update(U);
              else if (b.isLight) m.pushLight(b), b.castShadow && m.pushShadow(b);
              else if (b.isSprite) {
                if (!b.frustumCulled || j.intersectsSprite(b)) {
                  V && De.setFromMatrixPosition(b.matrixWorld).applyMatrix4(Pe);
                  const Q = q.update(b), ge = b.material;
                  ge.visible && g.push(b, Q, ge, z, De.z, null);
                }
              } else if ((b.isMesh || b.isLine || b.isPoints) && (!b.frustumCulled || j.intersectsObject(b))) {
                const Q = q.update(b), ge = b.material;
                if (V && (b.boundingSphere !== void 0 ? (b.boundingSphere === null && b.computeBoundingSphere(), De.copy(b.boundingSphere.center)) : (Q.boundingSphere === null && Q.computeBoundingSphere(), De.copy(Q.boundingSphere.center)), De.applyMatrix4(b.matrixWorld).applyMatrix4(Pe)), Array.isArray(ge)) {
                  const ve = Q.groups;
                  for (let Se = 0, Ue = ve.length; Se < Ue; Se++) {
                    const Ne = ve[Se], Oe = ge[Ne.materialIndex];
                    Oe && Oe.visible && g.push(b, Q, Oe, z, De.z, Ne);
                  }
                } else ge.visible && g.push(b, Q, ge, z, De.z, null);
              }
            }
            const N = b.children;
            for (let Q = 0, ge = N.length; Q < ge; Q++) Oh(N[Q], U, z, V);
          }
          function Zm(b, U, z, V) {
            const N = b.opaque, Q = b.transmissive, ge = b.transparent;
            m.setupLightsView(z), ne === true && re.setGlobalState(v.clippingPlanes, z), V && oe.viewport(L.copy(V)), N.length > 0 && Sl(N, U, z), Q.length > 0 && Sl(Q, U, z), ge.length > 0 && Sl(ge, U, z), oe.buffers.depth.setTest(true), oe.buffers.depth.setMask(true), oe.buffers.color.setMask(true), oe.setPolygonOffset(false);
          }
          function Jm(b, U, z, V) {
            if ((z.isScene === true ? z.overrideMaterial : null) !== null) return;
            m.state.transmissionRenderTarget[V.id] === void 0 && (m.state.transmissionRenderTarget[V.id] = new Gi(1, 1, {
              generateMipmaps: true,
              type: xe.has("EXT_color_buffer_half_float") || xe.has("EXT_color_buffer_float") ? mn : fn,
              minFilter: pn,
              samples: 4,
              stencilBuffer: s,
              resolveDepthBuffer: false,
              resolveStencilBuffer: false,
              colorSpace: Ke.workingColorSpace
            }));
            const N = m.state.transmissionRenderTarget[V.id], Q = V.viewport || L;
            N.setSize(Q.z * v.transmissionResolutionScale, Q.w * v.transmissionResolutionScale);
            const ge = v.getRenderTarget();
            v.setRenderTarget(N), v.getClearColor(H), X = v.getClearAlpha(), X < 1 && v.setClearColor(16777215, 0.5), v.clear(), $ && Le.render(z);
            const ve = v.toneMapping;
            v.toneMapping = Bn;
            const Se = V.viewport;
            if (V.viewport !== void 0 && (V.viewport = void 0), m.setupLightsView(V), ne === true && re.setGlobalState(v.clippingPlanes, V), Sl(b, z, V), C.updateMultisampleRenderTarget(N), C.updateRenderTargetMipmap(N), xe.has("WEBGL_multisampled_render_to_texture") === false) {
              let Ue = false;
              for (let Ne = 0, Oe = U.length; Ne < Oe; Ne++) {
                const tt = U[Ne], dt = tt.object, Wt = tt.geometry, pt = tt.material, vt = tt.group;
                if (pt.side === fi && dt.layers.test(V.layers)) {
                  const Ce = pt.side;
                  pt.side = Lt, pt.needsUpdate = true, $m(dt, z, V, Wt, pt, vt), pt.side = Ce, pt.needsUpdate = true, Ue = true;
                }
              }
              Ue === true && (C.updateMultisampleRenderTarget(N), C.updateRenderTargetMipmap(N));
            }
            v.setRenderTarget(ge), v.setClearColor(H, X), Se !== void 0 && (V.viewport = Se), v.toneMapping = ve;
          }
          function Sl(b, U, z) {
            const V = U.isScene === true ? U.overrideMaterial : null;
            for (let N = 0, Q = b.length; N < Q; N++) {
              const ge = b[N], ve = ge.object, Se = ge.geometry, Ue = V === null ? ge.material : V, Ne = ge.group;
              ve.layers.test(z.layers) && $m(ve, U, z, Se, Ue, Ne);
            }
          }
          function $m(b, U, z, V, N, Q) {
            b.onBeforeRender(v, U, z, V, N, Q), b.modelViewMatrix.multiplyMatrices(z.matrixWorldInverse, b.matrixWorld), b.normalMatrix.getNormalMatrix(b.modelViewMatrix), N.onBeforeRender(v, U, z, V, b, Q), N.transparent === true && N.side === fi && N.forceSinglePass === false ? (N.side = Lt, N.needsUpdate = true, v.renderBufferDirect(z, U, V, N, b, Q), N.side = ft, N.needsUpdate = true, v.renderBufferDirect(z, U, V, N, b, Q), N.side = fi) : v.renderBufferDirect(z, U, V, N, b, Q), b.onAfterRender(v, U, z, V, N, Q);
          }
          function El(b, U, z) {
            U.isScene !== true && (U = te);
            const V = de.get(b), N = m.state.lights, Q = m.state.shadowsArray, ge = N.state.version, ve = Ee.getParameters(b, N.state, Q, U, z), Se = Ee.getProgramCacheKey(ve);
            let Ue = V.programs;
            V.environment = b.isMeshStandardMaterial ? U.environment : null, V.fog = U.fog, V.envMap = (b.isMeshStandardMaterial ? O : M).get(b.envMap || V.environment), V.envMapRotation = V.environment !== null && b.envMap === null ? U.environmentRotation : b.envMapRotation, Ue === void 0 && (b.addEventListener("dispose", Je), Ue = /* @__PURE__ */ new Map(), V.programs = Ue);
            let Ne = Ue.get(Se);
            if (Ne !== void 0) {
              if (V.currentProgram === Ne && V.lightsStateVersion === ge) return eg(b, ve), Ne;
            } else ve.uniforms = Ee.getUniforms(b), b.onBeforeCompile(ve, v), Ne = Ee.acquireProgram(ve, Se), Ue.set(Se, Ne), V.uniforms = ve.uniforms;
            const Oe = V.uniforms;
            return (!b.isShaderMaterial && !b.isRawShaderMaterial || b.clipping === true) && (Oe.clippingPlanes = re.uniform), eg(b, ve), V.needsLights = zE(b), V.lightsStateVersion = ge, V.needsLights && (Oe.ambientLightColor.value = N.state.ambient, Oe.lightProbe.value = N.state.probe, Oe.directionalLights.value = N.state.directional, Oe.directionalLightShadows.value = N.state.directionalShadow, Oe.spotLights.value = N.state.spot, Oe.spotLightShadows.value = N.state.spotShadow, Oe.rectAreaLights.value = N.state.rectArea, Oe.ltc_1.value = N.state.rectAreaLTC1, Oe.ltc_2.value = N.state.rectAreaLTC2, Oe.pointLights.value = N.state.point, Oe.pointLightShadows.value = N.state.pointShadow, Oe.hemisphereLights.value = N.state.hemi, Oe.directionalShadowMap.value = N.state.directionalShadowMap, Oe.directionalShadowMatrix.value = N.state.directionalShadowMatrix, Oe.spotShadowMap.value = N.state.spotShadowMap, Oe.spotLightMatrix.value = N.state.spotLightMatrix, Oe.spotLightMap.value = N.state.spotLightMap, Oe.pointShadowMap.value = N.state.pointShadowMap, Oe.pointShadowMatrix.value = N.state.pointShadowMatrix), V.currentProgram = Ne, V.uniformsList = null, Ne;
          }
          function Qm(b) {
            if (b.uniformsList === null) {
              const U = b.currentProgram.getUniforms();
              b.uniformsList = tl.seqWithValue(U.seq, b.uniforms);
            }
            return b.uniformsList;
          }
          function eg(b, U) {
            const z = de.get(b);
            z.outputColorSpace = U.outputColorSpace, z.batching = U.batching, z.batchingColor = U.batchingColor, z.instancing = U.instancing, z.instancingColor = U.instancingColor, z.instancingMorph = U.instancingMorph, z.skinning = U.skinning, z.morphTargets = U.morphTargets, z.morphNormals = U.morphNormals, z.morphColors = U.morphColors, z.morphTargetsCount = U.morphTargetsCount, z.numClippingPlanes = U.numClippingPlanes, z.numIntersection = U.numClipIntersection, z.vertexAlphas = U.vertexAlphas, z.vertexTangents = U.vertexTangents, z.toneMapping = U.toneMapping;
          }
          function FE(b, U, z, V, N) {
            U.isScene !== true && (U = te), C.resetTextureUnits();
            const Q = U.fog, ge = V.isMeshStandardMaterial ? U.environment : null, ve = R === null ? v.outputColorSpace : R.isXRRenderTarget === true ? R.texture.colorSpace : oi, Se = (V.isMeshStandardMaterial ? O : M).get(V.envMap || ge), Ue = V.vertexColors === true && !!z.attributes.color && z.attributes.color.itemSize === 4, Ne = !!z.attributes.tangent && (!!V.normalMap || V.anisotropy > 0), Oe = !!z.morphAttributes.position, tt = !!z.morphAttributes.normal, dt = !!z.morphAttributes.color;
            let Wt = Bn;
            V.toneMapped && (R === null || R.isXRRenderTarget === true) && (Wt = v.toneMapping);
            const pt = z.morphAttributes.position || z.morphAttributes.normal || z.morphAttributes.color, vt = pt !== void 0 ? pt.length : 0, Ce = de.get(V), pi = m.state.lights;
            if (ne === true && (_e === true || b !== T)) {
              const $t = b === T && V.id === S;
              re.setState(V, b, $t);
            }
            let Xr = false;
            V.version === Ce.__version ? (Ce.needsLights && Ce.lightsStateVersion !== pi.state.version || Ce.outputColorSpace !== ve || N.isBatchedMesh && Ce.batching === false || !N.isBatchedMesh && Ce.batching === true || N.isBatchedMesh && Ce.batchingColor === true && N.colorTexture === null || N.isBatchedMesh && Ce.batchingColor === false && N.colorTexture !== null || N.isInstancedMesh && Ce.instancing === false || !N.isInstancedMesh && Ce.instancing === true || N.isSkinnedMesh && Ce.skinning === false || !N.isSkinnedMesh && Ce.skinning === true || N.isInstancedMesh && Ce.instancingColor === true && N.instanceColor === null || N.isInstancedMesh && Ce.instancingColor === false && N.instanceColor !== null || N.isInstancedMesh && Ce.instancingMorph === true && N.morphTexture === null || N.isInstancedMesh && Ce.instancingMorph === false && N.morphTexture !== null || Ce.envMap !== Se || V.fog === true && Ce.fog !== Q || Ce.numClippingPlanes !== void 0 && (Ce.numClippingPlanes !== re.numPlanes || Ce.numIntersection !== re.numIntersection) || Ce.vertexAlphas !== Ue || Ce.vertexTangents !== Ne || Ce.morphTargets !== Oe || Ce.morphNormals !== tt || Ce.morphColors !== dt || Ce.toneMapping !== Wt || Ce.morphTargetsCount !== vt) && (Xr = true) : (Xr = true, Ce.__version = V.version);
            let Zi = Ce.currentProgram;
            Xr === true && (Zi = El(V, U, N));
            let sa = false, Li = false, ao = false;
            const Mt = Zi.getUniforms(), zi = Ce.uniforms;
            if (oe.useProgram(Zi.program) && (sa = true, Li = true, ao = true), V.id !== S && (S = V.id, Li = true), sa || T !== b) {
              oe.buffers.depth.getReversed() ? (ae.copy(b.projectionMatrix), o_(ae), l_(ae), Mt.setValue(P, "projectionMatrix", ae)) : Mt.setValue(P, "projectionMatrix", b.projectionMatrix), Mt.setValue(P, "viewMatrix", b.matrixWorldInverse);
              const $t = Mt.map.cameraPosition;
              $t !== void 0 && $t.setValue(P, Re.setFromMatrixPosition(b.matrixWorld)), Me.logarithmicDepthBuffer && Mt.setValue(P, "logDepthBufFC", 2 / (Math.log(b.far + 1) / Math.LN2)), (V.isMeshPhongMaterial || V.isMeshToonMaterial || V.isMeshLambertMaterial || V.isMeshBasicMaterial || V.isMeshStandardMaterial || V.isShaderMaterial) && Mt.setValue(P, "isOrthographic", b.isOrthographicCamera === true), T !== b && (T = b, Li = true, ao = true);
            }
            if (N.isSkinnedMesh) {
              Mt.setOptional(P, N, "bindMatrix"), Mt.setOptional(P, N, "bindMatrixInverse");
              const $t = N.skeleton;
              $t && ($t.boneTexture === null && $t.computeBoneTexture(), Mt.setValue(P, "boneTexture", $t.boneTexture, C));
            }
            N.isBatchedMesh && (Mt.setOptional(P, N, "batchingTexture"), Mt.setValue(P, "batchingTexture", N._matricesTexture, C), Mt.setOptional(P, N, "batchingIdTexture"), Mt.setValue(P, "batchingIdTexture", N._indirectTexture, C), Mt.setOptional(P, N, "batchingColorTexture"), N._colorsTexture !== null && Mt.setValue(P, "batchingColorTexture", N._colorsTexture, C));
            const ki = z.morphAttributes;
            if ((ki.position !== void 0 || ki.normal !== void 0 || ki.color !== void 0) && Ie.update(N, z, Zi), (Li || Ce.receiveShadow !== N.receiveShadow) && (Ce.receiveShadow = N.receiveShadow, Mt.setValue(P, "receiveShadow", N.receiveShadow)), V.isMeshGouraudMaterial && V.envMap !== null && (zi.envMap.value = Se, zi.flipEnvMap.value = Se.isCubeTexture && Se.isRenderTargetTexture === false ? -1 : 1), V.isMeshStandardMaterial && V.envMap === null && U.environment !== null && (zi.envMapIntensity.value = U.environmentIntensity), Li && (Mt.setValue(P, "toneMappingExposure", v.toneMappingExposure), Ce.needsLights && BE(zi, ao), Q && V.fog === true && he.refreshFogUniforms(zi, Q), he.refreshMaterialUniforms(zi, V, G, K, m.state.transmissionRenderTarget[b.id]), tl.upload(P, Qm(Ce), zi, C)), V.isShaderMaterial && V.uniformsNeedUpdate === true && (tl.upload(P, Qm(Ce), zi, C), V.uniformsNeedUpdate = false), V.isSpriteMaterial && Mt.setValue(P, "center", N.center), Mt.setValue(P, "modelViewMatrix", N.modelViewMatrix), Mt.setValue(P, "normalMatrix", N.normalMatrix), Mt.setValue(P, "modelMatrix", N.matrixWorld), V.isShaderMaterial || V.isRawShaderMaterial) {
              const $t = V.uniformsGroups;
              for (let Ji = 0, Fh = $t.length; Ji < Fh; Ji++) {
                const jr = $t[Ji];
                I.update(jr, Zi), I.bind(jr, Zi);
              }
            }
            return Zi;
          }
          function BE(b, U) {
            b.ambientLightColor.needsUpdate = U, b.lightProbe.needsUpdate = U, b.directionalLights.needsUpdate = U, b.directionalLightShadows.needsUpdate = U, b.pointLights.needsUpdate = U, b.pointLightShadows.needsUpdate = U, b.spotLights.needsUpdate = U, b.spotLightShadows.needsUpdate = U, b.rectAreaLights.needsUpdate = U, b.hemisphereLights.needsUpdate = U;
          }
          function zE(b) {
            return b.isMeshLambertMaterial || b.isMeshToonMaterial || b.isMeshPhongMaterial || b.isMeshStandardMaterial || b.isShadowMaterial || b.isShaderMaterial && b.lights === true;
          }
          this.getActiveCubeFace = function() {
            return E;
          }, this.getActiveMipmapLevel = function() {
            return w;
          }, this.getRenderTarget = function() {
            return R;
          }, this.setRenderTargetTextures = function(b, U, z) {
            de.get(b.texture).__webglTexture = U, de.get(b.depthTexture).__webglTexture = z;
            const V = de.get(b);
            V.__hasExternalTextures = true, V.__autoAllocateDepthBuffer = z === void 0, V.__autoAllocateDepthBuffer || xe.has("WEBGL_multisampled_render_to_texture") === true && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), V.__useRenderToTexture = false);
          }, this.setRenderTargetFramebuffer = function(b, U) {
            const z = de.get(b);
            z.__webglFramebuffer = U, z.__useDefaultFramebuffer = U === void 0;
          };
          const kE = P.createFramebuffer();
          this.setRenderTarget = function(b, U = 0, z = 0) {
            R = b, E = U, w = z;
            let V = true, N = null, Q = false, ge = false;
            if (b) {
              const ve = de.get(b);
              if (ve.__useDefaultFramebuffer !== void 0) oe.bindFramebuffer(P.FRAMEBUFFER, null), V = false;
              else if (ve.__webglFramebuffer === void 0) C.setupRenderTarget(b);
              else if (ve.__hasExternalTextures) C.rebindTextures(b, de.get(b.texture).__webglTexture, de.get(b.depthTexture).__webglTexture);
              else if (b.depthBuffer) {
                const Ne = b.depthTexture;
                if (ve.__boundDepthTexture !== Ne) {
                  if (Ne !== null && de.has(Ne) && (b.width !== Ne.image.width || b.height !== Ne.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                  C.setupDepthRenderbuffer(b);
                }
              }
              const Se = b.texture;
              (Se.isData3DTexture || Se.isDataArrayTexture || Se.isCompressedArrayTexture) && (ge = true);
              const Ue = de.get(b).__webglFramebuffer;
              b.isWebGLCubeRenderTarget ? (Array.isArray(Ue[U]) ? N = Ue[U][z] : N = Ue[U], Q = true) : b.samples > 0 && C.useMultisampledRTT(b) === false ? N = de.get(b).__webglMultisampledFramebuffer : Array.isArray(Ue) ? N = Ue[z] : N = Ue, L.copy(b.viewport), B.copy(b.scissor), F = b.scissorTest;
            } else L.copy(we).multiplyScalar(G).floor(), B.copy(Be).multiplyScalar(G).floor(), F = We;
            if (z !== 0 && (N = kE), oe.bindFramebuffer(P.FRAMEBUFFER, N) && V && oe.drawBuffers(b, N), oe.viewport(L), oe.scissor(B), oe.setScissorTest(F), Q) {
              const ve = de.get(b.texture);
              P.framebufferTexture2D(P.FRAMEBUFFER, P.COLOR_ATTACHMENT0, P.TEXTURE_CUBE_MAP_POSITIVE_X + U, ve.__webglTexture, z);
            } else if (ge) {
              const ve = de.get(b.texture), Se = U;
              P.framebufferTextureLayer(P.FRAMEBUFFER, P.COLOR_ATTACHMENT0, ve.__webglTexture, z, Se);
            } else if (b !== null && z !== 0) {
              const ve = de.get(b.texture);
              P.framebufferTexture2D(P.FRAMEBUFFER, P.COLOR_ATTACHMENT0, P.TEXTURE_2D, ve.__webglTexture, z);
            }
            S = -1;
          }, this.readRenderTargetPixels = function(b, U, z, V, N, Q, ge) {
            if (!(b && b.isWebGLRenderTarget)) {
              console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
              return;
            }
            let ve = de.get(b).__webglFramebuffer;
            if (b.isWebGLCubeRenderTarget && ge !== void 0 && (ve = ve[ge]), ve) {
              oe.bindFramebuffer(P.FRAMEBUFFER, ve);
              try {
                const Se = b.texture, Ue = Se.format, Ne = Se.type;
                if (!Me.textureFormatReadable(Ue)) {
                  console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                  return;
                }
                if (!Me.textureTypeReadable(Ne)) {
                  console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                  return;
                }
                U >= 0 && U <= b.width - V && z >= 0 && z <= b.height - N && P.readPixels(U, z, V, N, He.convert(Ue), He.convert(Ne), Q);
              } finally {
                const Se = R !== null ? de.get(R).__webglFramebuffer : null;
                oe.bindFramebuffer(P.FRAMEBUFFER, Se);
              }
            }
          }, this.readRenderTargetPixelsAsync = async function(b, U, z, V, N, Q, ge) {
            if (!(b && b.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let ve = de.get(b).__webglFramebuffer;
            if (b.isWebGLCubeRenderTarget && ge !== void 0 && (ve = ve[ge]), ve) {
              const Se = b.texture, Ue = Se.format, Ne = Se.type;
              if (!Me.textureFormatReadable(Ue)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
              if (!Me.textureTypeReadable(Ne)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
              if (U >= 0 && U <= b.width - V && z >= 0 && z <= b.height - N) {
                oe.bindFramebuffer(P.FRAMEBUFFER, ve);
                const Oe = P.createBuffer();
                P.bindBuffer(P.PIXEL_PACK_BUFFER, Oe), P.bufferData(P.PIXEL_PACK_BUFFER, Q.byteLength, P.STREAM_READ), P.readPixels(U, z, V, N, He.convert(Ue), He.convert(Ne), 0);
                const tt = R !== null ? de.get(R).__webglFramebuffer : null;
                oe.bindFramebuffer(P.FRAMEBUFFER, tt);
                const dt = P.fenceSync(P.SYNC_GPU_COMMANDS_COMPLETE, 0);
                return P.flush(), await a_(P, dt, 4), P.bindBuffer(P.PIXEL_PACK_BUFFER, Oe), P.getBufferSubData(P.PIXEL_PACK_BUFFER, 0, Q), P.deleteBuffer(Oe), P.deleteSync(dt), Q;
              } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
            }
          }, this.copyFramebufferToTexture = function(b, U = null, z = 0) {
            b.isTexture !== true && (rs("WebGLRenderer: copyFramebufferToTexture function signature has changed."), U = arguments[0] || null, b = arguments[1]);
            const V = Math.pow(2, -z), N = Math.floor(b.image.width * V), Q = Math.floor(b.image.height * V), ge = U !== null ? U.x : 0, ve = U !== null ? U.y : 0;
            C.setTexture2D(b, 0), P.copyTexSubImage2D(P.TEXTURE_2D, z, 0, 0, ge, ve, N, Q), oe.unbindTexture();
          };
          const VE = P.createFramebuffer(), HE = P.createFramebuffer();
          this.copyTextureToTexture = function(b, U, z = null, V = null, N = 0, Q = null) {
            b.isTexture !== true && (rs("WebGLRenderer: copyTextureToTexture function signature has changed."), V = arguments[0] || null, b = arguments[1], U = arguments[2], Q = arguments[3] || 0, z = null), Q === null && (N !== 0 ? (rs("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), Q = N, N = 0) : Q = 0);
            let ge, ve, Se, Ue, Ne, Oe, tt, dt, Wt;
            const pt = b.isCompressedTexture ? b.mipmaps[Q] : b.image;
            if (z !== null) ge = z.max.x - z.min.x, ve = z.max.y - z.min.y, Se = z.isBox3 ? z.max.z - z.min.z : 1, Ue = z.min.x, Ne = z.min.y, Oe = z.isBox3 ? z.min.z : 0;
            else {
              const ki = Math.pow(2, -N);
              ge = Math.floor(pt.width * ki), ve = Math.floor(pt.height * ki), b.isDataArrayTexture ? Se = pt.depth : b.isData3DTexture ? Se = Math.floor(pt.depth * ki) : Se = 1, Ue = 0, Ne = 0, Oe = 0;
            }
            V !== null ? (tt = V.x, dt = V.y, Wt = V.z) : (tt = 0, dt = 0, Wt = 0);
            const vt = He.convert(U.format), Ce = He.convert(U.type);
            let pi;
            U.isData3DTexture ? (C.setTexture3D(U, 0), pi = P.TEXTURE_3D) : U.isDataArrayTexture || U.isCompressedArrayTexture ? (C.setTexture2DArray(U, 0), pi = P.TEXTURE_2D_ARRAY) : (C.setTexture2D(U, 0), pi = P.TEXTURE_2D), P.pixelStorei(P.UNPACK_FLIP_Y_WEBGL, U.flipY), P.pixelStorei(P.UNPACK_PREMULTIPLY_ALPHA_WEBGL, U.premultiplyAlpha), P.pixelStorei(P.UNPACK_ALIGNMENT, U.unpackAlignment);
            const Xr = P.getParameter(P.UNPACK_ROW_LENGTH), Zi = P.getParameter(P.UNPACK_IMAGE_HEIGHT), sa = P.getParameter(P.UNPACK_SKIP_PIXELS), Li = P.getParameter(P.UNPACK_SKIP_ROWS), ao = P.getParameter(P.UNPACK_SKIP_IMAGES);
            P.pixelStorei(P.UNPACK_ROW_LENGTH, pt.width), P.pixelStorei(P.UNPACK_IMAGE_HEIGHT, pt.height), P.pixelStorei(P.UNPACK_SKIP_PIXELS, Ue), P.pixelStorei(P.UNPACK_SKIP_ROWS, Ne), P.pixelStorei(P.UNPACK_SKIP_IMAGES, Oe);
            const Mt = b.isDataArrayTexture || b.isData3DTexture, zi = U.isDataArrayTexture || U.isData3DTexture;
            if (b.isDepthTexture) {
              const ki = de.get(b), $t = de.get(U), Ji = de.get(ki.__renderTarget), Fh = de.get($t.__renderTarget);
              oe.bindFramebuffer(P.READ_FRAMEBUFFER, Ji.__webglFramebuffer), oe.bindFramebuffer(P.DRAW_FRAMEBUFFER, Fh.__webglFramebuffer);
              for (let jr = 0; jr < Se; jr++) Mt && (P.framebufferTextureLayer(P.READ_FRAMEBUFFER, P.COLOR_ATTACHMENT0, de.get(b).__webglTexture, N, Oe + jr), P.framebufferTextureLayer(P.DRAW_FRAMEBUFFER, P.COLOR_ATTACHMENT0, de.get(U).__webglTexture, Q, Wt + jr)), P.blitFramebuffer(Ue, Ne, ge, ve, tt, dt, ge, ve, P.DEPTH_BUFFER_BIT, P.NEAREST);
              oe.bindFramebuffer(P.READ_FRAMEBUFFER, null), oe.bindFramebuffer(P.DRAW_FRAMEBUFFER, null);
            } else if (N !== 0 || b.isRenderTargetTexture || de.has(b)) {
              const ki = de.get(b), $t = de.get(U);
              oe.bindFramebuffer(P.READ_FRAMEBUFFER, VE), oe.bindFramebuffer(P.DRAW_FRAMEBUFFER, HE);
              for (let Ji = 0; Ji < Se; Ji++) Mt ? P.framebufferTextureLayer(P.READ_FRAMEBUFFER, P.COLOR_ATTACHMENT0, ki.__webglTexture, N, Oe + Ji) : P.framebufferTexture2D(P.READ_FRAMEBUFFER, P.COLOR_ATTACHMENT0, P.TEXTURE_2D, ki.__webglTexture, N), zi ? P.framebufferTextureLayer(P.DRAW_FRAMEBUFFER, P.COLOR_ATTACHMENT0, $t.__webglTexture, Q, Wt + Ji) : P.framebufferTexture2D(P.DRAW_FRAMEBUFFER, P.COLOR_ATTACHMENT0, P.TEXTURE_2D, $t.__webglTexture, Q), N !== 0 ? P.blitFramebuffer(Ue, Ne, ge, ve, tt, dt, ge, ve, P.COLOR_BUFFER_BIT, P.NEAREST) : zi ? P.copyTexSubImage3D(pi, Q, tt, dt, Wt + Ji, Ue, Ne, ge, ve) : P.copyTexSubImage2D(pi, Q, tt, dt, Ue, Ne, ge, ve);
              oe.bindFramebuffer(P.READ_FRAMEBUFFER, null), oe.bindFramebuffer(P.DRAW_FRAMEBUFFER, null);
            } else zi ? b.isDataTexture || b.isData3DTexture ? P.texSubImage3D(pi, Q, tt, dt, Wt, ge, ve, Se, vt, Ce, pt.data) : U.isCompressedArrayTexture ? P.compressedTexSubImage3D(pi, Q, tt, dt, Wt, ge, ve, Se, vt, pt.data) : P.texSubImage3D(pi, Q, tt, dt, Wt, ge, ve, Se, vt, Ce, pt) : b.isDataTexture ? P.texSubImage2D(P.TEXTURE_2D, Q, tt, dt, ge, ve, vt, Ce, pt.data) : b.isCompressedTexture ? P.compressedTexSubImage2D(P.TEXTURE_2D, Q, tt, dt, pt.width, pt.height, vt, pt.data) : P.texSubImage2D(P.TEXTURE_2D, Q, tt, dt, ge, ve, vt, Ce, pt);
            P.pixelStorei(P.UNPACK_ROW_LENGTH, Xr), P.pixelStorei(P.UNPACK_IMAGE_HEIGHT, Zi), P.pixelStorei(P.UNPACK_SKIP_PIXELS, sa), P.pixelStorei(P.UNPACK_SKIP_ROWS, Li), P.pixelStorei(P.UNPACK_SKIP_IMAGES, ao), Q === 0 && U.generateMipmaps && P.generateMipmap(pi), oe.unbindTexture();
          }, this.copyTextureToTexture3D = function(b, U, z = null, V = null, N = 0) {
            return b.isTexture !== true && (rs("WebGLRenderer: copyTextureToTexture3D function signature has changed."), z = arguments[0] || null, V = arguments[1] || null, b = arguments[2], U = arguments[3], N = arguments[4] || 0), rs('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(b, U, z, V, N);
          }, this.initRenderTarget = function(b) {
            de.get(b).__webglFramebuffer === void 0 && C.setupRenderTarget(b);
          }, this.initTexture = function(b) {
            b.isCubeTexture ? C.setTextureCube(b, 0) : b.isData3DTexture ? C.setTexture3D(b, 0) : b.isDataArrayTexture || b.isCompressedArrayTexture ? C.setTexture2DArray(b, 0) : C.setTexture2D(b, 0), oe.unbindTexture();
          }, this.resetState = function() {
            E = 0, w = 0, R = null, oe.reset(), _t.reset();
          }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
          }));
        }
        get coordinateSystem() {
          return gn;
        }
        get outputColorSpace() {
          return this._outputColorSpace;
        }
        set outputColorSpace(e) {
          this._outputColorSpace = e;
          const t = this.getContext();
          t.drawingBufferColorspace = Ke._getDrawingBufferColorSpace(e), t.unpackColorSpace = Ke._getUnpackColorSpace();
        }
      }
      function Jp(n, e) {
        if (e === Lg) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), n;
        if (e === _c || e === id) {
          let t = n.getIndex();
          if (t === null) {
            const a = [], o = n.getAttribute("position");
            if (o !== void 0) {
              for (let l = 0; l < o.count; l++) a.push(l);
              n.setIndex(a), t = n.getIndex();
            } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), n;
          }
          const i = t.count - 2, r = [];
          if (e === _c) for (let a = 1; a <= i; a++) r.push(t.getX(0)), r.push(t.getX(a)), r.push(t.getX(a + 1));
          else for (let a = 0; a < i; a++) a % 2 === 0 ? (r.push(t.getX(a)), r.push(t.getX(a + 1)), r.push(t.getX(a + 2))) : (r.push(t.getX(a + 2)), r.push(t.getX(a + 1)), r.push(t.getX(a)));
          r.length / 3 !== i && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
          const s = n.clone();
          return s.setIndex(r), s.clearGroups(), s;
        } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), n;
      }
      class FT extends _r {
        constructor(e) {
          super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
            return new HT(t);
          }), this.register(function(t) {
            return new GT(t);
          }), this.register(function(t) {
            return new $T(t);
          }), this.register(function(t) {
            return new QT(t);
          }), this.register(function(t) {
            return new eb(t);
          }), this.register(function(t) {
            return new XT(t);
          }), this.register(function(t) {
            return new jT(t);
          }), this.register(function(t) {
            return new qT(t);
          }), this.register(function(t) {
            return new YT(t);
          }), this.register(function(t) {
            return new VT(t);
          }), this.register(function(t) {
            return new KT(t);
          }), this.register(function(t) {
            return new WT(t);
          }), this.register(function(t) {
            return new JT(t);
          }), this.register(function(t) {
            return new ZT(t);
          }), this.register(function(t) {
            return new zT(t);
          }), this.register(function(t) {
            return new tb(t);
          }), this.register(function(t) {
            return new ib(t);
          });
        }
        load(e, t, i, r) {
          const s = this;
          let a;
          if (this.resourcePath !== "") a = this.resourcePath;
          else if (this.path !== "") {
            const c = Da.extractUrlBase(e);
            a = Da.resolveURL(c, this.path);
          } else a = Da.extractUrlBase(e);
          this.manager.itemStart(e);
          const o = function(c) {
            r ? r(c) : console.error(c), s.manager.itemError(e), s.manager.itemEnd(e);
          }, l = new cu(this.manager);
          l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(c) {
            try {
              s.parse(c, a, function(u) {
                t(u), s.manager.itemEnd(e);
              }, o);
            } catch (u) {
              o(u);
            }
          }, i, o);
        }
        setDRACOLoader(e) {
          return this.dracoLoader = e, this;
        }
        setKTX2Loader(e) {
          return this.ktx2Loader = e, this;
        }
        setMeshoptDecoder(e) {
          return this.meshoptDecoder = e, this;
        }
        register(e) {
          return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
        }
        unregister(e) {
          return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
        }
        parse(e, t, i, r) {
          let s;
          const a = {}, o = {}, l = new TextDecoder();
          if (typeof e == "string") s = JSON.parse(e);
          else if (e instanceof ArrayBuffer) if (l.decode(new Uint8Array(e, 0, 4)) === $p) {
            try {
              a[Xe.KHR_BINARY_GLTF] = new nb(e);
            } catch (u) {
              r && r(u);
              return;
            }
            s = JSON.parse(a[Xe.KHR_BINARY_GLTF].content);
          } else s = JSON.parse(l.decode(e));
          else s = e;
          if (s.asset === void 0 || s.asset.version[0] < 2) {
            r && r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return;
          }
          const c = new gb(s, {
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
          });
          c.fileLoader.setRequestHeader(this.requestHeader);
          for (let u = 0; u < this.pluginCallbacks.length; u++) {
            const h = this.pluginCallbacks[u](c);
            h.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), o[h.name] = h, a[h.name] = true;
          }
          if (s.extensionsUsed) for (let u = 0; u < s.extensionsUsed.length; ++u) {
            const h = s.extensionsUsed[u], d = s.extensionsRequired || [];
            switch (h) {
              case Xe.KHR_MATERIALS_UNLIT:
                a[h] = new kT();
                break;
              case Xe.KHR_DRACO_MESH_COMPRESSION:
                a[h] = new rb(s, this.dracoLoader);
                break;
              case Xe.KHR_TEXTURE_TRANSFORM:
                a[h] = new sb();
                break;
              case Xe.KHR_MESH_QUANTIZATION:
                a[h] = new ab();
                break;
              default:
                d.indexOf(h) >= 0 && o[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".');
            }
          }
          c.setExtensions(a), c.setPlugins(o), c.parse(i, r);
        }
        parseAsync(e, t) {
          const i = this;
          return new Promise(function(r, s) {
            i.parse(e, t, r, s);
          });
        }
      }
      function BT() {
        let n = {};
        return {
          get: function(e) {
            return n[e];
          },
          add: function(e, t) {
            n[e] = t;
          },
          remove: function(e) {
            delete n[e];
          },
          removeAll: function() {
            n = {};
          }
        };
      }
      const Xe = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
        KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
        EXT_MATERIALS_BUMP: "EXT_materials_bump",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_TEXTURE_AVIF: "EXT_texture_avif",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
        EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
      };
      class zT {
        constructor(e) {
          this.parser = e, this.name = Xe.KHR_LIGHTS_PUNCTUAL, this.cache = {
            refs: {},
            uses: {}
          };
        }
        _markDefs() {
          const e = this.parser, t = this.parser.json.nodes || [];
          for (let i = 0, r = t.length; i < r; i++) {
            const s = t[i];
            s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light);
          }
        }
        _loadLight(e) {
          const t = this.parser, i = "light:" + e;
          let r = t.cache.get(i);
          if (r) return r;
          const s = t.json, a = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
          let o;
          const l = new Ae(16777215);
          a.color !== void 0 && l.setRGB(a.color[0], a.color[1], a.color[2], oi);
          const c = a.range !== void 0 ? a.range : 0;
          switch (a.type) {
            case "directional":
              o = new gp(l), o.target.position.set(0, 0, -1), o.add(o.target);
              break;
            case "point":
              o = new pu(l), o.distance = c;
              break;
            case "spot":
              o = new zv(l), o.distance = c, a.spot = a.spot || {}, a.spot.innerConeAngle = a.spot.innerConeAngle !== void 0 ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = a.spot.outerConeAngle !== void 0 ? a.spot.outerConeAngle : Math.PI / 4, o.angle = a.spot.outerConeAngle, o.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, o.target.position.set(0, 0, -1), o.add(o.target);
              break;
            default:
              throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type);
          }
          return o.position.set(0, 0, 0), En(o, a), a.intensity !== void 0 && (o.intensity = a.intensity), o.name = t.createUniqueName(a.name || "light_" + e), r = Promise.resolve(o), t.cache.add(i, r), r;
        }
        getDependency(e, t) {
          if (e === "light") return this._loadLight(t);
        }
        createNodeAttachment(e) {
          const t = this, i = this.parser, r = i.json.nodes[e], s = (r.extensions && r.extensions[this.name] || {}).light;
          return s === void 0 ? null : this._loadLight(s).then(function(a) {
            return i._getNodeRef(t.cache, s, a);
          });
        }
      }
      class kT {
        constructor() {
          this.name = Xe.KHR_MATERIALS_UNLIT;
        }
        getMaterialType() {
          return tn;
        }
        extendParams(e, t, i) {
          const r = [];
          e.color = new Ae(1, 1, 1), e.opacity = 1;
          const s = t.pbrMetallicRoughness;
          if (s) {
            if (Array.isArray(s.baseColorFactor)) {
              const a = s.baseColorFactor;
              e.color.setRGB(a[0], a[1], a[2], oi), e.opacity = a[3];
            }
            s.baseColorTexture !== void 0 && r.push(i.assignTexture(e, "map", s.baseColorTexture, Kt));
          }
          return Promise.all(r);
        }
      }
      class VT {
        constructor(e) {
          this.parser = e, this.name = Xe.KHR_MATERIALS_EMISSIVE_STRENGTH;
        }
        extendMaterialParams(e, t) {
          const i = this.parser.json.materials[e];
          if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
          const r = i.extensions[this.name].emissiveStrength;
          return r !== void 0 && (t.emissiveIntensity = r), Promise.resolve();
        }
      }
      class HT {
        constructor(e) {
          this.parser = e, this.name = Xe.KHR_MATERIALS_CLEARCOAT;
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return !t.extensions || !t.extensions[this.name] ? null : rn;
        }
        extendMaterialParams(e, t) {
          const i = this.parser, r = i.json.materials[e];
          if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
          const s = [], a = r.extensions[this.name];
          if (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor), a.clearcoatTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), a.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), a.clearcoatRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), a.clearcoatNormalTexture !== void 0 && (s.push(i.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), a.clearcoatNormalTexture.scale !== void 0)) {
            const o = a.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new ee(o, o);
          }
          return Promise.all(s);
        }
      }
      class GT {
        constructor(e) {
          this.parser = e, this.name = Xe.KHR_MATERIALS_DISPERSION;
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return !t.extensions || !t.extensions[this.name] ? null : rn;
        }
        extendMaterialParams(e, t) {
          const i = this.parser.json.materials[e];
          if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
          const r = i.extensions[this.name];
          return t.dispersion = r.dispersion !== void 0 ? r.dispersion : 0, Promise.resolve();
        }
      }
      class WT {
        constructor(e) {
          this.parser = e, this.name = Xe.KHR_MATERIALS_IRIDESCENCE;
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return !t.extensions || !t.extensions[this.name] ? null : rn;
        }
        extendMaterialParams(e, t) {
          const i = this.parser, r = i.json.materials[e];
          if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
          const s = [], a = r.extensions[this.name];
          return a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor), a.iridescenceTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceMap", a.iridescenceTexture)), a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [
            100,
            400
          ]), a.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), a.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), a.iridescenceThicknessTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(s);
        }
      }
      class XT {
        constructor(e) {
          this.parser = e, this.name = Xe.KHR_MATERIALS_SHEEN;
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return !t.extensions || !t.extensions[this.name] ? null : rn;
        }
        extendMaterialParams(e, t) {
          const i = this.parser, r = i.json.materials[e];
          if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
          const s = [];
          t.sheenColor = new Ae(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
          const a = r.extensions[this.name];
          if (a.sheenColorFactor !== void 0) {
            const o = a.sheenColorFactor;
            t.sheenColor.setRGB(o[0], o[1], o[2], oi);
          }
          return a.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = a.sheenRoughnessFactor), a.sheenColorTexture !== void 0 && s.push(i.assignTexture(t, "sheenColorMap", a.sheenColorTexture, Kt)), a.sheenRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(s);
        }
      }
      class jT {
        constructor(e) {
          this.parser = e, this.name = Xe.KHR_MATERIALS_TRANSMISSION;
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return !t.extensions || !t.extensions[this.name] ? null : rn;
        }
        extendMaterialParams(e, t) {
          const i = this.parser, r = i.json.materials[e];
          if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
          const s = [], a = r.extensions[this.name];
          return a.transmissionFactor !== void 0 && (t.transmission = a.transmissionFactor), a.transmissionTexture !== void 0 && s.push(i.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(s);
        }
      }
      class qT {
        constructor(e) {
          this.parser = e, this.name = Xe.KHR_MATERIALS_VOLUME;
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return !t.extensions || !t.extensions[this.name] ? null : rn;
        }
        extendMaterialParams(e, t) {
          const i = this.parser, r = i.json.materials[e];
          if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
          const s = [], a = r.extensions[this.name];
          t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0, a.thicknessTexture !== void 0 && s.push(i.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 1 / 0;
          const o = a.attenuationColor || [
            1,
            1,
            1
          ];
          return t.attenuationColor = new Ae().setRGB(o[0], o[1], o[2], oi), Promise.all(s);
        }
      }
      class YT {
        constructor(e) {
          this.parser = e, this.name = Xe.KHR_MATERIALS_IOR;
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return !t.extensions || !t.extensions[this.name] ? null : rn;
        }
        extendMaterialParams(e, t) {
          const i = this.parser.json.materials[e];
          if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
          const r = i.extensions[this.name];
          return t.ior = r.ior !== void 0 ? r.ior : 1.5, Promise.resolve();
        }
      }
      class KT {
        constructor(e) {
          this.parser = e, this.name = Xe.KHR_MATERIALS_SPECULAR;
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return !t.extensions || !t.extensions[this.name] ? null : rn;
        }
        extendMaterialParams(e, t) {
          const i = this.parser, r = i.json.materials[e];
          if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
          const s = [], a = r.extensions[this.name];
          t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1, a.specularTexture !== void 0 && s.push(i.assignTexture(t, "specularIntensityMap", a.specularTexture));
          const o = a.specularColorFactor || [
            1,
            1,
            1
          ];
          return t.specularColor = new Ae().setRGB(o[0], o[1], o[2], oi), a.specularColorTexture !== void 0 && s.push(i.assignTexture(t, "specularColorMap", a.specularColorTexture, Kt)), Promise.all(s);
        }
      }
      class ZT {
        constructor(e) {
          this.parser = e, this.name = Xe.EXT_MATERIALS_BUMP;
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return !t.extensions || !t.extensions[this.name] ? null : rn;
        }
        extendMaterialParams(e, t) {
          const i = this.parser, r = i.json.materials[e];
          if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
          const s = [], a = r.extensions[this.name];
          return t.bumpScale = a.bumpFactor !== void 0 ? a.bumpFactor : 1, a.bumpTexture !== void 0 && s.push(i.assignTexture(t, "bumpMap", a.bumpTexture)), Promise.all(s);
        }
      }
      class JT {
        constructor(e) {
          this.parser = e, this.name = Xe.KHR_MATERIALS_ANISOTROPY;
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return !t.extensions || !t.extensions[this.name] ? null : rn;
        }
        extendMaterialParams(e, t) {
          const i = this.parser, r = i.json.materials[e];
          if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
          const s = [], a = r.extensions[this.name];
          return a.anisotropyStrength !== void 0 && (t.anisotropy = a.anisotropyStrength), a.anisotropyRotation !== void 0 && (t.anisotropyRotation = a.anisotropyRotation), a.anisotropyTexture !== void 0 && s.push(i.assignTexture(t, "anisotropyMap", a.anisotropyTexture)), Promise.all(s);
        }
      }
      class $T {
        constructor(e) {
          this.parser = e, this.name = Xe.KHR_TEXTURE_BASISU;
        }
        loadTexture(e) {
          const t = this.parser, i = t.json, r = i.textures[e];
          if (!r.extensions || !r.extensions[this.name]) return null;
          const s = r.extensions[this.name], a = t.options.ktx2Loader;
          if (!a) {
            if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null;
          }
          return t.loadTextureImage(e, s.source, a);
        }
      }
      class QT {
        constructor(e) {
          this.parser = e, this.name = Xe.EXT_TEXTURE_WEBP, this.isSupported = null;
        }
        loadTexture(e) {
          const t = this.name, i = this.parser, r = i.json, s = r.textures[e];
          if (!s.extensions || !s.extensions[t]) return null;
          const a = s.extensions[t], o = r.images[a.source];
          let l = i.textureLoader;
          if (o.uri) {
            const c = i.options.manager.getHandler(o.uri);
            c !== null && (l = c);
          }
          return this.detectSupport().then(function(c) {
            if (c) return i.loadTextureImage(e, a.source, l);
            if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return i.loadTexture(e);
          });
        }
        detectSupport() {
          return this.isSupported || (this.isSupported = new Promise(function(e) {
            const t = new Image();
            t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
              e(t.height === 1);
            };
          })), this.isSupported;
        }
      }
      class eb {
        constructor(e) {
          this.parser = e, this.name = Xe.EXT_TEXTURE_AVIF, this.isSupported = null;
        }
        loadTexture(e) {
          const t = this.name, i = this.parser, r = i.json, s = r.textures[e];
          if (!s.extensions || !s.extensions[t]) return null;
          const a = s.extensions[t], o = r.images[a.source];
          let l = i.textureLoader;
          if (o.uri) {
            const c = i.options.manager.getHandler(o.uri);
            c !== null && (l = c);
          }
          return this.detectSupport().then(function(c) {
            if (c) return i.loadTextureImage(e, a.source, l);
            if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
            return i.loadTexture(e);
          });
        }
        detectSupport() {
          return this.isSupported || (this.isSupported = new Promise(function(e) {
            const t = new Image();
            t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
              e(t.height === 1);
            };
          })), this.isSupported;
        }
      }
      class tb {
        constructor(e) {
          this.name = Xe.EXT_MESHOPT_COMPRESSION, this.parser = e;
        }
        loadBufferView(e) {
          const t = this.parser.json, i = t.bufferViews[e];
          if (i.extensions && i.extensions[this.name]) {
            const r = i.extensions[this.name], s = this.parser.getDependency("buffer", r.buffer), a = this.parser.options.meshoptDecoder;
            if (!a || !a.supported) {
              if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
              return null;
            }
            return s.then(function(o) {
              const l = r.byteOffset || 0, c = r.byteLength || 0, u = r.count, h = r.byteStride, d = new Uint8Array(o, l, c);
              return a.decodeGltfBufferAsync ? a.decodeGltfBufferAsync(u, h, d, r.mode, r.filter).then(function(p) {
                return p.buffer;
              }) : a.ready.then(function() {
                const p = new ArrayBuffer(u * h);
                return a.decodeGltfBuffer(new Uint8Array(p), u, h, d, r.mode, r.filter), p;
              });
            });
          } else return null;
        }
      }
      class ib {
        constructor(e) {
          this.name = Xe.EXT_MESH_GPU_INSTANCING, this.parser = e;
        }
        createNodeMesh(e) {
          const t = this.parser.json, i = t.nodes[e];
          if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0) return null;
          const r = t.meshes[i.mesh];
          for (const l of r.primitives) if (l.mode !== Ui.TRIANGLES && l.mode !== Ui.TRIANGLE_STRIP && l.mode !== Ui.TRIANGLE_FAN && l.mode !== void 0) return null;
          const s = i.extensions[this.name].attributes, a = [], o = {};
          for (const l in s) a.push(this.parser.getDependency("accessor", s[l]).then((c) => (o[l] = c, o[l])));
          return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then((l) => {
            const c = l.pop(), u = c.isGroup ? c.children : [
              c
            ], h = l[0].count, d = [];
            for (const p of u) {
              const f = new Fe(), _ = new D(), g = new Vn(), m = new D(1, 1, 1), y = new B_(p.geometry, p.material, h);
              for (let x = 0; x < h; x++) o.TRANSLATION && _.fromBufferAttribute(o.TRANSLATION, x), o.ROTATION && g.fromBufferAttribute(o.ROTATION, x), o.SCALE && m.fromBufferAttribute(o.SCALE, x), y.setMatrixAt(x, f.compose(_, g, m));
              for (const x in o) if (x === "_COLOR_0") {
                const v = o[x];
                y.instanceColor = new Xc(v.array, v.itemSize, v.normalized);
              } else x !== "TRANSLATION" && x !== "ROTATION" && x !== "SCALE" && p.geometry.setAttribute(x, o[x]);
              Tt.prototype.copy.call(y, p), this.parser.assignFinalMaterial(y), d.push(y);
            }
            return c.isGroup ? (c.clear(), c.add(...d), c) : d[0];
          }));
        }
      }
      const $p = "glTF", Na = 12, Qp = {
        JSON: 1313821514,
        BIN: 5130562
      };
      class nb {
        constructor(e) {
          this.name = Xe.KHR_BINARY_GLTF, this.content = null, this.body = null;
          const t = new DataView(e, 0, Na), i = new TextDecoder();
          if (this.header = {
            magic: i.decode(new Uint8Array(e.slice(0, 4))),
            version: t.getUint32(4, true),
            length: t.getUint32(8, true)
          }, this.header.magic !== $p) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
          if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
          const r = this.header.length - Na, s = new DataView(e, Na);
          let a = 0;
          for (; a < r; ) {
            const o = s.getUint32(a, true);
            a += 4;
            const l = s.getUint32(a, true);
            if (a += 4, l === Qp.JSON) {
              const c = new Uint8Array(e, Na + a, o);
              this.content = i.decode(c);
            } else if (l === Qp.BIN) {
              const c = Na + a;
              this.body = e.slice(c, c + o);
            }
            a += o;
          }
          if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
      }
      class rb {
        constructor(e, t) {
          if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
          this.name = Xe.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
        }
        decodePrimitive(e, t) {
          const i = this.json, r = this.dracoLoader, s = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes, o = {}, l = {}, c = {};
          for (const u in a) {
            const h = wu[u] || u.toLowerCase();
            o[h] = a[u];
          }
          for (const u in e.attributes) {
            const h = wu[u] || u.toLowerCase();
            if (a[u] !== void 0) {
              const d = i.accessors[e.attributes[u]], p = Ls[d.componentType];
              c[h] = p.name, l[h] = d.normalized === true;
            }
          }
          return t.getDependency("bufferView", s).then(function(u) {
            return new Promise(function(h, d) {
              r.decodeDracoFile(u, function(p) {
                for (const f in p.attributes) {
                  const _ = p.attributes[f], g = l[f];
                  g !== void 0 && (_.normalized = g);
                }
                h(p);
              }, o, c, oi, d);
            });
          });
        }
      }
      class sb {
        constructor() {
          this.name = Xe.KHR_TEXTURE_TRANSFORM;
        }
        extendTexture(e, t) {
          return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = true), e;
        }
      }
      class ab {
        constructor() {
          this.name = Xe.KHR_MESH_QUANTIZATION;
        }
      }
      class ef extends Pa {
        constructor(e, t, i, r) {
          super(e, t, i, r);
        }
        copySampleValue_(e) {
          const t = this.resultBuffer, i = this.sampleValues, r = this.valueSize, s = e * r * 3 + r;
          for (let a = 0; a !== r; a++) t[a] = i[s + a];
          return t;
        }
        interpolate_(e, t, i, r) {
          const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = o * 2, c = o * 3, u = r - t, h = (i - t) / u, d = h * h, p = d * h, f = e * c, _ = f - c, g = -2 * p + 3 * d, m = p - d, y = 1 - g, x = m - d + h;
          for (let v = 0; v !== o; v++) {
            const A = a[_ + v + o], E = a[_ + v + l] * u, w = a[f + v + o], R = a[f + v] * u;
            s[v] = y * A + x * E + g * w + m * R;
          }
          return s;
        }
      }
      const ob = new Vn();
      class lb extends ef {
        interpolate_(e, t, i, r) {
          const s = super.interpolate_(e, t, i, r);
          return ob.fromArray(s).normalize().toArray(s), s;
        }
      }
      const Ui = {
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6
      }, Ls = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
      }, tf = {
        9728: ai,
        9729: Mi,
        9984: Gh,
        9985: co,
        9986: ca,
        9987: pn
      }, nf = {
        33071: zn,
        33648: lo,
        10497: Jr
      }, Eu = {
        SCALAR: 1,
        VEC2: 2,
        VEC3: 3,
        VEC4: 4,
        MAT2: 4,
        MAT3: 9,
        MAT4: 16
      }, wu = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        TEXCOORD_0: "uv",
        TEXCOORD_1: "uv1",
        TEXCOORD_2: "uv2",
        TEXCOORD_3: "uv3",
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
      }, Zn = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
      }, cb = {
        CUBICSPLINE: void 0,
        LINEAR: da,
        STEP: ha
      }, Au = {
        OPAQUE: "OPAQUE",
        MASK: "MASK",
        BLEND: "BLEND"
      };
      function ub(n) {
        return n.DefaultMaterial === void 0 && (n.DefaultMaterial = new Ts({
          color: 16777215,
          emissive: 0,
          metalness: 1,
          roughness: 1,
          transparent: false,
          depthTest: true,
          side: ft
        })), n.DefaultMaterial;
      }
      function br(n, e, t) {
        for (const i in t.extensions) n[i] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = t.extensions[i]);
      }
      function En(n, e) {
        e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(n.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
      }
      function hb(n, e, t) {
        let i = false, r = false, s = false;
        for (let c = 0, u = e.length; c < u; c++) {
          const h = e[c];
          if (h.POSITION !== void 0 && (i = true), h.NORMAL !== void 0 && (r = true), h.COLOR_0 !== void 0 && (s = true), i && r && s) break;
        }
        if (!i && !r && !s) return Promise.resolve(n);
        const a = [], o = [], l = [];
        for (let c = 0, u = e.length; c < u; c++) {
          const h = e[c];
          if (i) {
            const d = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : n.attributes.position;
            a.push(d);
          }
          if (r) {
            const d = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : n.attributes.normal;
            o.push(d);
          }
          if (s) {
            const d = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : n.attributes.color;
            l.push(d);
          }
        }
        return Promise.all([
          Promise.all(a),
          Promise.all(o),
          Promise.all(l)
        ]).then(function(c) {
          const u = c[0], h = c[1], d = c[2];
          return i && (n.morphAttributes.position = u), r && (n.morphAttributes.normal = h), s && (n.morphAttributes.color = d), n.morphTargetsRelative = true, n;
        });
      }
      function db(n, e) {
        if (n.updateMorphTargets(), e.weights !== void 0) for (let t = 0, i = e.weights.length; t < i; t++) n.morphTargetInfluences[t] = e.weights[t];
        if (e.extras && Array.isArray(e.extras.targetNames)) {
          const t = e.extras.targetNames;
          if (n.morphTargetInfluences.length === t.length) {
            n.morphTargetDictionary = {};
            for (let i = 0, r = t.length; i < r; i++) n.morphTargetDictionary[t[i]] = i;
          } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
        }
      }
      function pb(n) {
        let e;
        const t = n.extensions && n.extensions[Xe.KHR_DRACO_MESH_COMPRESSION];
        if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + Ru(t.attributes) : e = n.indices + ":" + Ru(n.attributes) + ":" + n.mode, n.targets !== void 0) for (let i = 0, r = n.targets.length; i < r; i++) e += ":" + Ru(n.targets[i]);
        return e;
      }
      function Ru(n) {
        let e = "";
        const t = Object.keys(n).sort();
        for (let i = 0, r = t.length; i < r; i++) e += t[i] + ":" + n[t[i]] + ";";
        return e;
      }
      function Cu(n) {
        switch (n) {
          case Int8Array:
            return 1 / 127;
          case Uint8Array:
            return 1 / 255;
          case Int16Array:
            return 1 / 32767;
          case Uint16Array:
            return 1 / 65535;
          default:
            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
        }
      }
      function fb(n) {
        return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0 ? "image/webp" : n.search(/\.ktx2($|\?)/i) > 0 || n.search(/^data\:image\/ktx2/) === 0 ? "image/ktx2" : "image/png";
      }
      const mb = new Fe();
      class gb {
        constructor(e = {}, t = {}) {
          this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new BT(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
            refs: {},
            uses: {}
          }, this.cameraCache = {
            refs: {},
            uses: {}
          }, this.lightCache = {
            refs: {},
            uses: {}
          }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
          let i = false, r = -1, s = false, a = -1;
          if (typeof navigator < "u") {
            const o = navigator.userAgent;
            i = /^((?!chrome|android).)*safari/i.test(o) === true;
            const l = o.match(/Version\/(\d+)/);
            r = i && l ? parseInt(l[1], 10) : -1, s = o.indexOf("Firefox") > -1, a = s ? o.match(/Firefox\/([0-9]+)\./)[1] : -1;
          }
          typeof createImageBitmap > "u" || i && r < 17 || s && a < 98 ? this.textureLoader = new Fv(this.options.manager) : this.textureLoader = new Hv(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new cu(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(true);
        }
        setExtensions(e) {
          this.extensions = e;
        }
        setPlugins(e) {
          this.plugins = e;
        }
        parse(e, t) {
          const i = this, r = this.json, s = this.extensions;
          this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(a) {
            return a._markDefs && a._markDefs();
          }), Promise.all(this._invokeAll(function(a) {
            return a.beforeRoot && a.beforeRoot();
          })).then(function() {
            return Promise.all([
              i.getDependencies("scene"),
              i.getDependencies("animation"),
              i.getDependencies("camera")
            ]);
          }).then(function(a) {
            const o = {
              scene: a[0][r.scene || 0],
              scenes: a[0],
              animations: a[1],
              cameras: a[2],
              asset: r.asset,
              parser: i,
              userData: {}
            };
            return br(s, o, r), En(o, r), Promise.all(i._invokeAll(function(l) {
              return l.afterRoot && l.afterRoot(o);
            })).then(function() {
              for (const l of o.scenes) l.updateMatrixWorld();
              e(o);
            });
          }).catch(t);
        }
        _markDefs() {
          const e = this.json.nodes || [], t = this.json.skins || [], i = this.json.meshes || [];
          for (let r = 0, s = t.length; r < s; r++) {
            const a = t[r].joints;
            for (let o = 0, l = a.length; o < l; o++) e[a[o]].isBone = true;
          }
          for (let r = 0, s = e.length; r < s; r++) {
            const a = e[r];
            a.mesh !== void 0 && (this._addNodeRef(this.meshCache, a.mesh), a.skin !== void 0 && (i[a.mesh].isSkinnedMesh = true)), a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
          }
        }
        _addNodeRef(e, t) {
          t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
        }
        _getNodeRef(e, t, i) {
          if (e.refs[t] <= 1) return i;
          const r = i.clone(), s = (a, o) => {
            const l = this.associations.get(a);
            l != null && this.associations.set(o, l);
            for (const [c, u] of a.children.entries()) s(u, o.children[c]);
          };
          return s(i, r), r.name += "_instance_" + e.uses[t]++, r;
        }
        _invokeOne(e) {
          const t = Object.values(this.plugins);
          t.push(this);
          for (let i = 0; i < t.length; i++) {
            const r = e(t[i]);
            if (r) return r;
          }
          return null;
        }
        _invokeAll(e) {
          const t = Object.values(this.plugins);
          t.unshift(this);
          const i = [];
          for (let r = 0; r < t.length; r++) {
            const s = e(t[r]);
            s && i.push(s);
          }
          return i;
        }
        getDependency(e, t) {
          const i = e + ":" + t;
          let r = this.cache.get(i);
          if (!r) {
            switch (e) {
              case "scene":
                r = this.loadScene(t);
                break;
              case "node":
                r = this._invokeOne(function(s) {
                  return s.loadNode && s.loadNode(t);
                });
                break;
              case "mesh":
                r = this._invokeOne(function(s) {
                  return s.loadMesh && s.loadMesh(t);
                });
                break;
              case "accessor":
                r = this.loadAccessor(t);
                break;
              case "bufferView":
                r = this._invokeOne(function(s) {
                  return s.loadBufferView && s.loadBufferView(t);
                });
                break;
              case "buffer":
                r = this.loadBuffer(t);
                break;
              case "material":
                r = this._invokeOne(function(s) {
                  return s.loadMaterial && s.loadMaterial(t);
                });
                break;
              case "texture":
                r = this._invokeOne(function(s) {
                  return s.loadTexture && s.loadTexture(t);
                });
                break;
              case "skin":
                r = this.loadSkin(t);
                break;
              case "animation":
                r = this._invokeOne(function(s) {
                  return s.loadAnimation && s.loadAnimation(t);
                });
                break;
              case "camera":
                r = this.loadCamera(t);
                break;
              default:
                if (r = this._invokeOne(function(s) {
                  return s != this && s.getDependency && s.getDependency(e, t);
                }), !r) throw new Error("Unknown type: " + e);
                break;
            }
            this.cache.add(i, r);
          }
          return r;
        }
        getDependencies(e) {
          let t = this.cache.get(e);
          if (!t) {
            const i = this, r = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            t = Promise.all(r.map(function(s, a) {
              return i.getDependency(e, a);
            })), this.cache.add(e, t);
          }
          return t;
        }
        loadBuffer(e) {
          const t = this.json.buffers[e], i = this.fileLoader;
          if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
          if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[Xe.KHR_BINARY_GLTF].body);
          const r = this.options;
          return new Promise(function(s, a) {
            i.load(Da.resolveURL(t.uri, r.path), s, void 0, function() {
              a(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
            });
          });
        }
        loadBufferView(e) {
          const t = this.json.bufferViews[e];
          return this.getDependency("buffer", t.buffer).then(function(i) {
            const r = t.byteLength || 0, s = t.byteOffset || 0;
            return i.slice(s, s + r);
          });
        }
        loadAccessor(e) {
          const t = this, i = this.json, r = this.json.accessors[e];
          if (r.bufferView === void 0 && r.sparse === void 0) {
            const a = Eu[r.type], o = Ls[r.componentType], l = r.normalized === true, c = new o(r.count * a);
            return Promise.resolve(new li(c, a, l));
          }
          const s = [];
          return r.bufferView !== void 0 ? s.push(this.getDependency("bufferView", r.bufferView)) : s.push(null), r.sparse !== void 0 && (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", r.sparse.values.bufferView))), Promise.all(s).then(function(a) {
            const o = a[0], l = Eu[r.type], c = Ls[r.componentType], u = c.BYTES_PER_ELEMENT, h = u * l, d = r.byteOffset || 0, p = r.bufferView !== void 0 ? i.bufferViews[r.bufferView].byteStride : void 0, f = r.normalized === true;
            let _, g;
            if (p && p !== h) {
              const m = Math.floor(d / p), y = "InterleavedBuffer:" + r.bufferView + ":" + r.componentType + ":" + m + ":" + r.count;
              let x = t.cache.get(y);
              x || (_ = new c(o, m * p, r.count * p / u), x = new I_(_, p / u), t.cache.add(y, x)), g = new Vc(x, l, d % p / u, f);
            } else o === null ? _ = new c(r.count * l) : _ = new c(o, d, r.count * l), g = new li(_, l, f);
            if (r.sparse !== void 0) {
              const m = Eu.SCALAR, y = Ls[r.sparse.indices.componentType], x = r.sparse.indices.byteOffset || 0, v = r.sparse.values.byteOffset || 0, A = new y(a[1], x, r.sparse.count * m), E = new c(a[2], v, r.sparse.count * l);
              o !== null && (g = new li(g.array.slice(), g.itemSize, g.normalized)), g.normalized = false;
              for (let w = 0, R = A.length; w < R; w++) {
                const S = A[w];
                if (g.setX(S, E[w * l]), l >= 2 && g.setY(S, E[w * l + 1]), l >= 3 && g.setZ(S, E[w * l + 2]), l >= 4 && g.setW(S, E[w * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
              }
              g.normalized = f;
            }
            return g;
          });
        }
        loadTexture(e) {
          const t = this.json, i = this.options, r = t.textures[e].source, s = t.images[r];
          let a = this.textureLoader;
          if (s.uri) {
            const o = i.manager.getHandler(s.uri);
            o !== null && (a = o);
          }
          return this.loadTextureImage(e, r, a);
        }
        loadTextureImage(e, t, i) {
          const r = this, s = this.json, a = s.textures[e], o = s.images[t], l = (o.uri || o.bufferView) + ":" + a.sampler;
          if (this.textureCache[l]) return this.textureCache[l];
          const c = this.loadImageSource(t, i).then(function(u) {
            u.flipY = false, u.name = a.name || o.name || "", u.name === "" && typeof o.uri == "string" && o.uri.startsWith("data:image/") === false && (u.name = o.uri);
            const h = (s.samplers || {})[a.sampler] || {};
            return u.magFilter = tf[h.magFilter] || Mi, u.minFilter = tf[h.minFilter] || pn, u.wrapS = nf[h.wrapS] || Jr, u.wrapT = nf[h.wrapT] || Jr, u.generateMipmaps = !u.isCompressedTexture && u.minFilter !== ai && u.minFilter !== Mi, r.associations.set(u, {
              textures: e
            }), u;
          }).catch(function() {
            return null;
          });
          return this.textureCache[l] = c, c;
        }
        loadImageSource(e, t) {
          const i = this, r = this.json, s = this.options;
          if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then((h) => h.clone());
          const a = r.images[e], o = self.URL || self.webkitURL;
          let l = a.uri || "", c = false;
          if (a.bufferView !== void 0) l = i.getDependency("bufferView", a.bufferView).then(function(h) {
            c = true;
            const d = new Blob([
              h
            ], {
              type: a.mimeType
            });
            return l = o.createObjectURL(d), l;
          });
          else if (a.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
          const u = Promise.resolve(l).then(function(h) {
            return new Promise(function(d, p) {
              let f = d;
              t.isImageBitmapLoader === true && (f = function(_) {
                const g = new kt(_);
                g.needsUpdate = true, d(g);
              }), t.load(Da.resolveURL(h, s.path), f, void 0, p);
            });
          }).then(function(h) {
            return c === true && o.revokeObjectURL(l), En(h, a), h.userData.mimeType = a.mimeType || fb(a.uri), h;
          }).catch(function(h) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", l), h;
          });
          return this.sourceCache[e] = u, u;
        }
        assignTexture(e, t, i, r) {
          const s = this;
          return this.getDependency("texture", i.index).then(function(a) {
            if (!a) return null;
            if (i.texCoord !== void 0 && i.texCoord > 0 && (a = a.clone(), a.channel = i.texCoord), s.extensions[Xe.KHR_TEXTURE_TRANSFORM]) {
              const o = i.extensions !== void 0 ? i.extensions[Xe.KHR_TEXTURE_TRANSFORM] : void 0;
              if (o) {
                const l = s.associations.get(a);
                a = s.extensions[Xe.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), s.associations.set(a, l);
              }
            }
            return r !== void 0 && (a.colorSpace = r), e[t] = a, a;
          });
        }
        assignFinalMaterial(e) {
          const t = e.geometry;
          let i = e.material;
          const r = t.attributes.tangent === void 0, s = t.attributes.color !== void 0, a = t.attributes.normal === void 0;
          if (e.isPoints) {
            const o = "PointsMaterial:" + i.uuid;
            let l = this.cache.get(o);
            l || (l = new Zc(), en.prototype.copy.call(l, i), l.color.copy(i.color), l.map = i.map, l.sizeAttenuation = false, this.cache.add(o, l)), i = l;
          } else if (e.isLine) {
            const o = "LineBasicMaterial:" + i.uuid;
            let l = this.cache.get(o);
            l || (l = new Wd(), en.prototype.copy.call(l, i), l.color.copy(i.color), l.map = i.map, this.cache.add(o, l)), i = l;
          }
          if (r || s || a) {
            let o = "ClonedMaterial:" + i.uuid + ":";
            r && (o += "derivative-tangents:"), s && (o += "vertex-colors:"), a && (o += "flat-shading:");
            let l = this.cache.get(o);
            l || (l = i.clone(), s && (l.vertexColors = true), a && (l.flatShading = true), r && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(o, l), this.associations.set(l, this.associations.get(i))), i = l;
          }
          e.material = i;
        }
        getMaterialType() {
          return Ts;
        }
        loadMaterial(e) {
          const t = this, i = this.json, r = this.extensions, s = i.materials[e];
          let a;
          const o = {}, l = s.extensions || {}, c = [];
          if (l[Xe.KHR_MATERIALS_UNLIT]) {
            const h = r[Xe.KHR_MATERIALS_UNLIT];
            a = h.getMaterialType(), c.push(h.extendParams(o, s, t));
          } else {
            const h = s.pbrMetallicRoughness || {};
            if (o.color = new Ae(1, 1, 1), o.opacity = 1, Array.isArray(h.baseColorFactor)) {
              const d = h.baseColorFactor;
              o.color.setRGB(d[0], d[1], d[2], oi), o.opacity = d[3];
            }
            h.baseColorTexture !== void 0 && c.push(t.assignTexture(o, "map", h.baseColorTexture, Kt)), o.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, o.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(o, "metalnessMap", h.metallicRoughnessTexture)), c.push(t.assignTexture(o, "roughnessMap", h.metallicRoughnessTexture))), a = this._invokeOne(function(d) {
              return d.getMaterialType && d.getMaterialType(e);
            }), c.push(Promise.all(this._invokeAll(function(d) {
              return d.extendMaterialParams && d.extendMaterialParams(e, o);
            })));
          }
          s.doubleSided === true && (o.side = fi);
          const u = s.alphaMode || Au.OPAQUE;
          if (u === Au.BLEND ? (o.transparent = true, o.depthWrite = false) : (o.transparent = false, u === Au.MASK && (o.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)), s.normalTexture !== void 0 && a !== tn && (c.push(t.assignTexture(o, "normalMap", s.normalTexture)), o.normalScale = new ee(1, 1), s.normalTexture.scale !== void 0)) {
            const h = s.normalTexture.scale;
            o.normalScale.set(h, h);
          }
          if (s.occlusionTexture !== void 0 && a !== tn && (c.push(t.assignTexture(o, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && a !== tn) {
            const h = s.emissiveFactor;
            o.emissive = new Ae().setRGB(h[0], h[1], h[2], oi);
          }
          return s.emissiveTexture !== void 0 && a !== tn && c.push(t.assignTexture(o, "emissiveMap", s.emissiveTexture, Kt)), Promise.all(c).then(function() {
            const h = new a(o);
            return s.name && (h.name = s.name), En(h, s), t.associations.set(h, {
              materials: e
            }), s.extensions && br(r, h, s), h;
          });
        }
        createUniqueName(e) {
          const t = ot.sanitizeNodeName(e || "");
          return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
        }
        loadGeometries(e) {
          const t = this, i = this.extensions, r = this.primitiveCache;
          function s(o) {
            return i[Xe.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o, t).then(function(l) {
              return rf(l, o, t);
            });
          }
          const a = [];
          for (let o = 0, l = e.length; o < l; o++) {
            const c = e[o], u = pb(c), h = r[u];
            if (h) a.push(h.promise);
            else {
              let d;
              c.extensions && c.extensions[Xe.KHR_DRACO_MESH_COMPRESSION] ? d = s(c) : d = rf(new mi(), c, t), r[u] = {
                primitive: c,
                promise: d
              }, a.push(d);
            }
          }
          return Promise.all(a);
        }
        loadMesh(e) {
          const t = this, i = this.json, r = this.extensions, s = i.meshes[e], a = s.primitives, o = [];
          for (let l = 0, c = a.length; l < c; l++) {
            const u = a[l].material === void 0 ? ub(this.cache) : this.getDependency("material", a[l].material);
            o.push(u);
          }
          return o.push(t.loadGeometries(a)), Promise.all(o).then(function(l) {
            const c = l.slice(0, l.length - 1), u = l[l.length - 1], h = [];
            for (let p = 0, f = u.length; p < f; p++) {
              const _ = u[p], g = a[p];
              let m;
              const y = c[p];
              if (g.mode === Ui.TRIANGLES || g.mode === Ui.TRIANGLE_STRIP || g.mode === Ui.TRIANGLE_FAN || g.mode === void 0) m = s.isSkinnedMesh === true ? new U_(_, y) : new Dt(_, y), m.isSkinnedMesh === true && m.normalizeSkinWeights(), g.mode === Ui.TRIANGLE_STRIP ? m.geometry = Jp(m.geometry, id) : g.mode === Ui.TRIANGLE_FAN && (m.geometry = Jp(m.geometry, _c));
              else if (g.mode === Ui.LINES) m = new V_(_, y);
              else if (g.mode === Ui.LINE_STRIP) m = new Kc(_, y);
              else if (g.mode === Ui.LINE_LOOP) m = new H_(_, y);
              else if (g.mode === Ui.POINTS) m = new Zd(_, y);
              else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + g.mode);
              Object.keys(m.geometry.morphAttributes).length > 0 && db(m, s), m.name = t.createUniqueName(s.name || "mesh_" + e), En(m, s), g.extensions && br(r, m, g), t.assignFinalMaterial(m), h.push(m);
            }
            for (let p = 0, f = h.length; p < f; p++) t.associations.set(h[p], {
              meshes: e,
              primitives: p
            });
            if (h.length === 1) return s.extensions && br(r, h[0], s), h[0];
            const d = new Yn();
            s.extensions && br(r, d, s), t.associations.set(d, {
              meshes: e
            });
            for (let p = 0, f = h.length; p < f; p++) d.add(h[p]);
            return d;
          });
        }
        loadCamera(e) {
          let t;
          const i = this.json.cameras[e], r = i[i.type];
          if (!r) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return;
          }
          return i.type === "perspective" ? t = new ui(r_.radToDeg(r.yfov), r.aspectRatio || 1, r.znear || 1, r.zfar || 2e6) : i.type === "orthographic" && (t = new Jo(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)), i.name && (t.name = this.createUniqueName(i.name)), En(t, i), Promise.resolve(t);
        }
        loadSkin(e) {
          const t = this.json.skins[e], i = [];
          for (let r = 0, s = t.joints.length; r < s; r++) i.push(this._loadNodeShallow(t.joints[r]));
          return t.inverseBindMatrices !== void 0 ? i.push(this.getDependency("accessor", t.inverseBindMatrices)) : i.push(null), Promise.all(i).then(function(r) {
            const s = r.pop(), a = r, o = [], l = [];
            for (let c = 0, u = a.length; c < u; c++) {
              const h = a[c];
              if (h) {
                o.push(h);
                const d = new Fe();
                s !== null && d.fromArray(s.array, c * 16), l.push(d);
              } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]);
            }
            return new Wc(o, l);
          });
        }
        loadAnimation(e) {
          const t = this.json, i = this, r = t.animations[e], s = r.name ? r.name : "animation_" + e, a = [], o = [], l = [], c = [], u = [];
          for (let h = 0, d = r.channels.length; h < d; h++) {
            const p = r.channels[h], f = r.samplers[p.sampler], _ = p.target, g = _.node, m = r.parameters !== void 0 ? r.parameters[f.input] : f.input, y = r.parameters !== void 0 ? r.parameters[f.output] : f.output;
            _.node !== void 0 && (a.push(this.getDependency("node", g)), o.push(this.getDependency("accessor", m)), l.push(this.getDependency("accessor", y)), c.push(f), u.push(_));
          }
          return Promise.all([
            Promise.all(a),
            Promise.all(o),
            Promise.all(l),
            Promise.all(c),
            Promise.all(u)
          ]).then(function(h) {
            const d = h[0], p = h[1], f = h[2], _ = h[3], g = h[4], m = [];
            for (let y = 0, x = d.length; y < x; y++) {
              const v = d[y], A = p[y], E = f[y], w = _[y], R = g[y];
              if (v === void 0) continue;
              v.updateMatrix && v.updateMatrix();
              const S = i._createAnimationTracks(v, A, E, w, R);
              if (S) for (let T = 0; T < S.length; T++) m.push(S[T]);
            }
            return new Pv(s, void 0, m);
          });
        }
        createNodeMesh(e) {
          const t = this.json, i = this, r = t.nodes[e];
          return r.mesh === void 0 ? null : i.getDependency("mesh", r.mesh).then(function(s) {
            const a = i._getNodeRef(i.meshCache, r.mesh, s);
            return r.weights !== void 0 && a.traverse(function(o) {
              if (o.isMesh) for (let l = 0, c = r.weights.length; l < c; l++) o.morphTargetInfluences[l] = r.weights[l];
            }), a;
          });
        }
        loadNode(e) {
          const t = this.json, i = this, r = t.nodes[e], s = i._loadNodeShallow(e), a = [], o = r.children || [];
          for (let c = 0, u = o.length; c < u; c++) a.push(i.getDependency("node", o[c]));
          const l = r.skin === void 0 ? Promise.resolve(null) : i.getDependency("skin", r.skin);
          return Promise.all([
            s,
            Promise.all(a),
            l
          ]).then(function(c) {
            const u = c[0], h = c[1], d = c[2];
            d !== null && u.traverse(function(p) {
              p.isSkinnedMesh && p.bind(d, mb);
            });
            for (let p = 0, f = h.length; p < f; p++) u.add(h[p]);
            return u;
          });
        }
        _loadNodeShallow(e) {
          const t = this.json, i = this.extensions, r = this;
          if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
          const s = t.nodes[e], a = s.name ? r.createUniqueName(s.name) : "", o = [], l = r._invokeOne(function(c) {
            return c.createNodeMesh && c.createNodeMesh(e);
          });
          return l && o.push(l), s.camera !== void 0 && o.push(r.getDependency("camera", s.camera).then(function(c) {
            return r._getNodeRef(r.cameraCache, s.camera, c);
          })), r._invokeAll(function(c) {
            return c.createNodeAttachment && c.createNodeAttachment(e);
          }).forEach(function(c) {
            o.push(c);
          }), this.nodeCache[e] = Promise.all(o).then(function(c) {
            let u;
            if (s.isBone === true ? u = new zd() : c.length > 1 ? u = new Yn() : c.length === 1 ? u = c[0] : u = new Tt(), u !== c[0]) for (let h = 0, d = c.length; h < d; h++) u.add(c[h]);
            if (s.name && (u.userData.name = s.name, u.name = a), En(u, s), s.extensions && br(i, u, s), s.matrix !== void 0) {
              const h = new Fe();
              h.fromArray(s.matrix), u.applyMatrix4(h);
            } else s.translation !== void 0 && u.position.fromArray(s.translation), s.rotation !== void 0 && u.quaternion.fromArray(s.rotation), s.scale !== void 0 && u.scale.fromArray(s.scale);
            return r.associations.has(u) || r.associations.set(u, {}), r.associations.get(u).nodes = e, u;
          }), this.nodeCache[e];
        }
        loadScene(e) {
          const t = this.extensions, i = this.json.scenes[e], r = this, s = new Yn();
          i.name && (s.name = r.createUniqueName(i.name)), En(s, i), i.extensions && br(t, s, i);
          const a = i.nodes || [], o = [];
          for (let l = 0, c = a.length; l < c; l++) o.push(r.getDependency("node", a[l]));
          return Promise.all(o).then(function(l) {
            for (let u = 0, h = l.length; u < h; u++) s.add(l[u]);
            const c = (u) => {
              const h = /* @__PURE__ */ new Map();
              for (const [d, p] of r.associations) (d instanceof en || d instanceof kt) && h.set(d, p);
              return u.traverse((d) => {
                const p = r.associations.get(d);
                p != null && h.set(d, p);
              }), h;
            };
            return r.associations = c(s), s;
          });
        }
        _createAnimationTracks(e, t, i, r, s) {
          const a = [], o = e.name ? e.name : e.uuid, l = [];
          Zn[s.path] === Zn.weights ? e.traverse(function(d) {
            d.morphTargetInfluences && l.push(d.name ? d.name : d.uuid);
          }) : l.push(o);
          let c;
          switch (Zn[s.path]) {
            case Zn.weights:
              c = Ss;
              break;
            case Zn.rotation:
              c = Es;
              break;
            case Zn.position:
            case Zn.scale:
              c = As;
              break;
            default:
              switch (i.itemSize) {
                case 1:
                  c = Ss;
                  break;
                case 2:
                case 3:
                default:
                  c = As;
                  break;
              }
              break;
          }
          const u = r.interpolation !== void 0 ? cb[r.interpolation] : da, h = this._getArrayFromAccessor(i);
          for (let d = 0, p = l.length; d < p; d++) {
            const f = new c(l[d] + "." + Zn[s.path], t.array, h, u);
            r.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(f), a.push(f);
          }
          return a;
        }
        _getArrayFromAccessor(e) {
          let t = e.array;
          if (e.normalized) {
            const i = Cu(t.constructor), r = new Float32Array(t.length);
            for (let s = 0, a = t.length; s < a; s++) r[s] = t[s] * i;
            t = r;
          }
          return t;
        }
        _createCubicSplineTrackInterpolant(e) {
          e.createInterpolant = function(t) {
            const i = this instanceof Es ? lb : ef;
            return new i(this.times, this.values, this.getValueSize() / 3, t);
          }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
        }
      }
      function _b(n, e, t) {
        const i = e.attributes, r = new vn();
        if (i.POSITION !== void 0) {
          const o = t.json.accessors[i.POSITION], l = o.min, c = o.max;
          if (l !== void 0 && c !== void 0) {
            if (r.set(new D(l[0], l[1], l[2]), new D(c[0], c[1], c[2])), o.normalized) {
              const u = Cu(Ls[o.componentType]);
              r.min.multiplyScalar(u), r.max.multiplyScalar(u);
            }
          } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return;
          }
        } else return;
        const s = e.targets;
        if (s !== void 0) {
          const o = new D(), l = new D();
          for (let c = 0, u = s.length; c < u; c++) {
            const h = s[c];
            if (h.POSITION !== void 0) {
              const d = t.json.accessors[h.POSITION], p = d.min, f = d.max;
              if (p !== void 0 && f !== void 0) {
                if (l.setX(Math.max(Math.abs(p[0]), Math.abs(f[0]))), l.setY(Math.max(Math.abs(p[1]), Math.abs(f[1]))), l.setZ(Math.max(Math.abs(p[2]), Math.abs(f[2]))), d.normalized) {
                  const _ = Cu(Ls[d.componentType]);
                  l.multiplyScalar(_);
                }
                o.max(l);
              } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            }
          }
          r.expandByVector(o);
        }
        n.boundingBox = r;
        const a = new $i();
        r.getCenter(a.center), a.radius = r.min.distanceTo(r.max) / 2, n.boundingSphere = a;
      }
      function rf(n, e, t) {
        const i = e.attributes, r = [];
        function s(a, o) {
          return t.getDependency("accessor", a).then(function(l) {
            n.setAttribute(o, l);
          });
        }
        for (const a in i) {
          const o = wu[a] || a.toLowerCase();
          o in n.attributes || r.push(s(i[a], o));
        }
        if (e.indices !== void 0 && !n.index) {
          const a = t.getDependency("accessor", e.indices).then(function(o) {
            n.setIndex(o);
          });
          r.push(a);
        }
        return Ke.workingColorSpace !== oi && "COLOR_0" in i && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Ke.workingColorSpace}" not supported.`), En(n, e), _b(n, e, t), Promise.all(r).then(function() {
          return e.targets !== void 0 ? hb(n, e.targets, t) : n;
        });
      }
      class Pu extends _r {
        constructor(e) {
          super(e);
        }
        load(e, t, i, r) {
          const s = this, a = new cu(this.manager);
          a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(o) {
            const l = s.parse(JSON.parse(o));
            t && t(l);
          }, i, r);
        }
        parse(e) {
          return new vb(e);
        }
      }
      class vb {
        constructor(e) {
          this.isFont = true, this.type = "Font", this.data = e;
        }
        generateShapes(e, t = 100) {
          const i = [], r = xb(e, t, this.data);
          for (let s = 0, a = r.length; s < a; s++) i.push(...r[s].toShapes());
          return i;
        }
      }
      function xb(n, e, t) {
        const i = Array.from(n), r = e / t.resolution, s = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * r, a = [];
        let o = 0, l = 0;
        for (let c = 0; c < i.length; c++) {
          const u = i[c];
          if (u === `
`) o = 0, l -= s;
          else {
            const h = yb(u, r, o, l, t);
            o += h.offsetX, a.push(h.path);
          }
        }
        return a;
      }
      function yb(n, e, t, i, r) {
        const s = r.glyphs[n] || r.glyphs["?"];
        if (!s) {
          console.error('THREE.Font: character "' + n + '" does not exists in font family ' + r.familyName + ".");
          return;
        }
        const a = new e0();
        let o, l, c, u, h, d, p, f;
        if (s.o) {
          const _ = s._cachedOutline || (s._cachedOutline = s.o.split(" "));
          for (let g = 0, m = _.length; g < m; ) switch (_[g++]) {
            case "m":
              o = _[g++] * e + t, l = _[g++] * e + i, a.moveTo(o, l);
              break;
            case "l":
              o = _[g++] * e + t, l = _[g++] * e + i, a.lineTo(o, l);
              break;
            case "q":
              c = _[g++] * e + t, u = _[g++] * e + i, h = _[g++] * e + t, d = _[g++] * e + i, a.quadraticCurveTo(h, d, c, u);
              break;
            case "b":
              c = _[g++] * e + t, u = _[g++] * e + i, h = _[g++] * e + t, d = _[g++] * e + i, p = _[g++] * e + t, f = _[g++] * e + i, a.bezierCurveTo(h, d, p, f, c, u);
              break;
          }
        }
        return {
          offsetX: s.ha * e,
          path: a
        };
      }
      class Lu extends ou {
        constructor(e, t = {}) {
          const i = t.font;
          if (i === void 0) super();
          else {
            const r = i.generateShapes(e, t.size);
            t.depth === void 0 && (t.depth = 50), t.bevelThickness === void 0 && (t.bevelThickness = 10), t.bevelSize === void 0 && (t.bevelSize = 8), t.bevelEnabled === void 0 && (t.bevelEnabled = false), super(r, t);
          }
          this.type = "TextGeometry";
        }
      }
      function wn(n) {
        if (n === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return n;
      }
      function sf(n, e) {
        n.prototype = Object.create(e.prototype), n.prototype.constructor = n, n.__proto__ = e;
      }
      var Si = {
        autoSleep: 120,
        force3D: "auto",
        nullTargetWarn: 1,
        units: {
          lineHeight: ""
        }
      }, Ds = {
        duration: 0.5,
        overwrite: false,
        delay: 0
      }, Du, Jt, xt, on = 1e8, ii = 1 / on, Iu = Math.PI * 2, Mb = Iu / 4, Tb = 0, af = Math.sqrt, bb = Math.cos, Sb = Math.sin, Yt = function(n) {
        return typeof n == "string";
      }, Rt = function(n) {
        return typeof n == "function";
      }, An = function(n) {
        return typeof n == "number";
      }, Nu = function(n) {
        return typeof n > "u";
      }, ln = function(n) {
        return typeof n == "object";
      }, gi = function(n) {
        return n !== false;
      }, Uu = function() {
        return typeof window < "u";
      }, nl = function(n) {
        return Rt(n) || Yt(n);
      }, of = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {
      }, ni = Array.isArray, Ou = /(?:-?\.?\d|\.)+/gi, lf = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, Is = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, Fu = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, cf = /[+-]=-?[.\d]+/, uf = /[^,'"\[\]\s]+/gi, Eb = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, St, cn, Bu, zu, Ei = {}, rl = {}, hf, df = function(n) {
        return (rl = Us(n, Ei)) && xi;
      }, ku = function(n, e) {
        return console.warn("Invalid property", n, "set to", e, "Missing plugin? gsap.registerPlugin()");
      }, Ua = function(n, e) {
        return !e && console.warn(n);
      }, pf = function(n, e) {
        return n && (Ei[n] = e) && rl && (rl[n] = e) || Ei;
      }, Oa = function() {
        return 0;
      }, wb = {
        suppressEvents: true,
        isStart: true,
        kill: false
      }, sl = {
        suppressEvents: true,
        kill: false
      }, Ab = {
        suppressEvents: true
      }, Vu = {}, Jn = [], Hu = {}, ff, wi = {}, Gu = {}, mf = 30, al = [], Wu = "", Xu = function(n) {
        var e = n[0], t, i;
        if (ln(e) || Rt(e) || (n = [
          n
        ]), !(t = (e._gsap || {}).harness)) {
          for (i = al.length; i-- && !al[i].targetTest(e); ) ;
          t = al[i];
        }
        for (i = n.length; i--; ) n[i] && (n[i]._gsap || (n[i]._gsap = new Wf(n[i], t))) || n.splice(i, 1);
        return n;
      }, Sr = function(n) {
        return n._gsap || Xu(Fi(n))[0]._gsap;
      }, gf = function(n, e, t) {
        return (t = n[e]) && Rt(t) ? n[e]() : Nu(t) && n.getAttribute && n.getAttribute(e) || t;
      }, _i = function(n, e) {
        return (n = n.split(",")).forEach(e) || n;
      }, It = function(n) {
        return Math.round(n * 1e5) / 1e5 || 0;
      }, Ft = function(n) {
        return Math.round(n * 1e7) / 1e7 || 0;
      }, Ns = function(n, e) {
        var t = e.charAt(0), i = parseFloat(e.substr(2));
        return n = parseFloat(n), t === "+" ? n + i : t === "-" ? n - i : t === "*" ? n * i : n / i;
      }, Rb = function(n, e) {
        for (var t = e.length, i = 0; n.indexOf(e[i]) < 0 && ++i < t; ) ;
        return i < t;
      }, ol = function() {
        var n = Jn.length, e = Jn.slice(0), t, i;
        for (Hu = {}, Jn.length = 0, t = 0; t < n; t++) i = e[t], i && i._lazy && (i.render(i._lazy[0], i._lazy[1], true)._lazy = 0);
      }, _f = function(n, e, t, i) {
        Jn.length && !Jt && ol(), n.render(e, t, Jt && e < 0 && (n._initted || n._startAt)), Jn.length && !Jt && ol();
      }, vf = function(n) {
        var e = parseFloat(n);
        return (e || e === 0) && (n + "").match(uf).length < 2 ? e : Yt(n) ? n.trim() : n;
      }, xf = function(n) {
        return n;
      }, Ai = function(n, e) {
        for (var t in e) t in n || (n[t] = e[t]);
        return n;
      }, Cb = function(n) {
        return function(e, t) {
          for (var i in t) i in e || i === "duration" && n || i === "ease" || (e[i] = t[i]);
        };
      }, Us = function(n, e) {
        for (var t in e) n[t] = e[t];
        return n;
      }, yf = function n(e, t) {
        for (var i in t) i !== "__proto__" && i !== "constructor" && i !== "prototype" && (e[i] = ln(t[i]) ? n(e[i] || (e[i] = {}), t[i]) : t[i]);
        return e;
      }, ll = function(n, e) {
        var t = {}, i;
        for (i in n) i in e || (t[i] = n[i]);
        return t;
      }, Fa = function(n) {
        var e = n.parent || St, t = n.keyframes ? Cb(ni(n.keyframes)) : Ai;
        if (gi(n.inherit)) for (; e; ) t(n, e.vars.defaults), e = e.parent || e._dp;
        return n;
      }, Pb = function(n, e) {
        for (var t = n.length, i = t === e.length; i && t-- && n[t] === e[t]; ) ;
        return t < 0;
      }, Mf = function(n, e, t, i, r) {
        var s = n[i], a;
        if (r) for (a = e[r]; s && s[r] > a; ) s = s._prev;
        return s ? (e._next = s._next, s._next = e) : (e._next = n[t], n[t] = e), e._next ? e._next._prev = e : n[i] = e, e._prev = s, e.parent = e._dp = n, e;
      }, cl = function(n, e, t, i) {
        t === void 0 && (t = "_first"), i === void 0 && (i = "_last");
        var r = e._prev, s = e._next;
        r ? r._next = s : n[t] === e && (n[t] = s), s ? s._prev = r : n[i] === e && (n[i] = r), e._next = e._prev = e.parent = null;
      }, $n = function(n, e) {
        n.parent && (!e || n.parent.autoRemoveChildren) && n.parent.remove && n.parent.remove(n), n._act = 0;
      }, Er = function(n, e) {
        if (n && (!e || e._end > n._dur || e._start < 0)) for (var t = n; t; ) t._dirty = 1, t = t.parent;
        return n;
      }, Lb = function(n) {
        for (var e = n.parent; e && e.parent; ) e._dirty = 1, e.totalDuration(), e = e.parent;
        return n;
      }, ju = function(n, e, t, i) {
        return n._startAt && (Jt ? n._startAt.revert(sl) : n.vars.immediateRender && !n.vars.autoRevert || n._startAt.render(e, true, i));
      }, Db = function n(e) {
        return !e || e._ts && n(e.parent);
      }, Tf = function(n) {
        return n._repeat ? Os(n._tTime, n = n.duration() + n._rDelay) * n : 0;
      }, Os = function(n, e) {
        var t = Math.floor(n = Ft(n / e));
        return n && t === n ? t - 1 : t;
      }, ul = function(n, e) {
        return (n - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur);
      }, hl = function(n) {
        return n._end = Ft(n._start + (n._tDur / Math.abs(n._ts || n._rts || ii) || 0));
      }, dl = function(n, e) {
        var t = n._dp;
        return t && t.smoothChildTiming && n._ts && (n._start = Ft(t._time - (n._ts > 0 ? e / n._ts : ((n._dirty ? n.totalDuration() : n._tDur) - e) / -n._ts)), hl(n), t._dirty || Er(t, n)), n;
      }, bf = function(n, e) {
        var t;
        if ((e._time || !e._dur && e._initted || e._start < n._time && (e._dur || !e.add)) && (t = ul(n.rawTime(), e), (!e._dur || za(0, e.totalDuration(), t) - e._tTime > ii) && e.render(t, true)), Er(n, e)._dp && n._initted && n._time >= n._dur && n._ts) {
          if (n._dur < n.duration()) for (t = n; t._dp; ) t.rawTime() >= 0 && t.totalTime(t._tTime), t = t._dp;
          n._zTime = -1e-8;
        }
      }, un = function(n, e, t, i) {
        return e.parent && $n(e), e._start = Ft((An(t) ? t : t || n !== St ? Oi(n, t, e) : n._time) + e._delay), e._end = Ft(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)), Mf(n, e, "_first", "_last", n._sort ? "_start" : 0), qu(e) || (n._recent = e), i || bf(n, e), n._ts < 0 && dl(n, n._tTime), n;
      }, Sf = function(n, e) {
        return (Ei.ScrollTrigger || ku("scrollTrigger", e)) && Ei.ScrollTrigger.create(e, n);
      }, Ef = function(n, e, t, i, r) {
        if (ih(n, e, r), !n._initted) return 1;
        if (!t && n._pt && !Jt && (n._dur && n.vars.lazy !== false || !n._dur && n.vars.lazy) && ff !== Ci.frame) return Jn.push(n), n._lazy = [
          r,
          i
        ], 1;
      }, Ib = function n(e) {
        var t = e.parent;
        return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || n(t));
      }, qu = function(n) {
        var e = n.data;
        return e === "isFromStart" || e === "isStart";
      }, Nb = function(n, e, t, i) {
        var r = n.ratio, s = e < 0 || !e && (!n._start && Ib(n) && !(!n._initted && qu(n)) || (n._ts < 0 || n._dp._ts < 0) && !qu(n)) ? 0 : 1, a = n._rDelay, o = 0, l, c, u;
        if (a && n._repeat && (o = za(0, n._tDur, e), c = Os(o, a), n._yoyo && c & 1 && (s = 1 - s), c !== Os(n._tTime, a) && (r = 1 - s, n.vars.repeatRefresh && n._initted && n.invalidate())), s !== r || Jt || i || n._zTime === ii || !e && n._zTime) {
          if (!n._initted && Ef(n, e, i, t, o)) return;
          for (u = n._zTime, n._zTime = e || (t ? ii : 0), t || (t = e && !u), n.ratio = s, n._from && (s = 1 - s), n._time = 0, n._tTime = o, l = n._pt; l; ) l.r(s, l.d), l = l._next;
          e < 0 && ju(n, e, t, true), n._onUpdate && !t && Ri(n, "onUpdate"), o && n._repeat && !t && n.parent && Ri(n, "onRepeat"), (e >= n._tDur || e < 0) && n.ratio === s && (s && $n(n, 1), !t && !Jt && (Ri(n, s ? "onComplete" : "onReverseComplete", true), n._prom && n._prom()));
        } else n._zTime || (n._zTime = e);
      }, Ub = function(n, e, t) {
        var i;
        if (t > e) for (i = n._first; i && i._start <= t; ) {
          if (i.data === "isPause" && i._start > e) return i;
          i = i._next;
        }
        else for (i = n._last; i && i._start >= t; ) {
          if (i.data === "isPause" && i._start < e) return i;
          i = i._prev;
        }
      }, Fs = function(n, e, t, i) {
        var r = n._repeat, s = Ft(e) || 0, a = n._tTime / n._tDur;
        return a && !i && (n._time *= s / n._dur), n._dur = s, n._tDur = r ? r < 0 ? 1e10 : Ft(s * (r + 1) + n._rDelay * r) : s, a > 0 && !i && dl(n, n._tTime = n._tDur * a), n.parent && hl(n), t || Er(n.parent, n), n;
      }, wf = function(n) {
        return n instanceof di ? Er(n) : Fs(n, n._dur);
      }, Ob = {
        _start: 0,
        endTime: Oa,
        totalDuration: Oa
      }, Oi = function n(e, t, i) {
        var r = e.labels, s = e._recent || Ob, a = e.duration() >= on ? s.endTime(false) : e._dur, o, l, c;
        return Yt(t) && (isNaN(t) || t in r) ? (l = t.charAt(0), c = t.substr(-1) === "%", o = t.indexOf("="), l === "<" || l === ">" ? (o >= 0 && (t = t.replace(/=/, "")), (l === "<" ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (c ? (o < 0 ? s : i).totalDuration() / 100 : 1)) : o < 0 ? (t in r || (r[t] = a), r[t]) : (l = parseFloat(t.charAt(o - 1) + t.substr(o + 1)), c && i && (l = l / 100 * (ni(i) ? i[0] : i).totalDuration()), o > 1 ? n(e, t.substr(0, o - 1), i) + l : a + l)) : t == null ? a : +t;
      }, Ba = function(n, e, t) {
        var i = An(e[1]), r = (i ? 2 : 1) + (n < 2 ? 0 : 1), s = e[r], a, o;
        if (i && (s.duration = e[1]), s.parent = t, n) {
          for (a = s, o = t; o && !("immediateRender" in a); ) a = o.vars.defaults || {}, o = gi(o.vars.inherit) && o.parent;
          s.immediateRender = gi(a.immediateRender), n < 2 ? s.runBackwards = 1 : s.startAt = e[r - 1];
        }
        return new Bt(e[0], s, e[r + 1]);
      }, Qn = function(n, e) {
        return n || n === 0 ? e(n) : e;
      }, za = function(n, e, t) {
        return t < n ? n : t > e ? e : t;
      }, ri = function(n, e) {
        return !Yt(n) || !(e = Eb.exec(n)) ? "" : e[1];
      }, Fb = function(n, e, t) {
        return Qn(t, function(i) {
          return za(n, e, i);
        });
      }, Yu = [].slice, Af = function(n, e) {
        return n && ln(n) && "length" in n && (!e && !n.length || n.length - 1 in n && ln(n[0])) && !n.nodeType && n !== cn;
      }, Bb = function(n, e, t) {
        return t === void 0 && (t = []), n.forEach(function(i) {
          var r;
          return Yt(i) && !e || Af(i, 1) ? (r = t).push.apply(r, Fi(i)) : t.push(i);
        }) || t;
      }, Fi = function(n, e, t) {
        return xt && !e && xt.selector ? xt.selector(n) : Yt(n) && !t && (Bu || !zs()) ? Yu.call((e || zu).querySelectorAll(n), 0) : ni(n) ? Bb(n, t) : Af(n) ? Yu.call(n, 0) : n ? [
          n
        ] : [];
      }, Ku = function(n) {
        return n = Fi(n)[0] || Ua("Invalid scope") || {}, function(e) {
          var t = n.current || n.nativeElement || n;
          return Fi(e, t.querySelectorAll ? t : t === n ? Ua("Invalid scope") || zu.createElement("div") : n);
        };
      }, Rf = function(n) {
        return n.sort(function() {
          return 0.5 - Math.random();
        });
      }, Cf = function(n) {
        if (Rt(n)) return n;
        var e = ln(n) ? n : {
          each: n
        }, t = wr(e.ease), i = e.from || 0, r = parseFloat(e.base) || 0, s = {}, a = i > 0 && i < 1, o = isNaN(i) || a, l = e.axis, c = i, u = i;
        return Yt(i) ? c = u = {
          center: 0.5,
          edges: 0.5,
          end: 1
        }[i] || 0 : !a && o && (c = i[0], u = i[1]), function(h, d, p) {
          var f = (p || e).length, _ = s[f], g, m, y, x, v, A, E, w, R;
          if (!_) {
            if (R = e.grid === "auto" ? 0 : (e.grid || [
              1,
              on
            ])[1], !R) {
              for (E = -1e8; E < (E = p[R++].getBoundingClientRect().left) && R < f; ) ;
              R < f && R--;
            }
            for (_ = s[f] = [], g = o ? Math.min(R, f) * c - 0.5 : i % R, m = R === on ? 0 : o ? f * u / R - 0.5 : i / R | 0, E = 0, w = on, A = 0; A < f; A++) y = A % R - g, x = m - (A / R | 0), _[A] = v = l ? Math.abs(l === "y" ? x : y) : af(y * y + x * x), v > E && (E = v), v < w && (w = v);
            i === "random" && Rf(_), _.max = E - w, _.min = w, _.v = f = (parseFloat(e.amount) || parseFloat(e.each) * (R > f ? f - 1 : l ? l === "y" ? f / R : R : Math.max(R, f / R)) || 0) * (i === "edges" ? -1 : 1), _.b = f < 0 ? r - f : r, _.u = ri(e.amount || e.each) || 0, t = t && f < 0 ? Vf(t) : t;
          }
          return f = (_[h] - _.min) / _.max || 0, Ft(_.b + (t ? t(f) : f) * _.v) + _.u;
        };
      }, Zu = function(n) {
        var e = Math.pow(10, ((n + "").split(".")[1] || "").length);
        return function(t) {
          var i = Ft(Math.round(parseFloat(t) / n) * n * e);
          return (i - i % 1) / e + (An(t) ? 0 : ri(t));
        };
      }, Pf = function(n, e) {
        var t = ni(n), i, r;
        return !t && ln(n) && (i = t = n.radius || on, n.values ? (n = Fi(n.values), (r = !An(n[0])) && (i *= i)) : n = Zu(n.increment)), Qn(e, t ? Rt(n) ? function(s) {
          return r = n(s), Math.abs(r - s) <= i ? r : s;
        } : function(s) {
          for (var a = parseFloat(r ? s.x : s), o = parseFloat(r ? s.y : 0), l = on, c = 0, u = n.length, h, d; u--; ) r ? (h = n[u].x - a, d = n[u].y - o, h = h * h + d * d) : h = Math.abs(n[u] - a), h < l && (l = h, c = u);
          return c = !i || l <= i ? n[c] : s, r || c === s || An(s) ? c : c + ri(s);
        } : Zu(n));
      }, Lf = function(n, e, t, i) {
        return Qn(ni(n) ? !e : t === true ? !!(t = 0) : !i, function() {
          return ni(n) ? n[~~(Math.random() * n.length)] : (t = t || 1e-5) && (i = t < 1 ? Math.pow(10, (t + "").length - 2) : 1) && Math.floor(Math.round((n - t / 2 + Math.random() * (e - n + t * 0.99)) / t) * t * i) / i;
        });
      }, zb = function() {
        for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++) e[t] = arguments[t];
        return function(i) {
          return e.reduce(function(r, s) {
            return s(r);
          }, i);
        };
      }, kb = function(n, e) {
        return function(t) {
          return n(parseFloat(t)) + (e || ri(t));
        };
      }, Vb = function(n, e, t) {
        return If(n, e, 0, 1, t);
      }, Df = function(n, e, t) {
        return Qn(t, function(i) {
          return n[~~e(i)];
        });
      }, Hb = function n(e, t, i) {
        var r = t - e;
        return ni(e) ? Df(e, n(0, e.length), t) : Qn(i, function(s) {
          return (r + (s - e) % r) % r + e;
        });
      }, Gb = function n(e, t, i) {
        var r = t - e, s = r * 2;
        return ni(e) ? Df(e, n(0, e.length - 1), t) : Qn(i, function(a) {
          return a = (s + (a - e) % s) % s || 0, e + (a > r ? s - a : a);
        });
      }, ka = function(n) {
        for (var e = 0, t = "", i, r, s, a; ~(i = n.indexOf("random(", e)); ) s = n.indexOf(")", i), a = n.charAt(i + 7) === "[", r = n.substr(i + 7, s - i - 7).match(a ? uf : Ou), t += n.substr(e, i - e) + Lf(a ? r : +r[0], a ? 0 : +r[1], +r[2] || 1e-5), e = s + 1;
        return t + n.substr(e, n.length - e);
      }, If = function(n, e, t, i, r) {
        var s = e - n, a = i - t;
        return Qn(r, function(o) {
          return t + ((o - n) / s * a || 0);
        });
      }, Wb = function n(e, t, i, r) {
        var s = isNaN(e + t) ? 0 : function(p) {
          return (1 - p) * e + p * t;
        };
        if (!s) {
          var a = Yt(e), o = {}, l, c, u, h, d;
          if (i === true && (r = 1) && (i = null), a) e = {
            p: e
          }, t = {
            p: t
          };
          else if (ni(e) && !ni(t)) {
            for (u = [], h = e.length, d = h - 2, c = 1; c < h; c++) u.push(n(e[c - 1], e[c]));
            h--, s = function(p) {
              p *= h;
              var f = Math.min(d, ~~p);
              return u[f](p - f);
            }, i = t;
          } else r || (e = Us(ni(e) ? [] : {}, e));
          if (!u) {
            for (l in t) eh.call(o, e, l, "get", t[l]);
            s = function(p) {
              return sh(p, o) || (a ? e.p : e);
            };
          }
        }
        return Qn(i, s);
      }, Nf = function(n, e, t) {
        var i = n.labels, r = on, s, a, o;
        for (s in i) a = i[s] - e, a < 0 == !!t && a && r > (a = Math.abs(a)) && (o = s, r = a);
        return o;
      }, Ri = function(n, e, t) {
        var i = n.vars, r = i[e], s = xt, a = n._ctx, o, l, c;
        if (r) return o = i[e + "Params"], l = i.callbackScope || n, t && Jn.length && ol(), a && (xt = a), c = o ? r.apply(l, o) : r.call(l), xt = s, c;
      }, Va = function(n) {
        return $n(n), n.scrollTrigger && n.scrollTrigger.kill(!!Jt), n.progress() < 1 && Ri(n, "onInterrupt"), n;
      }, Bs, Uf = [], Of = function(n) {
        if (n) if (n = !n.name && n.default || n, Uu() || n.headless) {
          var e = n.name, t = Rt(n), i = e && !t && n.init ? function() {
            this._props = [];
          } : n, r = {
            init: Oa,
            render: sh,
            add: eh,
            kill: aS,
            modifier: sS,
            rawVars: 0
          }, s = {
            targetTest: 0,
            get: 0,
            getSetter: rh,
            aliases: {},
            register: 0
          };
          if (zs(), n !== i) {
            if (wi[e]) return;
            Ai(i, Ai(ll(n, r), s)), Us(i.prototype, Us(r, ll(n, s))), wi[i.prop = e] = i, n.targetTest && (al.push(i), Vu[e] = 1), e = (e === "css" ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin";
          }
          pf(e, i), n.register && n.register(xi, i, vi);
        } else Uf.push(n);
      }, mt = 255, Ha = {
        aqua: [
          0,
          mt,
          mt
        ],
        lime: [
          0,
          mt,
          0
        ],
        silver: [
          192,
          192,
          192
        ],
        black: [
          0,
          0,
          0
        ],
        maroon: [
          128,
          0,
          0
        ],
        teal: [
          0,
          128,
          128
        ],
        blue: [
          0,
          0,
          mt
        ],
        navy: [
          0,
          0,
          128
        ],
        white: [
          mt,
          mt,
          mt
        ],
        olive: [
          128,
          128,
          0
        ],
        yellow: [
          mt,
          mt,
          0
        ],
        orange: [
          mt,
          165,
          0
        ],
        gray: [
          128,
          128,
          128
        ],
        purple: [
          128,
          0,
          128
        ],
        green: [
          0,
          128,
          0
        ],
        red: [
          mt,
          0,
          0
        ],
        pink: [
          mt,
          192,
          203
        ],
        cyan: [
          0,
          mt,
          mt
        ],
        transparent: [
          mt,
          mt,
          mt,
          0
        ]
      }, Ju = function(n, e, t) {
        return n += n < 0 ? 1 : n > 1 ? -1 : 0, (n * 6 < 1 ? e + (t - e) * n * 6 : n < 0.5 ? t : n * 3 < 2 ? e + (t - e) * (2 / 3 - n) * 6 : e) * mt + 0.5 | 0;
      }, Ff = function(n, e, t) {
        var i = n ? An(n) ? [
          n >> 16,
          n >> 8 & mt,
          n & mt
        ] : 0 : Ha.black, r, s, a, o, l, c, u, h, d, p;
        if (!i) {
          if (n.substr(-1) === "," && (n = n.substr(0, n.length - 1)), Ha[n]) i = Ha[n];
          else if (n.charAt(0) === "#") {
            if (n.length < 6 && (r = n.charAt(1), s = n.charAt(2), a = n.charAt(3), n = "#" + r + r + s + s + a + a + (n.length === 5 ? n.charAt(4) + n.charAt(4) : "")), n.length === 9) return i = parseInt(n.substr(1, 6), 16), [
              i >> 16,
              i >> 8 & mt,
              i & mt,
              parseInt(n.substr(7), 16) / 255
            ];
            n = parseInt(n.substr(1), 16), i = [
              n >> 16,
              n >> 8 & mt,
              n & mt
            ];
          } else if (n.substr(0, 3) === "hsl") {
            if (i = p = n.match(Ou), !e) o = +i[0] % 360 / 360, l = +i[1] / 100, c = +i[2] / 100, s = c <= 0.5 ? c * (l + 1) : c + l - c * l, r = c * 2 - s, i.length > 3 && (i[3] *= 1), i[0] = Ju(o + 1 / 3, r, s), i[1] = Ju(o, r, s), i[2] = Ju(o - 1 / 3, r, s);
            else if (~n.indexOf("=")) return i = n.match(lf), t && i.length < 4 && (i[3] = 1), i;
          } else i = n.match(Ou) || Ha.transparent;
          i = i.map(Number);
        }
        return e && !p && (r = i[0] / mt, s = i[1] / mt, a = i[2] / mt, u = Math.max(r, s, a), h = Math.min(r, s, a), c = (u + h) / 2, u === h ? o = l = 0 : (d = u - h, l = c > 0.5 ? d / (2 - u - h) : d / (u + h), o = u === r ? (s - a) / d + (s < a ? 6 : 0) : u === s ? (a - r) / d + 2 : (r - s) / d + 4, o *= 60), i[0] = ~~(o + 0.5), i[1] = ~~(l * 100 + 0.5), i[2] = ~~(c * 100 + 0.5)), t && i.length < 4 && (i[3] = 1), i;
      }, Bf = function(n) {
        var e = [], t = [], i = -1;
        return n.split(er).forEach(function(r) {
          var s = r.match(Is) || [];
          e.push.apply(e, s), t.push(i += s.length + 1);
        }), e.c = t, e;
      }, zf = function(n, e, t) {
        var i = "", r = (n + i).match(er), s = e ? "hsla(" : "rgba(", a = 0, o, l, c, u;
        if (!r) return n;
        if (r = r.map(function(h) {
          return (h = Ff(h, e, 1)) && s + (e ? h[0] + "," + h[1] + "%," + h[2] + "%," + h[3] : h.join(",")) + ")";
        }), t && (c = Bf(n), o = t.c, o.join(i) !== c.c.join(i))) for (l = n.replace(er, "1").split(Is), u = l.length - 1; a < u; a++) i += l[a] + (~o.indexOf(a) ? r.shift() || s + "0,0,0,0)" : (c.length ? c : r.length ? r : t).shift());
        if (!l) for (l = n.split(er), u = l.length - 1; a < u; a++) i += l[a] + r[a];
        return i + l[u];
      }, er = function() {
        var n = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e;
        for (e in Ha) n += "|" + e + "\\b";
        return new RegExp(n + ")", "gi");
      }(), Xb = /hsl[a]?\(/, kf = function(n) {
        var e = n.join(" "), t;
        if (er.lastIndex = 0, er.test(e)) return t = Xb.test(e), n[1] = zf(n[1], t), n[0] = zf(n[0], t, Bf(n[1])), true;
      }, Ga, Ci = function() {
        var n = Date.now, e = 500, t = 33, i = n(), r = i, s = 1e3 / 240, a = s, o = [], l, c, u, h, d, p, f = function _(g) {
          var m = n() - r, y = g === true, x, v, A, E;
          if ((m > e || m < 0) && (i += m - t), r += m, A = r - i, x = A - a, (x > 0 || y) && (E = ++h.frame, d = A - h.time * 1e3, h.time = A = A / 1e3, a += x + (x >= s ? 4 : s - x), v = 1), y || (l = c(_)), v) for (p = 0; p < o.length; p++) o[p](A, d, E, g);
        };
        return h = {
          time: 0,
          frame: 0,
          tick: function() {
            f(true);
          },
          deltaRatio: function(_) {
            return d / (1e3 / (_ || 60));
          },
          wake: function() {
            hf && (!Bu && Uu() && (cn = Bu = window, zu = cn.document || {}, Ei.gsap = xi, (cn.gsapVersions || (cn.gsapVersions = [])).push(xi.version), df(rl || cn.GreenSockGlobals || !cn.gsap && cn || {}), Uf.forEach(Of)), u = typeof requestAnimationFrame < "u" && requestAnimationFrame, l && h.sleep(), c = u || function(_) {
              return setTimeout(_, a - h.time * 1e3 + 1 | 0);
            }, Ga = 1, f(2));
          },
          sleep: function() {
            (u ? cancelAnimationFrame : clearTimeout)(l), Ga = 0, c = Oa;
          },
          lagSmoothing: function(_, g) {
            e = _ || 1 / 0, t = Math.min(g || 33, e);
          },
          fps: function(_) {
            s = 1e3 / (_ || 240), a = h.time * 1e3 + s;
          },
          add: function(_, g, m) {
            var y = g ? function(x, v, A, E) {
              _(x, v, A, E), h.remove(y);
            } : _;
            return h.remove(_), o[m ? "unshift" : "push"](y), zs(), y;
          },
          remove: function(_, g) {
            ~(g = o.indexOf(_)) && o.splice(g, 1) && p >= g && p--;
          },
          _listeners: o
        }, h;
      }(), zs = function() {
        return !Ga && Ci.wake();
      }, qe = {}, jb = /^[\d.\-M][\d.\-,\s]/, qb = /["']/g, Yb = function(n) {
        for (var e = {}, t = n.substr(1, n.length - 3).split(":"), i = t[0], r = 1, s = t.length, a, o, l; r < s; r++) o = t[r], a = r !== s - 1 ? o.lastIndexOf(",") : o.length, l = o.substr(0, a), e[i] = isNaN(l) ? l.replace(qb, "").trim() : +l, i = o.substr(a + 1).trim();
        return e;
      }, Kb = function(n) {
        var e = n.indexOf("(") + 1, t = n.indexOf(")"), i = n.indexOf("(", e);
        return n.substring(e, ~i && i < t ? n.indexOf(")", t + 1) : t);
      }, Zb = function(n) {
        var e = (n + "").split("("), t = qe[e[0]];
        return t && e.length > 1 && t.config ? t.config.apply(null, ~n.indexOf("{") ? [
          Yb(e[1])
        ] : Kb(n).split(",").map(vf)) : qe._CE && jb.test(n) ? qe._CE("", n) : t;
      }, Vf = function(n) {
        return function(e) {
          return 1 - n(1 - e);
        };
      }, Hf = function n(e, t) {
        for (var i = e._first, r; i; ) i instanceof di ? n(i, t) : i.vars.yoyoEase && (!i._yoyo || !i._repeat) && i._yoyo !== t && (i.timeline ? n(i.timeline, t) : (r = i._ease, i._ease = i._yEase, i._yEase = r, i._yoyo = t)), i = i._next;
      }, wr = function(n, e) {
        return n && (Rt(n) ? n : qe[n] || Zb(n)) || e;
      }, Ar = function(n, e, t, i) {
        t === void 0 && (t = function(a) {
          return 1 - e(1 - a);
        }), i === void 0 && (i = function(a) {
          return a < 0.5 ? e(a * 2) / 2 : 1 - e((1 - a) * 2) / 2;
        });
        var r = {
          easeIn: e,
          easeOut: t,
          easeInOut: i
        }, s;
        return _i(n, function(a) {
          qe[a] = Ei[a] = r, qe[s = a.toLowerCase()] = t;
          for (var o in r) qe[s + (o === "easeIn" ? ".in" : o === "easeOut" ? ".out" : ".inOut")] = qe[a + "." + o] = r[o];
        }), r;
      }, Gf = function(n) {
        return function(e) {
          return e < 0.5 ? (1 - n(1 - e * 2)) / 2 : 0.5 + n((e - 0.5) * 2) / 2;
        };
      }, $u = function n(e, t, i) {
        var r = t >= 1 ? t : 1, s = (i || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1), a = s / Iu * (Math.asin(1 / r) || 0), o = function(c) {
          return c === 1 ? 1 : r * Math.pow(2, -10 * c) * Sb((c - a) * s) + 1;
        }, l = e === "out" ? o : e === "in" ? function(c) {
          return 1 - o(1 - c);
        } : Gf(o);
        return s = Iu / s, l.config = function(c, u) {
          return n(e, c, u);
        }, l;
      }, Qu = function n(e, t) {
        t === void 0 && (t = 1.70158);
        var i = function(s) {
          return s ? --s * s * ((t + 1) * s + t) + 1 : 0;
        }, r = e === "out" ? i : e === "in" ? function(s) {
          return 1 - i(1 - s);
        } : Gf(i);
        return r.config = function(s) {
          return n(e, s);
        }, r;
      };
      _i("Linear,Quad,Cubic,Quart,Quint,Strong", function(n, e) {
        var t = e < 5 ? e + 1 : e;
        Ar(n + ",Power" + (t - 1), e ? function(i) {
          return Math.pow(i, t);
        } : function(i) {
          return i;
        }, function(i) {
          return 1 - Math.pow(1 - i, t);
        }, function(i) {
          return i < 0.5 ? Math.pow(i * 2, t) / 2 : 1 - Math.pow((1 - i) * 2, t) / 2;
        });
      }), qe.Linear.easeNone = qe.none = qe.Linear.easeIn, Ar("Elastic", $u("in"), $u("out"), $u()), function(n, e) {
        var t = 1 / e, i = 2 * t, r = 2.5 * t, s = function(a) {
          return a < t ? n * a * a : a < i ? n * Math.pow(a - 1.5 / e, 2) + 0.75 : a < r ? n * (a -= 2.25 / e) * a + 0.9375 : n * Math.pow(a - 2.625 / e, 2) + 0.984375;
        };
        Ar("Bounce", function(a) {
          return 1 - s(1 - a);
        }, s);
      }(7.5625, 2.75), Ar("Expo", function(n) {
        return Math.pow(2, 10 * (n - 1)) * n + n * n * n * n * n * n * (1 - n);
      }), Ar("Circ", function(n) {
        return -(af(1 - n * n) - 1);
      }), Ar("Sine", function(n) {
        return n === 1 ? 1 : -bb(n * Mb) + 1;
      }), Ar("Back", Qu("in"), Qu("out"), Qu()), qe.SteppedEase = qe.steps = Ei.SteppedEase = {
        config: function(n, e) {
          n === void 0 && (n = 1);
          var t = 1 / n, i = n + (e ? 0 : 1), r = e ? 1 : 0, s = 1 - ii;
          return function(a) {
            return ((i * za(0, s, a) | 0) + r) * t;
          };
        }
      }, Ds.ease = qe["quad.out"], _i("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(n) {
        return Wu += n + "," + n + "Params,";
      });
      var Wf = function(n, e) {
        this.id = Tb++, n._gsap = this, this.target = n, this.harness = e, this.get = e ? e.get : gf, this.set = e ? e.getSetter : rh;
      }, Wa = function() {
        function n(t) {
          this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Fs(this, +t.duration, 1, 1), this.data = t.data, xt && (this._ctx = xt, xt.data.push(this)), Ga || Ci.wake();
        }
        var e = n.prototype;
        return e.delay = function(t) {
          return t || t === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay;
        }, e.duration = function(t) {
          return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur;
        }, e.totalDuration = function(t) {
          return arguments.length ? (this._dirty = 0, Fs(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
        }, e.totalTime = function(t, i) {
          if (zs(), !arguments.length) return this._tTime;
          var r = this._dp;
          if (r && r.smoothChildTiming && this._ts) {
            for (dl(this, t), !r._dp || r.parent || bf(r, this); r && r.parent; ) r.parent._time !== r._start + (r._ts >= 0 ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, true), r = r.parent;
            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && un(this._dp, this, this._start - this._delay);
          }
          return (this._tTime !== t || !this._dur && !i || this._initted && Math.abs(this._zTime) === ii || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), _f(this, t, i)), this;
        }, e.time = function(t, i) {
          return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Tf(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), i) : this._time;
        }, e.totalProgress = function(t, i) {
          return arguments.length ? this.totalTime(this.totalDuration() * t, i) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;
        }, e.progress = function(t, i) {
          return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - t : t) + Tf(this), i) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
        }, e.iteration = function(t, i) {
          var r = this.duration() + this._rDelay;
          return arguments.length ? this.totalTime(this._time + (t - 1) * r, i) : this._repeat ? Os(this._tTime, r) + 1 : 1;
        }, e.timeScale = function(t, i) {
          if (!arguments.length) return this._rts === -1e-8 ? 0 : this._rts;
          if (this._rts === t) return this;
          var r = this.parent && this._ts ? ul(this.parent._time, this) : this._tTime;
          return this._rts = +t || 0, this._ts = this._ps || t === -1e-8 ? 0 : this._rts, this.totalTime(za(-Math.abs(this._delay), this._tDur, r), i !== false), hl(this), Lb(this);
        }, e.paused = function(t) {
          return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (zs(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== ii && (this._tTime -= ii)))), this) : this._ps;
        }, e.startTime = function(t) {
          if (arguments.length) {
            this._start = t;
            var i = this.parent || this._dp;
            return i && (i._sort || !this.parent) && un(i, this, t - this._delay), this;
          }
          return this._start;
        }, e.endTime = function(t) {
          return this._start + (gi(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
        }, e.rawTime = function(t) {
          var i = this.parent || this._dp;
          return i ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? ul(i.rawTime(t), this) : this._tTime : this._tTime;
        }, e.revert = function(t) {
          t === void 0 && (t = Ab);
          var i = Jt;
          return Jt = t, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(t), this.totalTime(-0.01, t.suppressEvents)), this.data !== "nested" && t.kill !== false && this.kill(), Jt = i, this;
        }, e.globalTime = function(t) {
          for (var i = this, r = arguments.length ? t : i.rawTime(); i; ) r = i._start + r / (Math.abs(i._ts) || 1), i = i._dp;
          return !this.parent && this._sat ? this._sat.globalTime(t) : r;
        }, e.repeat = function(t) {
          return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t, wf(this)) : this._repeat === -2 ? 1 / 0 : this._repeat;
        }, e.repeatDelay = function(t) {
          if (arguments.length) {
            var i = this._time;
            return this._rDelay = t, wf(this), i ? this.time(i) : this;
          }
          return this._rDelay;
        }, e.yoyo = function(t) {
          return arguments.length ? (this._yoyo = t, this) : this._yoyo;
        }, e.seek = function(t, i) {
          return this.totalTime(Oi(this, t), gi(i));
        }, e.restart = function(t, i) {
          return this.play().totalTime(t ? -this._delay : 0, gi(i)), this._dur || (this._zTime = -1e-8), this;
        }, e.play = function(t, i) {
          return t != null && this.seek(t, i), this.reversed(false).paused(false);
        }, e.reverse = function(t, i) {
          return t != null && this.seek(t || this.totalDuration(), i), this.reversed(true).paused(false);
        }, e.pause = function(t, i) {
          return t != null && this.seek(t, i), this.paused(true);
        }, e.resume = function() {
          return this.paused(false);
        }, e.reversed = function(t) {
          return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0;
        }, e.invalidate = function() {
          return this._initted = this._act = 0, this._zTime = -1e-8, this;
        }, e.isActive = function() {
          var t = this.parent || this._dp, i = this._start, r;
          return !!(!t || this._ts && this._initted && t.isActive() && (r = t.rawTime(true)) >= i && r < this.endTime(true) - ii);
        }, e.eventCallback = function(t, i, r) {
          var s = this.vars;
          return arguments.length > 1 ? (i ? (s[t] = i, r && (s[t + "Params"] = r), t === "onUpdate" && (this._onUpdate = i)) : delete s[t], this) : s[t];
        }, e.then = function(t) {
          var i = this;
          return new Promise(function(r) {
            var s = Rt(t) ? t : xf, a = function() {
              var o = i.then;
              i.then = null, Rt(s) && (s = s(i)) && (s.then || s === i) && (i.then = o), r(s), i.then = o;
            };
            i._initted && i.totalProgress() === 1 && i._ts >= 0 || !i._tTime && i._ts < 0 ? a() : i._prom = a;
          });
        }, e.kill = function() {
          Va(this);
        }, n;
      }();
      Ai(Wa.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: false,
        parent: null,
        _initted: false,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -1e-8,
        _prom: 0,
        _ps: false,
        _rts: 1
      });
      var di = function(n) {
        sf(e, n);
        function e(i, r) {
          var s;
          return i === void 0 && (i = {}), s = n.call(this, i) || this, s.labels = {}, s.smoothChildTiming = !!i.smoothChildTiming, s.autoRemoveChildren = !!i.autoRemoveChildren, s._sort = gi(i.sortChildren), St && un(i.parent || St, wn(s), r), i.reversed && s.reverse(), i.paused && s.paused(true), i.scrollTrigger && Sf(wn(s), i.scrollTrigger), s;
        }
        var t = e.prototype;
        return t.to = function(i, r, s) {
          return Ba(0, arguments, this), this;
        }, t.from = function(i, r, s) {
          return Ba(1, arguments, this), this;
        }, t.fromTo = function(i, r, s, a) {
          return Ba(2, arguments, this), this;
        }, t.set = function(i, r, s) {
          return r.duration = 0, r.parent = this, Fa(r).repeatDelay || (r.repeat = 0), r.immediateRender = !!r.immediateRender, new Bt(i, r, Oi(this, s), 1), this;
        }, t.call = function(i, r, s) {
          return un(this, Bt.delayedCall(0, i, r), s);
        }, t.staggerTo = function(i, r, s, a, o, l, c) {
          return s.duration = r, s.stagger = s.stagger || a, s.onComplete = l, s.onCompleteParams = c, s.parent = this, new Bt(i, s, Oi(this, o)), this;
        }, t.staggerFrom = function(i, r, s, a, o, l, c) {
          return s.runBackwards = 1, Fa(s).immediateRender = gi(s.immediateRender), this.staggerTo(i, r, s, a, o, l, c);
        }, t.staggerFromTo = function(i, r, s, a, o, l, c, u) {
          return a.startAt = s, Fa(a).immediateRender = gi(a.immediateRender), this.staggerTo(i, r, a, o, l, c, u);
        }, t.render = function(i, r, s) {
          var a = this._time, o = this._dirty ? this.totalDuration() : this._tDur, l = this._dur, c = i <= 0 ? 0 : Ft(i), u = this._zTime < 0 != i < 0 && (this._initted || !l), h, d, p, f, _, g, m, y, x, v, A, E;
          if (this !== St && c > o && i >= 0 && (c = o), c !== this._tTime || s || u) {
            if (a !== this._time && l && (c += this._time - a, i += this._time - a), h = c, x = this._start, y = this._ts, g = !y, u && (l || (a = this._zTime), (i || !r) && (this._zTime = i)), this._repeat) {
              if (A = this._yoyo, _ = l + this._rDelay, this._repeat < -1 && i < 0) return this.totalTime(_ * 100 + i, r, s);
              if (h = Ft(c % _), c === o ? (f = this._repeat, h = l) : (v = Ft(c / _), f = ~~v, f && f === v && (h = l, f--), h > l && (h = l)), v = Os(this._tTime, _), !a && this._tTime && v !== f && this._tTime - v * _ - this._dur <= 0 && (v = f), A && f & 1 && (h = l - h, E = 1), f !== v && !this._lock) {
                var w = A && v & 1, R = w === (A && f & 1);
                if (f < v && (w = !w), a = w ? 0 : c % l ? l : c, this._lock = 1, this.render(a || (E ? 0 : Ft(f * _)), r, !l)._lock = 0, this._tTime = c, !r && this.parent && Ri(this, "onRepeat"), this.vars.repeatRefresh && !E && (this.invalidate()._lock = 1), a && a !== this._time || g !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                if (l = this._dur, o = this._tDur, R && (this._lock = 2, a = w ? l : -1e-4, this.render(a, true), this.vars.repeatRefresh && !E && this.invalidate()), this._lock = 0, !this._ts && !g) return this;
                Hf(this, E);
              }
            }
            if (this._hasPause && !this._forcing && this._lock < 2 && (m = Ub(this, Ft(a), Ft(h)), m && (c -= h - (h = m._start))), this._tTime = c, this._time = h, this._act = !y, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = i, a = 0), !a && h && !r && !f && (Ri(this, "onStart"), this._tTime !== c)) return this;
            if (h >= a && i >= 0) for (d = this._first; d; ) {
              if (p = d._next, (d._act || h >= d._start) && d._ts && m !== d) {
                if (d.parent !== this) return this.render(i, r, s);
                if (d.render(d._ts > 0 ? (h - d._start) * d._ts : (d._dirty ? d.totalDuration() : d._tDur) + (h - d._start) * d._ts, r, s), h !== this._time || !this._ts && !g) {
                  m = 0, p && (c += this._zTime = -1e-8);
                  break;
                }
              }
              d = p;
            }
            else {
              d = this._last;
              for (var S = i < 0 ? i : h; d; ) {
                if (p = d._prev, (d._act || S <= d._end) && d._ts && m !== d) {
                  if (d.parent !== this) return this.render(i, r, s);
                  if (d.render(d._ts > 0 ? (S - d._start) * d._ts : (d._dirty ? d.totalDuration() : d._tDur) + (S - d._start) * d._ts, r, s || Jt && (d._initted || d._startAt)), h !== this._time || !this._ts && !g) {
                    m = 0, p && (c += this._zTime = S ? -1e-8 : ii);
                    break;
                  }
                }
                d = p;
              }
            }
            if (m && !r && (this.pause(), m.render(h >= a ? 0 : -1e-8)._zTime = h >= a ? 1 : -1, this._ts)) return this._start = x, hl(this), this.render(i, r, s);
            this._onUpdate && !r && Ri(this, "onUpdate", true), (c === o && this._tTime >= this.totalDuration() || !c && a) && (x === this._start || Math.abs(y) !== Math.abs(this._ts)) && (this._lock || ((i || !l) && (c === o && this._ts > 0 || !c && this._ts < 0) && $n(this, 1), !r && !(i < 0 && !a) && (c || a || !o) && (Ri(this, c === o && i >= 0 ? "onComplete" : "onReverseComplete", true), this._prom && !(c < o && this.timeScale() > 0) && this._prom())));
          }
          return this;
        }, t.add = function(i, r) {
          var s = this;
          if (An(r) || (r = Oi(this, r, i)), !(i instanceof Wa)) {
            if (ni(i)) return i.forEach(function(a) {
              return s.add(a, r);
            }), this;
            if (Yt(i)) return this.addLabel(i, r);
            if (Rt(i)) i = Bt.delayedCall(0, i);
            else return this;
          }
          return this !== i ? un(this, i, r) : this;
        }, t.getChildren = function(i, r, s, a) {
          i === void 0 && (i = true), r === void 0 && (r = true), s === void 0 && (s = true), a === void 0 && (a = -1e8);
          for (var o = [], l = this._first; l; ) l._start >= a && (l instanceof Bt ? r && o.push(l) : (s && o.push(l), i && o.push.apply(o, l.getChildren(true, r, s)))), l = l._next;
          return o;
        }, t.getById = function(i) {
          for (var r = this.getChildren(1, 1, 1), s = r.length; s--; ) if (r[s].vars.id === i) return r[s];
        }, t.remove = function(i) {
          return Yt(i) ? this.removeLabel(i) : Rt(i) ? this.killTweensOf(i) : (i.parent === this && cl(this, i), i === this._recent && (this._recent = this._last), Er(this));
        }, t.totalTime = function(i, r) {
          return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Ft(Ci.time - (this._ts > 0 ? i / this._ts : (this.totalDuration() - i) / -this._ts))), n.prototype.totalTime.call(this, i, r), this._forcing = 0, this) : this._tTime;
        }, t.addLabel = function(i, r) {
          return this.labels[i] = Oi(this, r), this;
        }, t.removeLabel = function(i) {
          return delete this.labels[i], this;
        }, t.addPause = function(i, r, s) {
          var a = Bt.delayedCall(0, r || Oa, s);
          return a.data = "isPause", this._hasPause = 1, un(this, a, Oi(this, i));
        }, t.removePause = function(i) {
          var r = this._first;
          for (i = Oi(this, i); r; ) r._start === i && r.data === "isPause" && $n(r), r = r._next;
        }, t.killTweensOf = function(i, r, s) {
          for (var a = this.getTweensOf(i, s), o = a.length; o--; ) tr !== a[o] && a[o].kill(i, r);
          return this;
        }, t.getTweensOf = function(i, r) {
          for (var s = [], a = Fi(i), o = this._first, l = An(r), c; o; ) o instanceof Bt ? Rb(o._targets, a) && (l ? (!tr || o._initted && o._ts) && o.globalTime(0) <= r && o.globalTime(o.totalDuration()) > r : !r || o.isActive()) && s.push(o) : (c = o.getTweensOf(a, r)).length && s.push.apply(s, c), o = o._next;
          return s;
        }, t.tweenTo = function(i, r) {
          r = r || {};
          var s = this, a = Oi(s, i), o = r, l = o.startAt, c = o.onStart, u = o.onStartParams, h = o.immediateRender, d, p = Bt.to(s, Ai({
            ease: r.ease || "none",
            lazy: false,
            immediateRender: false,
            time: a,
            overwrite: "auto",
            duration: r.duration || Math.abs((a - (l && "time" in l ? l.time : s._time)) / s.timeScale()) || ii,
            onStart: function() {
              if (s.pause(), !d) {
                var f = r.duration || Math.abs((a - (l && "time" in l ? l.time : s._time)) / s.timeScale());
                p._dur !== f && Fs(p, f, 0, 1).render(p._time, true, true), d = 1;
              }
              c && c.apply(p, u || []);
            }
          }, r));
          return h ? p.render(0) : p;
        }, t.tweenFromTo = function(i, r, s) {
          return this.tweenTo(r, Ai({
            startAt: {
              time: Oi(this, i)
            }
          }, s));
        }, t.recent = function() {
          return this._recent;
        }, t.nextLabel = function(i) {
          return i === void 0 && (i = this._time), Nf(this, Oi(this, i));
        }, t.previousLabel = function(i) {
          return i === void 0 && (i = this._time), Nf(this, Oi(this, i), 1);
        }, t.currentLabel = function(i) {
          return arguments.length ? this.seek(i, true) : this.previousLabel(this._time + ii);
        }, t.shiftChildren = function(i, r, s) {
          s === void 0 && (s = 0);
          for (var a = this._first, o = this.labels, l; a; ) a._start >= s && (a._start += i, a._end += i), a = a._next;
          if (r) for (l in o) o[l] >= s && (o[l] += i);
          return Er(this);
        }, t.invalidate = function(i) {
          var r = this._first;
          for (this._lock = 0; r; ) r.invalidate(i), r = r._next;
          return n.prototype.invalidate.call(this, i);
        }, t.clear = function(i) {
          i === void 0 && (i = true);
          for (var r = this._first, s; r; ) s = r._next, this.remove(r), r = s;
          return this._dp && (this._time = this._tTime = this._pTime = 0), i && (this.labels = {}), Er(this);
        }, t.totalDuration = function(i) {
          var r = 0, s = this, a = s._last, o = on, l, c, u;
          if (arguments.length) return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -i : i));
          if (s._dirty) {
            for (u = s.parent; a; ) l = a._prev, a._dirty && a.totalDuration(), c = a._start, c > o && s._sort && a._ts && !s._lock ? (s._lock = 1, un(s, a, c - a._delay, 1)._lock = 0) : o = c, c < 0 && a._ts && (r -= c, (!u && !s._dp || u && u.smoothChildTiming) && (s._start += c / s._ts, s._time -= c, s._tTime -= c), s.shiftChildren(-c, false, -1 / 0), o = 0), a._end > r && a._ts && (r = a._end), a = l;
            Fs(s, s === St && s._time > r ? s._time : r, 1, 1), s._dirty = 0;
          }
          return s._tDur;
        }, e.updateRoot = function(i) {
          if (St._ts && (_f(St, ul(i, St)), ff = Ci.frame), Ci.frame >= mf) {
            mf += Si.autoSleep || 120;
            var r = St._first;
            if ((!r || !r._ts) && Si.autoSleep && Ci._listeners.length < 2) {
              for (; r && !r._ts; ) r = r._next;
              r || Ci.sleep();
            }
          }
        }, e;
      }(Wa);
      Ai(di.prototype, {
        _lock: 0,
        _hasPause: 0,
        _forcing: 0
      });
      var Jb = function(n, e, t, i, r, s, a) {
        var o = new vi(this._pt, n, e, 0, 1, Zf, null, r), l = 0, c = 0, u, h, d, p, f, _, g, m;
        for (o.b = t, o.e = i, t += "", i += "", (g = ~i.indexOf("random(")) && (i = ka(i)), s && (m = [
          t,
          i
        ], s(m, n, e), t = m[0], i = m[1]), h = t.match(Fu) || []; u = Fu.exec(i); ) p = u[0], f = i.substring(l, u.index), d ? d = (d + 1) % 5 : f.substr(-5) === "rgba(" && (d = 1), p !== h[c++] && (_ = parseFloat(h[c - 1]) || 0, o._pt = {
          _next: o._pt,
          p: f || c === 1 ? f : ",",
          s: _,
          c: p.charAt(1) === "=" ? Ns(_, p) - _ : parseFloat(p) - _,
          m: d && d < 4 ? Math.round : 0
        }, l = Fu.lastIndex);
        return o.c = l < i.length ? i.substring(l, i.length) : "", o.fp = a, (cf.test(i) || g) && (o.e = 0), this._pt = o, o;
      }, eh = function(n, e, t, i, r, s, a, o, l, c) {
        Rt(i) && (i = i(r || 0, n, s));
        var u = n[e], h = t !== "get" ? t : Rt(u) ? l ? n[e.indexOf("set") || !Rt(n["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : n[e]() : u, d = Rt(u) ? l ? iS : Yf : nh, p;
        if (Yt(i) && (~i.indexOf("random(") && (i = ka(i)), i.charAt(1) === "=" && (p = Ns(h, i) + (ri(h) || 0), (p || p === 0) && (i = p))), !c || h !== i || th) return !isNaN(h * i) && i !== "" ? (p = new vi(this._pt, n, e, +h || 0, i - (h || 0), typeof u == "boolean" ? rS : Kf, 0, d), l && (p.fp = l), a && p.modifier(a, this, n), this._pt = p) : (!u && !(e in n) && ku(e, i), Jb.call(this, n, e, h, i, d, o || Si.stringFilter, l));
      }, $b = function(n, e, t, i, r) {
        if (Rt(n) && (n = Xa(n, r, e, t, i)), !ln(n) || n.style && n.nodeType || ni(n) || of(n)) return Yt(n) ? Xa(n, r, e, t, i) : n;
        var s = {}, a;
        for (a in n) s[a] = Xa(n[a], r, e, t, i);
        return s;
      }, Xf = function(n, e, t, i, r, s) {
        var a, o, l, c;
        if (wi[n] && (a = new wi[n]()).init(r, a.rawVars ? e[n] : $b(e[n], i, r, s, t), t, i, s) !== false && (t._pt = o = new vi(t._pt, r, n, 0, 1, a.render, a, 0, a.priority), t !== Bs)) for (l = t._ptLookup[t._targets.indexOf(r)], c = a._props.length; c--; ) l[a._props[c]] = o;
        return a;
      }, tr, th, ih = function n(e, t, i) {
        var r = e.vars, s = r.ease, a = r.startAt, o = r.immediateRender, l = r.lazy, c = r.onUpdate, u = r.runBackwards, h = r.yoyoEase, d = r.keyframes, p = r.autoRevert, f = e._dur, _ = e._startAt, g = e._targets, m = e.parent, y = m && m.data === "nested" ? m.vars.targets : g, x = e._overwrite === "auto" && !Du, v = e.timeline, A, E, w, R, S, T, L, B, F, H, X, k, K;
        if (v && (!d || !s) && (s = "none"), e._ease = wr(s, Ds.ease), e._yEase = h ? Vf(wr(h === true ? s : h, Ds.ease)) : 0, h && e._yoyo && !e._repeat && (h = e._yEase, e._yEase = e._ease, e._ease = h), e._from = !v && !!r.runBackwards, !v || d && !r.stagger) {
          if (B = g[0] ? Sr(g[0]).harness : 0, k = B && r[B.prop], A = ll(r, Vu), _ && (_._zTime < 0 && _.progress(1), t < 0 && u && o && !p ? _.render(-1, true) : _.revert(u && f ? sl : wb), _._lazy = 0), a) {
            if ($n(e._startAt = Bt.set(g, Ai({
              data: "isStart",
              overwrite: false,
              parent: m,
              immediateRender: true,
              lazy: !_ && gi(l),
              startAt: null,
              delay: 0,
              onUpdate: c && function() {
                return Ri(e, "onUpdate");
              },
              stagger: 0
            }, a))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (Jt || !o && !p) && e._startAt.revert(sl), o && f && t <= 0 && i <= 0) {
              t && (e._zTime = t);
              return;
            }
          } else if (u && f && !_) {
            if (t && (o = false), w = Ai({
              overwrite: false,
              data: "isFromStart",
              lazy: o && !_ && gi(l),
              immediateRender: o,
              stagger: 0,
              parent: m
            }, A), k && (w[B.prop] = k), $n(e._startAt = Bt.set(g, w)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (Jt ? e._startAt.revert(sl) : e._startAt.render(-1, true)), e._zTime = t, !o) n(e._startAt, ii, ii);
            else if (!t) return;
          }
          for (e._pt = e._ptCache = 0, l = f && gi(l) || l && !f, E = 0; E < g.length; E++) {
            if (S = g[E], L = S._gsap || Xu(g)[E]._gsap, e._ptLookup[E] = H = {}, Hu[L.id] && Jn.length && ol(), X = y === g ? E : y.indexOf(S), B && (F = new B()).init(S, k || A, e, X, y) !== false && (e._pt = R = new vi(e._pt, S, F.name, 0, 1, F.render, F, 0, F.priority), F._props.forEach(function(G) {
              H[G] = R;
            }), F.priority && (T = 1)), !B || k) for (w in A) wi[w] && (F = Xf(w, A, e, X, S, y)) ? F.priority && (T = 1) : H[w] = R = eh.call(e, S, w, "get", A[w], X, y, 0, r.stringFilter);
            e._op && e._op[E] && e.kill(S, e._op[E]), x && e._pt && (tr = e, St.killTweensOf(S, H, e.globalTime(t)), K = !e.parent, tr = 0), e._pt && l && (Hu[L.id] = 1);
          }
          T && Jf(e), e._onInit && e._onInit(e);
        }
        e._onUpdate = c, e._initted = (!e._op || e._pt) && !K, d && t <= 0 && v.render(on, true, true);
      }, Qb = function(n, e, t, i, r, s, a, o) {
        var l = (n._pt && n._ptCache || (n._ptCache = {}))[e], c, u, h, d;
        if (!l) for (l = n._ptCache[e] = [], h = n._ptLookup, d = n._targets.length; d--; ) {
          if (c = h[d][e], c && c.d && c.d._pt) for (c = c.d._pt; c && c.p !== e && c.fp !== e; ) c = c._next;
          if (!c) return th = 1, n.vars[e] = "+=0", ih(n, a), th = 0, o ? Ua(e + " not eligible for reset") : 1;
          l.push(c);
        }
        for (d = l.length; d--; ) u = l[d], c = u._pt || u, c.s = (i || i === 0) && !r ? i : c.s + (i || 0) + s * c.c, c.c = t - c.s, u.e && (u.e = It(t) + ri(u.e)), u.b && (u.b = c.s + ri(u.b));
      }, eS = function(n, e) {
        var t = n[0] ? Sr(n[0]).harness : 0, i = t && t.aliases, r, s, a, o;
        if (!i) return e;
        r = Us({}, e);
        for (s in i) if (s in r) for (o = i[s].split(","), a = o.length; a--; ) r[o[a]] = r[s];
        return r;
      }, tS = function(n, e, t, i) {
        var r = e.ease || i || "power1.inOut", s, a;
        if (ni(e)) a = t[n] || (t[n] = []), e.forEach(function(o, l) {
          return a.push({
            t: l / (e.length - 1) * 100,
            v: o,
            e: r
          });
        });
        else for (s in e) a = t[s] || (t[s] = []), s === "ease" || a.push({
          t: parseFloat(n),
          v: e[s],
          e: r
        });
      }, Xa = function(n, e, t, i, r) {
        return Rt(n) ? n.call(e, t, i, r) : Yt(n) && ~n.indexOf("random(") ? ka(n) : n;
      }, jf = Wu + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", qf = {};
      _i(jf + ",id,stagger,delay,duration,paused,scrollTrigger", function(n) {
        return qf[n] = 1;
      });
      var Bt = function(n) {
        sf(e, n);
        function e(i, r, s, a) {
          var o;
          typeof r == "number" && (s.duration = r, r = s, s = null), o = n.call(this, a ? r : Fa(r)) || this;
          var l = o.vars, c = l.duration, u = l.delay, h = l.immediateRender, d = l.stagger, p = l.overwrite, f = l.keyframes, _ = l.defaults, g = l.scrollTrigger, m = l.yoyoEase, y = r.parent || St, x = (ni(i) || of(i) ? An(i[0]) : "length" in r) ? [
            i
          ] : Fi(i), v, A, E, w, R, S, T, L;
          if (o._targets = x.length ? Xu(x) : Ua("GSAP target " + i + " not found. https://gsap.com", !Si.nullTargetWarn) || [], o._ptLookup = [], o._overwrite = p, f || d || nl(c) || nl(u)) {
            if (r = o.vars, v = o.timeline = new di({
              data: "nested",
              defaults: _ || {},
              targets: y && y.data === "nested" ? y.vars.targets : x
            }), v.kill(), v.parent = v._dp = wn(o), v._start = 0, d || nl(c) || nl(u)) {
              if (w = x.length, T = d && Cf(d), ln(d)) for (R in d) ~jf.indexOf(R) && (L || (L = {}), L[R] = d[R]);
              for (A = 0; A < w; A++) E = ll(r, qf), E.stagger = 0, m && (E.yoyoEase = m), L && Us(E, L), S = x[A], E.duration = +Xa(c, wn(o), A, S, x), E.delay = (+Xa(u, wn(o), A, S, x) || 0) - o._delay, !d && w === 1 && E.delay && (o._delay = u = E.delay, o._start += u, E.delay = 0), v.to(S, E, T ? T(A, S, x) : 0), v._ease = qe.none;
              v.duration() ? c = u = 0 : o.timeline = 0;
            } else if (f) {
              Fa(Ai(v.vars.defaults, {
                ease: "none"
              })), v._ease = wr(f.ease || r.ease || "none");
              var B = 0, F, H, X;
              if (ni(f)) f.forEach(function(k) {
                return v.to(x, k, ">");
              }), v.duration();
              else {
                E = {};
                for (R in f) R === "ease" || R === "easeEach" || tS(R, f[R], E, f.easeEach);
                for (R in E) for (F = E[R].sort(function(k, K) {
                  return k.t - K.t;
                }), B = 0, A = 0; A < F.length; A++) H = F[A], X = {
                  ease: H.e,
                  duration: (H.t - (A ? F[A - 1].t : 0)) / 100 * c
                }, X[R] = H.v, v.to(x, X, B), B += X.duration;
                v.duration() < c && v.to({}, {
                  duration: c - v.duration()
                });
              }
            }
            c || o.duration(c = v.duration());
          } else o.timeline = 0;
          return p === true && !Du && (tr = wn(o), St.killTweensOf(x), tr = 0), un(y, wn(o), s), r.reversed && o.reverse(), r.paused && o.paused(true), (h || !c && !f && o._start === Ft(y._time) && gi(h) && Db(wn(o)) && y.data !== "nested") && (o._tTime = -1e-8, o.render(Math.max(0, -u) || 0)), g && Sf(wn(o), g), o;
        }
        var t = e.prototype;
        return t.render = function(i, r, s) {
          var a = this._time, o = this._tDur, l = this._dur, c = i < 0, u = i > o - ii && !c ? o : i < ii ? 0 : i, h, d, p, f, _, g, m, y, x;
          if (!l) Nb(this, i, r, s);
          else if (u !== this._tTime || !i || s || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== c || this._lazy) {
            if (h = u, y = this.timeline, this._repeat) {
              if (f = l + this._rDelay, this._repeat < -1 && c) return this.totalTime(f * 100 + i, r, s);
              if (h = Ft(u % f), u === o ? (p = this._repeat, h = l) : (_ = Ft(u / f), p = ~~_, p && p === _ ? (h = l, p--) : h > l && (h = l)), g = this._yoyo && p & 1, g && (x = this._yEase, h = l - h), _ = Os(this._tTime, f), h === a && !s && this._initted && p === _) return this._tTime = u, this;
              p !== _ && (y && this._yEase && Hf(y, g), this.vars.repeatRefresh && !g && !this._lock && h !== f && this._initted && (this._lock = s = 1, this.render(Ft(f * p), true).invalidate()._lock = 0));
            }
            if (!this._initted) {
              if (Ef(this, c ? i : h, s, r, u)) return this._tTime = 0, this;
              if (a !== this._time && !(s && this.vars.repeatRefresh && p !== _)) return this;
              if (l !== this._dur) return this.render(i, r, s);
            }
            if (this._tTime = u, this._time = h, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = m = (x || this._ease)(h / l), this._from && (this.ratio = m = 1 - m), h && !a && !r && !p && (Ri(this, "onStart"), this._tTime !== u)) return this;
            for (d = this._pt; d; ) d.r(m, d.d), d = d._next;
            y && y.render(i < 0 ? i : y._dur * y._ease(h / this._dur), r, s) || this._startAt && (this._zTime = i), this._onUpdate && !r && (c && ju(this, i, r, s), Ri(this, "onUpdate")), this._repeat && p !== _ && this.vars.onRepeat && !r && this.parent && Ri(this, "onRepeat"), (u === this._tDur || !u) && this._tTime === u && (c && !this._onUpdate && ju(this, i, true, true), (i || !l) && (u === this._tDur && this._ts > 0 || !u && this._ts < 0) && $n(this, 1), !r && !(c && !a) && (u || a || g) && (Ri(this, u === o ? "onComplete" : "onReverseComplete", true), this._prom && !(u < o && this.timeScale() > 0) && this._prom()));
          }
          return this;
        }, t.targets = function() {
          return this._targets;
        }, t.invalidate = function(i) {
          return (!i || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(i), n.prototype.invalidate.call(this, i);
        }, t.resetTo = function(i, r, s, a, o) {
          Ga || Ci.wake(), this._ts || this.play();
          var l = Math.min(this._dur, (this._dp._time - this._start) * this._ts), c;
          return this._initted || ih(this, l), c = this._ease(l / this._dur), Qb(this, i, r, s, a, c, l, o) ? this.resetTo(i, r, s, a, 1) : (dl(this, 0), this.parent || Mf(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0));
        }, t.kill = function(i, r) {
          if (r === void 0 && (r = "all"), !i && (!r || r === "all")) return this._lazy = this._pt = 0, this.parent ? Va(this) : this.scrollTrigger && this.scrollTrigger.kill(!!Jt), this;
          if (this.timeline) {
            var s = this.timeline.totalDuration();
            return this.timeline.killTweensOf(i, r, tr && tr.vars.overwrite !== true)._first || Va(this), this.parent && s !== this.timeline.totalDuration() && Fs(this, this._dur * this.timeline._tDur / s, 0, 1), this;
          }
          var a = this._targets, o = i ? Fi(i) : a, l = this._ptLookup, c = this._pt, u, h, d, p, f, _, g;
          if ((!r || r === "all") && Pb(a, o)) return r === "all" && (this._pt = 0), Va(this);
          for (u = this._op = this._op || [], r !== "all" && (Yt(r) && (f = {}, _i(r, function(m) {
            return f[m] = 1;
          }), r = f), r = eS(a, r)), g = a.length; g--; ) if (~o.indexOf(a[g])) {
            h = l[g], r === "all" ? (u[g] = r, p = h, d = {}) : (d = u[g] = u[g] || {}, p = r);
            for (f in p) _ = h && h[f], _ && ((!("kill" in _.d) || _.d.kill(f) === true) && cl(this, _, "_pt"), delete h[f]), d !== "all" && (d[f] = 1);
          }
          return this._initted && !this._pt && c && Va(this), this;
        }, e.to = function(i, r) {
          return new e(i, r, arguments[2]);
        }, e.from = function(i, r) {
          return Ba(1, arguments);
        }, e.delayedCall = function(i, r, s, a) {
          return new e(r, 0, {
            immediateRender: false,
            lazy: false,
            overwrite: false,
            delay: i,
            onComplete: r,
            onReverseComplete: r,
            onCompleteParams: s,
            onReverseCompleteParams: s,
            callbackScope: a
          });
        }, e.fromTo = function(i, r, s) {
          return Ba(2, arguments);
        }, e.set = function(i, r) {
          return r.duration = 0, r.repeatDelay || (r.repeat = 0), new e(i, r);
        }, e.killTweensOf = function(i, r, s) {
          return St.killTweensOf(i, r, s);
        }, e;
      }(Wa);
      Ai(Bt.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0
      }), _i("staggerTo,staggerFrom,staggerFromTo", function(n) {
        Bt[n] = function() {
          var e = new di(), t = Yu.call(arguments, 0);
          return t.splice(n === "staggerFromTo" ? 5 : 4, 0, 0), e[n].apply(e, t);
        };
      });
      var nh = function(n, e, t) {
        return n[e] = t;
      }, Yf = function(n, e, t) {
        return n[e](t);
      }, iS = function(n, e, t, i) {
        return n[e](i.fp, t);
      }, nS = function(n, e, t) {
        return n.setAttribute(e, t);
      }, rh = function(n, e) {
        return Rt(n[e]) ? Yf : Nu(n[e]) && n.setAttribute ? nS : nh;
      }, Kf = function(n, e) {
        return e.set(e.t, e.p, Math.round((e.s + e.c * n) * 1e6) / 1e6, e);
      }, rS = function(n, e) {
        return e.set(e.t, e.p, !!(e.s + e.c * n), e);
      }, Zf = function(n, e) {
        var t = e._pt, i = "";
        if (!n && e.b) i = e.b;
        else if (n === 1 && e.e) i = e.e;
        else {
          for (; t; ) i = t.p + (t.m ? t.m(t.s + t.c * n) : Math.round((t.s + t.c * n) * 1e4) / 1e4) + i, t = t._next;
          i += e.c;
        }
        e.set(e.t, e.p, i, e);
      }, sh = function(n, e) {
        for (var t = e._pt; t; ) t.r(n, t.d), t = t._next;
      }, sS = function(n, e, t, i) {
        for (var r = this._pt, s; r; ) s = r._next, r.p === i && r.modifier(n, e, t), r = s;
      }, aS = function(n) {
        for (var e = this._pt, t, i; e; ) i = e._next, e.p === n && !e.op || e.op === n ? cl(this, e, "_pt") : e.dep || (t = 1), e = i;
        return !t;
      }, oS = function(n, e, t, i) {
        i.mSet(n, e, i.m.call(i.tween, t, i.mt), i);
      }, Jf = function(n) {
        for (var e = n._pt, t, i, r, s; e; ) {
          for (t = e._next, i = r; i && i.pr > e.pr; ) i = i._next;
          (e._prev = i ? i._prev : s) ? e._prev._next = e : r = e, (e._next = i) ? i._prev = e : s = e, e = t;
        }
        n._pt = r;
      }, vi = function() {
        function n(t, i, r, s, a, o, l, c, u) {
          this.t = i, this.s = s, this.c = a, this.p = r, this.r = o || Kf, this.d = l || this, this.set = c || nh, this.pr = u || 0, this._next = t, t && (t._prev = this);
        }
        var e = n.prototype;
        return e.modifier = function(t, i, r) {
          this.mSet = this.mSet || this.set, this.set = oS, this.m = t, this.mt = r, this.tween = i;
        }, n;
      }();
      _i(Wu + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(n) {
        return Vu[n] = 1;
      }), Ei.TweenMax = Ei.TweenLite = Bt, Ei.TimelineLite = Ei.TimelineMax = di, St = new di({
        sortChildren: false,
        defaults: Ds,
        autoRemoveChildren: true,
        id: "root",
        smoothChildTiming: true
      }), Si.stringFilter = kf;
      var Rr = [], pl = {}, lS = [], $f = 0, cS = 0, ah = function(n) {
        return (pl[n] || lS).map(function(e) {
          return e();
        });
      }, oh = function() {
        var n = Date.now(), e = [];
        n - $f > 2 && (ah("matchMediaInit"), Rr.forEach(function(t) {
          var i = t.queries, r = t.conditions, s, a, o, l;
          for (a in i) s = cn.matchMedia(i[a]).matches, s && (o = 1), s !== r[a] && (r[a] = s, l = 1);
          l && (t.revert(), o && e.push(t));
        }), ah("matchMediaRevert"), e.forEach(function(t) {
          return t.onMatch(t, function(i) {
            return t.add(null, i);
          });
        }), $f = n, ah("matchMedia"));
      }, Qf = function() {
        function n(t, i) {
          this.selector = i && Ku(i), this.data = [], this._r = [], this.isReverted = false, this.id = cS++, t && this.add(t);
        }
        var e = n.prototype;
        return e.add = function(t, i, r) {
          Rt(t) && (r = i, i = t, t = Rt);
          var s = this, a = function() {
            var o = xt, l = s.selector, c;
            return o && o !== s && o.data.push(s), r && (s.selector = Ku(r)), xt = s, c = i.apply(s, arguments), Rt(c) && s._r.push(c), xt = o, s.selector = l, s.isReverted = false, c;
          };
          return s.last = a, t === Rt ? a(s, function(o) {
            return s.add(null, o);
          }) : t ? s[t] = a : a;
        }, e.ignore = function(t) {
          var i = xt;
          xt = null, t(this), xt = i;
        }, e.getTweens = function() {
          var t = [];
          return this.data.forEach(function(i) {
            return i instanceof n ? t.push.apply(t, i.getTweens()) : i instanceof Bt && !(i.parent && i.parent.data === "nested") && t.push(i);
          }), t;
        }, e.clear = function() {
          this._r.length = this.data.length = 0;
        }, e.kill = function(t, i) {
          var r = this;
          if (t ? function() {
            for (var a = r.getTweens(), o = r.data.length, l; o--; ) l = r.data[o], l.data === "isFlip" && (l.revert(), l.getChildren(true, true, false).forEach(function(c) {
              return a.splice(a.indexOf(c), 1);
            }));
            for (a.map(function(c) {
              return {
                g: c._dur || c._delay || c._sat && !c._sat.vars.immediateRender ? c.globalTime(0) : -1 / 0,
                t: c
              };
            }).sort(function(c, u) {
              return u.g - c.g || -1 / 0;
            }).forEach(function(c) {
              return c.t.revert(t);
            }), o = r.data.length; o--; ) l = r.data[o], l instanceof di ? l.data !== "nested" && (l.scrollTrigger && l.scrollTrigger.revert(), l.kill()) : !(l instanceof Bt) && l.revert && l.revert(t);
            r._r.forEach(function(c) {
              return c(t, r);
            }), r.isReverted = true;
          }() : this.data.forEach(function(a) {
            return a.kill && a.kill();
          }), this.clear(), i) for (var s = Rr.length; s--; ) Rr[s].id === this.id && Rr.splice(s, 1);
        }, e.revert = function(t) {
          this.kill(t || {});
        }, n;
      }(), uS = function() {
        function n(t) {
          this.contexts = [], this.scope = t, xt && xt.data.push(this);
        }
        var e = n.prototype;
        return e.add = function(t, i, r) {
          ln(t) || (t = {
            matches: t
          });
          var s = new Qf(0, r || this.scope), a = s.conditions = {}, o, l, c;
          xt && !s.selector && (s.selector = xt.selector), this.contexts.push(s), i = s.add("onMatch", i), s.queries = t;
          for (l in t) l === "all" ? c = 1 : (o = cn.matchMedia(t[l]), o && (Rr.indexOf(s) < 0 && Rr.push(s), (a[l] = o.matches) && (c = 1), o.addListener ? o.addListener(oh) : o.addEventListener("change", oh)));
          return c && i(s, function(u) {
            return s.add(null, u);
          }), this;
        }, e.revert = function(t) {
          this.kill(t || {});
        }, e.kill = function(t) {
          this.contexts.forEach(function(i) {
            return i.kill(t, true);
          });
        }, n;
      }(), fl = {
        registerPlugin: function() {
          for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++) e[t] = arguments[t];
          e.forEach(function(i) {
            return Of(i);
          });
        },
        timeline: function(n) {
          return new di(n);
        },
        getTweensOf: function(n, e) {
          return St.getTweensOf(n, e);
        },
        getProperty: function(n, e, t, i) {
          Yt(n) && (n = Fi(n)[0]);
          var r = Sr(n || {}).get, s = t ? xf : vf;
          return t === "native" && (t = ""), n && (e ? s((wi[e] && wi[e].get || r)(n, e, t, i)) : function(a, o, l) {
            return s((wi[a] && wi[a].get || r)(n, a, o, l));
          });
        },
        quickSetter: function(n, e, t) {
          if (n = Fi(n), n.length > 1) {
            var i = n.map(function(c) {
              return xi.quickSetter(c, e, t);
            }), r = i.length;
            return function(c) {
              for (var u = r; u--; ) i[u](c);
            };
          }
          n = n[0] || {};
          var s = wi[e], a = Sr(n), o = a.harness && (a.harness.aliases || {})[e] || e, l = s ? function(c) {
            var u = new s();
            Bs._pt = 0, u.init(n, t ? c + t : c, Bs, 0, [
              n
            ]), u.render(1, u), Bs._pt && sh(1, Bs);
          } : a.set(n, o);
          return s ? l : function(c) {
            return l(n, o, t ? c + t : c, a, 1);
          };
        },
        quickTo: function(n, e, t) {
          var i, r = xi.to(n, Ai((i = {}, i[e] = "+=0.1", i.paused = true, i.stagger = 0, i), t || {})), s = function(a, o, l) {
            return r.resetTo(e, a, o, l);
          };
          return s.tween = r, s;
        },
        isTweening: function(n) {
          return St.getTweensOf(n, true).length > 0;
        },
        defaults: function(n) {
          return n && n.ease && (n.ease = wr(n.ease, Ds.ease)), yf(Ds, n || {});
        },
        config: function(n) {
          return yf(Si, n || {});
        },
        registerEffect: function(n) {
          var e = n.name, t = n.effect, i = n.plugins, r = n.defaults, s = n.extendTimeline;
          (i || "").split(",").forEach(function(a) {
            return a && !wi[a] && !Ei[a] && Ua(e + " effect requires " + a + " plugin.");
          }), Gu[e] = function(a, o, l) {
            return t(Fi(a), Ai(o || {}, r), l);
          }, s && (di.prototype[e] = function(a, o, l) {
            return this.add(Gu[e](a, ln(o) ? o : (l = o) && {}, this), l);
          });
        },
        registerEase: function(n, e) {
          qe[n] = wr(e);
        },
        parseEase: function(n, e) {
          return arguments.length ? wr(n, e) : qe;
        },
        getById: function(n) {
          return St.getById(n);
        },
        exportRoot: function(n, e) {
          n === void 0 && (n = {});
          var t = new di(n), i, r;
          for (t.smoothChildTiming = gi(n.smoothChildTiming), St.remove(t), t._dp = 0, t._time = t._tTime = St._time, i = St._first; i; ) r = i._next, (e || !(!i._dur && i instanceof Bt && i.vars.onComplete === i._targets[0])) && un(t, i, i._start - i._delay), i = r;
          return un(St, t, 0), t;
        },
        context: function(n, e) {
          return n ? new Qf(n, e) : xt;
        },
        matchMedia: function(n) {
          return new uS(n);
        },
        matchMediaRefresh: function() {
          return Rr.forEach(function(n) {
            var e = n.conditions, t, i;
            for (i in e) e[i] && (e[i] = false, t = 1);
            t && n.revert();
          }) || oh();
        },
        addEventListener: function(n, e) {
          var t = pl[n] || (pl[n] = []);
          ~t.indexOf(e) || t.push(e);
        },
        removeEventListener: function(n, e) {
          var t = pl[n], i = t && t.indexOf(e);
          i >= 0 && t.splice(i, 1);
        },
        utils: {
          wrap: Hb,
          wrapYoyo: Gb,
          distribute: Cf,
          random: Lf,
          snap: Pf,
          normalize: Vb,
          getUnit: ri,
          clamp: Fb,
          splitColor: Ff,
          toArray: Fi,
          selector: Ku,
          mapRange: If,
          pipe: zb,
          unitize: kb,
          interpolate: Wb,
          shuffle: Rf
        },
        install: df,
        effects: Gu,
        ticker: Ci,
        updateRoot: di.updateRoot,
        plugins: wi,
        globalTimeline: St,
        core: {
          PropTween: vi,
          globals: pf,
          Tween: Bt,
          Timeline: di,
          Animation: Wa,
          getCache: Sr,
          _removeLinkedListItem: cl,
          reverting: function() {
            return Jt;
          },
          context: function(n) {
            return n && xt && (xt.data.push(n), n._ctx = xt), xt;
          },
          suppressOverwrites: function(n) {
            return Du = n;
          }
        }
      };
      _i("to,from,fromTo,delayedCall,set,killTweensOf", function(n) {
        return fl[n] = Bt[n];
      }), Ci.add(di.updateRoot), Bs = fl.to({}, {
        duration: 0
      });
      var hS = function(n, e) {
        for (var t = n._pt; t && t.p !== e && t.op !== e && t.fp !== e; ) t = t._next;
        return t;
      }, dS = function(n, e) {
        var t = n._targets, i, r, s;
        for (i in e) for (r = t.length; r--; ) s = n._ptLookup[r][i], s && (s = s.d) && (s._pt && (s = hS(s, i)), s && s.modifier && s.modifier(e[i], n, t[r], i));
      }, lh = function(n, e) {
        return {
          name: n,
          rawVars: 1,
          init: function(t, i, r) {
            r._onInit = function(s) {
              var a, o;
              if (Yt(i) && (a = {}, _i(i, function(l) {
                return a[l] = 1;
              }), i = a), e) {
                a = {};
                for (o in i) a[o] = e(i[o]);
                i = a;
              }
              dS(s, i);
            };
          }
        };
      }, xi = fl.registerPlugin({
        name: "attr",
        init: function(n, e, t, i, r) {
          var s, a, o;
          this.tween = t;
          for (s in e) o = n.getAttribute(s) || "", a = this.add(n, "setAttribute", (o || 0) + "", e[s], i, r, 0, 0, s), a.op = s, a.b = o, this._props.push(s);
        },
        render: function(n, e) {
          for (var t = e._pt; t; ) Jt ? t.set(t.t, t.p, t.b, t) : t.r(n, t.d), t = t._next;
        }
      }, {
        name: "endArray",
        init: function(n, e) {
          for (var t = e.length; t--; ) this.add(n, t, n[t] || 0, e[t], 0, 0, 0, 0, 0, 1);
        }
      }, lh("roundProps", Zu), lh("modifiers"), lh("snap", Pf)) || fl;
      Bt.version = di.version = xi.version = "3.12.7", hf = 1, Uu() && zs(), qe.Power0, qe.Power1, qe.Power2, qe.Power3, qe.Power4, qe.Linear, qe.Quad, qe.Cubic, qe.Quart, qe.Quint, qe.Strong, qe.Elastic, qe.Back, qe.SteppedEase, qe.Bounce, qe.Sine, qe.Expo, qe.Circ;
      var em, ir, ks, ch, Cr, tm, uh, pS = function() {
        return typeof window < "u";
      }, Rn = {}, Pr = 180 / Math.PI, Vs = Math.PI / 180, Hs = Math.atan2, im = 1e8, hh = /([A-Z])/g, fS = /(left|right|width|margin|padding|x)/i, mS = /[\s,\(]\S/, hn = {
        autoAlpha: "opacity,visibility",
        scale: "scaleX,scaleY",
        alpha: "opacity"
      }, dh = function(n, e) {
        return e.set(e.t, e.p, Math.round((e.s + e.c * n) * 1e4) / 1e4 + e.u, e);
      }, gS = function(n, e) {
        return e.set(e.t, e.p, n === 1 ? e.e : Math.round((e.s + e.c * n) * 1e4) / 1e4 + e.u, e);
      }, _S = function(n, e) {
        return e.set(e.t, e.p, n ? Math.round((e.s + e.c * n) * 1e4) / 1e4 + e.u : e.b, e);
      }, vS = function(n, e) {
        var t = e.s + e.c * n;
        e.set(e.t, e.p, ~~(t + (t < 0 ? -0.5 : 0.5)) + e.u, e);
      }, nm = function(n, e) {
        return e.set(e.t, e.p, n ? e.e : e.b, e);
      }, rm = function(n, e) {
        return e.set(e.t, e.p, n !== 1 ? e.b : e.e, e);
      }, xS = function(n, e, t) {
        return n.style[e] = t;
      }, yS = function(n, e, t) {
        return n.style.setProperty(e, t);
      }, MS = function(n, e, t) {
        return n._gsap[e] = t;
      }, TS = function(n, e, t) {
        return n._gsap.scaleX = n._gsap.scaleY = t;
      }, bS = function(n, e, t, i, r) {
        var s = n._gsap;
        s.scaleX = s.scaleY = t, s.renderTransform(r, s);
      }, SS = function(n, e, t, i, r) {
        var s = n._gsap;
        s[e] = t, s.renderTransform(r, s);
      }, Et = "transform", yi = Et + "Origin", ES = function n(e, t) {
        var i = this, r = this.target, s = r.style, a = r._gsap;
        if (e in Rn && s) {
          if (this.tfm = this.tfm || {}, e !== "transform") e = hn[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function(o) {
            return i.tfm[o] = Cn(r, o);
          }) : this.tfm[e] = a.x ? a[e] : Cn(r, e), e === yi && (this.tfm.zOrigin = a.zOrigin);
          else return hn.transform.split(",").forEach(function(o) {
            return n.call(i, o, t);
          });
          if (this.props.indexOf(Et) >= 0) return;
          a.svg && (this.svgo = r.getAttribute("data-svg-origin"), this.props.push(yi, t, "")), e = Et;
        }
        (s || t) && this.props.push(e, t, s[e]);
      }, sm = function(n) {
        n.translate && (n.removeProperty("translate"), n.removeProperty("scale"), n.removeProperty("rotate"));
      }, wS = function() {
        var n = this.props, e = this.target, t = e.style, i = e._gsap, r, s;
        for (r = 0; r < n.length; r += 3) n[r + 1] ? n[r + 1] === 2 ? e[n[r]](n[r + 2]) : e[n[r]] = n[r + 2] : n[r + 2] ? t[n[r]] = n[r + 2] : t.removeProperty(n[r].substr(0, 2) === "--" ? n[r] : n[r].replace(hh, "-$1").toLowerCase());
        if (this.tfm) {
          for (s in this.tfm) i[s] = this.tfm[s];
          i.svg && (i.renderTransform(), e.setAttribute("data-svg-origin", this.svgo || "")), r = uh(), (!r || !r.isStart) && !t[Et] && (sm(t), i.zOrigin && t[yi] && (t[yi] += " " + i.zOrigin + "px", i.zOrigin = 0, i.renderTransform()), i.uncache = 1);
        }
      }, am = function(n, e) {
        var t = {
          target: n,
          props: [],
          revert: wS,
          save: ES
        };
        return n._gsap || xi.core.getCache(n), e && n.style && n.nodeType && e.split(",").forEach(function(i) {
          return t.save(i);
        }), t;
      }, om, ph = function(n, e) {
        var t = ir.createElementNS ? ir.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), n) : ir.createElement(n);
        return t && t.style ? t : ir.createElement(n);
      }, dn = function n(e, t, i) {
        var r = getComputedStyle(e);
        return r[t] || r.getPropertyValue(t.replace(hh, "-$1").toLowerCase()) || r.getPropertyValue(t) || !i && n(e, Gs(t) || t, 1) || "";
      }, lm = "O,Moz,ms,Ms,Webkit".split(","), Gs = function(n, e, t) {
        var i = e || Cr, r = i.style, s = 5;
        if (n in r && !t) return n;
        for (n = n.charAt(0).toUpperCase() + n.substr(1); s-- && !(lm[s] + n in r); ) ;
        return s < 0 ? null : (s === 3 ? "ms" : s >= 0 ? lm[s] : "") + n;
      }, fh = function() {
        pS() && window.document && (em = window, ir = em.document, ks = ir.documentElement, Cr = ph("div") || {
          style: {}
        }, ph("div"), Et = Gs(Et), yi = Et + "Origin", Cr.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", om = !!Gs("perspective"), uh = xi.core.reverting, ch = 1);
      }, cm = function(n) {
        var e = n.ownerSVGElement, t = ph("svg", e && e.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = n.cloneNode(true), r;
        i.style.display = "block", t.appendChild(i), ks.appendChild(t);
        try {
          r = i.getBBox();
        } catch {
        }
        return t.removeChild(i), ks.removeChild(t), r;
      }, um = function(n, e) {
        for (var t = e.length; t--; ) if (n.hasAttribute(e[t])) return n.getAttribute(e[t]);
      }, hm = function(n) {
        var e, t;
        try {
          e = n.getBBox();
        } catch {
          e = cm(n), t = 1;
        }
        return e && (e.width || e.height) || t || (e = cm(n)), e && !e.width && !e.x && !e.y ? {
          x: +um(n, [
            "x",
            "cx",
            "x1"
          ]) || 0,
          y: +um(n, [
            "y",
            "cy",
            "y1"
          ]) || 0,
          width: 0,
          height: 0
        } : e;
      }, dm = function(n) {
        return !!(n.getCTM && (!n.parentNode || n.ownerSVGElement) && hm(n));
      }, Lr = function(n, e) {
        if (e) {
          var t = n.style, i;
          e in Rn && e !== yi && (e = Et), t.removeProperty ? (i = e.substr(0, 2), (i === "ms" || e.substr(0, 6) === "webkit") && (e = "-" + e), t.removeProperty(i === "--" ? e : e.replace(hh, "-$1").toLowerCase())) : t.removeAttribute(e);
        }
      }, nr = function(n, e, t, i, r, s) {
        var a = new vi(n._pt, e, t, 0, 1, s ? rm : nm);
        return n._pt = a, a.b = i, a.e = r, n._props.push(t), a;
      }, pm = {
        deg: 1,
        rad: 1,
        turn: 1
      }, AS = {
        grid: 1,
        flex: 1
      }, rr = function n(e, t, i, r) {
        var s = parseFloat(i) || 0, a = (i + "").trim().substr((s + "").length) || "px", o = Cr.style, l = fS.test(t), c = e.tagName.toLowerCase() === "svg", u = (c ? "client" : "offset") + (l ? "Width" : "Height"), h = 100, d = r === "px", p = r === "%", f, _, g, m;
        if (r === a || !s || pm[r] || pm[a]) return s;
        if (a !== "px" && !d && (s = n(e, t, i, "px")), m = e.getCTM && dm(e), (p || a === "%") && (Rn[t] || ~t.indexOf("adius"))) return f = m ? e.getBBox()[l ? "width" : "height"] : e[u], It(p ? s / f * h : s / 100 * f);
        if (o[l ? "width" : "height"] = h + (d ? a : r), _ = r !== "rem" && ~t.indexOf("adius") || r === "em" && e.appendChild && !c ? e : e.parentNode, m && (_ = (e.ownerSVGElement || {}).parentNode), (!_ || _ === ir || !_.appendChild) && (_ = ir.body), g = _._gsap, g && p && g.width && l && g.time === Ci.time && !g.uncache) return It(s / g.width * h);
        if (p && (t === "height" || t === "width")) {
          var y = e.style[t];
          e.style[t] = h + r, f = e[u], y ? e.style[t] = y : Lr(e, t);
        } else (p || a === "%") && !AS[dn(_, "display")] && (o.position = dn(e, "position")), _ === e && (o.position = "static"), _.appendChild(Cr), f = Cr[u], _.removeChild(Cr), o.position = "absolute";
        return l && p && (g = Sr(_), g.time = Ci.time, g.width = _[u]), It(d ? f * s / h : f && s ? h / f * s : 0);
      }, Cn = function(n, e, t, i) {
        var r;
        return ch || fh(), e in hn && e !== "transform" && (e = hn[e], ~e.indexOf(",") && (e = e.split(",")[0])), Rn[e] && e !== "transform" ? (r = qa(n, i), r = e !== "transformOrigin" ? r[e] : r.svg ? r.origin : gl(dn(n, yi)) + " " + r.zOrigin + "px") : (r = n.style[e], (!r || r === "auto" || i || ~(r + "").indexOf("calc(")) && (r = ml[e] && ml[e](n, e, t) || dn(n, e) || gf(n, e) || (e === "opacity" ? 1 : 0))), t && !~(r + "").trim().indexOf(" ") ? rr(n, e, r, t) + t : r;
      }, RS = function(n, e, t, i) {
        if (!t || t === "none") {
          var r = Gs(e, n, 1), s = r && dn(n, r, 1);
          s && s !== t ? (e = r, t = s) : e === "borderColor" && (t = dn(n, "borderTopColor"));
        }
        var a = new vi(this._pt, n.style, e, 0, 1, Zf), o = 0, l = 0, c, u, h, d, p, f, _, g, m, y, x, v;
        if (a.b = t, a.e = i, t += "", i += "", i === "auto" && (f = n.style[e], n.style[e] = i, i = dn(n, e) || i, f ? n.style[e] = f : Lr(n, e)), c = [
          t,
          i
        ], kf(c), t = c[0], i = c[1], h = t.match(Is) || [], v = i.match(Is) || [], v.length) {
          for (; u = Is.exec(i); ) _ = u[0], m = i.substring(o, u.index), p ? p = (p + 1) % 5 : (m.substr(-5) === "rgba(" || m.substr(-5) === "hsla(") && (p = 1), _ !== (f = h[l++] || "") && (d = parseFloat(f) || 0, x = f.substr((d + "").length), _.charAt(1) === "=" && (_ = Ns(d, _) + x), g = parseFloat(_), y = _.substr((g + "").length), o = Is.lastIndex - y.length, y || (y = y || Si.units[e] || x, o === i.length && (i += y, a.e += y)), x !== y && (d = rr(n, e, f, y) || 0), a._pt = {
            _next: a._pt,
            p: m || l === 1 ? m : ",",
            s: d,
            c: g - d,
            m: p && p < 4 || e === "zIndex" ? Math.round : 0
          });
          a.c = o < i.length ? i.substring(o, i.length) : "";
        } else a.r = e === "display" && i === "none" ? rm : nm;
        return cf.test(i) && (a.e = 0), this._pt = a, a;
      }, fm = {
        top: "0%",
        bottom: "100%",
        left: "0%",
        right: "100%",
        center: "50%"
      }, CS = function(n) {
        var e = n.split(" "), t = e[0], i = e[1] || "50%";
        return (t === "top" || t === "bottom" || i === "left" || i === "right") && (n = t, t = i, i = n), e[0] = fm[t] || t, e[1] = fm[i] || i, e.join(" ");
      }, PS = function(n, e) {
        if (e.tween && e.tween._time === e.tween._dur) {
          var t = e.t, i = t.style, r = e.u, s = t._gsap, a, o, l;
          if (r === "all" || r === true) i.cssText = "", o = 1;
          else for (r = r.split(","), l = r.length; --l > -1; ) a = r[l], Rn[a] && (o = 1, a = a === "transformOrigin" ? yi : Et), Lr(t, a);
          o && (Lr(t, Et), s && (s.svg && t.removeAttribute("transform"), i.scale = i.rotate = i.translate = "none", qa(t, 1), s.uncache = 1, sm(i)));
        }
      }, ml = {
        clearProps: function(n, e, t, i, r) {
          if (r.data !== "isFromStart") {
            var s = n._pt = new vi(n._pt, e, t, 0, 0, PS);
            return s.u = i, s.pr = -10, s.tween = r, n._props.push(t), 1;
          }
        }
      }, ja = [
        1,
        0,
        0,
        1,
        0,
        0
      ], mm = {}, gm = function(n) {
        return n === "matrix(1, 0, 0, 1, 0, 0)" || n === "none" || !n;
      }, _m = function(n) {
        var e = dn(n, Et);
        return gm(e) ? ja : e.substr(7).match(lf).map(It);
      }, mh = function(n, e) {
        var t = n._gsap || Sr(n), i = n.style, r = _m(n), s, a, o, l;
        return t.svg && n.getAttribute("transform") ? (o = n.transform.baseVal.consolidate().matrix, r = [
          o.a,
          o.b,
          o.c,
          o.d,
          o.e,
          o.f
        ], r.join(",") === "1,0,0,1,0,0" ? ja : r) : (r === ja && !n.offsetParent && n !== ks && !t.svg && (o = i.display, i.display = "block", s = n.parentNode, (!s || !n.offsetParent && !n.getBoundingClientRect().width) && (l = 1, a = n.nextElementSibling, ks.appendChild(n)), r = _m(n), o ? i.display = o : Lr(n, "display"), l && (a ? s.insertBefore(n, a) : s ? s.appendChild(n) : ks.removeChild(n))), e && r.length > 6 ? [
          r[0],
          r[1],
          r[4],
          r[5],
          r[12],
          r[13]
        ] : r);
      }, gh = function(n, e, t, i, r, s) {
        var a = n._gsap, o = r || mh(n, true), l = a.xOrigin || 0, c = a.yOrigin || 0, u = a.xOffset || 0, h = a.yOffset || 0, d = o[0], p = o[1], f = o[2], _ = o[3], g = o[4], m = o[5], y = e.split(" "), x = parseFloat(y[0]) || 0, v = parseFloat(y[1]) || 0, A, E, w, R;
        t ? o !== ja && (E = d * _ - p * f) && (w = x * (_ / E) + v * (-f / E) + (f * m - _ * g) / E, R = x * (-p / E) + v * (d / E) - (d * m - p * g) / E, x = w, v = R) : (A = hm(n), x = A.x + (~y[0].indexOf("%") ? x / 100 * A.width : x), v = A.y + (~(y[1] || y[0]).indexOf("%") ? v / 100 * A.height : v)), i || i !== false && a.smooth ? (g = x - l, m = v - c, a.xOffset = u + (g * d + m * f) - g, a.yOffset = h + (g * p + m * _) - m) : a.xOffset = a.yOffset = 0, a.xOrigin = x, a.yOrigin = v, a.smooth = !!i, a.origin = e, a.originIsAbsolute = !!t, n.style[yi] = "0px 0px", s && (nr(s, a, "xOrigin", l, x), nr(s, a, "yOrigin", c, v), nr(s, a, "xOffset", u, a.xOffset), nr(s, a, "yOffset", h, a.yOffset)), n.setAttribute("data-svg-origin", x + " " + v);
      }, qa = function(n, e) {
        var t = n._gsap || new Wf(n);
        if ("x" in t && !e && !t.uncache) return t;
        var i = n.style, r = t.scaleX < 0, s = "px", a = "deg", o = getComputedStyle(n), l = dn(n, yi) || "0", c, u, h, d, p, f, _, g, m, y, x, v, A, E, w, R, S, T, L, B, F, H, X, k, K, G, ie, ue, we, Be, We, j;
        return c = u = h = f = _ = g = m = y = x = 0, d = p = 1, t.svg = !!(n.getCTM && dm(n)), o.translate && ((o.translate !== "none" || o.scale !== "none" || o.rotate !== "none") && (i[Et] = (o.translate !== "none" ? "translate3d(" + (o.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (o.rotate !== "none" ? "rotate(" + o.rotate + ") " : "") + (o.scale !== "none" ? "scale(" + o.scale.split(" ").join(",") + ") " : "") + (o[Et] !== "none" ? o[Et] : "")), i.scale = i.rotate = i.translate = "none"), E = mh(n, t.svg), t.svg && (t.uncache ? (K = n.getBBox(), l = t.xOrigin - K.x + "px " + (t.yOrigin - K.y) + "px", k = "") : k = !e && n.getAttribute("data-svg-origin"), gh(n, k || l, !!k || t.originIsAbsolute, t.smooth !== false, E)), v = t.xOrigin || 0, A = t.yOrigin || 0, E !== ja && (T = E[0], L = E[1], B = E[2], F = E[3], c = H = E[4], u = X = E[5], E.length === 6 ? (d = Math.sqrt(T * T + L * L), p = Math.sqrt(F * F + B * B), f = T || L ? Hs(L, T) * Pr : 0, m = B || F ? Hs(B, F) * Pr + f : 0, m && (p *= Math.abs(Math.cos(m * Vs))), t.svg && (c -= v - (v * T + A * B), u -= A - (v * L + A * F))) : (j = E[6], Be = E[7], ie = E[8], ue = E[9], we = E[10], We = E[11], c = E[12], u = E[13], h = E[14], w = Hs(j, we), _ = w * Pr, w && (R = Math.cos(-w), S = Math.sin(-w), k = H * R + ie * S, K = X * R + ue * S, G = j * R + we * S, ie = H * -S + ie * R, ue = X * -S + ue * R, we = j * -S + we * R, We = Be * -S + We * R, H = k, X = K, j = G), w = Hs(-B, we), g = w * Pr, w && (R = Math.cos(-w), S = Math.sin(-w), k = T * R - ie * S, K = L * R - ue * S, G = B * R - we * S, We = F * S + We * R, T = k, L = K, B = G), w = Hs(L, T), f = w * Pr, w && (R = Math.cos(w), S = Math.sin(w), k = T * R + L * S, K = H * R + X * S, L = L * R - T * S, X = X * R - H * S, T = k, H = K), _ && Math.abs(_) + Math.abs(f) > 359.9 && (_ = f = 0, g = 180 - g), d = It(Math.sqrt(T * T + L * L + B * B)), p = It(Math.sqrt(X * X + j * j)), w = Hs(H, X), m = Math.abs(w) > 2e-4 ? w * Pr : 0, x = We ? 1 / (We < 0 ? -We : We) : 0), t.svg && (k = n.getAttribute("transform"), t.forceCSS = n.setAttribute("transform", "") || !gm(dn(n, Et)), k && n.setAttribute("transform", k))), Math.abs(m) > 90 && Math.abs(m) < 270 && (r ? (d *= -1, m += f <= 0 ? 180 : -180, f += f <= 0 ? 180 : -180) : (p *= -1, m += m <= 0 ? 180 : -180)), e = e || t.uncache, t.x = c - ((t.xPercent = c && (!e && t.xPercent || (Math.round(n.offsetWidth / 2) === Math.round(-c) ? -50 : 0))) ? n.offsetWidth * t.xPercent / 100 : 0) + s, t.y = u - ((t.yPercent = u && (!e && t.yPercent || (Math.round(n.offsetHeight / 2) === Math.round(-u) ? -50 : 0))) ? n.offsetHeight * t.yPercent / 100 : 0) + s, t.z = h + s, t.scaleX = It(d), t.scaleY = It(p), t.rotation = It(f) + a, t.rotationX = It(_) + a, t.rotationY = It(g) + a, t.skewX = m + a, t.skewY = y + a, t.transformPerspective = x + s, (t.zOrigin = parseFloat(l.split(" ")[2]) || !e && t.zOrigin || 0) && (i[yi] = gl(l)), t.xOffset = t.yOffset = 0, t.force3D = Si.force3D, t.renderTransform = t.svg ? DS : om ? vm : LS, t.uncache = 0, t;
      }, gl = function(n) {
        return (n = n.split(" "))[0] + " " + n[1];
      }, _h = function(n, e, t) {
        var i = ri(e);
        return It(parseFloat(e) + parseFloat(rr(n, "x", t + "px", i))) + i;
      }, LS = function(n, e) {
        e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, vm(n, e);
      }, Dr = "0deg", Ya = "0px", Ir = ") ", vm = function(n, e) {
        var t = e || this, i = t.xPercent, r = t.yPercent, s = t.x, a = t.y, o = t.z, l = t.rotation, c = t.rotationY, u = t.rotationX, h = t.skewX, d = t.skewY, p = t.scaleX, f = t.scaleY, _ = t.transformPerspective, g = t.force3D, m = t.target, y = t.zOrigin, x = "", v = g === "auto" && n && n !== 1 || g === true;
        if (y && (u !== Dr || c !== Dr)) {
          var A = parseFloat(c) * Vs, E = Math.sin(A), w = Math.cos(A), R;
          A = parseFloat(u) * Vs, R = Math.cos(A), s = _h(m, s, E * R * -y), a = _h(m, a, -Math.sin(A) * -y), o = _h(m, o, w * R * -y + y);
        }
        _ !== Ya && (x += "perspective(" + _ + Ir), (i || r) && (x += "translate(" + i + "%, " + r + "%) "), (v || s !== Ya || a !== Ya || o !== Ya) && (x += o !== Ya || v ? "translate3d(" + s + ", " + a + ", " + o + ") " : "translate(" + s + ", " + a + Ir), l !== Dr && (x += "rotate(" + l + Ir), c !== Dr && (x += "rotateY(" + c + Ir), u !== Dr && (x += "rotateX(" + u + Ir), (h !== Dr || d !== Dr) && (x += "skew(" + h + ", " + d + Ir), (p !== 1 || f !== 1) && (x += "scale(" + p + ", " + f + Ir), m.style[Et] = x || "translate(0, 0)";
      }, DS = function(n, e) {
        var t = e || this, i = t.xPercent, r = t.yPercent, s = t.x, a = t.y, o = t.rotation, l = t.skewX, c = t.skewY, u = t.scaleX, h = t.scaleY, d = t.target, p = t.xOrigin, f = t.yOrigin, _ = t.xOffset, g = t.yOffset, m = t.forceCSS, y = parseFloat(s), x = parseFloat(a), v, A, E, w, R;
        o = parseFloat(o), l = parseFloat(l), c = parseFloat(c), c && (c = parseFloat(c), l += c, o += c), o || l ? (o *= Vs, l *= Vs, v = Math.cos(o) * u, A = Math.sin(o) * u, E = Math.sin(o - l) * -h, w = Math.cos(o - l) * h, l && (c *= Vs, R = Math.tan(l - c), R = Math.sqrt(1 + R * R), E *= R, w *= R, c && (R = Math.tan(c), R = Math.sqrt(1 + R * R), v *= R, A *= R)), v = It(v), A = It(A), E = It(E), w = It(w)) : (v = u, w = h, A = E = 0), (y && !~(s + "").indexOf("px") || x && !~(a + "").indexOf("px")) && (y = rr(d, "x", s, "px"), x = rr(d, "y", a, "px")), (p || f || _ || g) && (y = It(y + p - (p * v + f * E) + _), x = It(x + f - (p * A + f * w) + g)), (i || r) && (R = d.getBBox(), y = It(y + i / 100 * R.width), x = It(x + r / 100 * R.height)), R = "matrix(" + v + "," + A + "," + E + "," + w + "," + y + "," + x + ")", d.setAttribute("transform", R), m && (d.style[Et] = R);
      }, IS = function(n, e, t, i, r) {
        var s = 360, a = Yt(r), o = parseFloat(r) * (a && ~r.indexOf("rad") ? Pr : 1), l = o - i, c = i + l + "deg", u, h;
        return a && (u = r.split("_")[1], u === "short" && (l %= s, l !== l % (s / 2) && (l += l < 0 ? s : -360)), u === "cw" && l < 0 ? l = (l + s * im) % s - ~~(l / s) * s : u === "ccw" && l > 0 && (l = (l - s * im) % s - ~~(l / s) * s)), n._pt = h = new vi(n._pt, e, t, i, l, gS), h.e = c, h.u = "deg", n._props.push(t), h;
      }, xm = function(n, e) {
        for (var t in e) n[t] = e[t];
        return n;
      }, NS = function(n, e, t) {
        var i = xm({}, t._gsap), r = "perspective,force3D,transformOrigin,svgOrigin", s = t.style, a, o, l, c, u, h, d, p;
        i.svg ? (l = t.getAttribute("transform"), t.setAttribute("transform", ""), s[Et] = e, a = qa(t, 1), Lr(t, Et), t.setAttribute("transform", l)) : (l = getComputedStyle(t)[Et], s[Et] = e, a = qa(t, 1), s[Et] = l);
        for (o in Rn) l = i[o], c = a[o], l !== c && r.indexOf(o) < 0 && (d = ri(l), p = ri(c), u = d !== p ? rr(t, o, l, p) : parseFloat(l), h = parseFloat(c), n._pt = new vi(n._pt, a, o, u, h - u, dh), n._pt.u = p || 0, n._props.push(o));
        xm(a, i);
      };
      _i("padding,margin,Width,Radius", function(n, e) {
        var t = "Top", i = "Right", r = "Bottom", s = "Left", a = (e < 3 ? [
          t,
          i,
          r,
          s
        ] : [
          t + s,
          t + i,
          r + i,
          r + s
        ]).map(function(o) {
          return e < 2 ? n + o : "border" + o + n;
        });
        ml[e > 1 ? "border" + n : n] = function(o, l, c, u, h) {
          var d, p;
          if (arguments.length < 4) return d = a.map(function(f) {
            return Cn(o, f, c);
          }), p = d.join(" "), p.split(d[0]).length === 5 ? d[0] : p;
          d = (u + "").split(" "), p = {}, a.forEach(function(f, _) {
            return p[f] = d[_] = d[_] || d[(_ - 1) / 2 | 0];
          }), o.init(l, p, h);
        };
      });
      var ym = {
        name: "css",
        register: fh,
        targetTest: function(n) {
          return n.style && n.nodeType;
        },
        init: function(n, e, t, i, r) {
          var s = this._props, a = n.style, o = t.vars.startAt, l, c, u, h, d, p, f, _, g, m, y, x, v, A, E, w;
          ch || fh(), this.styles = this.styles || am(n), w = this.styles.props, this.tween = t;
          for (f in e) if (f !== "autoRound" && (c = e[f], !(wi[f] && Xf(f, e, t, i, n, r)))) {
            if (d = typeof c, p = ml[f], d === "function" && (c = c.call(t, i, n, r), d = typeof c), d === "string" && ~c.indexOf("random(") && (c = ka(c)), p) p(this, n, f, c, t) && (E = 1);
            else if (f.substr(0, 2) === "--") l = (getComputedStyle(n).getPropertyValue(f) + "").trim(), c += "", er.lastIndex = 0, er.test(l) || (_ = ri(l), g = ri(c)), g ? _ !== g && (l = rr(n, f, l, g) + g) : _ && (c += _), this.add(a, "setProperty", l, c, i, r, 0, 0, f), s.push(f), w.push(f, 0, a[f]);
            else if (d !== "undefined") {
              if (o && f in o ? (l = typeof o[f] == "function" ? o[f].call(t, i, n, r) : o[f], Yt(l) && ~l.indexOf("random(") && (l = ka(l)), ri(l + "") || l === "auto" || (l += Si.units[f] || ri(Cn(n, f)) || ""), (l + "").charAt(1) === "=" && (l = Cn(n, f))) : l = Cn(n, f), h = parseFloat(l), m = d === "string" && c.charAt(1) === "=" && c.substr(0, 2), m && (c = c.substr(2)), u = parseFloat(c), f in hn && (f === "autoAlpha" && (h === 1 && Cn(n, "visibility") === "hidden" && u && (h = 0), w.push("visibility", 0, a.visibility), nr(this, a, "visibility", h ? "inherit" : "hidden", u ? "inherit" : "hidden", !u)), f !== "scale" && f !== "transform" && (f = hn[f], ~f.indexOf(",") && (f = f.split(",")[0]))), y = f in Rn, y) {
                if (this.styles.save(f), x || (v = n._gsap, v.renderTransform && !e.parseTransform || qa(n, e.parseTransform), A = e.smoothOrigin !== false && v.smooth, x = this._pt = new vi(this._pt, a, Et, 0, 1, v.renderTransform, v, 0, -1), x.dep = 1), f === "scale") this._pt = new vi(this._pt, v, "scaleY", v.scaleY, (m ? Ns(v.scaleY, m + u) : u) - v.scaleY || 0, dh), this._pt.u = 0, s.push("scaleY", f), f += "X";
                else if (f === "transformOrigin") {
                  w.push(yi, 0, a[yi]), c = CS(c), v.svg ? gh(n, c, 0, A, 0, this) : (g = parseFloat(c.split(" ")[2]) || 0, g !== v.zOrigin && nr(this, v, "zOrigin", v.zOrigin, g), nr(this, a, f, gl(l), gl(c)));
                  continue;
                } else if (f === "svgOrigin") {
                  gh(n, c, 1, A, 0, this);
                  continue;
                } else if (f in mm) {
                  IS(this, v, f, h, m ? Ns(h, m + c) : c);
                  continue;
                } else if (f === "smoothOrigin") {
                  nr(this, v, "smooth", v.smooth, c);
                  continue;
                } else if (f === "force3D") {
                  v[f] = c;
                  continue;
                } else if (f === "transform") {
                  NS(this, c, n);
                  continue;
                }
              } else f in a || (f = Gs(f) || f);
              if (y || (u || u === 0) && (h || h === 0) && !mS.test(c) && f in a) _ = (l + "").substr((h + "").length), u || (u = 0), g = ri(c) || (f in Si.units ? Si.units[f] : _), _ !== g && (h = rr(n, f, l, g)), this._pt = new vi(this._pt, y ? v : a, f, h, (m ? Ns(h, m + u) : u) - h, !y && (g === "px" || f === "zIndex") && e.autoRound !== false ? vS : dh), this._pt.u = g || 0, _ !== g && g !== "%" && (this._pt.b = l, this._pt.r = _S);
              else if (f in a) RS.call(this, n, f, l, m ? m + c : c);
              else if (f in n) this.add(n, f, l || n[f], m ? m + c : c, i, r);
              else if (f !== "parseTransform") {
                ku(f, c);
                continue;
              }
              y || (f in a ? w.push(f, 0, a[f]) : typeof n[f] == "function" ? w.push(f, 2, n[f]()) : w.push(f, 1, l || n[f])), s.push(f);
            }
          }
          E && Jf(this);
        },
        render: function(n, e) {
          if (e.tween._time || !uh()) for (var t = e._pt; t; ) t.r(n, t.d), t = t._next;
          else e.styles.revert();
        },
        get: Cn,
        aliases: hn,
        getSetter: function(n, e, t) {
          var i = hn[e];
          return i && i.indexOf(",") < 0 && (e = i), e in Rn && e !== yi && (n._gsap.x || Cn(n, "x")) ? t && tm === t ? e === "scale" ? TS : MS : (tm = t || {}) && (e === "scale" ? bS : SS) : n.style && !Nu(n.style[e]) ? xS : ~e.indexOf("-") ? yS : rh(n, e);
        },
        core: {
          _removeProperty: Lr,
          _getMatrix: mh
        }
      };
      xi.utils.checkPrefix = Gs, xi.core.getStyleSaver = am, function(n, e, t, i) {
        var r = _i(n + "," + e + "," + t, function(s) {
          Rn[s] = 1;
        });
        _i(e, function(s) {
          Si.units[s] = "deg", mm[s] = 1;
        }), hn[r[13]] = n + "," + e, _i(i, function(s) {
          var a = s.split(":");
          hn[a[1]] = r[a[0]];
        });
      }("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"), _i("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(n) {
        Si.units[n] = "px";
      }), xi.registerPlugin(ym), wt = xi.registerPlugin(ym) || xi, wt.core.Tween;
      const vh = /* @__PURE__ */ new Map(), xh = [], Ws = new vr(), _l = new ee();
      let zt = null;
      const yh = new ee(), Nr = [];
      async function vl(n) {
        return await (await fetch(n)).text();
      }
      async function Mh(n, e, t, i = 1.5, r) {
        return new Promise((s, a) => {
          new Pu().load("./../../res/font/GenosThin_Regular.json", async (o) => {
            try {
              const l = new Lu(n, {
                font: o,
                size: i,
                depth: 0.05,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.03,
                bevelSize: 0.02,
                bevelOffset: 0,
                bevelSegments: 5
              }), c = await vl("./../../res/shaders/textVertexShader.glsl"), u = await vl("./../../res/shaders/textFragmentShader.glsl"), h = new ti({
                uniforms: {
                  textColor: {
                    value: new Ae(249 / 255, 159 / 255, 0 / 255)
                  },
                  opacity: {
                    value: 1
                  }
                },
                vertexShader: c,
                fragmentShader: u,
                transparent: true
              }), d = new Dt(l, h);
              d.position.set(e.x, e.y, e.z), d.rotation.set(t.x, t.y, t.z), r.add(d), s(d);
            } catch (l) {
              a(l);
            }
          }, void 0, a);
        });
      }
      function xl(n, e, t, i, r, s, a, o) {
        if (vh.has(n)) {
          const l = vh.get(n);
          return l.position.set(t.x, t.y, t.z), l.scale.set(i, i, i), l.rotation.set(r.x, r.y, r.z), a.add(l), Mm(l, s), o && o(l), l;
        }
        new FT().load(e, (l) => {
          const c = l.scene;
          c.position.set(t.x, t.y, t.z), c.scale.set(i, i, i), c.rotation.set(r.x, r.y, r.z), c.traverse((u) => {
            u.isMesh && u.geometry.computeBoundingSphere();
          }), vh.set(n, c), a.add(c), Mm(c, s), o && o(c);
        }, void 0, (l) => {
          console.error(`Error loading model ${n}:`, l);
        });
      }
      function Mm(n, e) {
        (e == null ? void 0 : e.position) && wt.to(n.position, {
          x: e.position.x,
          y: e.position.y,
          z: e.position.z,
          duration: e.position.duration || 3,
          ease: e.position.ease || "power2.out"
        }), (e == null ? void 0 : e.rotation) && wt.to(n.rotation, {
          x: n.rotation.x + (e.rotation.x || 0),
          y: n.rotation.y + (e.rotation.y || 0),
          z: n.rotation.z + (e.rotation.z || 0),
          duration: e.rotation.duration || 45,
          ease: e.rotation.ease || "linear",
          repeat: e.rotation.repeat ?? -1
        });
      }
      function US(n, e, t, i) {
        const r = new Yn();
        r.position.set(e.x, e.y, e.z), r.rotation.set(t.x, t.y, t.z);
        const s = 1.2, a = 0;
        n.forEach((o, l) => {
          const c = {
            x: 0,
            y: a - l * s,
            z: 0
          }, u = Tm(o.text, c, i, o.onClick);
          r.add(u);
        }), i.add(r);
      }
      function Tm(n, e, t, i, r = 0.5) {
        const s = new Pu(), a = new Dt();
        return s.load("./../../res/font/GenosThin_Regular.json", (o) => {
          const l = new Lu(n, {
            font: o,
            size: r,
            depth: 0.05,
            curveSegments: 12,
            bevelEnabled: true,
            bevelThickness: 0.03,
            bevelSize: 0.02,
            bevelOffset: 0,
            bevelSegments: 5
          }), c = new Ts({
            color: 16777215,
            transparent: true,
            opacity: 1,
            emissive: 0,
            metalness: 0,
            roughness: 1
          });
          a.geometry = l, a.material = c, a.position.set(e.x + 1, e.y - 1.25, e.z), a.userData.onClick = i, a.userData.originalColor = c.color.getHex(), xh.push(a), wt.to(c, {
            opacity: 1,
            duration: 2,
            delay: Math.abs(e.y) * 0.15,
            ease: "power2.out"
          });
        }), a;
      }
      function OS(n, e, t) {
        const i = t.domElement.getBoundingClientRect();
        _l.x = (n.clientX - i.left) / i.width * 2 - 1, _l.y = -((n.clientY - i.top) / i.height) * 2 + 1, Ws.setFromCamera(_l, e);
        const r = Ws.intersectObjects(xh);
        if (r.length > 0) {
          const s = r[0].object;
          zt !== s && (zt && (wt.to(zt.material.color, {
            r: (zt.userData.originalColor >> 16 & 255) / 255,
            g: (zt.userData.originalColor >> 8 & 255) / 255,
            b: (zt.userData.originalColor & 255) / 255,
            duration: 0.3
          }), wt.to(zt.scale, {
            x: 1,
            y: 1,
            z: 1,
            duration: 0.3
          })), zt = s, document.body.style.cursor = "pointer", zt.userData.originalColorStored || (zt.userData.originalColor = zt.material.color.getHex(), zt.userData.originalColorStored = true), wt.to(zt.material.color, {
            r: 1,
            g: 0.5,
            b: 0,
            duration: 0.3
          }));
        } else zt && (wt.to(zt.material.color, {
          r: (zt.userData.originalColor >> 16 & 255) / 255,
          g: (zt.userData.originalColor >> 8 & 255) / 255,
          b: (zt.userData.originalColor & 255) / 255,
          duration: 0.3
        }), wt.to(zt.scale, {
          x: 1,
          y: 1,
          z: 1,
          duration: 0.3
        }), zt = null), document.body.style.cursor = "default";
      }
      function FS(n, e) {
        Ws.setFromCamera(_l, e);
        const t = Ws.intersectObjects(xh);
        if (t.length > 0) {
          const i = t[0].object;
          i.userData.onClick && i.userData.onClick();
        }
      }
      function BS(n, e, t) {
        window.addEventListener("mousemove", (i) => OS(i, n, t)), window.addEventListener("click", (i) => FS(i, n));
      }
      function Th(n, e) {
        n.traverse((t) => {
          t.isMesh && (t.userData.onClick = e, Nr.push(t));
        });
      }
      function zS(n, e) {
        window.addEventListener("click", (t) => {
          const i = e.domElement.getBoundingClientRect();
          yh.x = (t.clientX - i.left) / i.width * 2 - 1, yh.y = -((t.clientY - i.top) / i.height) * 2 + 1, Ws.setFromCamera(yh, n);
          const r = Ws.intersectObjects(Nr, true);
          if (r.length > 0) {
            const s = r[0].object;
            s.userData.onClick && s.userData.onClick();
          }
        });
      }
      async function Xs(n, e, t, i = 0.7, r, s) {
        return new Promise((a, o) => {
          new Pu().load("/res/font/Roboto_Regular.json", async (l) => {
            try {
              const c = new Lu(n, {
                font: l,
                size: i,
                depth: 0.05,
                curveSegments: 12,
                bevelEnabled: true,
                bevelThickness: 0.03,
                bevelSize: 0.02,
                bevelOffset: 0,
                bevelSegments: 5
              });
              c.computeBoundingBox(), c.center();
              const u = await vl("/res/shaders/textVertexShader.glsl"), h = await vl("/res/shaders/textFragmentShader.glsl"), d = new ti({
                uniforms: {
                  textColor: {
                    value: new Ae(249 / 255, 159 / 255, 0 / 255)
                  }
                },
                vertexShader: u,
                fragmentShader: h
              }), p = new Dt(c, d);
              p.position.set(e.x, e.y, e.z + 0.02), p.rotation.set(t.x, t.y, t.z), r.add(p);
              const f = c.boundingBox.getSize(new D()), _ = 0.3, g = new pr(f.x + _, f.y + _, 0.2), m = new Ts({
                color: 0,
                transparent: true,
                opacity: 0.05,
                emissive: new Ae(0),
                emissiveIntensity: 1
              }), y = new Dt(g, m);
              y.position.set(e.x, e.y, e.z), y.rotation.set(t.x, t.y, t.z), y.name = `button-${n.replace(/\s+/g, "-")}`, s && Th(y, s), r.add(y), a({
                textMesh: p,
                buttonMesh: y
              });
            } catch (c) {
              o(c);
            }
          }, void 0, o);
        });
      }
      function bh(n, e = {}) {
        if (!n || !n.material || !("emissive" in n.material)) return;
        const { color: t = "#ff9900", intensity: i = 1.5 } = e;
        n.material.emissive = new Ae(t), n.material.emissiveIntensity = i, n.material.needsUpdate = true;
      }
      const bm = {
        name: "CopyShader",
        uniforms: {
          tDiffuse: {
            value: null
          },
          opacity: {
            value: 1
          }
        },
        vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
        fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
      };
      class Ka {
        constructor() {
          this.isPass = true, this.enabled = true, this.needsSwap = true, this.clear = false, this.renderToScreen = false;
        }
        setSize() {
        }
        render() {
          console.error("THREE.Pass: .render() must be implemented in derived pass.");
        }
        dispose() {
        }
      }
      const kS = new Jo(-1, 1, 1, -1, 0, 1);
      class VS extends mi {
        constructor() {
          super(), this.setAttribute("position", new Zt([
            -1,
            3,
            0,
            -1,
            -1,
            0,
            3,
            -1,
            0
          ], 3)), this.setAttribute("uv", new Zt([
            0,
            2,
            0,
            0,
            2,
            0
          ], 2));
        }
      }
      const HS = new VS();
      class Sm {
        constructor(e) {
          this._mesh = new Dt(HS, e);
        }
        dispose() {
          this._mesh.geometry.dispose();
        }
        render(e) {
          e.render(this._mesh, kS);
        }
        get material() {
          return this._mesh.material;
        }
        set material(e) {
          this._mesh.material = e;
        }
      }
      class GS extends Ka {
        constructor(e, t) {
          super(), this.textureID = t !== void 0 ? t : "tDiffuse", e instanceof ti ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = No.clone(e.uniforms), this.material = new ti({
            name: e.name !== void 0 ? e.name : "unspecified",
            defines: Object.assign({}, e.defines),
            uniforms: this.uniforms,
            vertexShader: e.vertexShader,
            fragmentShader: e.fragmentShader
          })), this.fsQuad = new Sm(this.material);
        }
        render(e, t, i) {
          this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
        }
        dispose() {
          this.material.dispose(), this.fsQuad.dispose();
        }
      }
      class Em extends Ka {
        constructor(e, t) {
          super(), this.scene = e, this.camera = t, this.clear = true, this.needsSwap = false, this.inverse = false;
        }
        render(e, t, i) {
          const r = e.getContext(), s = e.state;
          s.buffers.color.setMask(false), s.buffers.depth.setMask(false), s.buffers.color.setLocked(true), s.buffers.depth.setLocked(true);
          let a, o;
          this.inverse ? (a = 0, o = 1) : (a = 1, o = 0), s.buffers.stencil.setTest(true), s.buffers.stencil.setOp(r.REPLACE, r.REPLACE, r.REPLACE), s.buffers.stencil.setFunc(r.ALWAYS, a, 4294967295), s.buffers.stencil.setClear(o), s.buffers.stencil.setLocked(true), e.setRenderTarget(i), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), s.buffers.color.setLocked(false), s.buffers.depth.setLocked(false), s.buffers.color.setMask(true), s.buffers.depth.setMask(true), s.buffers.stencil.setLocked(false), s.buffers.stencil.setFunc(r.EQUAL, 1, 4294967295), s.buffers.stencil.setOp(r.KEEP, r.KEEP, r.KEEP), s.buffers.stencil.setLocked(true);
        }
      }
      class WS extends Ka {
        constructor() {
          super(), this.needsSwap = false;
        }
        render(e) {
          e.state.buffers.stencil.setLocked(false), e.state.buffers.stencil.setTest(false);
        }
      }
      class XS {
        constructor(e, t) {
          if (this.renderer = e, this._pixelRatio = e.getPixelRatio(), t === void 0) {
            const i = e.getSize(new ee());
            this._width = i.width, this._height = i.height, t = new Gi(this._width * this._pixelRatio, this._height * this._pixelRatio, {
              type: mn
            }), t.texture.name = "EffectComposer.rt1";
          } else this._width = t.width, this._height = t.height;
          this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = true, this.passes = [], this.copyPass = new GS(bm), this.copyPass.material.blending = jt, this.clock = new Wv();
        }
        swapBuffers() {
          const e = this.readBuffer;
          this.readBuffer = this.writeBuffer, this.writeBuffer = e;
        }
        addPass(e) {
          this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
        }
        insertPass(e, t) {
          this.passes.splice(t, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
        }
        removePass(e) {
          const t = this.passes.indexOf(e);
          t !== -1 && this.passes.splice(t, 1);
        }
        isLastEnabledPass(e) {
          for (let t = e + 1; t < this.passes.length; t++) if (this.passes[t].enabled) return false;
          return true;
        }
        render(e) {
          e === void 0 && (e = this.clock.getDelta());
          const t = this.renderer.getRenderTarget();
          let i = false;
          for (let r = 0, s = this.passes.length; r < s; r++) {
            const a = this.passes[r];
            if (a.enabled !== false) {
              if (a.renderToScreen = this.renderToScreen && this.isLastEnabledPass(r), a.render(this.renderer, this.writeBuffer, this.readBuffer, e, i), a.needsSwap) {
                if (i) {
                  const o = this.renderer.getContext(), l = this.renderer.state.buffers.stencil;
                  l.setFunc(o.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), l.setFunc(o.EQUAL, 1, 4294967295);
                }
                this.swapBuffers();
              }
              Em !== void 0 && (a instanceof Em ? i = true : a instanceof WS && (i = false));
            }
          }
          this.renderer.setRenderTarget(t);
        }
        reset(e) {
          if (e === void 0) {
            const t = this.renderer.getSize(new ee());
            this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, e = this.renderTarget1.clone(), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
          }
          this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
        }
        setSize(e, t) {
          this._width = e, this._height = t;
          const i = this._width * this._pixelRatio, r = this._height * this._pixelRatio;
          this.renderTarget1.setSize(i, r), this.renderTarget2.setSize(i, r);
          for (let s = 0; s < this.passes.length; s++) this.passes[s].setSize(i, r);
        }
        setPixelRatio(e) {
          this._pixelRatio = e, this.setSize(this._width, this._height);
        }
        dispose() {
          this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
        }
      }
      class jS extends Ka {
        constructor(e, t, i = null, r = null, s = null) {
          super(), this.scene = e, this.camera = t, this.overrideMaterial = i, this.clearColor = r, this.clearAlpha = s, this.clear = true, this.clearDepth = false, this.needsSwap = false, this._oldClearColor = new Ae();
        }
        render(e, t, i) {
          const r = e.autoClear;
          e.autoClear = false;
          let s, a;
          this.overrideMaterial !== null && (a = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (e.getClearColor(this._oldClearColor), e.setClearColor(this.clearColor, e.getClearAlpha())), this.clearAlpha !== null && (s = e.getClearAlpha(), e.setClearAlpha(this.clearAlpha)), this.clearDepth == true && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : i), this.clear === true && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor !== null && e.setClearColor(this._oldClearColor), this.clearAlpha !== null && e.setClearAlpha(s), this.overrideMaterial !== null && (this.scene.overrideMaterial = a), e.autoClear = r;
        }
      }
      const qS = {
        uniforms: {
          tDiffuse: {
            value: null
          },
          luminosityThreshold: {
            value: 1
          },
          smoothWidth: {
            value: 1
          },
          defaultColor: {
            value: new Ae(0)
          },
          defaultOpacity: {
            value: 0
          }
        },
        vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
        fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			float v = luminance( texel.xyz );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`
      };
      class js extends Ka {
        constructor(e, t, i, r) {
          super(), this.strength = t !== void 0 ? t : 1, this.radius = i, this.threshold = r, this.resolution = e !== void 0 ? new ee(e.x, e.y) : new ee(256, 256), this.clearColor = new Ae(0, 0, 0), this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
          let s = Math.round(this.resolution.x / 2), a = Math.round(this.resolution.y / 2);
          this.renderTargetBright = new Gi(s, a, {
            type: mn
          }), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = false;
          for (let h = 0; h < this.nMips; h++) {
            const d = new Gi(s, a, {
              type: mn
            });
            d.texture.name = "UnrealBloomPass.h" + h, d.texture.generateMipmaps = false, this.renderTargetsHorizontal.push(d);
            const p = new Gi(s, a, {
              type: mn
            });
            p.texture.name = "UnrealBloomPass.v" + h, p.texture.generateMipmaps = false, this.renderTargetsVertical.push(p), s = Math.round(s / 2), a = Math.round(a / 2);
          }
          const o = qS;
          this.highPassUniforms = No.clone(o.uniforms), this.highPassUniforms.luminosityThreshold.value = r, this.highPassUniforms.smoothWidth.value = 0.01, this.materialHighPassFilter = new ti({
            uniforms: this.highPassUniforms,
            vertexShader: o.vertexShader,
            fragmentShader: o.fragmentShader
          }), this.separableBlurMaterials = [];
          const l = [
            3,
            5,
            7,
            9,
            11
          ];
          s = Math.round(this.resolution.x / 2), a = Math.round(this.resolution.y / 2);
          for (let h = 0; h < this.nMips; h++) this.separableBlurMaterials.push(this.getSeparableBlurMaterial(l[h])), this.separableBlurMaterials[h].uniforms.invSize.value = new ee(1 / s, 1 / a), s = Math.round(s / 2), a = Math.round(a / 2);
          this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = t, this.compositeMaterial.uniforms.bloomRadius.value = 0.1;
          const c = [
            1,
            0.8,
            0.6,
            0.4,
            0.2
          ];
          this.compositeMaterial.uniforms.bloomFactors.value = c, this.bloomTintColors = [
            new D(1, 1, 1),
            new D(1, 1, 1),
            new D(1, 1, 1),
            new D(1, 1, 1),
            new D(1, 1, 1)
          ], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors;
          const u = bm;
          this.copyUniforms = No.clone(u.uniforms), this.blendMaterial = new ti({
            uniforms: this.copyUniforms,
            vertexShader: u.vertexShader,
            fragmentShader: u.fragmentShader,
            blending: qr,
            depthTest: false,
            depthWrite: false,
            transparent: true
          }), this.enabled = true, this.needsSwap = false, this._oldClearColor = new Ae(), this.oldClearAlpha = 1, this.basic = new tn(), this.fsQuad = new Sm(null);
        }
        dispose() {
          for (let e = 0; e < this.renderTargetsHorizontal.length; e++) this.renderTargetsHorizontal[e].dispose();
          for (let e = 0; e < this.renderTargetsVertical.length; e++) this.renderTargetsVertical[e].dispose();
          this.renderTargetBright.dispose();
          for (let e = 0; e < this.separableBlurMaterials.length; e++) this.separableBlurMaterials[e].dispose();
          this.compositeMaterial.dispose(), this.blendMaterial.dispose(), this.basic.dispose(), this.fsQuad.dispose();
        }
        setSize(e, t) {
          let i = Math.round(e / 2), r = Math.round(t / 2);
          this.renderTargetBright.setSize(i, r);
          for (let s = 0; s < this.nMips; s++) this.renderTargetsHorizontal[s].setSize(i, r), this.renderTargetsVertical[s].setSize(i, r), this.separableBlurMaterials[s].uniforms.invSize.value = new ee(1 / i, 1 / r), i = Math.round(i / 2), r = Math.round(r / 2);
        }
        render(e, t, i, r, s) {
          e.getClearColor(this._oldClearColor), this.oldClearAlpha = e.getClearAlpha();
          const a = e.autoClear;
          e.autoClear = false, e.setClearColor(this.clearColor, 0), s && e.state.buffers.stencil.setTest(false), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = i.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), this.highPassUniforms.tDiffuse.value = i.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, e.setRenderTarget(this.renderTargetBright), e.clear(), this.fsQuad.render(e);
          let o = this.renderTargetBright;
          for (let l = 0; l < this.nMips; l++) this.fsQuad.material = this.separableBlurMaterials[l], this.separableBlurMaterials[l].uniforms.colorTexture.value = o.texture, this.separableBlurMaterials[l].uniforms.direction.value = js.BlurDirectionX, e.setRenderTarget(this.renderTargetsHorizontal[l]), e.clear(), this.fsQuad.render(e), this.separableBlurMaterials[l].uniforms.colorTexture.value = this.renderTargetsHorizontal[l].texture, this.separableBlurMaterials[l].uniforms.direction.value = js.BlurDirectionY, e.setRenderTarget(this.renderTargetsVertical[l]), e.clear(), this.fsQuad.render(e), o = this.renderTargetsVertical[l];
          this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, e.setRenderTarget(this.renderTargetsHorizontal[0]), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.blendMaterial, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, s && e.state.buffers.stencil.setTest(true), this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(i), this.fsQuad.render(e)), e.setClearColor(this._oldClearColor, this.oldClearAlpha), e.autoClear = a;
        }
        getSeparableBlurMaterial(e) {
          const t = [];
          for (let i = 0; i < e; i++) t.push(0.39894 * Math.exp(-0.5 * i * i / (e * e)) / e);
          return new ti({
            defines: {
              KERNEL_RADIUS: e
            },
            uniforms: {
              colorTexture: {
                value: null
              },
              invSize: {
                value: new ee(0.5, 0.5)
              },
              direction: {
                value: new ee(0.5, 0.5)
              },
              gaussianCoefficients: {
                value: t
              }
            },
            vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
            fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 invSize;
				uniform vec2 direction;
				uniform float gaussianCoefficients[KERNEL_RADIUS];

				void main() {
					float weightSum = gaussianCoefficients[0];
					vec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianCoefficients[i];
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`
          });
        }
        getCompositeMaterial(e) {
          return new ti({
            defines: {
              NUM_MIPS: e
            },
            uniforms: {
              blurTexture1: {
                value: null
              },
              blurTexture2: {
                value: null
              },
              blurTexture3: {
                value: null
              },
              blurTexture4: {
                value: null
              },
              blurTexture5: {
                value: null
              },
              bloomStrength: {
                value: 1
              },
              bloomFactors: {
                value: null
              },
              bloomTintColors: {
                value: null
              },
              bloomRadius: {
                value: 0
              }
            },
            vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
            fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`
          });
        }
      }
      js.BlurDirectionX = new ee(1, 0), js.BlurDirectionY = new ee(0, 1);
      function YS(n, e = {
        density: 1
      }) {
        const t = new mi(), i = [], r = 4e3, s = 6e3, a = Math.floor(5e3 * e.density);
        for (let c = 0; c < a; c++) {
          let u, h, d, p;
          do
            u = (Math.random() - 0.5) * s * 2, h = (Math.random() - 0.5) * s * 2, d = (Math.random() - 0.5) * s * 2, p = Math.sqrt(u * u + h * h + d * d);
          while (p < r);
          i.push(u, h, d);
        }
        t.setAttribute("position", new Zt(i, 3));
        const o = new Zc({
          color: 16777164,
          size: 3,
          sizeAttenuation: true,
          transparent: true,
          opacity: 1,
          blending: qr
        }), l = new Zd(t, o);
        n.add(l);
      }
      function KS(n, e, t, i = 2) {
        const r = new lu(6, 32, 32), s = new Ts({
          emissive: new Ae(16777164),
          emissiveIntensity: 3,
          roughness: 0.1
        }), a = new Dt(r, s);
        a.position.set(-100, 250, -500), n.add(a);
        const o = new pu(16755200, 10, 500);
        o.position.copy(a.position), n.add(o);
        const l = new XS(e);
        l.addPass(new jS(n, t));
        const c = new js(new ee(window.innerWidth, window.innerHeight), i, 0.4, 1.2);
        return l.addPass(c), l;
      }
      let ut = null, Pn = null, Yi = null;
      function ZS() {
        if (ut) {
          ut.style.display = "flex";
          return;
        }
        console.log("Creating Name viewport"), ut = document.createElement("div"), ut.id = "name-viewport-container", ut.style.position = "fixed", ut.style.top = "50%", ut.style.left = "50%", ut.style.transform = "translate(-50%, -50%)", ut.style.width = "80%", ut.style.maxWidth = "1200px", ut.style.height = "80vh", ut.style.backgroundColor = "rgba(0, 0, 0, 0.9)", ut.style.border = "0.5px solid #FFFF", ut.style.borderRadius = "20px", ut.style.boxShadow = "0 0 30px rgba(0, 123, 255, 0.5)", ut.style.zIndex = "1000", ut.style.display = "flex", ut.style.flexDirection = "column", ut.style.overflow = "hidden";
        const n = document.createElement("div");
        n.style.display = "flex", n.style.justifyContent = "space-between", n.style.alignItems = "center", n.style.padding = "1px 2px", n.style.backgroundColor = "rgba(0, 0, 0, 0.3)", n.style.color = "white", n.style.borderTopLeftRadius = "20px", n.style.borderTopRightRadius = "20px";
        const e = document.createElement("h2");
        e.style.fontSize = "1.2rem", Yi = document.createElement("button"), Yi.textContent = "\u2715", Yi.style.background = "none", Yi.style.border = "none", Yi.style.color = "white", Yi.style.fontSize = "1.5rem", Yi.style.cursor = "pointer", Yi.style.padding = "0 5px", Yi.style.lineHeight = "1", n.appendChild(Yi), ut.appendChild(n), Pn = document.createElement("iframe"), Pn.src = "./public/psycheName/public/name/psycheName.html", Pn.style.width = "100%", Pn.style.height = "100%", Pn.style.border = "none", Pn.style.backgroundColor = "#222", Pn.onerror = () => {
          console.error("Failed to load iframe content");
        }, Pn.onload = () => {
          console.log("Iframe loaded successfully");
        }, ut.appendChild(Pn), document.body.appendChild(ut), wt.from(ut, {
          opacity: 0,
          scale: 0.8,
          duration: 0.4,
          ease: "power2.out"
        }), Yi.addEventListener("click", Sh), document.addEventListener("keydown", JS);
      }
      function Sh() {
        ut && wt.to(ut, {
          opacity: 0,
          scale: 0.8,
          duration: 0.3,
          ease: "power2.in",
          onComplete: () => {
            ut.style.display = "none", ut.style.opacity = 1, ut.style.transform = "translate(-50%, -50%) scale(1)";
          }
        });
      }
      function JS(n) {
        n.key === "Escape" && Sh();
      }
      function qs(n, e = {}) {
        const { backgroundColor: t = "rgba(0, 0, 0, 0.125)", borderColor: i = "#ffffcc", borderWidth: r = "2px", borderRadius: s = "10px", boxShadow: a = "0 0 25px rgba(255, 255, 204, 0.6)", zIndex: o = "900" } = e;
        n.style.position = "fixed", n.style.top = "50%", n.style.left = "50%", n.style.transform = "translate(-50%, -50%)", n.style.backgroundColor = t, n.style.border = `${r} solid ${i}`, n.style.borderRadius = s, n.style.boxShadow = a, n.style.zIndex = o, n.style.display = "flex", n.style.flexDirection = "column", n.style.overflow = "hidden";
      }
      function Ys(n, e = {}) {
        const { backgroundColor: t = "rgba(26, 26, 58, 0.125)", gradientStart: i = "rgba(26, 26, 58, 0.125)", gradientEnd: r = "rgba(58, 58, 106, 0.125)", textColor: s = "white", padding: a = "10px 15px" } = e;
        n.style.display = "flex", n.style.justifyContent = "space-between", n.style.alignItems = "center", n.style.padding = a, n.style.backgroundColor = t, n.style.backgroundImage = `linear-gradient(to right, ${i}, ${r})`, n.style.color = s, n.style.borderTopLeftRadius = "8px", n.style.borderTopRightRadius = "8px";
      }
      function Ks(n, e = {}) {
        const { fontSize: t = "1.2rem", textShadow: i = "0 0 5px rgba(255, 255, 204, 0.7)", letterSpacing: r = "0.5px" } = e;
        n.style.margin = "0", n.style.fontSize = t, n.style.textShadow = i, n.style.letterSpacing = r;
      }
      function Zs(n, e = {}) {
        const { color: t = "white", fontSize: i = "1.5rem" } = e;
        n.style.background = "none", n.style.border = "none", n.style.color = t, n.style.fontSize = i, n.style.cursor = "pointer", n.style.padding = "0 5px", n.style.lineHeight = "1";
      }
      function $S(n, e = {}) {
        const { color: t = "white", fontSize: i = "1.2rem" } = e;
        n.style.background = "none", n.style.border = "none", n.style.color = t, n.style.fontSize = i, n.style.cursor = "pointer", n.style.padding = "0 5px", n.style.lineHeight = "1", n.style.marginRight = "5px";
      }
      function Js(n, e = {}) {
        const { backgroundColor: t = "rgba(0, 0, 0, 0.1)" } = e;
        n.style.width = "100%", n.style.height = "100%", n.style.border = "none", n.style.backgroundColor = t, n.style.overflow = "auto", n.scrolling = "yes";
      }
      function $s(n) {
        const e = n.createElement("style");
        e.textContent = `
        /* Hide scrollbars for WebKit browsers */
        iframe::-webkit-scrollbar,
        *::-webkit-scrollbar {
            width: 0 !important;
            height: 0 !important;
            display: none !important;
        }
        
        /* Hide scrollbars for Firefox */
        iframe,
        * {
            scrollbar-width: none !important;
            -ms-overflow-style: none !important;
        }
        
        /* Allow scrolling but hide scrollbars */
        iframe {
            overflow: auto !important;
        }
    `, n.head.appendChild(e);
      }
      function Qs(n) {
        try {
          const e = n.contentDocument || n.contentWindow.document, t = e.createElement("style");
          t.textContent = `
            /* Hide all scrollbars in the iframe content */
            ::-webkit-scrollbar { 
                width: 0 !important; 
                height: 0 !important; 
                display: none !important; 
            }
            * { 
                scrollbar-width: none !important; 
                -ms-overflow-style: none !important;
            }
            html, body {
                overflow: auto !important;
                scrollbar-width: none !important;
                -ms-overflow-style: none !important;
            }
            
            /* Ensure content is scrollable */
            body {
                overflow-y: auto !important;
                overflow-x: auto !important;
            }
        `, e.head.appendChild(t);
        } catch (e) {
          console.error("Could not modify iframe content due to cross-origin restrictions:", e);
        }
      }
      function ea(n) {
        const e = document.createElement("div");
        e.style.position = "absolute", e.style.top = "0", e.style.left = "0", e.style.width = "100%", e.style.height = "100%", e.style.pointerEvents = "none", e.style.background = "radial-gradient(circle at 50% 50%, rgba(255, 255, 204, 0.03) 0%, transparent 80%)", e.style.borderRadius = "10px", e.style.zIndex = "1", n.appendChild(e);
      }
      function ta(n, e = 20) {
        const t = document.createElement("div");
        t.style.position = "absolute", t.style.top = "0", t.style.left = "0", t.style.width = "100%", t.style.height = "100%", t.style.overflow = "hidden", t.style.pointerEvents = "none", t.style.zIndex = "0", t.style.borderRadius = "10px", n.appendChild(t);
        for (let i = 0; i < e; i++) {
          const r = document.createElement("div"), s = Math.random() * 2 + 1, a = Math.random() * 100, o = Math.random() * 100, l = Math.random() * 0.5 + 0.1, c = Math.random() * 3 + 2, u = Math.random() * 2;
          r.style.position = "absolute", r.style.width = `${s}px`, r.style.height = `${s}px`, r.style.borderRadius = "50%", r.style.backgroundColor = "#ffffcc", r.style.left = `${a}%`, r.style.top = `${o}%`, r.style.opacity = `${l}`, t.appendChild(r), wt.to(r, {
            opacity: 0.1,
            duration: c,
            repeat: -1,
            yoyo: true,
            ease: "sine.inOut",
            delay: u
          });
        }
        return t;
      }
      function ia(n, e, t) {
        const i = wt.timeline();
        return i.from(n, {
          opacity: 0,
          scale: 0.7,
          duration: 0.6,
          ease: "power2.out"
        }), i.from(e, {
          y: -50,
          opacity: 0,
          duration: 0.4,
          ease: "back.out(1.7)"
        }, "-=0.3"), i.from(t, {
          opacity: 0,
          y: 30,
          duration: 0.5,
          ease: "power2.out"
        }, "-=0.2"), i;
      }
      function na(n, e = {}) {
        const { color: t = "rgba(255, 255, 204, 0.7)", intensity: i = "30px", duration: r = 2 } = e;
        return wt.to(n, {
          boxShadow: `0 0 ${i} ${t}`,
          repeat: -1,
          yoyo: true,
          duration: r,
          ease: "sine.inOut"
        });
      }
      function sr(n, e) {
        const t = wt.timeline({
          onComplete: e
        });
        return t.to(n, {
          boxShadow: "0 0 40px rgba(255, 255, 204, 0.9)",
          duration: 0.3,
          ease: "power1.in"
        }), t.to(n, {
          opacity: 0,
          scale: 0.7,
          duration: 0.5,
          ease: "power2.in"
        }, "-=0.1"), t;
      }
      aa = function() {
        if (document.readyState === "loading") {
          document.addEventListener("DOMContentLoaded", aa);
          return;
        }
        const n = document.querySelectorAll("button"), e = Array.from(n).filter((t) => t.textContent === "\u21A9" || t.innerHTML === "\u21A9");
        console.log("Found return buttons:", e.length), e.forEach((t) => {
          const i = t.cloneNode(true);
          t.parentNode.replaceChild(i, t), i.addEventListener("click", function(r) {
            r.preventDefault(), r.stopPropagation();
            let s = i.closest('[id$="-viewport-container"]');
            if (!s) {
              console.error("No viewport found for return button");
              return;
            }
            console.log("Found viewport for return button:", s.id);
            const a = s.querySelector("iframe");
            if (!a) {
              console.error("No iframe found in viewport");
              return;
            }
            const o = s.querySelector("h2");
            o && (o.textContent = "Psyche Mission Games"), a.src = "./games/games.html", console.log("Loading games HTML in viewport:", s.id);
          });
        });
      }, aa(), document.addEventListener("DOMContentLoaded", aa), setInterval(aa, 1e3);
      let $e = null, Ln = null, Ur = null, Za = null;
      function wm() {
        const n = window.innerWidth, e = window.innerHeight, t = window.devicePixelRatio || 1;
        console.log(`Screen size: ${n}x${e}, Pixel ratio: ${t}`);
        let i, r, s;
        return n === 2388 && e === 1668 || e === 2388 && n === 1668 ? (console.log('iPad Pro 11" detected'), i = "90%", s = "2000px", r = "90vh") : n >= 2e3 ? (i = "85%", s = "2400px", r = "85vh") : n >= 1600 ? (i = "88%", s = "1900px", r = "88vh") : n >= 1200 ? (i = "90%", s = "1500px", r = "90vh") : n >= 992 ? (i = "92%", s = "1150px", r = "92vh") : n >= 768 ? (i = "95%", s = "950px", r = "95vh") : (i = "98%", s = "100%", r = "98vh"), {
          width: i,
          maxWidth: s,
          height: r
        };
      }
      function Ja() {
        if (!$e) return;
        const { width: n, maxWidth: e, height: t } = wm();
        $e.style.width = n, $e.style.maxWidth = e, $e.style.height = t, console.log(`Viewport resized to: width=${n}, maxWidth=${e}, height=${t}`);
      }
      function QS() {
        if ($e) {
          $e.style.display = "flex", Ja();
          return;
        }
        console.log("Creating games viewport"), $e = document.createElement("div"), $e.id = "games-viewport-container", qs($e, {
          backgroundColor: "rgba(0, 0, 0, 0.05)",
          borderColor: "rgba(122, 95, 62, 0.3)",
          boxShadow: "0 0 15px rgba(122, 95, 62, 0.3)"
        });
        const { width: n, maxWidth: e, height: t } = wm();
        $e.style.width = n, $e.style.maxWidth = e, $e.style.height = t;
        const i = document.createElement("div");
        Ys(i, {
          backgroundColor: "rgba(10, 10, 20, 0.2)",
          gradientStart: "rgba(10, 10, 20, 0.2)",
          gradientEnd: "rgba(20, 20, 40, 0.2)"
        });
        const r = document.createElement("h2");
        r.textContent = "Psyche Mission Games", Ks(r);
        const s = document.createElement("div");
        s.style.display = "flex", s.style.alignItems = "center";
        const a = document.createElement("button");
        a.textContent = "\u21A9", $S(a), Ur = document.createElement("button"), Ur.textContent = "\u2715", Zs(Ur), s.appendChild(a), s.appendChild(Ur), i.appendChild(r), i.appendChild(s), $e.appendChild(i), Ln = document.createElement("iframe"), Ln.src = "/public/games/games.html", Js(Ln, {
          backgroundColor: "rgba(0, 0, 0, 0.0)"
        }), $s(document), Ln.onerror = () => {
          console.error("Failed to load games iframe content");
        }, Ln.onload = () => {
          console.log("Games iframe loaded successfully"), Qs(Ln);
        }, $e.appendChild(Ln), document.body.appendChild($e), ea($e), ta($e), ia($e, i, Ln), na($e), Ur.addEventListener("click", yl), a.addEventListener("click", yl), document.addEventListener("keydown", Am), window.addEventListener("resize", Ja), Za = new ResizeObserver((o) => {
          console.log("ResizeObserver detected size change"), Ja();
        }), Za.observe(document.body);
      }
      function yl() {
        $e && sr($e, () => {
          $e.style.display = "none", $e.style.opacity = 1, $e.style.transform = "translate(-50%, -50%) scale(1)";
        });
      }
      function Am(n) {
        n.key === "Escape" && yl();
      }
      function eE() {
        $e && (Ur.removeEventListener("click", yl), document.removeEventListener("keydown", Am), window.removeEventListener("resize", Ja), Za && (Za.disconnect(), Za = null), document.body.removeChild($e), $e = null, Ln = null, Ur = null);
      }
      window.setGamesViewportSize = function(n, e) {
        if (!$e) {
          console.warn("Games viewport is not currently active");
          return;
        }
        return console.log(`Manually setting viewport size to ${n}x${e}`), $e.style.width = `${n}px`, $e.style.maxWidth = `${n}px`, $e.style.height = `${e}px`, $e.style.transform = "translate(-50%, -50%)", `Viewport size set to ${n}x${e}`;
      }, window.resetGamesViewportSize = function() {
        if (!$e) {
          console.warn("Games viewport is not currently active");
          return;
        }
        return Ja(), "Viewport size reset to responsive mode";
      };
      let Ye = null, Gt = null, Or = null, $a = null;
      function Rm() {
        const n = window.innerWidth, e = window.innerHeight, t = window.devicePixelRatio || 1;
        console.log(`Screen size: ${n}x${e}, Pixel ratio: ${t}`);
        let i, r, s;
        return n === 2388 && e === 1668 || e === 2388 && n === 1668 ? (console.log('iPad Pro 11" detected'), i = "90%", s = "2000px", r = "90vh") : n >= 2e3 ? (i = "85%", s = "2400px", r = "85vh") : n >= 1600 ? (i = "88%", s = "1900px", r = "88vh") : n >= 1200 ? (i = "90%", s = "1500px", r = "90vh") : n >= 992 ? (i = "92%", s = "1150px", r = "92vh") : n >= 768 ? (i = "95%", s = "950px", r = "95vh") : (i = "98%", s = "100%", r = "98vh"), {
          width: i,
          maxWidth: s,
          height: r
        };
      }
      function Fr() {
        if (!Ye) return;
        const { width: n, maxWidth: e, height: t } = Rm();
        if (Ye.style.width = n, Ye.style.maxWidth = e, Ye.style.height = t, console.log(`Viewport resized to: width=${n}, maxWidth=${e}, height=${t}`), Gt && Gt.contentDocument) try {
          const i = Gt.contentDocument || Gt.contentWindow.document;
          if (i.getElementById("container1")) {
            const r = Math.min(1, window.innerWidth / 1920);
            let s = i.getElementById("responsive-scaling");
            s || (s = i.createElement("style"), s.id = "responsive-scaling", i.head.appendChild(s)), s.textContent = `
                    #container1 {
                        transform: scale(${r});
                        transform-origin: center top;
                        width: calc(100% / ${r});
                        margin-left: auto;
                        margin-right: auto;
                    }
                    
                    #astronautCar {
                        max-width: 100%;
                        height: auto;
                    }
                `, console.log(`Applied responsive scaling: ${r}`);
          }
        } catch (i) {
          console.error("Could not modify iframe content:", i);
        }
      }
      function Cm() {
        if (Ye) {
          Ye.style.display = "flex", Fr();
          return;
        }
        console.log("Creating kids viewport"), Ye = document.createElement("div"), Ye.id = "kids-viewport-container", qs(Ye);
        const { width: n, maxWidth: e, height: t } = Rm();
        Ye.style.width = n, Ye.style.maxWidth = e, Ye.style.height = t;
        const i = document.createElement("div");
        Ys(i);
        const r = document.createElement("h2");
        r.textContent = "Psyche Jr - Kids Space Explorer", Ks(r), Or = document.createElement("button"), Or.textContent = "\u2715", Zs(Or), i.appendChild(r), i.appendChild(Or), Ye.appendChild(i), Gt = document.createElement("iframe"), Gt.src = "/public/PsycheJR/kids.html", Js(Gt), $s(document), Gt.onerror = () => {
          console.error("Failed to load kids iframe content");
        }, Gt.onload = () => {
          console.log("Kids iframe loaded successfully"), Qs(Gt), Fr();
          try {
            const s = Gt.contentDocument || Gt.contentWindow.document;
            new MutationObserver(() => {
              Fr();
            }).observe(s.body, {
              childList: true,
              subtree: true
            });
          } catch (s) {
            console.error("Could not set up MutationObserver:", s);
          }
        }, Ye.appendChild(Gt), document.body.appendChild(Ye), ea(Ye), ta(Ye), ia(Ye, i, Gt), na(Ye), Or.addEventListener("click", () => {
          sr(Ye, wh);
        }), document.addEventListener("keydown", Pm), window.addEventListener("resize", Fr), $a = new ResizeObserver((s) => {
          console.log("ResizeObserver detected size change"), Fr();
        }), $a.observe(document.body);
      }
      function Eh() {
        Ye && sr(Ye, () => {
          Ye.style.display = "none", Ye.style.opacity = 1, Ye.style.transform = "translate(-50%, -50%) scale(1)";
        });
      }
      function Pm(n) {
        n.key === "Escape" && sr(Ye, wh);
      }
      function wh() {
        Ye && (Or.removeEventListener("click", Eh), document.removeEventListener("keydown", Pm), window.removeEventListener("resize", Fr), $a && ($a.disconnect(), $a = null), document.body.removeChild(Ye), Ye = null, Gt = null, Or = null);
      }
      window.setKidsViewportSize = function(n, e) {
        if (!Ye) {
          console.warn("Kids viewport is not currently active");
          return;
        }
        if (console.log(`Manually setting viewport size to ${n}x${e}`), Ye.style.width = `${n}px`, Ye.style.maxWidth = `${n}px`, Ye.style.height = `${e}px`, Ye.style.transform = "translate(-50%, -50%)", Gt && Gt.contentDocument) try {
          const t = (Gt.contentDocument || Gt.contentWindow.document).getElementById("container1");
          if (t) {
            const i = Math.min(1, n / 1920);
            t.style.transform = `scale(${i})`, t.style.transformOrigin = "center top", t.style.width = `calc(100% / ${i})`, console.log(`Applied manual scaling: ${i}`);
          }
        } catch (t) {
          console.error("Could not modify iframe content:", t);
        }
        return `Viewport size set to ${n}x${e}`;
      }, window.resetKidsViewportSize = function() {
        if (!Ye) {
          console.warn("Kids viewport is not currently active");
          return;
        }
        return Fr(), "Viewport size reset to responsive mode";
      };
      const tE = Object.freeze(Object.defineProperty({
        __proto__: null,
        destroyKidsViewport: wh,
        hideKidsViewport: Eh,
        showKidsViewport: Cm
      }, Symbol.toStringTag, {
        value: "Module"
      }));
      let yt = null, Dn = null, Br = null, zr = null, Qa = null, In = null;
      function iE() {
        if (yt) {
          yt.style.display = "flex";
          return;
        }
        console.log("Creating Year viewport"), yt = document.createElement("div"), yt.id = "year-viewport-container", qs(yt, {
          backgroundColor: "rgba(0, 0, 0, 0.9)",
          borderColor: "rgb(255, 255, 255)",
          boxShadow: "0 0 20px rgba(255, 255, 204, 0.6)"
        }), yt.style.width = "80%", yt.style.maxWidth = "1440px", yt.style.height = "95vh", zr = document.createElement("div"), Ys(zr, {
          backgroundColor: "#f9a000",
          gradientStart: "#f9a000",
          gradientEnd: "#f9a000"
        }), Qa = document.createElement("h2"), Qa.textContent = "Compare Earth and Psyche", Ks(Qa), Br = document.createElement("button"), Br.textContent = "\u2715", Zs(Br), zr.appendChild(Qa), zr.appendChild(Br), yt.appendChild(zr), Dn = document.createElement("iframe"), Dn.src = "./../../public/year/year.html", Js(Dn, {
          backgroundColor: "#222"
        }), Dn.onerror = () => {
          console.error("Failed to load iframe content");
        }, Dn.onload = () => {
          console.log("Iframe loaded successfully"), Qs(Dn);
        }, yt.appendChild(Dn), document.body.appendChild(yt), ea(yt), ta(yt, 15), ia(yt, zr, Dn), In = na(yt, {
          color: "rgba(255, 255, 255, 0.6)",
          intensity: "25px"
        }), $s(document), Br.addEventListener("click", Ah), document.addEventListener("keydown", Lm);
      }
      function Ah() {
        yt && (In && In.kill(), sr(yt, () => {
          yt.style.display = "none", yt.style.opacity = 1, yt.style.transform = "translate(-50%, -50%) scale(1)", document.body.classList.add("overlay-open"), In && (In.restart(), In.pause());
        }).play());
      }
      function Lm(n) {
        n.key === "Escape" && Ah();
      }
      function nE() {
        yt ? (In && In.kill(), wt.to(yt, {
          y: "100%",
          duration: 0.5,
          ease: "power1.in",
          onComplete: () => {
            Br.removeEventListener("click", Ah), document.removeEventListener("keydown", Lm), document.body.removeChild(yt), yt = null, Dn = null, Br = null, zr = null, Qa = null, In = null;
          }
        })) : console.log("No viewport container found to destroy.");
      }
      function rE(n, e, t, i) {
        var r;
        const s = (r = t[4]) == null ? void 0 : r.position;
        if (!s) return console.error("Section 4 position not found."), Promise.reject("Section 4 position not found.");
        const a = {
          x: s.x,
          y: s.y + 2,
          z: s.z - 12
        }, o = {
          x: 0.2,
          y: 0,
          z: 0
        };
        return new Promise((l, c) => {
          try {
            const { buttonMesh: u } = Xs(`Explore the Cosmic Comparison
between Earth and Psyche`, a, o, 0.7, n, () => {
              iE(), console.log("Cosmic Comparison button clicked.");
            }), h = new vr(), d = new ee();
            window.addEventListener("mousemove", (p) => {
              const f = i.domElement.getBoundingClientRect();
              d.x = (p.clientX - f.left) / f.width * 2 - 1, d.y = -((p.clientY - f.top) / f.height) * 2 + 1, h.setFromCamera(d, e);
              const _ = h.intersectObjects(Nr);
              i.domElement.style.cursor = _.length > 0 ? "pointer" : "default";
            }), l();
          } catch (u) {
            c(u);
          }
        });
      }
      function sE(n, e) {
        const t = no() === 4;
        for (let i = 0; i < e.children.length; i++) {
          const r = e.children[i];
          r.userData && r.userData.section4Element && (r.visible = t);
        }
      }
      function aE() {
      }
      window.setWebsiteViewportSize = function(n, e) {
        {
          console.warn("Website viewport is not currently active");
          return;
        }
      }, window.resetWebsiteViewportSize = function() {
        {
          console.warn("Website viewport is not currently active");
          return;
        }
      };
      let Qe = null, Nt = null, kr = null, eo = null;
      function Dm() {
        const n = window.innerWidth, e = window.innerHeight, t = window.devicePixelRatio || 1;
        console.log(`Screen size: ${n}x${e}, Pixel ratio: ${t}`);
        let i, r, s;
        return n === 2388 && e === 1668 || e === 2388 && n === 1668 ? (console.log('iPad Pro 11" detected'), i = "90%", s = "2000px", r = "90vh") : n >= 2e3 ? (i = "85%", s = "2400px", r = "85vh") : n >= 1600 ? (i = "88%", s = "1900px", r = "88vh") : n >= 1200 ? (i = "90%", s = "1500px", r = "90vh") : n >= 992 ? (i = "92%", s = "1150px", r = "92vh") : n >= 768 ? (i = "95%", s = "950px", r = "95vh") : (i = "98%", s = "100%", r = "98vh"), {
          width: i,
          maxWidth: s,
          height: r
        };
      }
      function Vr() {
        if (!Qe) return;
        const { width: n, maxWidth: e, height: t } = Dm();
        if (Qe.style.width = n, Qe.style.maxWidth = e, Qe.style.height = t, console.log(`Viewport resized to: width=${n}, maxWidth=${e}, height=${t}`), Nt && Nt.contentDocument) try {
          const i = Nt.contentDocument || Nt.contentWindow.document;
          if (i.getElementById("psyche-container")) {
            const r = parseInt(n) || window.innerWidth * (parseInt(n) / 100), s = Math.min(1, r / 1920);
            let a = i.getElementById("responsive-scaling");
            a || (a = i.createElement("style"), a.id = "responsive-scaling", i.head.appendChild(a)), a.textContent = `
                    /* Responsive scaling for surface2 content */
                    #psyche-container {
                        width: 100% !important;
                        height: ${Math.max(300, 50 * s)}vh !important;
                        max-width: 100% !important;
                    }
                    
                    #header-h1 {
                        font-size: ${Math.max(40, 90 * s)}px !important;
                    }
                    
                    #materials, #features, #dimensions, #comparable, #explore {
                        width: 90% !important;
                    }
                    
                    #inner-materials h1, #inner-features h1, #inner-dimensions h1, 
                    #inner-comparable h1, #inner-explore h1 {
                        font-size: ${Math.max(30, 60 * s)}px !important;
                    }
                    
                    #inner-materials p, #inner-features p, #inner-dimensions p, 
                    #inner-comparable p, #inner-explore p {
                        font-size: ${Math.max(18, 40 * s)}px !important;
                    }
                    
                    #comparable h3 {
                        font-size: ${Math.max(25, 50 * s)}px !important;
                    }
                    
                    #comparable h4 {
                        font-size: ${Math.max(20, 40 * s)}px !important;
                    }
                    
                    /* Ensure content is scrollable */
                    body {
                        overflow-y: auto !important;
                    }
                `, console.log(`Applied responsive scaling: ${s}`), Nt.contentWindow.updatePsycheModelSize && setTimeout(() => {
              Nt.contentWindow.updatePsycheModelSize(), console.log("Triggered 3D model resize");
            }, 100);
          }
        } catch (i) {
          console.error("Could not modify iframe content:", i);
        }
      }
      function oE() {
        if (Qe) {
          Qe.style.display = "flex", Vr();
          return;
        }
        console.log("Creating surface2 viewport"), Qe = document.createElement("div"), Qe.id = "surface2-viewport-container", qs(Qe, {
          backgroundColor: "rgba(0, 0, 0, 0.05)",
          borderColor: "rgba(122, 95, 62, 0.3)",
          boxShadow: "0 0 15px rgba(122, 95, 62, 0.3)"
        });
        const { width: n, maxWidth: e, height: t } = Dm();
        Qe.style.width = n, Qe.style.maxWidth = e, Qe.style.height = t;
        const i = document.createElement("div");
        Ys(i, {
          backgroundColor: "rgba(10, 10, 20, 0.2)",
          gradientStart: "rgba(10, 10, 20, 0.2)",
          gradientEnd: "rgba(20, 20, 40, 0.2)"
        });
        const r = document.createElement("h2");
        r.textContent = "The Surface of Psyche", Ks(r), kr = document.createElement("button"), kr.textContent = "\u2715", Zs(kr), i.appendChild(r), i.appendChild(kr), Qe.appendChild(i), Nt = document.createElement("iframe"), Nt.src = "/public/PsycheJR/surface2.html", Js(Nt, {
          backgroundColor: "rgba(0, 0, 0, 0.0)"
        }), $s(document), Nt.onerror = () => {
          console.error("Failed to load surface2 iframe content");
        }, Nt.onload = () => {
          console.log("Surface2 iframe loaded successfully"), Qs(Nt), Vr();
          try {
            const s = Nt.contentDocument || Nt.contentWindow.document, a = new MutationObserver(() => {
              Vr();
            });
            a.observe(s.body, {
              childList: true,
              subtree: true
            });
            const o = s.getElementById("psyche-container");
            if (o) {
              a.observe(o, {
                childList: true,
                subtree: true,
                attributes: true
              });
              const l = new Event("resize");
              window.dispatchEvent(l);
            }
          } catch (s) {
            console.error("Could not set up MutationObserver:", s);
          }
        }, Qe.appendChild(Nt), document.body.appendChild(Qe), ea(Qe), ta(Qe), ia(Qe, i, Nt), na(Qe), kr.addEventListener("click", Rh), document.addEventListener("keydown", Im), window.addEventListener("resize", Vr), eo = new ResizeObserver((s) => {
          console.log("ResizeObserver detected size change"), Vr();
        }), eo.observe(document.body);
      }
      function Rh() {
        Qe && sr(Qe, () => {
          Qe.style.display = "none", Qe.style.opacity = 1, Qe.style.transform = "translate(-50%, -50%) scale(1)", document.body.classList.add("overlay-open");
        });
      }
      function Im(n) {
        n.key === "Escape" && Rh();
      }
      function lE() {
        Qe && (kr.removeEventListener("click", Rh), document.removeEventListener("keydown", Im), window.removeEventListener("resize", Vr), eo && (eo.disconnect(), eo = null), document.body.removeChild(Qe), Qe = null, Nt = null, kr = null);
      }
      window.setSurface2ViewportSize = function(n, e) {
        if (!Qe) {
          console.warn("Surface2 viewport is not currently active");
          return;
        }
        if (console.log(`Manually setting viewport size to ${n}x${e}`), Qe.style.width = `${n}px`, Qe.style.maxWidth = `${n}px`, Qe.style.height = `${e}px`, Qe.style.transform = "translate(-50%, -50%)", Nt && Nt.contentDocument) try {
          const t = Nt.contentDocument || Nt.contentWindow.document;
          if (t.getElementById("psyche-container")) {
            const i = Math.min(1, n / 1920);
            let r = t.getElementById("responsive-scaling");
            r || (r = t.createElement("style"), r.id = "responsive-scaling", t.head.appendChild(r)), r.textContent = `
                    /* Responsive scaling for surface2 content */
                    #psyche-container {
                        width: 100% !important;
                        height: ${Math.max(300, 50 * i)}vh !important;
                        max-width: 100% !important;
                    }
                    
                    #header-h1 {
                        font-size: ${Math.max(40, 90 * i)}px !important;
                    }
                    
                    #materials, #features, #dimensions, #comparable, #explore {
                        width: 90% !important;
                    }
                    
                    #inner-materials h1, #inner-features h1, #inner-dimensions h1, 
                    #inner-comparable h1, #inner-explore h1 {
                        font-size: ${Math.max(30, 60 * i)}px !important;
                    }
                    
                    #inner-materials p, #inner-features p, #inner-dimensions p, 
                    #inner-comparable p, #inner-explore p {
                        font-size: ${Math.max(18, 40 * i)}px !important;
                    }
                    
                    #comparable h3 {
                        font-size: ${Math.max(25, 50 * i)}px !important;
                    }
                    
                    #comparable h4 {
                        font-size: ${Math.max(20, 40 * i)}px !important;
                    }
                `, console.log(`Applied manual scaling: ${i}`);
            const s = new Event("resize");
            window.dispatchEvent(s);
          }
        } catch (t) {
          console.error("Could not modify iframe content:", t);
        }
        return `Viewport size set to ${n}x${e}`;
      }, window.resetSurface2ViewportSize = function() {
        if (!Qe) {
          console.warn("Surface2 viewport is not currently active");
          return;
        }
        return Vr(), "Viewport size reset to responsive mode";
      };
      let et = null, Nn = null, Hr = null, to = null;
      function Nm() {
        const n = window.innerWidth, e = window.innerHeight, t = window.devicePixelRatio || 1;
        console.log(`Screen size: ${n}x${e}, Pixel ratio: ${t}`);
        let i, r, s;
        return n === 2388 && e === 1668 || e === 2388 && n === 1668 ? (console.log('iPad Pro 11" detected'), i = "90%", s = "2000px", r = "90vh") : n >= 2e3 ? (i = "85%", s = "2400px", r = "85vh") : n >= 1600 ? (i = "88%", s = "1900px", r = "88vh") : n >= 1200 ? (i = "90%", s = "1500px", r = "90vh") : n >= 992 ? (i = "92%", s = "1150px", r = "92vh") : n >= 768 ? (i = "95%", s = "950px", r = "95vh") : (i = "98%", s = "100%", r = "98vh"), {
          width: i,
          maxWidth: s,
          height: r
        };
      }
      function io() {
        if (!et) return;
        const { width: n, maxWidth: e, height: t } = Nm();
        et.style.width = n, et.style.maxWidth = e, et.style.height = t, console.log(`Viewport resized to: width=${n}, maxWidth=${e}, height=${t}`);
      }
      function cE() {
        if (et) {
          et.style.display = "flex", io();
          return;
        }
        console.log("Creating location2 viewport"), et = document.createElement("div"), et.id = "location2-viewport-container", qs(et, {
          backgroundColor: "rgba(0, 0, 0, 0.05)",
          borderColor: "rgba(122, 95, 62, 0.3)",
          boxShadow: "0 0 15px rgba(122, 95, 62, 0.3)"
        });
        const { width: n, maxWidth: e, height: t } = Nm();
        et.style.width = n, et.style.maxWidth = e, et.style.height = t;
        const i = document.createElement("div");
        Ys(i, {
          backgroundColor: "rgba(10, 10, 20, 0.2)",
          gradientStart: "rgba(10, 10, 20, 0.2)",
          gradientEnd: "rgba(20, 20, 40, 0.2)"
        });
        const r = document.createElement("h2");
        r.textContent = "Psyche's Location in Space", Ks(r), Hr = document.createElement("button"), Hr.textContent = "\u2715", Zs(Hr), i.appendChild(r), i.appendChild(Hr), et.appendChild(i), Nn = document.createElement("iframe"), Nn.src = "/public/PsycheJR/location2.html", Js(Nn, {
          backgroundColor: "rgba(0, 0, 0, 0.0)"
        }), $s(document), Nn.onerror = () => {
          console.error("Failed to load location2 iframe content");
        }, Nn.onload = () => {
          console.log("Location2 iframe loaded successfully"), Qs(Nn);
        }, et.appendChild(Nn), document.body.appendChild(et), ea(et), ta(et), ia(et, i, Nn), na(et), Hr.addEventListener("click", Ch), document.addEventListener("keydown", Um), window.addEventListener("resize", io), to = new ResizeObserver((s) => {
          console.log("ResizeObserver detected size change"), io();
        }), to.observe(document.body);
      }
      function Ch() {
        et && sr(et, () => {
          et.style.display = "none", et.style.opacity = 1, et.style.transform = "translate(-50%, -50%) scale(1)", document.body.classList.add("overlay-open");
        });
      }
      function Um(n) {
        n.key === "Escape" && Ch();
      }
      function uE() {
        et && (Hr.removeEventListener("click", Ch), document.removeEventListener("keydown", Um), window.removeEventListener("resize", io), to && (to.disconnect(), to = null), document.body.removeChild(et), et = null, Nn = null, Hr = null);
      }
      window.setLocation2ViewportSize = function(n, e) {
        if (!et) {
          console.warn("Location2 viewport is not currently active");
          return;
        }
        return console.log(`Manually setting viewport size to ${n}x${e}`), et.style.width = `${n}px`, et.style.maxWidth = `${n}px`, et.style.height = `${e}px`, et.style.transform = "translate(-50%, -50%)", `Viewport size set to ${n}x${e}`;
      }, window.resetLocation2ViewportSize = function() {
        if (!et) {
          console.warn("Location2 viewport is not currently active");
          return;
        }
        return io(), "Viewport size reset to responsive mode";
      };
      let Gr, Om, Ph, ra = 1, Lh = false, Dh = 0;
      const Fm = {
        2: Sh,
        3: Eh,
        4: nE,
        5: aE,
        6: eE,
        7: lE,
        8: uE
      };
      let Ih = ra;
      function hE(n) {
        Dh = n.touches[0].clientY;
      }
      function dE(n) {
        const e = n.touches[0].clientY, t = Dh - e;
        Dh = e, zm({
          deltaY: t
        }), n.preventDefault();
      }
      function pE(n, e, t) {
        Gr = n, Om = t, Ph = e, window.addEventListener("wheel", zm, {
          passive: false
        }), window.addEventListener("touchstart", hE, {
          passive: false
        }), window.addEventListener("touchmove", dE, {
          passive: false
        }), window.addEventListener("resize", () => Bm(Gr, Om));
      }
      function Bm(n, e) {
        if (!n || !e) {
          console.error("onResize called without a valid camera or renderer.");
          return;
        }
        const t = Math.max(window.innerWidth, 768), i = t / window.innerHeight;
        if (n.aspect = i, n.updateProjectionMatrix(), e.setSize(t, window.innerHeight), e.setPixelRatio(Math.min(window.devicePixelRatio, 2)), t < 1300) {
          const r = (1300 - t) * 0.048;
          n.fov = Math.min(75 + r, 100);
        } else n.fov = 75;
        n.updateProjectionMatrix();
      }
      function zm(n) {
        if (Lh) return;
        const e = n.deltaY > 0 ? 1 : -1;
        let t = ra + e;
        console.log("Swipe Direction: ", e), t > 8 ? t = 1 : t < 1 && (t = 8), Lh = true, Nh(t);
      }
      function Nh(n, e = null) {
        if (n < 0 || n >= Ph.length) return;
        Fm[Ih] && Fm[Ih](), ra = n, Ih = n, ra = n;
        const t = Ph[n].position;
        wt.to(Gr.position, {
          x: t.x,
          y: t.y,
          z: t.z,
          duration: 2,
          ease: "power4.inOut",
          onUpdate: () => {
          },
          onComplete: () => {
            n !== 6 && new D(Gr.position.x, Gr.position.y, Gr.position.z - 1), Lh = false, console.log("Moved to Section:", ra);
            const i = new D();
            Gr.getWorldDirection(i), console.log("Camera is now looking in direction:", i);
          }
        });
      }
      function no() {
        return ra;
      }
      const fE = "modulepreload", mE = function(n) {
        return "/" + n;
      }, km = {}, Uh = function(n, e, t) {
        let i = Promise.resolve();
        if (e && e.length > 0) {
          document.getElementsByTagName("link");
          const s = document.querySelector("meta[property=csp-nonce]"), a = (s == null ? void 0 : s.nonce) || (s == null ? void 0 : s.getAttribute("nonce"));
          i = Promise.allSettled(e.map((o) => {
            if (o = mE(o), o in km) return;
            km[o] = true;
            const l = o.endsWith(".css"), c = l ? '[rel="stylesheet"]' : "";
            if (document.querySelector(`link[href="${o}"]${c}`)) return;
            const u = document.createElement("link");
            if (u.rel = l ? "stylesheet" : fE, l || (u.as = "script"), u.crossOrigin = "", u.href = o, a && u.setAttribute("nonce", a), document.head.appendChild(u), l) return new Promise((h, d) => {
              u.addEventListener("load", h), u.addEventListener("error", () => d(new Error(`Unable to preload CSS for ${o}`)));
            });
          }));
        }
        function r(s) {
          const a = new Event("vite:preloadError", {
            cancelable: true
          });
          if (a.payload = s, window.dispatchEvent(a), !a.defaultPrevented) throw s;
        }
        return i.then((s) => {
          for (const a of s || []) a.status === "rejected" && r(a.reason);
          return n().catch(r);
        });
      };
      function gE() {
        const n = document.getElementById("mouse-scroll-indicator");
        n.style.display = "block";
        const e = document.querySelector(".mouse-scroll-indicator");
        if (!e) return;
        const t = window.innerWidth, i = window.innerHeight, r = Math.min(t, i) / 300;
        document.documentElement.style.setProperty("--dynamic-scale", r);
        const s = document.createElement("div");
        s.id = "scroll-text", s.textContent = "SCROLL UP OR DOWN TO EXPLORE", document.body.appendChild(s), setTimeout(() => {
          e.classList.add("moved"), s.classList.add("fade-out");
        }, 3e3), setTimeout(() => {
          s.remove();
        }, 4500);
      }
      function _E(n) {
        const e = document.getElementById("cn-icon-wrapper"), t = document.getElementById("cn-wrapper"), i = document.getElementById("cn-overlay"), r = document.createElement("ul");
        r.style.listStyle = "none", r.style.padding = "0";
        let s = false, a = false, o = null, l = null;
        r.innerHTML = "", n.forEach((p, f) => {
          const _ = document.createElement("li"), g = document.createElement("div");
          g.textContent = p.name;
          const m = document.createElement("span");
          if (m.textContent = "\u25BA", m.style.cursor = "pointer", m.style.marginLeft = "15px", _.style.cursor = "pointer", _.style.padding = "10px", _.style.color = "black", _.style.borderBottom = "1px solid rgba(255,255,255,0.3)", _.textContent = p.name, _.addEventListener("click", () => {
            Nh(f, p.position), u();
          }), p.subsections && p.subsections.length > 0) {
            _.appendChild(m);
            const y = document.createElement("ul");
            y.style.listStyle = "none", y.style.marginLeft = "5px", y.style.display = "none", p.subsections.forEach((x) => {
              const v = document.createElement("li");
              v.textContent = x.name, v.style.cursor = "pointer", v.addEventListener("click", (A) => {
                A.stopPropagation(), Nh(f, x.position), u();
              }), y.appendChild(v);
            }), m.addEventListener("click", (x) => {
              x.stopPropagation(), y.style.display === "none" ? (y.style.display = "block", m.classList.toggle("arrow-rotated")) : (y.style.display = "none", m.classList.toggle("arrow-rotated"));
            }), _.appendChild(y);
          }
          if (r.appendChild(_), p.name === "Games Section") {
            const y = document.createElement("ul");
            y.className = "submenu", y.style.listStyle = "none", y.style.padding = "0", y.style.marginLeft = "20px", y.style.display = "block", y.style.backgroundColor = "rgba(0, 0, 0, 0.8)", y.style.borderRadius = "5px", y.style.overflow = "hidden", [
              {
                name: "PsycheJR",
                path: "../PsycheJR/kids.html"
              },
              {
                name: "Escape Velocity",
                path: "../escapeVelocity/escape-velocity.html"
              },
              {
                name: "SpacePic",
                path: "../spacepic/photo.html"
              }
            ].forEach((v) => {
              const A = document.createElement("li");
              A.textContent = v.name, A.style.cursor = "pointer", A.style.padding = "8px 15px", A.style.color = "#00aaff", A.style.borderBottom = "1px solid rgba(255,255,255,0.1)", A.style.fontSize = "0.9em", A.addEventListener("mouseover", () => {
                A.style.backgroundColor = "rgba(0, 170, 255, 0.2)", A.style.opacity = "1", A.style.color = "black";
              }), A.addEventListener("mouseout", () => {
                A.style.backgroundColor = "transparent", A.style.opacity = "1", A.style.color = "#00aaff";
              }), A.addEventListener("click", (E) => {
                E.stopPropagation(), v.name === "PsycheJR" ? Uh(() => Promise.resolve().then(() => tE), void 0).then((w) => {
                  w.showKidsViewport();
                }) : v.name === "Escape Velocity" ? Uh(() => Promise.resolve().then(() => DE), void 0).then((w) => {
                  w.showEscapeVelocityViewport();
                }) : v.name === "SpacePic" && Uh(() => la(() => XE(() => import("./viewportspacepic-vBhYZtMZ-CaoZ_fz_-BgGiMCZn.js"), []), []), []).then((w) => {
                  w.showSpacePicViewport();
                }), document.body.classList.remove("overlay-open");
              }), y.appendChild(A);
            }), _.appendChild(y), _.addEventListener("click", (v) => {
              const A = y.style.display;
              document.querySelectorAll(".submenu").forEach((E) => {
                E.style.display = "none";
              }), y.style.display = A === "none" ? "block" : "none", v.stopPropagation();
            });
            const x = document.createElement("span");
            x.textContent = " \u25BC", x.style.fontSize = "0.8em", x.style.marginLeft = "5px", _.appendChild(x);
          }
        }), t.appendChild(r);
        function c() {
          clearTimeout(o), clearTimeout(l), s = true, a = true, t.classList.remove("closing"), t.classList.add("opened-nav"), i.classList.add("active"), e.classList.add("active"), e.style.transition = "transform 0.5s ease-in-out", e.style.transform = "rotate(360deg)";
        }
        function u() {
          s && (s = false, a = false, t.classList.add("closing"), o = setTimeout(() => {
            t.classList.remove("opened-nav"), t.classList.remove("closing");
          }, 300), i.classList.remove("active"), e.classList.remove("active"), e.style.transition = "transform 0.5s ease-in-out", e.style.transform = "rotate(0deg)");
        }
        function h() {
          s ? u() : c();
        }
        function d() {
          a || (l = setTimeout(() => {
            u();
          }, 250));
        }
        e.addEventListener("mouseenter", () => {
          a || c();
        }), t.addEventListener("mouseenter", () => {
          a || c();
        }), e.addEventListener("mouseleave", d), t.addEventListener("mouseleave", d), e.addEventListener("click", h), i.addEventListener("click", u), document.addEventListener("click", (p) => {
          !t.contains(p.target) && !e.contains(p.target) && u();
        });
      }
      function vE(n, e, t) {
        return new Promise((i) => {
          var r;
          const s = (r = t[0]) == null ? void 0 : r.position, a = {
            x: s.x - 12,
            y: s.y + 6,
            z: s.z - 13
          };
          console.log("TMP", a);
          const o = {
            x: 0,
            y: 0.1,
            z: 0
          };
          Mh("REFERENCES", a, o, 1, n), US([
            {
              text: "Development Team",
              onClick: () => console.log("DevTeam Clicked")
            },
            {
              text: "Sponsor",
              onClick: () => console.log("Sponsor Clicked")
            },
            {
              text: "Code",
              onClick: () => console.log("Explore Clicked")
            },
            {
              text: "Images",
              onClick: () => console.log("Surface Clicked")
            }
          ], a, o, n), i();
        });
      }
      function xE(n, e, t) {
        var i;
        const r = (i = t[1]) == null ? void 0 : i.position;
        if (!r) return console.error("Section 1 position not found."), Promise.reject("Section 1 position not found.");
        const s = {
          x: r.x - 12,
          y: r.y + 3,
          z: r.z - 13
        }, a = {
          x: 0,
          y: Math.PI / 12,
          z: 0
        }, o = {
          x: r.x - 11,
          y: r.y - 2,
          z: r.z - 13
        }, l = {
          x: 0,
          y: Math.PI / 12,
          z: 0
        };
        return new Promise(async (c, u) => {
          Mh("YEAR ON PSYCHE", s, a, 1.5, n);
          const h = await Mh(`16 Psyche is a giant asteroid in our solar system!
    Explore this site to learn about 16 Psyche,
     its origin, orbit, and what makes it unique!
`, o, l, 0.5, n);
          h.material.uniforms.opacity.value = 0, wt.to(h.material.uniforms.opacity, {
            value: 1,
            duration: 2.5,
            delay: 4
          }), xl("asteroid", "/res/models/psyche_new.glb", {
            x: 80,
            y: 60,
            z: 20
          }, 6, {
            x: 0,
            y: 0,
            z: 0
          }, {
            position: {
              x: 20,
              y: 16,
              z: -45,
              duration: 3,
              ease: "power2.out"
            },
            rotation: {
              y: -6.28319,
              z: 6.28319,
              duration: 45,
              ease: "linear",
              repeat: -1
            }
          }, n, (d) => {
            c();
          }), setTimeout(() => u("Model load timeout"), 1e4);
        }).then(() => {
          console.log("section 1 loaded");
        }).catch((c) => {
          console.error("Error loading Section 1:", c);
        });
      }
      function yE(n, e, t, i) {
        var r;
        const s = (r = t[2]) == null ? void 0 : r.position;
        if (!s) return console.error("Section 2 position not found."), Promise.reject("Section 2 position not found.");
        const a = {
          x: s.x,
          y: s.y + 6,
          z: s.z - 12
        }, o = {
          x: 0.2,
          y: 0,
          z: 0
        };
        return new Promise((l, c) => {
          try {
            const { buttonMesh: u } = Xs("CLICK HERE TO LEARN HOW PSYCHE GOT ITS NAME!", a, o, 0.7, n, () => {
              console.log("Origin button clicked."), ZS();
            }), h = new vr(), d = new ee();
            window.addEventListener("mousemove", (p) => {
              const f = i.domElement.getBoundingClientRect();
              d.x = (p.clientX - f.left) / f.width * 2 - 1, d.y = -((p.clientY - f.top) / f.height) * 2 + 1, h.setFromCamera(d, e);
              const _ = h.intersectObjects(Nr);
              i.domElement.style.cursor = _.length > 0 ? "pointer" : "default";
            }), l();
          } catch (u) {
            c(u);
          }
        });
      }
      function ME() {
        const n = window.innerWidth;
        let e, t, i, r = 1, s = 1;
        return n >= 2e3 ? (r = 1.3, s = 1.3, e = 50) : n >= 1600 ? (r = 1.2, s = 1.2, e = 45) : n >= 1200 ? (r = 1.1, s = 1.1, e = 42) : n >= 992 ? (r = 1, s = 1) : n >= 768 ? (r = 0.9, s = 0.9, e = 38) : (r = 0.8, s = 0.8, e = 35), {
          posX: e,
          posY: t,
          posZ: i,
          buttonScale: r,
          labelScale: s
        };
      }
      function TE(n, e, t, i) {
        return new Promise((r, s) => {
          var a;
          const o = (a = t[3]) == null ? void 0 : a.position;
          if (!o) {
            console.error("Section 3 position not found."), s("Section 3 position not found.");
            return;
          }
          const { buttonScale: l } = ME(), c = {
            x: o.x,
            y: o.y + 2,
            z: o.z - 12
          }, u = {
            x: 0.2,
            y: 0,
            z: 0
          };
          try {
            Xs("Explore the Psyche Jr Kids Experience", c, u, l, n, () => {
              Cm(), console.log("Psyche Jr button clicked.");
            }).then(({ textMesh: h, buttonMesh: d }) => {
              const p = d.material.emissive.clone(), f = d.material.emissiveIntensity, _ = new vr(), g = new ee();
              window.addEventListener("mousemove", (m) => {
                const y = i.domElement.getBoundingClientRect();
                g.x = (m.clientX - y.left) / y.width * 2 - 1, g.y = -((m.clientY - y.top) / y.height) * 2 + 1, _.setFromCamera(g, e), _.intersectObjects([
                  d
                ]).length > 0 ? (bh(d, {
                  color: "#ff9900",
                  intensity: 2
                }), i.domElement.style.cursor = "pointer") : (d.material.emissive = p, d.material.emissiveIntensity = f, d.material.needsUpdate = true, i.domElement.style.cursor = "default");
              });
            }), r();
          } catch (h) {
            console.error("Error setting up Section 3:", h), s(h);
          }
        });
      }
      function bE(n, e) {
        const t = no() === 3;
        for (let i = 0; i < e.children.length; i++) {
          const r = e.children[i];
          r.userData && r.userData.section3Element && (r.visible = t);
        }
      }
      let st = null, ar = null, ro = null, Vm = null;
      function Hm() {
        const n = window.innerWidth, e = window.innerHeight, t = window.devicePixelRatio || 1;
        console.log(`Screen size: ${n}x${e}, Pixel ratio: ${t}`);
        let i, r, s;
        return n === 2388 && e === 1668 || e === 2388 && n === 1668 ? (console.log('iPad Pro 11" detected'), i = "90%", s = "2000px", r = "90vh") : n >= 2e3 ? (i = "85%", s = "2400px", r = "85vh") : n >= 1600 ? (i = "88%", s = "1900px", r = "88vh") : n >= 1200 ? (i = "90%", s = "1500px", r = "90vh") : n >= 992 ? (i = "92%", s = "1150px", r = "92vh") : n >= 768 ? (i = "95%", s = "950px", r = "95vh") : (i = "98%", s = "100%", r = "98vh"), {
          width: i,
          maxWidth: s,
          height: r
        };
      }
      function Ml() {
        if (!st) return;
        const { width: n, maxWidth: e, height: t } = Hm();
        st.style.width = n, st.style.maxWidth = e, st.style.height = t, console.log(`Viewport resized to: width=${n}, maxWidth=${e}, height=${t}`);
      }
      function SE() {
        if (st) {
          st.style.display = "flex", Ml();
          return;
        }
        console.log("Creating website viewport"), st = document.createElement("div"), st.id = "website-viewport-container", qs(st, {
          backgroundColor: "rgba(0, 0, 0, 0.05)",
          borderColor: "rgba(122, 95, 62, 0.3)",
          boxShadow: "0 0 15px rgba(122, 95, 62, 0.3)"
        });
        const { width: n, maxWidth: e, height: t } = Hm();
        st.style.width = n, st.style.maxWidth = e, st.style.height = t;
        const i = document.createElement("div");
        Ys(i, {
          backgroundColor: "rgba(10, 10, 20, 0.2)",
          gradientStart: "rgba(10, 10, 20, 0.2)",
          gradientEnd: "rgba(20, 20, 40, 0.2)"
        });
        const r = document.createElement("h2");
        r.textContent = "Psyche Mission Website", Ks(r);
        const s = document.createElement("div");
        s.style.display = "flex", s.style.alignItems = "center", ro = document.createElement("button"), ro.textContent = "\u2715", Zs(ro), s.appendChild(ro), i.appendChild(r), i.appendChild(s), st.appendChild(i), ar = document.createElement("iframe"), ar.src = "./../../public/website/index.html", Js(ar, {
          backgroundColor: "rgba(0, 0, 0, 0.0)"
        }), $s(document), ar.onerror = () => {
          console.error("Failed to load website iframe content");
        }, ar.onload = () => {
          console.log("Website iframe loaded successfully"), Qs(ar);
        }, st.appendChild(ar), document.body.appendChild(st), ea(st), ta(st), ia(st, i, ar), na(st), ro.addEventListener("click", Gm), document.addEventListener("keydown", EE), window.addEventListener("resize", Ml), Vm = new ResizeObserver((a) => {
          console.log("ResizeObserver detected size change"), Ml();
        }), Vm.observe(document.body);
      }
      function Gm() {
        st && sr(st, () => {
          st.style.display = "none", st.style.opacity = 1, st.style.transform = "translate(-50%, -50%) scale(1)", document.body.classList.add("overlay-open");
        });
      }
      function EE(n) {
        n.key === "Escape" && Gm();
      }
      window.setWebsiteViewportSize = function(n, e) {
        if (!st) {
          console.warn("Website viewport is not currently active");
          return;
        }
        return console.log(`Manually setting viewport size to ${n}x${e}`), st.style.width = `${n}px`, st.style.maxWidth = `${n}px`, st.style.height = `${e}px`, st.style.transform = "translate(-50%, -50%)", `Viewport size set to ${n}x${e}`;
      }, window.resetWebsiteViewportSize = function() {
        if (!st) {
          console.warn("Website viewport is not currently active");
          return;
        }
        return Ml(), "Viewport size reset to responsive mode";
      };
      function wE(n, e, t, i) {
        var r;
        const s = (r = t[5]) == null ? void 0 : r.position;
        if (!s) return console.error("Section 5 position not found."), Promise.reject("Section 5 position not found.");
        const a = {
          x: s.x,
          y: s.y + 2,
          z: s.z - 12
        }, o = {
          x: s.x,
          y: s.y - 3,
          z: s.z - 20
        }, l = {
          x: 0.2,
          y: 0,
          z: 0
        }, c = {
          x: 0.2,
          y: 0,
          z: 0
        };
        return new Promise((u, h) => {
          try {
            xl("probe", "./../../res/models/nasaLogo.glb", o, 0.7, c, null, n, () => {
              console.log("loaded model");
            });
            const { buttonMesh: d } = Xs("Explore the Mission Website", a, l, 0.7, n, () => {
              SE(), console.log("Psyche Jr button clicked.");
            }), p = new vr(), f = new ee();
            window.addEventListener("mousemove", (_) => {
              const g = i.domElement.getBoundingClientRect();
              f.x = (_.clientX - g.left) / g.width * 2 - 1, f.y = -((_.clientY - g.top) / g.height) * 2 + 1, p.setFromCamera(f, e);
              const m = p.intersectObjects(Nr);
              i.domElement.style.cursor = m.length > 0 ? "pointer" : "default";
            }), u();
          } catch (d) {
            console.error("Error loading Section 5:", d), h(d);
          }
        });
      }
      let AE = false;
      function RE(n, e, t, i) {
        return new Promise((r, s) => {
          var a;
          const o = (a = t[6]) == null ? void 0 : a.position;
          if (!o) return console.error("Section 6 position not found."), s("Section 6 position not found.");
          const l = {
            x: o.x,
            y: o.y + 2,
            z: o.z - 12
          }, c = {
            x: o.x,
            y: o.y - 5,
            z: o.z - 12
          }, u = {
            x: 0.2,
            y: 0,
            z: 0
          }, h = {
            x: 0.2,
            y: 0.5,
            z: 0
          };
          try {
            xl("controller", "./../../res/models/arcade_controller.glb", c, 2, h, null, n, () => {
              console.log("loaded model");
            });
            const { buttonMesh: d } = Xs("Try some Psyche inspired games!", l, u, 0.7, n, () => {
              QS(), console.log("Games button clicked.");
            });
            bh(d, {
              color: "#ff9900",
              intensity: 2
            });
            const p = new vr(), f = new ee();
            window.addEventListener("mousemove", (_) => {
              const g = i.domElement.getBoundingClientRect();
              f.x = (_.clientX - g.left) / g.width * 2 - 1, f.y = -((_.clientY - g.top) / g.height) * 2 + 1, p.setFromCamera(f, e);
              const m = p.intersectObjects(Nr);
              i.domElement.style.cursor = m.length > 0 ? "pointer" : "default";
            }), AE = true, r();
          } catch (d) {
            s(d);
          }
        });
      }
      function CE(n, e, t) {
        return new Promise((i, r) => {
          var s;
          const a = (s = t[7]) == null ? void 0 : s.position;
          if (!a) {
            console.error("Error: Section 7 position not found."), r("Section 7 position not found.");
            return;
          }
          const o = {
            x: a.x + 5,
            y: a.y + 10,
            z: a.z - 20
          };
          n.add(Tm("Surface of Psyche", o, n, oE, 1.5)), i();
        });
      }
      function PE(n, e, t, i) {
        var r;
        const s = (r = t[8]) == null ? void 0 : r.position;
        if (!s) return console.error("Section 8 position not found."), Promise.reject("Section 8 position not found.");
        const a = {
          x: s.x,
          y: s.y + 2,
          z: s.z - 12
        }, o = {
          x: s.x,
          y: s.y - 3,
          z: s.z - 12
        };
        console.log("map pin location: ", o);
        const l = {
          x: 0.2,
          y: 0,
          z: 0
        }, c = {
          x: -0.02,
          y: 0.5,
          z: 0
        };
        return new Promise((u, h) => {
          try {
            xl("controller", "./../../res/models/navigation_pin.glb", o, 1, c, {
              rotation: {
                x: 0,
                y: -40,
                z: 0,
                duration: 45,
                ease: "linear",
                repeat: -1
              }
            }, n, () => {
              console.log("loaded model");
            });
            const { buttonMesh: d } = Xs("Explore Psyche's Location!", a, l, 0.7, n, () => {
              cE(), console.log("Location button clicked.");
            });
            bh(d, {
              color: "#ff9900",
              intensity: 2
            });
            const p = new vr(), f = new ee();
            window.addEventListener("mousemove", (_) => {
              const g = i.domElement.getBoundingClientRect();
              f.x = (_.clientX - g.left) / g.width * 2 - 1, f.y = -((_.clientY - g.top) / g.height) * 2 + 1, p.setFromCamera(f, e);
              const m = p.intersectObjects(Nr);
              i.domElement.style.cursor = m.length > 0 ? "pointer" : "default";
            }), u();
          } catch (d) {
            h(d);
          }
        });
      }
      const Wm = [];
      function LE(n, e) {
        if (Wm.length === 0) return;
        const t = no() === 8;
        Wm.forEach((i) => {
          i.visible !== t && (i.visible = t);
        });
      }
      let ht = null, Bi = null, Pi = null;
      function Tl() {
        if (ht) {
          ht.style.display = "flex";
          return;
        }
        console.log("Creating escape velocity viewport"), ht = document.createElement("div"), ht.id = "escape-velocity-viewport-container", ht.style.position = "fixed", ht.style.top = "50%", ht.style.left = "50%", ht.style.transform = "translate(-50%, -50%)", ht.style.width = "80%", ht.style.maxWidth = "1440px", ht.style.height = "80vh", ht.style.backgroundColor = "rgba(0, 0, 0, 0.9)", ht.style.border = "2px solid #007bff", ht.style.borderRadius = "10px", ht.style.boxShadow = "0 0 20px rgba(0, 123, 255, 0.5)", ht.style.zIndex = "900", ht.style.display = "flex", ht.style.flexDirection = "column", ht.style.overflow = "hidden";
        const n = document.createElement("div");
        n.style.display = "flex", n.style.justifyContent = "space-between", n.style.alignItems = "center", n.style.padding = "10px 15px", n.style.backgroundColor = "#007bff", n.style.color = "white", n.style.borderTopLeftRadius = "8px", n.style.borderTopRightRadius = "8px";
        const e = document.createElement("h2");
        e.textContent = "Escape Velocity Game", e.style.margin = "0", e.style.fontSize = "1.2rem";
        const t = document.createElement("div");
        t.style.display = "flex", t.style.alignItems = "center", t.style.gap = "10px";
        const i = document.createElement("button");
        i.textContent = "\u21A9", i.style.background = "none", i.style.border = "none", i.style.color = "white", i.style.fontSize = "1.2rem", i.style.cursor = "pointer", i.style.padding = "0 5px", i.style.lineHeight = "1", i.style.marginRight = "5px", Pi = document.createElement("button"), Pi.textContent = "\u2715", Pi.style.background = "none", Pi.style.border = "none", Pi.style.color = "white", Pi.style.fontSize = "1.5rem", Pi.style.cursor = "pointer", Pi.style.padding = "0 5px", Pi.style.lineHeight = "1", t.appendChild(i), t.appendChild(Pi), n.appendChild(e), n.appendChild(t), ht.appendChild(n), Bi = document.createElement("iframe"), Bi.src = "./escapeVelocity/escape-velocity.html", Bi.style.width = "100%", Bi.style.height = "100%", Bi.style.border = "none", Bi.style.backgroundColor = "#222", Bi.onerror = () => {
          console.error("Failed to load iframe content");
        }, Bi.onload = () => {
          console.log("Iframe loaded successfully");
        }, ht.appendChild(Bi), document.body.appendChild(ht);
        const r = wt.timeline();
        r.from(ht, {
          opacity: 0,
          scale: 0.8,
          duration: 0.4,
          ease: "power2.out"
        }), r.from(n, {
          y: -50,
          duration: 0.3,
          ease: "back.out(1.7)"
        }, "-=0.2"), r.from(Bi, {
          opacity: 0,
          y: 20,
          duration: 0.3,
          ease: "power2.out"
        }, "-=0.1"), Pi.addEventListener("click", so), i.addEventListener("click", function(s) {
          s.preventDefault(), s.stopPropagation(), e.textContent = "Psyche Mission Games", Bi.src = "./games/games.html", console.log("Loading games HTML in escape velocity viewport");
        }), document.addEventListener("keydown", Xm), setTimeout(aa, 100);
      }
      function so() {
        ht && wt.to(ht, {
          opacity: 0,
          scale: 0.8,
          duration: 0.3,
          ease: "power2.in",
          onComplete: () => {
            jm(), document.body.classList.add("overlay-open");
          }
        });
      }
      function Xm(n) {
        n.key === "Escape" && so();
      }
      function jm() {
        ht && (Pi.removeEventListener("click", so), document.removeEventListener("keydown", Xm), document.body.removeChild(ht), ht = null, Bi = null, Pi = null);
      }
      const DE = Object.freeze(Object.defineProperty({
        __proto__: null,
        destroyEscapeVelocityViewport: jm,
        hideEscapeVelocityViewport: so,
        showEscapeVelocityViewport: Tl
      }, Symbol.toStringTag, {
        value: "Module"
      }));
      let qm = [], bl = false;
      function IE(n, e, t, i) {
        return new Promise((r, s) => {
          try {
            const a = new pr(40, 20, 5), o = new tn({
              color: 31743,
              transparent: false
            }), l = new Dt(a, o);
            l.position.set(200, 300, -110), l.userData.section9Element = true, n.add(l);
            const c = [];
            c.push(l);
            const u = document.createElement("canvas");
            u.width = 256, u.height = 128;
            const h = u.getContext("2d");
            h.fillStyle = "#007bff", h.fillRect(0, 0, u.width, u.height), h.font = "bold 24px Arial", h.fillStyle = "white", h.textAlign = "center", h.textBaseline = "middle", h.fillText("Escape Velocity", u.width / 2, u.height / 2);
            const d = new G_(u), p = new tn({
              map: d,
              transparent: true
            }), f = new Ca(50, 25), _ = new Dt(f, p);
            _.position.set(200, 300, -107), _.userData.section9Element = true, n.add(_), c.push(_);
            const g = new pu(16777215, 2, 200);
            g.position.set(200, 300, -100), g.userData.section9Element = true, n.add(g), c.push(g);
            const m = new _p(16777215, 0.5);
            m.userData.section9Element = true, n.add(m), c.push(m), Th(l, () => {
              Tl();
            }), Th(_, () => {
              Tl();
            });
            let y = false;
            l.userData.onPointerOver = () => {
              y || (wt.to(l.material.color, {
                r: 0,
                g: 0.337,
                b: 0.702,
                duration: 0.3
              }), y = true);
            }, l.userData.onPointerOut = () => {
              y && (wt.to(l.material.color, {
                r: 0,
                g: 0.482,
                b: 1,
                duration: 0.3
              }), y = false);
            }, c.forEach((x) => {
              x.visible = false;
            }), r();
          } catch (a) {
            s(a);
          }
        });
      }
      function NE(n, e) {
        if (qm.length === 0) return;
        const t = no() === 9;
        qm.forEach((i) => {
          i.visible !== t && (i.visible = t);
        }), t && !bl ? setTimeout(() => {
          Tl(), bl = true;
        }, 500) : !t && bl && (so(), bl = false);
      }
      function UE() {
        document.getElementById("loading-screen");
        const n = document.getElementById("progress-bar"), e = [
          {
            name: "REFERENCES",
            position: {
              x: -150,
              y: -150,
              z: 13
            }
          },
          {
            name: "WELCOME",
            position: {
              x: 0,
              y: 0,
              z: 13
            }
          },
          {
            name: "16 PSYCHE",
            position: {
              x: 20,
              y: 30,
              z: 10
            }
          },
          {
            name: "PSYCHE Jr",
            position: {
              x: -150,
              y: 150,
              z: 13
            }
          },
          {
            name: "COSMIC COMPARISON",
            position: {
              x: 0,
              y: 300,
              z: 13
            }
          },
          {
            name: "MISSION",
            position: {
              x: 150,
              y: 150,
              z: 13
            }
          },
          {
            name: "GAMES",
            position: {
              x: 300,
              y: 0,
              z: 13
            },
            subsections: [
              {
                name: "Temperature Control",
                position: {
                  x: 300,
                  y: 0,
                  z: 13
                }
              },
              {
                name: "Balance Game",
                position: {
                  x: 300,
                  y: 0,
                  z: 13
                }
              },
              {
                name: "Escape Velocity",
                position: {
                  x: 300,
                  y: 0,
                  z: 13
                }
              },
              {
                name: "SpacePic",
                position: {
                  x: 300,
                  y: 0,
                  z: 13
                }
              }
            ]
          },
          {
            name: "SURFACE OF PSYCHE",
            position: {
              x: 150,
              y: -150,
              z: 13
            }
          },
          {
            name: "LOCATION OF PYSCHE",
            position: {
              x: 0,
              y: -300,
              z: 13
            }
          }
        ];
        _E(e);
        const t = new D_(), i = new ui(75, window.innerWidth / window.innerHeight, 0.1, 5e3);
        i.position.set(0, 0, 13);
        const r = new OT({
          antialias: true
        });
        r.setSize(window.innerWidth, window.innerHeight), r.setPixelRatio(window.devicePixelRatio), document.getElementById("canvas-container").appendChild(r.domElement);
        const s = new _p(16777215, 0.5);
        t.add(s);
        const a = new gp(8019774, 10);
        a.position.set(-15, 5, 5), t.add(a), pE(i, e, r);
        const o = navigator.hardwareConcurrency < 4 || window.devicePixelRatio < 1.5, l = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent), c = o ? 0.5 : 1, u = o ? 1 : 2, h = document.getElementById("debug-panel");
        function d() {
          const y = no();
          h.innerHTML = `
      <strong>DEBUG PANEL:</strong><br>
      <strong>Current Section:</strong>
      ${y}<br>
      <strong>Camera Position:</strong><br>
      X: ${i.position.x.toFixed(2)}<br>
      Y: ${i.position.y.toFixed(2)}<br>
      Z: ${i.position.z.toFixed(2)}<br>
      Is Mobile: ${l}<br>
      Concurrency: ${navigator.hardwareConcurrency}<br>
      PixelRatio: ${window.devicePixelRatio}
    `;
        }
        function p() {
          requestAnimationFrame(p), d(), f ? f.render() : r.render(t, i), bE(i, t), sE(i, t), LE(), NE();
        }
        BS(i, t, r);
        const f = KS(t, r, i, u), _ = [
          vE(t, i, e),
          xE(t, i, e),
          yE(t, i, e, r),
          TE(t, i, e, r),
          rE(t, i, e, r),
          wE(t, i, e, r),
          RE(t, i, e, r),
          CE(t, i, e),
          PE(t, i, e, r),
          IE(t)
        ];
        let g = 0;
        const m = _.length;
        _.forEach((y) => {
          y.then(() => {
            g++;
            const x = g / m * 100;
            n.style.width = `${x}%`, g === m && (console.log("All sections loaded."), YS(t, {
              density: c
            }), zS(i, r), gE(), p(), OE(), document.getElementById("cn-icon-wrapper").style.display = "flex");
          }).catch((x) => {
            console.error("Error loading a section:", x);
          });
        });
      }
      function OE() {
        const n = document.getElementById("loading-screen");
        n.style.transition = "opacity 0.5s ease", n.style.opacity = "0", setTimeout(() => n.remove(), 500);
      }
      window.addEventListener("resize", () => {
        camera && renderer ? Bm(camera, renderer) : console.warn("Resize event fired, but camera or renderer is not defined.");
      }), UE();
    })();
  })();
})();
export {
  wt as S,
  __tla,
  aa as r
};
