let ra, St;
let __tla = (async () => {
  (function() {
    const nn = document.createElement("link").relList;
    if (nn && nn.supports && nn.supports("modulepreload")) return;
    for (const wt of document.querySelectorAll('link[rel="modulepreload"]')) na(wt);
    new MutationObserver((wt) => {
      for (const qt of wt) if (qt.type === "childList") for (const At of qt.addedNodes) At.tagName === "LINK" && At.rel === "modulepreload" && na(At);
    }).observe(document, {
      childList: true,
      subtree: true
    });
    function Dr(wt) {
      const qt = {};
      return wt.integrity && (qt.integrity = wt.integrity), wt.referrerPolicy && (qt.referrerPolicy = wt.referrerPolicy), wt.crossOrigin === "use-credentials" ? qt.credentials = "include" : wt.crossOrigin === "anonymous" ? qt.credentials = "omit" : qt.credentials = "same-origin", qt;
    }
    function na(wt) {
      if (wt.ep) return;
      wt.ep = true;
      const qt = Dr(wt);
      fetch(wt.href, qt);
    }
  })();
  const zT = "modulepreload", kT = function(rn) {
    return "/" + rn;
  }, Jm = {}, HT = function(nn, Dr, na) {
    let wt = Promise.resolve();
    if (Dr && Dr.length > 0) {
      document.getElementsByTagName("link");
      const At = document.querySelector("meta[property=csp-nonce]"), Ot = (At == null ? void 0 : At.nonce) || (At == null ? void 0 : At.getAttribute("nonce"));
      wt = Promise.allSettled(Dr.map((vt) => {
        if (vt = kT(vt), vt in Jm) return;
        Jm[vt] = true;
        const ti = vt.endsWith(".css"), Fi = ti ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${vt}"]${Fi}`)) return;
        const ii = document.createElement("link");
        if (ii.rel = ti ? "stylesheet" : zT, ti || (ii.as = "script"), ii.crossOrigin = "", ii.href = vt, Ot && ii.setAttribute("nonce", Ot), document.head.appendChild(ii), ti) return new Promise((Wn, ro) => {
          ii.addEventListener("load", Wn), ii.addEventListener("error", () => ro(new Error(`Unable to preload CSS for ${vt}`)));
        });
      }));
    }
    function qt(At) {
      const Ot = new Event("vite:preloadError", {
        cancelable: true
      });
      if (Ot.payload = At, window.dispatchEvent(Ot), !Ot.defaultPrevented) throw At;
    }
    return wt.then((At) => {
      for (const Ot of At || []) Ot.status === "rejected" && qt(Ot.reason);
      return nn().catch(qt);
    });
  };
  (async () => {
    (function() {
      const r = document.createElement("link").relList;
      if (r && r.supports && r.supports("modulepreload")) return;
      for (const i of document.querySelectorAll('link[rel="modulepreload"]')) t(i);
      new MutationObserver((i) => {
        for (const n of i) if (n.type === "childList") for (const s of n.addedNodes) s.tagName === "LINK" && s.rel === "modulepreload" && t(s);
      }).observe(document, {
        childList: true,
        subtree: true
      });
      function e(i) {
        const n = {};
        return i.integrity && (n.integrity = i.integrity), i.referrerPolicy && (n.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? n.credentials = "include" : i.crossOrigin === "anonymous" ? n.credentials = "omit" : n.credentials = "same-origin", n;
      }
      function t(i) {
        if (i.ep) return;
        i.ep = true;
        const n = e(i);
        fetch(i.href, n);
      }
    })();
    const rn = "173", nn = 0, Dr = 1, na = 2, wt = 1, qt = 2, At = 3, Ot = 0, vt = 1, ti = 2, Fi = 0, ii = 1, Wn = 2, ro = 3, Oh = 4, $m = 5, sn = 100, Qm = 101, eg = 102, tg = 103, ig = 104, rg = 200, ng = 201, sg = 202, ag = 203, Sl = 204, El = 205, og = 206, lg = 207, cg = 208, ug = 209, hg = 210, dg = 211, pg = 212, fg = 213, mg = 214, Tl = 0, wl = 1, Al = 2, Xn = 3, Rl = 4, Cl = 5, Pl = 6, Ll = 7, Nh = 0, gg = 1, _g = 2, Ir = 0, vg = 1, xg = 2, yg = 3, Mg = 4, bg = 5, Sg = 6, Eg = 7, Fh = "attached", Tg = "detached", Bh = 300, jn = 301, qn = 302, Dl = 303, Il = 304, no = 306, Yn = 1e3, Ur = 1001, so = 1002, ri = 1003, zh = 1004, sa = 1005, _i = 1006, ao = 1007, cr = 1008, ur = 1009, kh = 1010, Hh = 1011, aa = 1012, Ul = 1013, an = 1014, Bi = 1015, hr = 1016, Ol = 1017, Nl = 1018, Kn = 1020, Vh = 35902, Gh = 1021, Wh = 1022, Ri = 1023, Xh = 1024, jh = 1025, Zn = 1026, Jn = 1027, Fl = 1028, Bl = 1029, qh = 1030, zl = 1031, kl = 1033, oo = 33776, lo = 33777, co = 33778, uo = 33779, Hl = 35840, Vl = 35841, Gl = 35842, Wl = 35843, Xl = 36196, jl = 37492, ql = 37496, Yl = 37808, Kl = 37809, Zl = 37810, Jl = 37811, $l = 37812, Ql = 37813, ec = 37814, tc = 37815, ic = 37816, rc = 37817, nc = 37818, sc = 37819, ac = 37820, oc = 37821, ho = 36492, lc = 36494, cc = 36495, Yh = 36283, uc = 36284, hc = 36285, dc = 36286, oa = 2300, la = 2301, pc = 2302, Kh = 2400, Zh = 2401, Jh = 2402, wg = 2500, Ag = 0, $h = 1, fc = 2, Rg = 3200, Cg = 3201, Qh = 0, Pg = 1, Or = "", Gt = "srgb", ni = "srgb-linear", po = "linear", ot = "srgb", $n = 7680, ed = 519, Lg = 512, Dg = 513, Ig = 514, td = 515, Ug = 516, Og = 517, Ng = 518, Fg = 519, mc = 35044, id = "300 es", dr = 2e3, fo = 2001;
    class Qn {
      addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const i = this._listeners;
        i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
      }
      hasEventListener(e, t) {
        const i = this._listeners;
        return i === void 0 ? false : i[e] !== void 0 && i[e].indexOf(t) !== -1;
      }
      removeEventListener(e, t) {
        const i = this._listeners;
        if (i === void 0) return;
        const n = i[e];
        if (n !== void 0) {
          const s = n.indexOf(t);
          s !== -1 && n.splice(s, 1);
        }
      }
      dispatchEvent(e) {
        const t = this._listeners;
        if (t === void 0) return;
        const i = t[e.type];
        if (i !== void 0) {
          e.target = this;
          const n = i.slice(0);
          for (let s = 0, a = n.length; s < a; s++) n[s].call(this, e);
          e.target = null;
        }
      }
    }
    const Yt = [
      "00",
      "01",
      "02",
      "03",
      "04",
      "05",
      "06",
      "07",
      "08",
      "09",
      "0a",
      "0b",
      "0c",
      "0d",
      "0e",
      "0f",
      "10",
      "11",
      "12",
      "13",
      "14",
      "15",
      "16",
      "17",
      "18",
      "19",
      "1a",
      "1b",
      "1c",
      "1d",
      "1e",
      "1f",
      "20",
      "21",
      "22",
      "23",
      "24",
      "25",
      "26",
      "27",
      "28",
      "29",
      "2a",
      "2b",
      "2c",
      "2d",
      "2e",
      "2f",
      "30",
      "31",
      "32",
      "33",
      "34",
      "35",
      "36",
      "37",
      "38",
      "39",
      "3a",
      "3b",
      "3c",
      "3d",
      "3e",
      "3f",
      "40",
      "41",
      "42",
      "43",
      "44",
      "45",
      "46",
      "47",
      "48",
      "49",
      "4a",
      "4b",
      "4c",
      "4d",
      "4e",
      "4f",
      "50",
      "51",
      "52",
      "53",
      "54",
      "55",
      "56",
      "57",
      "58",
      "59",
      "5a",
      "5b",
      "5c",
      "5d",
      "5e",
      "5f",
      "60",
      "61",
      "62",
      "63",
      "64",
      "65",
      "66",
      "67",
      "68",
      "69",
      "6a",
      "6b",
      "6c",
      "6d",
      "6e",
      "6f",
      "70",
      "71",
      "72",
      "73",
      "74",
      "75",
      "76",
      "77",
      "78",
      "79",
      "7a",
      "7b",
      "7c",
      "7d",
      "7e",
      "7f",
      "80",
      "81",
      "82",
      "83",
      "84",
      "85",
      "86",
      "87",
      "88",
      "89",
      "8a",
      "8b",
      "8c",
      "8d",
      "8e",
      "8f",
      "90",
      "91",
      "92",
      "93",
      "94",
      "95",
      "96",
      "97",
      "98",
      "99",
      "9a",
      "9b",
      "9c",
      "9d",
      "9e",
      "9f",
      "a0",
      "a1",
      "a2",
      "a3",
      "a4",
      "a5",
      "a6",
      "a7",
      "a8",
      "a9",
      "aa",
      "ab",
      "ac",
      "ad",
      "ae",
      "af",
      "b0",
      "b1",
      "b2",
      "b3",
      "b4",
      "b5",
      "b6",
      "b7",
      "b8",
      "b9",
      "ba",
      "bb",
      "bc",
      "bd",
      "be",
      "bf",
      "c0",
      "c1",
      "c2",
      "c3",
      "c4",
      "c5",
      "c6",
      "c7",
      "c8",
      "c9",
      "ca",
      "cb",
      "cc",
      "cd",
      "ce",
      "cf",
      "d0",
      "d1",
      "d2",
      "d3",
      "d4",
      "d5",
      "d6",
      "d7",
      "d8",
      "d9",
      "da",
      "db",
      "dc",
      "dd",
      "de",
      "df",
      "e0",
      "e1",
      "e2",
      "e3",
      "e4",
      "e5",
      "e6",
      "e7",
      "e8",
      "e9",
      "ea",
      "eb",
      "ec",
      "ed",
      "ee",
      "ef",
      "f0",
      "f1",
      "f2",
      "f3",
      "f4",
      "f5",
      "f6",
      "f7",
      "f8",
      "f9",
      "fa",
      "fb",
      "fc",
      "fd",
      "fe",
      "ff"
    ];
    let rd = 1234567;
    const ca = Math.PI / 180, es = 180 / Math.PI;
    function Ci() {
      const r = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, i = Math.random() * 4294967295 | 0;
      return (Yt[r & 255] + Yt[r >> 8 & 255] + Yt[r >> 16 & 255] + Yt[r >> 24 & 255] + "-" + Yt[e & 255] + Yt[e >> 8 & 255] + "-" + Yt[e >> 16 & 15 | 64] + Yt[e >> 24 & 255] + "-" + Yt[t & 63 | 128] + Yt[t >> 8 & 255] + "-" + Yt[t >> 16 & 255] + Yt[t >> 24 & 255] + Yt[i & 255] + Yt[i >> 8 & 255] + Yt[i >> 16 & 255] + Yt[i >> 24 & 255]).toLowerCase();
    }
    function Ge(r, e, t) {
      return Math.max(e, Math.min(t, r));
    }
    function gc(r, e) {
      return (r % e + e) % e;
    }
    function Bg(r, e, t, i, n) {
      return i + (r - e) * (n - i) / (t - e);
    }
    function zg(r, e, t) {
      return r !== e ? (t - r) / (e - r) : 0;
    }
    function ua(r, e, t) {
      return (1 - t) * r + t * e;
    }
    function kg(r, e, t, i) {
      return ua(r, e, 1 - Math.exp(-t * i));
    }
    function Hg(r, e = 1) {
      return e - Math.abs(gc(r, e * 2) - e);
    }
    function Vg(r, e, t) {
      return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e), r * r * (3 - 2 * r));
    }
    function Gg(r, e, t) {
      return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e), r * r * r * (r * (r * 6 - 15) + 10));
    }
    function Wg(r, e) {
      return r + Math.floor(Math.random() * (e - r + 1));
    }
    function Xg(r, e) {
      return r + Math.random() * (e - r);
    }
    function jg(r) {
      return r * (0.5 - Math.random());
    }
    function qg(r) {
      r !== void 0 && (rd = r);
      let e = rd += 1831565813;
      return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
    }
    function Yg(r) {
      return r * ca;
    }
    function Kg(r) {
      return r * es;
    }
    function Zg(r) {
      return (r & r - 1) === 0 && r !== 0;
    }
    function Jg(r) {
      return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
    }
    function $g(r) {
      return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
    }
    function Qg(r, e, t, i, n) {
      const s = Math.cos, a = Math.sin, o = s(t / 2), l = a(t / 2), c = s((e + i) / 2), u = a((e + i) / 2), h = s((e - i) / 2), d = a((e - i) / 2), p = s((i - e) / 2), f = a((i - e) / 2);
      switch (n) {
        case "XYX":
          r.set(o * u, l * h, l * d, o * c);
          break;
        case "YZY":
          r.set(l * d, o * u, l * h, o * c);
          break;
        case "ZXZ":
          r.set(l * h, l * d, o * u, o * c);
          break;
        case "XZX":
          r.set(o * u, l * f, l * p, o * c);
          break;
        case "YXY":
          r.set(l * p, o * u, l * f, o * c);
          break;
        case "ZYZ":
          r.set(l * f, l * p, o * u, o * c);
          break;
        default:
          console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + n);
      }
    }
    function zi(r, e) {
      switch (e.constructor) {
        case Float32Array:
          return r;
        case Uint32Array:
          return r / 4294967295;
        case Uint16Array:
          return r / 65535;
        case Uint8Array:
          return r / 255;
        case Int32Array:
          return Math.max(r / 2147483647, -1);
        case Int16Array:
          return Math.max(r / 32767, -1);
        case Int8Array:
          return Math.max(r / 127, -1);
        default:
          throw new Error("Invalid component type.");
      }
    }
    function nt(r, e) {
      switch (e.constructor) {
        case Float32Array:
          return r;
        case Uint32Array:
          return Math.round(r * 4294967295);
        case Uint16Array:
          return Math.round(r * 65535);
        case Uint8Array:
          return Math.round(r * 255);
        case Int32Array:
          return Math.round(r * 2147483647);
        case Int16Array:
          return Math.round(r * 32767);
        case Int8Array:
          return Math.round(r * 127);
        default:
          throw new Error("Invalid component type.");
      }
    }
    const e_ = {
      DEG2RAD: ca,
      RAD2DEG: es,
      generateUUID: Ci,
      clamp: Ge,
      euclideanModulo: gc,
      mapLinear: Bg,
      inverseLerp: zg,
      lerp: ua,
      damp: kg,
      pingpong: Hg,
      smoothstep: Vg,
      smootherstep: Gg,
      randInt: Wg,
      randFloat: Xg,
      randFloatSpread: jg,
      seededRandom: qg,
      degToRad: Yg,
      radToDeg: Kg,
      isPowerOfTwo: Zg,
      ceilPowerOfTwo: Jg,
      floorPowerOfTwo: $g,
      setQuaternionFromProperEuler: Qg,
      normalize: nt,
      denormalize: zi
    };
    class ee {
      constructor(e = 0, t = 0) {
        ee.prototype.isVector2 = true, this.x = e, this.y = t;
      }
      get width() {
        return this.x;
      }
      set width(e) {
        this.x = e;
      }
      get height() {
        return this.y;
      }
      set height(e) {
        this.y = e;
      }
      set(e, t) {
        return this.x = e, this.y = t, this;
      }
      setScalar(e) {
        return this.x = e, this.y = e, this;
      }
      setX(e) {
        return this.x = e, this;
      }
      setY(e) {
        return this.y = e, this;
      }
      setComponent(e, t) {
        switch (e) {
          case 0:
            this.x = t;
            break;
          case 1:
            this.y = t;
            break;
          default:
            throw new Error("index is out of range: " + e);
        }
        return this;
      }
      getComponent(e) {
        switch (e) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + e);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y);
      }
      copy(e) {
        return this.x = e.x, this.y = e.y, this;
      }
      add(e) {
        return this.x += e.x, this.y += e.y, this;
      }
      addScalar(e) {
        return this.x += e, this.y += e, this;
      }
      addVectors(e, t) {
        return this.x = e.x + t.x, this.y = e.y + t.y, this;
      }
      addScaledVector(e, t) {
        return this.x += e.x * t, this.y += e.y * t, this;
      }
      sub(e) {
        return this.x -= e.x, this.y -= e.y, this;
      }
      subScalar(e) {
        return this.x -= e, this.y -= e, this;
      }
      subVectors(e, t) {
        return this.x = e.x - t.x, this.y = e.y - t.y, this;
      }
      multiply(e) {
        return this.x *= e.x, this.y *= e.y, this;
      }
      multiplyScalar(e) {
        return this.x *= e, this.y *= e, this;
      }
      divide(e) {
        return this.x /= e.x, this.y /= e.y, this;
      }
      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }
      applyMatrix3(e) {
        const t = this.x, i = this.y, n = e.elements;
        return this.x = n[0] * t + n[3] * i + n[6], this.y = n[1] * t + n[4] * i + n[7], this;
      }
      min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
      }
      max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
      }
      clamp(e, t) {
        return this.x = Ge(this.x, e.x, t.x), this.y = Ge(this.y, e.y, t.y), this;
      }
      clampScalar(e, t) {
        return this.x = Ge(this.x, e, t), this.y = Ge(this.y, e, t), this;
      }
      clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Ge(i, e, t));
      }
      floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
      }
      ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
      }
      round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
      }
      roundToZero() {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
      }
      negate() {
        return this.x = -this.x, this.y = -this.y, this;
      }
      dot(e) {
        return this.x * e.x + this.y * e.y;
      }
      cross(e) {
        return this.x * e.y - this.y * e.x;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI;
      }
      angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0) return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(Ge(i, -1, 1));
      }
      distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
      }
      distanceToSquared(e) {
        const t = this.x - e.x, i = this.y - e.y;
        return t * t + i * i;
      }
      manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
      }
      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }
      lerp(e, t) {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
      }
      lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this;
      }
      equals(e) {
        return e.x === this.x && e.y === this.y;
      }
      fromArray(e, t = 0) {
        return this.x = e[t], this.y = e[t + 1], this;
      }
      toArray(e = [], t = 0) {
        return e[t] = this.x, e[t + 1] = this.y, e;
      }
      fromBufferAttribute(e, t) {
        return this.x = e.getX(t), this.y = e.getY(t), this;
      }
      rotateAround(e, t) {
        const i = Math.cos(t), n = Math.sin(t), s = this.x - e.x, a = this.y - e.y;
        return this.x = s * i - a * n + e.x, this.y = s * n + a * i + e.y, this;
      }
      random() {
        return this.x = Math.random(), this.y = Math.random(), this;
      }
      *[Symbol.iterator]() {
        yield this.x, yield this.y;
      }
    }
    class ze {
      constructor(e, t, i, n, s, a, o, l, c) {
        ze.prototype.isMatrix3 = true, this.elements = [
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ], e !== void 0 && this.set(e, t, i, n, s, a, o, l, c);
      }
      set(e, t, i, n, s, a, o, l, c) {
        const u = this.elements;
        return u[0] = e, u[1] = n, u[2] = o, u[3] = t, u[4] = s, u[5] = l, u[6] = i, u[7] = a, u[8] = c, this;
      }
      identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
      }
      copy(e) {
        const t = this.elements, i = e.elements;
        return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this;
      }
      extractBasis(e, t, i) {
        return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this;
      }
      setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this;
      }
      multiply(e) {
        return this.multiplyMatrices(this, e);
      }
      premultiply(e) {
        return this.multiplyMatrices(e, this);
      }
      multiplyMatrices(e, t) {
        const i = e.elements, n = t.elements, s = this.elements, a = i[0], o = i[3], l = i[6], c = i[1], u = i[4], h = i[7], d = i[2], p = i[5], f = i[8], _ = n[0], g = n[3], m = n[6], y = n[1], x = n[4], v = n[7], A = n[2], T = n[5], w = n[8];
        return s[0] = a * _ + o * y + l * A, s[3] = a * g + o * x + l * T, s[6] = a * m + o * v + l * w, s[1] = c * _ + u * y + h * A, s[4] = c * g + u * x + h * T, s[7] = c * m + u * v + h * w, s[2] = d * _ + p * y + f * A, s[5] = d * g + p * x + f * T, s[8] = d * m + p * v + f * w, this;
      }
      multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
      }
      determinant() {
        const e = this.elements, t = e[0], i = e[1], n = e[2], s = e[3], a = e[4], o = e[5], l = e[6], c = e[7], u = e[8];
        return t * a * u - t * o * c - i * s * u + i * o * l + n * s * c - n * a * l;
      }
      invert() {
        const e = this.elements, t = e[0], i = e[1], n = e[2], s = e[3], a = e[4], o = e[5], l = e[6], c = e[7], u = e[8], h = u * a - o * c, d = o * l - u * s, p = c * s - a * l, f = t * h + i * d + n * p;
        if (f === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const _ = 1 / f;
        return e[0] = h * _, e[1] = (n * c - u * i) * _, e[2] = (o * i - n * a) * _, e[3] = d * _, e[4] = (u * t - n * l) * _, e[5] = (n * s - o * t) * _, e[6] = p * _, e[7] = (i * l - c * t) * _, e[8] = (a * t - i * s) * _, this;
      }
      transpose() {
        let e;
        const t = this.elements;
        return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
      }
      getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose();
      }
      transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
      }
      setUvTransform(e, t, i, n, s, a, o) {
        const l = Math.cos(s), c = Math.sin(s);
        return this.set(i * l, i * c, -i * (l * a + c * o) + a + e, -n * c, n * l, -n * (-c * a + l * o) + o + t, 0, 0, 1), this;
      }
      scale(e, t) {
        return this.premultiply(_c.makeScale(e, t)), this;
      }
      rotate(e) {
        return this.premultiply(_c.makeRotation(-e)), this;
      }
      translate(e, t) {
        return this.premultiply(_c.makeTranslation(e, t)), this;
      }
      makeTranslation(e, t) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
      }
      makeRotation(e) {
        const t = Math.cos(e), i = Math.sin(e);
        return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
      }
      makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
      }
      equals(e) {
        const t = this.elements, i = e.elements;
        for (let n = 0; n < 9; n++) if (t[n] !== i[n]) return false;
        return true;
      }
      fromArray(e, t = 0) {
        for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
        return this;
      }
      toArray(e = [], t = 0) {
        const i = this.elements;
        return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e;
      }
      clone() {
        return new this.constructor().fromArray(this.elements);
      }
    }
    const _c = new ze();
    function nd(r) {
      for (let e = r.length - 1; e >= 0; --e) if (r[e] >= 65535) return true;
      return false;
    }
    function ha(r) {
      return document.createElementNS("http://www.w3.org/1999/xhtml", r);
    }
    function t_() {
      const r = ha("canvas");
      return r.style.display = "block", r;
    }
    const sd = {};
    function ts(r) {
      r in sd || (sd[r] = true, console.warn(r));
    }
    function i_(r, e, t) {
      return new Promise(function(i, n) {
        function s() {
          switch (r.clientWaitSync(e, r.SYNC_FLUSH_COMMANDS_BIT, 0)) {
            case r.WAIT_FAILED:
              n();
              break;
            case r.TIMEOUT_EXPIRED:
              setTimeout(s, t);
              break;
            default:
              i();
          }
        }
        setTimeout(s, t);
      });
    }
    function r_(r) {
      const e = r.elements;
      e[2] = 0.5 * e[2] + 0.5 * e[3], e[6] = 0.5 * e[6] + 0.5 * e[7], e[10] = 0.5 * e[10] + 0.5 * e[11], e[14] = 0.5 * e[14] + 0.5 * e[15];
    }
    function n_(r) {
      const e = r.elements;
      e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1);
    }
    const ad = new ze().set(0.4123908, 0.3575843, 0.1804808, 0.212639, 0.7151687, 0.0721923, 0.0193308, 0.1191948, 0.9505322), od = new ze().set(3.2409699, -1.5373832, -0.4986108, -0.9692436, 1.8759675, 0.0415551, 0.0556301, -0.203977, 1.0569715);
    function s_() {
      const r = {
        enabled: true,
        workingColorSpace: ni,
        spaces: {},
        convert: function(n, s, a) {
          return this.enabled === false || s === a || !s || !a || (this.spaces[s].transfer === ot && (n.r = pr(n.r), n.g = pr(n.g), n.b = pr(n.b)), this.spaces[s].primaries !== this.spaces[a].primaries && (n.applyMatrix3(this.spaces[s].toXYZ), n.applyMatrix3(this.spaces[a].fromXYZ)), this.spaces[a].transfer === ot && (n.r = is(n.r), n.g = is(n.g), n.b = is(n.b))), n;
        },
        fromWorkingColorSpace: function(n, s) {
          return this.convert(n, this.workingColorSpace, s);
        },
        toWorkingColorSpace: function(n, s) {
          return this.convert(n, s, this.workingColorSpace);
        },
        getPrimaries: function(n) {
          return this.spaces[n].primaries;
        },
        getTransfer: function(n) {
          return n === Or ? po : this.spaces[n].transfer;
        },
        getLuminanceCoefficients: function(n, s = this.workingColorSpace) {
          return n.fromArray(this.spaces[s].luminanceCoefficients);
        },
        define: function(n) {
          Object.assign(this.spaces, n);
        },
        _getMatrix: function(n, s, a) {
          return n.copy(this.spaces[s].toXYZ).multiply(this.spaces[a].fromXYZ);
        },
        _getDrawingBufferColorSpace: function(n) {
          return this.spaces[n].outputColorSpaceConfig.drawingBufferColorSpace;
        },
        _getUnpackColorSpace: function(n = this.workingColorSpace) {
          return this.spaces[n].workingColorSpaceConfig.unpackColorSpace;
        }
      }, e = [
        0.64,
        0.33,
        0.3,
        0.6,
        0.15,
        0.06
      ], t = [
        0.2126,
        0.7152,
        0.0722
      ], i = [
        0.3127,
        0.329
      ];
      return r.define({
        [ni]: {
          primaries: e,
          whitePoint: i,
          transfer: po,
          toXYZ: ad,
          fromXYZ: od,
          luminanceCoefficients: t,
          workingColorSpaceConfig: {
            unpackColorSpace: Gt
          },
          outputColorSpaceConfig: {
            drawingBufferColorSpace: Gt
          }
        },
        [Gt]: {
          primaries: e,
          whitePoint: i,
          transfer: ot,
          toXYZ: ad,
          fromXYZ: od,
          luminanceCoefficients: t,
          outputColorSpaceConfig: {
            drawingBufferColorSpace: Gt
          }
        }
      }), r;
    }
    const Ke = s_();
    function pr(r) {
      return r < 0.04045 ? r * 0.0773993808 : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
    }
    function is(r) {
      return r < 31308e-7 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
    }
    let rs;
    class a_ {
      static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
        let t;
        if (e instanceof HTMLCanvasElement) t = e;
        else {
          rs === void 0 && (rs = ha("canvas")), rs.width = e.width, rs.height = e.height;
          const i = rs.getContext("2d");
          e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), t = rs;
        }
        return t.toDataURL("image/png");
      }
      static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
          const t = ha("canvas");
          t.width = e.width, t.height = e.height;
          const i = t.getContext("2d");
          i.drawImage(e, 0, 0, e.width, e.height);
          const n = i.getImageData(0, 0, e.width, e.height), s = n.data;
          for (let a = 0; a < s.length; a++) s[a] = pr(s[a] / 255) * 255;
          return i.putImageData(n, 0, 0), t;
        } else if (e.data) {
          const t = e.data.slice(0);
          for (let i = 0; i < t.length; i++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(pr(t[i] / 255) * 255) : t[i] = pr(t[i]);
          return {
            data: t,
            width: e.width,
            height: e.height
          };
        } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
      }
    }
    let o_ = 0;
    class ld {
      constructor(e = null) {
        this.isSource = true, Object.defineProperty(this, "id", {
          value: o_++
        }), this.uuid = Ci(), this.data = e, this.dataReady = true, this.version = 0;
      }
      set needsUpdate(e) {
        e === true && this.version++;
      }
      toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
        const i = {
          uuid: this.uuid,
          url: ""
        }, n = this.data;
        if (n !== null) {
          let s;
          if (Array.isArray(n)) {
            s = [];
            for (let a = 0, o = n.length; a < o; a++) n[a].isDataTexture ? s.push(vc(n[a].image)) : s.push(vc(n[a]));
          } else s = vc(n);
          i.url = s;
        }
        return t || (e.images[this.uuid] = i), i;
      }
    }
    function vc(r) {
      return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? a_.getDataURL(r) : r.data ? {
        data: Array.from(r.data),
        width: r.width,
        height: r.height,
        type: r.data.constructor.name
      } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
    }
    let l_ = 0;
    class Nt extends Qn {
      constructor(e = Nt.DEFAULT_IMAGE, t = Nt.DEFAULT_MAPPING, i = Ur, n = Ur, s = _i, a = cr, o = Ri, l = ur, c = Nt.DEFAULT_ANISOTROPY, u = Or) {
        super(), this.isTexture = true, Object.defineProperty(this, "id", {
          value: l_++
        }), this.uuid = Ci(), this.name = "", this.source = new ld(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = i, this.wrapT = n, this.magFilter = s, this.minFilter = a, this.anisotropy = c, this.format = o, this.internalFormat = null, this.type = l, this.offset = new ee(0, 0), this.repeat = new ee(1, 1), this.center = new ee(0, 0), this.rotation = 0, this.matrixAutoUpdate = true, this.matrix = new ze(), this.generateMipmaps = true, this.premultiplyAlpha = false, this.flipY = true, this.unpackAlignment = 4, this.colorSpace = u, this.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = false, this.pmremVersion = 0;
      }
      get image() {
        return this.source.data;
      }
      set image(e = null) {
        this.source.data = e;
      }
      updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = true, this;
      }
      toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
        const i = {
          metadata: {
            version: 4.6,
            type: "Texture",
            generator: "Texture.toJSON"
          },
          uuid: this.uuid,
          name: this.name,
          image: this.source.toJSON(e).uuid,
          mapping: this.mapping,
          channel: this.channel,
          repeat: [
            this.repeat.x,
            this.repeat.y
          ],
          offset: [
            this.offset.x,
            this.offset.y
          ],
          center: [
            this.center.x,
            this.center.y
          ],
          rotation: this.rotation,
          wrap: [
            this.wrapS,
            this.wrapT
          ],
          format: this.format,
          internalFormat: this.internalFormat,
          type: this.type,
          colorSpace: this.colorSpace,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
          generateMipmaps: this.generateMipmaps,
          premultiplyAlpha: this.premultiplyAlpha,
          unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i;
      }
      dispose() {
        this.dispatchEvent({
          type: "dispose"
        });
      }
      transformUv(e) {
        if (this.mapping !== Bh) return e;
        if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
          case Yn:
            e.x = e.x - Math.floor(e.x);
            break;
          case Ur:
            e.x = e.x < 0 ? 0 : 1;
            break;
          case so:
            Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
            break;
        }
        if (e.y < 0 || e.y > 1) switch (this.wrapT) {
          case Yn:
            e.y = e.y - Math.floor(e.y);
            break;
          case Ur:
            e.y = e.y < 0 ? 0 : 1;
            break;
          case so:
            Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
            break;
        }
        return this.flipY && (e.y = 1 - e.y), e;
      }
      set needsUpdate(e) {
        e === true && (this.version++, this.source.needsUpdate = true);
      }
      set needsPMREMUpdate(e) {
        e === true && this.pmremVersion++;
      }
    }
    Nt.DEFAULT_IMAGE = null, Nt.DEFAULT_MAPPING = Bh, Nt.DEFAULT_ANISOTROPY = 1;
    class it {
      constructor(e = 0, t = 0, i = 0, n = 1) {
        it.prototype.isVector4 = true, this.x = e, this.y = t, this.z = i, this.w = n;
      }
      get width() {
        return this.z;
      }
      set width(e) {
        this.z = e;
      }
      get height() {
        return this.w;
      }
      set height(e) {
        this.w = e;
      }
      set(e, t, i, n) {
        return this.x = e, this.y = t, this.z = i, this.w = n, this;
      }
      setScalar(e) {
        return this.x = e, this.y = e, this.z = e, this.w = e, this;
      }
      setX(e) {
        return this.x = e, this;
      }
      setY(e) {
        return this.y = e, this;
      }
      setZ(e) {
        return this.z = e, this;
      }
      setW(e) {
        return this.w = e, this;
      }
      setComponent(e, t) {
        switch (e) {
          case 0:
            this.x = t;
            break;
          case 1:
            this.y = t;
            break;
          case 2:
            this.z = t;
            break;
          case 3:
            this.w = t;
            break;
          default:
            throw new Error("index is out of range: " + e);
        }
        return this;
      }
      getComponent(e) {
        switch (e) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error("index is out of range: " + e);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      }
      copy(e) {
        return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
      }
      add(e) {
        return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
      }
      addScalar(e) {
        return this.x += e, this.y += e, this.z += e, this.w += e, this;
      }
      addVectors(e, t) {
        return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
      }
      addScaledVector(e, t) {
        return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
      }
      sub(e) {
        return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
      }
      subScalar(e) {
        return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
      }
      subVectors(e, t) {
        return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
      }
      multiply(e) {
        return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
      }
      multiplyScalar(e) {
        return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
      }
      applyMatrix4(e) {
        const t = this.x, i = this.y, n = this.z, s = this.w, a = e.elements;
        return this.x = a[0] * t + a[4] * i + a[8] * n + a[12] * s, this.y = a[1] * t + a[5] * i + a[9] * n + a[13] * s, this.z = a[2] * t + a[6] * i + a[10] * n + a[14] * s, this.w = a[3] * t + a[7] * i + a[11] * n + a[15] * s, this;
      }
      divide(e) {
        return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
      }
      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }
      setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
      }
      setAxisAngleFromRotationMatrix(e) {
        let t, i, n, s;
        const a = e.elements, o = a[0], l = a[4], c = a[8], u = a[1], h = a[5], d = a[9], p = a[2], f = a[6], _ = a[10];
        if (Math.abs(l - u) < 0.01 && Math.abs(c - p) < 0.01 && Math.abs(d - f) < 0.01) {
          if (Math.abs(l + u) < 0.1 && Math.abs(c + p) < 0.1 && Math.abs(d + f) < 0.1 && Math.abs(o + h + _ - 3) < 0.1) return this.set(1, 0, 0, 0), this;
          t = Math.PI;
          const m = (o + 1) / 2, y = (h + 1) / 2, x = (_ + 1) / 2, v = (l + u) / 4, A = (c + p) / 4, T = (d + f) / 4;
          return m > y && m > x ? m < 0.01 ? (i = 0, n = 0.707106781, s = 0.707106781) : (i = Math.sqrt(m), n = v / i, s = A / i) : y > x ? y < 0.01 ? (i = 0.707106781, n = 0, s = 0.707106781) : (n = Math.sqrt(y), i = v / n, s = T / n) : x < 0.01 ? (i = 0.707106781, n = 0.707106781, s = 0) : (s = Math.sqrt(x), i = A / s, n = T / s), this.set(i, n, s, t), this;
        }
        let g = Math.sqrt((f - d) * (f - d) + (c - p) * (c - p) + (u - l) * (u - l));
        return Math.abs(g) < 1e-3 && (g = 1), this.x = (f - d) / g, this.y = (c - p) / g, this.z = (u - l) / g, this.w = Math.acos((o + h + _ - 1) / 2), this;
      }
      setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this;
      }
      min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
      }
      max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
      }
      clamp(e, t) {
        return this.x = Ge(this.x, e.x, t.x), this.y = Ge(this.y, e.y, t.y), this.z = Ge(this.z, e.z, t.z), this.w = Ge(this.w, e.w, t.w), this;
      }
      clampScalar(e, t) {
        return this.x = Ge(this.x, e, t), this.y = Ge(this.y, e, t), this.z = Ge(this.z, e, t), this.w = Ge(this.w, e, t), this;
      }
      clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Ge(i, e, t));
      }
      floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
      }
      ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
      }
      round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
      }
      roundToZero() {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
      }
      negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
      }
      dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }
      lerp(e, t) {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
      }
      lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this;
      }
      equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
      }
      fromArray(e, t = 0) {
        return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
      }
      toArray(e = [], t = 0) {
        return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
      }
      fromBufferAttribute(e, t) {
        return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
      }
      random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
      }
      *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z, yield this.w;
      }
    }
    class c_ extends Qn {
      constructor(e = 1, t = 1, i = {}) {
        super(), this.isRenderTarget = true, this.width = e, this.height = t, this.depth = 1, this.scissor = new it(0, 0, e, t), this.scissorTest = false, this.viewport = new it(0, 0, e, t);
        const n = {
          width: e,
          height: t,
          depth: 1
        };
        i = Object.assign({
          generateMipmaps: false,
          internalFormat: null,
          minFilter: _i,
          depthBuffer: true,
          stencilBuffer: false,
          resolveDepthBuffer: true,
          resolveStencilBuffer: true,
          depthTexture: null,
          samples: 0,
          count: 1
        }, i);
        const s = new Nt(n, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
        s.flipY = false, s.generateMipmaps = i.generateMipmaps, s.internalFormat = i.internalFormat, this.textures = [];
        const a = i.count;
        for (let o = 0; o < a; o++) this.textures[o] = s.clone(), this.textures[o].isRenderTargetTexture = true, this.textures[o].renderTarget = this;
        this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = i.depthTexture, this.samples = i.samples;
      }
      get texture() {
        return this.textures[0];
      }
      set texture(e) {
        this.textures[0] = e;
      }
      set depthTexture(e) {
        this._depthTexture !== null && (this._depthTexture.renderTarget = null), e !== null && (e.renderTarget = this), this._depthTexture = e;
      }
      get depthTexture() {
        return this._depthTexture;
      }
      setSize(e, t, i = 1) {
        if (this.width !== e || this.height !== t || this.depth !== i) {
          this.width = e, this.height = t, this.depth = i;
          for (let n = 0, s = this.textures.length; n < s; n++) this.textures[n].image.width = e, this.textures[n].image.height = t, this.textures[n].image.depth = i;
          this.dispose();
        }
        this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
        for (let i = 0, n = e.textures.length; i < n; i++) this.textures[i] = e.textures[i].clone(), this.textures[i].isRenderTargetTexture = true, this.textures[i].renderTarget = this;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new ld(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
      }
      dispose() {
        this.dispatchEvent({
          type: "dispose"
        });
      }
    }
    class ki extends c_ {
      constructor(e = 1, t = 1, i = {}) {
        super(e, t, i), this.isWebGLRenderTarget = true;
      }
    }
    class cd extends Nt {
      constructor(e = null, t = 1, i = 1, n = 1) {
        super(null), this.isDataArrayTexture = true, this.image = {
          data: e,
          width: t,
          height: i,
          depth: n
        }, this.magFilter = ri, this.minFilter = ri, this.wrapR = Ur, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
      }
      addLayerUpdate(e) {
        this.layerUpdates.add(e);
      }
      clearLayerUpdates() {
        this.layerUpdates.clear();
      }
    }
    class u_ extends Nt {
      constructor(e = null, t = 1, i = 1, n = 1) {
        super(null), this.isData3DTexture = true, this.image = {
          data: e,
          width: t,
          height: i,
          depth: n
        }, this.magFilter = ri, this.minFilter = ri, this.wrapR = Ur, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
      }
    }
    class Nr {
      constructor(e = 0, t = 0, i = 0, n = 1) {
        this.isQuaternion = true, this._x = e, this._y = t, this._z = i, this._w = n;
      }
      static slerpFlat(e, t, i, n, s, a, o) {
        let l = i[n + 0], c = i[n + 1], u = i[n + 2], h = i[n + 3];
        const d = s[a + 0], p = s[a + 1], f = s[a + 2], _ = s[a + 3];
        if (o === 0) {
          e[t + 0] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = h;
          return;
        }
        if (o === 1) {
          e[t + 0] = d, e[t + 1] = p, e[t + 2] = f, e[t + 3] = _;
          return;
        }
        if (h !== _ || l !== d || c !== p || u !== f) {
          let g = 1 - o;
          const m = l * d + c * p + u * f + h * _, y = m >= 0 ? 1 : -1, x = 1 - m * m;
          if (x > Number.EPSILON) {
            const A = Math.sqrt(x), T = Math.atan2(A, m * y);
            g = Math.sin(g * T) / A, o = Math.sin(o * T) / A;
          }
          const v = o * y;
          if (l = l * g + d * v, c = c * g + p * v, u = u * g + f * v, h = h * g + _ * v, g === 1 - o) {
            const A = 1 / Math.sqrt(l * l + c * c + u * u + h * h);
            l *= A, c *= A, u *= A, h *= A;
          }
        }
        e[t] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = h;
      }
      static multiplyQuaternionsFlat(e, t, i, n, s, a) {
        const o = i[n], l = i[n + 1], c = i[n + 2], u = i[n + 3], h = s[a], d = s[a + 1], p = s[a + 2], f = s[a + 3];
        return e[t] = o * f + u * h + l * p - c * d, e[t + 1] = l * f + u * d + c * h - o * p, e[t + 2] = c * f + u * p + o * d - l * h, e[t + 3] = u * f - o * h - l * d - c * p, e;
      }
      get x() {
        return this._x;
      }
      set x(e) {
        this._x = e, this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(e) {
        this._y = e, this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(e) {
        this._z = e, this._onChangeCallback();
      }
      get w() {
        return this._w;
      }
      set w(e) {
        this._w = e, this._onChangeCallback();
      }
      set(e, t, i, n) {
        return this._x = e, this._y = t, this._z = i, this._w = n, this._onChangeCallback(), this;
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      }
      copy(e) {
        return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
      }
      setFromEuler(e, t = true) {
        const i = e._x, n = e._y, s = e._z, a = e._order, o = Math.cos, l = Math.sin, c = o(i / 2), u = o(n / 2), h = o(s / 2), d = l(i / 2), p = l(n / 2), f = l(s / 2);
        switch (a) {
          case "XYZ":
            this._x = d * u * h + c * p * f, this._y = c * p * h - d * u * f, this._z = c * u * f + d * p * h, this._w = c * u * h - d * p * f;
            break;
          case "YXZ":
            this._x = d * u * h + c * p * f, this._y = c * p * h - d * u * f, this._z = c * u * f - d * p * h, this._w = c * u * h + d * p * f;
            break;
          case "ZXY":
            this._x = d * u * h - c * p * f, this._y = c * p * h + d * u * f, this._z = c * u * f + d * p * h, this._w = c * u * h - d * p * f;
            break;
          case "ZYX":
            this._x = d * u * h - c * p * f, this._y = c * p * h + d * u * f, this._z = c * u * f - d * p * h, this._w = c * u * h + d * p * f;
            break;
          case "YZX":
            this._x = d * u * h + c * p * f, this._y = c * p * h + d * u * f, this._z = c * u * f - d * p * h, this._w = c * u * h - d * p * f;
            break;
          case "XZY":
            this._x = d * u * h - c * p * f, this._y = c * p * h - d * u * f, this._z = c * u * f + d * p * h, this._w = c * u * h + d * p * f;
            break;
          default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a);
        }
        return t === true && this._onChangeCallback(), this;
      }
      setFromAxisAngle(e, t) {
        const i = t / 2, n = Math.sin(i);
        return this._x = e.x * n, this._y = e.y * n, this._z = e.z * n, this._w = Math.cos(i), this._onChangeCallback(), this;
      }
      setFromRotationMatrix(e) {
        const t = e.elements, i = t[0], n = t[4], s = t[8], a = t[1], o = t[5], l = t[9], c = t[2], u = t[6], h = t[10], d = i + o + h;
        if (d > 0) {
          const p = 0.5 / Math.sqrt(d + 1);
          this._w = 0.25 / p, this._x = (u - l) * p, this._y = (s - c) * p, this._z = (a - n) * p;
        } else if (i > o && i > h) {
          const p = 2 * Math.sqrt(1 + i - o - h);
          this._w = (u - l) / p, this._x = 0.25 * p, this._y = (n + a) / p, this._z = (s + c) / p;
        } else if (o > h) {
          const p = 2 * Math.sqrt(1 + o - i - h);
          this._w = (s - c) / p, this._x = (n + a) / p, this._y = 0.25 * p, this._z = (l + u) / p;
        } else {
          const p = 2 * Math.sqrt(1 + h - i - o);
          this._w = (a - n) / p, this._x = (s + c) / p, this._y = (l + u) / p, this._z = 0.25 * p;
        }
        return this._onChangeCallback(), this;
      }
      setFromUnitVectors(e, t) {
        let i = e.dot(t) + 1;
        return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize();
      }
      angleTo(e) {
        return 2 * Math.acos(Math.abs(Ge(this.dot(e), -1, 1)));
      }
      rotateTowards(e, t) {
        const i = this.angleTo(e);
        if (i === 0) return this;
        const n = Math.min(1, t / i);
        return this.slerp(e, n), this;
      }
      identity() {
        return this.set(0, 0, 0, 1);
      }
      invert() {
        return this.conjugate();
      }
      conjugate() {
        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
      }
      dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
      }
      lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
      }
      length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
      }
      normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
      }
      multiply(e) {
        return this.multiplyQuaternions(this, e);
      }
      premultiply(e) {
        return this.multiplyQuaternions(e, this);
      }
      multiplyQuaternions(e, t) {
        const i = e._x, n = e._y, s = e._z, a = e._w, o = t._x, l = t._y, c = t._z, u = t._w;
        return this._x = i * u + a * o + n * c - s * l, this._y = n * u + a * l + s * o - i * c, this._z = s * u + a * c + i * l - n * o, this._w = a * u - i * o - n * l - s * c, this._onChangeCallback(), this;
      }
      slerp(e, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(e);
        const i = this._x, n = this._y, s = this._z, a = this._w;
        let o = a * e._w + i * e._x + n * e._y + s * e._z;
        if (o < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e), o >= 1) return this._w = a, this._x = i, this._y = n, this._z = s, this;
        const l = 1 - o * o;
        if (l <= Number.EPSILON) {
          const p = 1 - t;
          return this._w = p * a + t * this._w, this._x = p * i + t * this._x, this._y = p * n + t * this._y, this._z = p * s + t * this._z, this.normalize(), this;
        }
        const c = Math.sqrt(l), u = Math.atan2(c, o), h = Math.sin((1 - t) * u) / c, d = Math.sin(t * u) / c;
        return this._w = a * h + this._w * d, this._x = i * h + this._x * d, this._y = n * h + this._y * d, this._z = s * h + this._z * d, this._onChangeCallback(), this;
      }
      slerpQuaternions(e, t, i) {
        return this.copy(e).slerp(t, i);
      }
      random() {
        const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), i = Math.random(), n = Math.sqrt(1 - i), s = Math.sqrt(i);
        return this.set(n * Math.sin(e), n * Math.cos(e), s * Math.sin(t), s * Math.cos(t));
      }
      equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
      }
      fromArray(e, t = 0) {
        return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
      }
      toArray(e = [], t = 0) {
        return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
      }
      fromBufferAttribute(e, t) {
        return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
      }
      toJSON() {
        return this.toArray();
      }
      _onChange(e) {
        return this._onChangeCallback = e, this;
      }
      _onChangeCallback() {
      }
      *[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._w;
      }
    }
    class D {
      constructor(e = 0, t = 0, i = 0) {
        D.prototype.isVector3 = true, this.x = e, this.y = t, this.z = i;
      }
      set(e, t, i) {
        return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this;
      }
      setScalar(e) {
        return this.x = e, this.y = e, this.z = e, this;
      }
      setX(e) {
        return this.x = e, this;
      }
      setY(e) {
        return this.y = e, this;
      }
      setZ(e) {
        return this.z = e, this;
      }
      setComponent(e, t) {
        switch (e) {
          case 0:
            this.x = t;
            break;
          case 1:
            this.y = t;
            break;
          case 2:
            this.z = t;
            break;
          default:
            throw new Error("index is out of range: " + e);
        }
        return this;
      }
      getComponent(e) {
        switch (e) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + e);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z);
      }
      copy(e) {
        return this.x = e.x, this.y = e.y, this.z = e.z, this;
      }
      add(e) {
        return this.x += e.x, this.y += e.y, this.z += e.z, this;
      }
      addScalar(e) {
        return this.x += e, this.y += e, this.z += e, this;
      }
      addVectors(e, t) {
        return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
      }
      addScaledVector(e, t) {
        return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
      }
      sub(e) {
        return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
      }
      subScalar(e) {
        return this.x -= e, this.y -= e, this.z -= e, this;
      }
      subVectors(e, t) {
        return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
      }
      multiply(e) {
        return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
      }
      multiplyScalar(e) {
        return this.x *= e, this.y *= e, this.z *= e, this;
      }
      multiplyVectors(e, t) {
        return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
      }
      applyEuler(e) {
        return this.applyQuaternion(ud.setFromEuler(e));
      }
      applyAxisAngle(e, t) {
        return this.applyQuaternion(ud.setFromAxisAngle(e, t));
      }
      applyMatrix3(e) {
        const t = this.x, i = this.y, n = this.z, s = e.elements;
        return this.x = s[0] * t + s[3] * i + s[6] * n, this.y = s[1] * t + s[4] * i + s[7] * n, this.z = s[2] * t + s[5] * i + s[8] * n, this;
      }
      applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize();
      }
      applyMatrix4(e) {
        const t = this.x, i = this.y, n = this.z, s = e.elements, a = 1 / (s[3] * t + s[7] * i + s[11] * n + s[15]);
        return this.x = (s[0] * t + s[4] * i + s[8] * n + s[12]) * a, this.y = (s[1] * t + s[5] * i + s[9] * n + s[13]) * a, this.z = (s[2] * t + s[6] * i + s[10] * n + s[14]) * a, this;
      }
      applyQuaternion(e) {
        const t = this.x, i = this.y, n = this.z, s = e.x, a = e.y, o = e.z, l = e.w, c = 2 * (a * n - o * i), u = 2 * (o * t - s * n), h = 2 * (s * i - a * t);
        return this.x = t + l * c + a * h - o * u, this.y = i + l * u + o * c - s * h, this.z = n + l * h + s * u - a * c, this;
      }
      project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
      }
      unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
      }
      transformDirection(e) {
        const t = this.x, i = this.y, n = this.z, s = e.elements;
        return this.x = s[0] * t + s[4] * i + s[8] * n, this.y = s[1] * t + s[5] * i + s[9] * n, this.z = s[2] * t + s[6] * i + s[10] * n, this.normalize();
      }
      divide(e) {
        return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
      }
      divideScalar(e) {
        return this.multiplyScalar(1 / e);
      }
      min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
      }
      max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
      }
      clamp(e, t) {
        return this.x = Ge(this.x, e.x, t.x), this.y = Ge(this.y, e.y, t.y), this.z = Ge(this.z, e.z, t.z), this;
      }
      clampScalar(e, t) {
        return this.x = Ge(this.x, e, t), this.y = Ge(this.y, e, t), this.z = Ge(this.z, e, t), this;
      }
      clampLength(e, t) {
        const i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Ge(i, e, t));
      }
      floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
      }
      ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
      }
      round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
      }
      roundToZero() {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
      }
      negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
      }
      dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(e) {
        return this.normalize().multiplyScalar(e);
      }
      lerp(e, t) {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
      }
      lerpVectors(e, t, i) {
        return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this;
      }
      cross(e) {
        return this.crossVectors(this, e);
      }
      crossVectors(e, t) {
        const i = e.x, n = e.y, s = e.z, a = t.x, o = t.y, l = t.z;
        return this.x = n * l - s * o, this.y = s * a - i * l, this.z = i * o - n * a, this;
      }
      projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0) return this.set(0, 0, 0);
        const i = e.dot(this) / t;
        return this.copy(e).multiplyScalar(i);
      }
      projectOnPlane(e) {
        return xc.copy(this).projectOnVector(e), this.sub(xc);
      }
      reflect(e) {
        return this.sub(xc.copy(e).multiplyScalar(2 * this.dot(e)));
      }
      angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0) return Math.PI / 2;
        const i = this.dot(e) / t;
        return Math.acos(Ge(i, -1, 1));
      }
      distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e));
      }
      distanceToSquared(e) {
        const t = this.x - e.x, i = this.y - e.y, n = this.z - e.z;
        return t * t + i * i + n * n;
      }
      manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
      }
      setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
      }
      setFromSphericalCoords(e, t, i) {
        const n = Math.sin(t) * e;
        return this.x = n * Math.sin(i), this.y = Math.cos(t) * e, this.z = n * Math.cos(i), this;
      }
      setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
      }
      setFromCylindricalCoords(e, t, i) {
        return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this;
      }
      setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12], this.y = t[13], this.z = t[14], this;
      }
      setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length(), i = this.setFromMatrixColumn(e, 1).length(), n = this.setFromMatrixColumn(e, 2).length();
        return this.x = t, this.y = i, this.z = n, this;
      }
      setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4);
      }
      setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3);
      }
      setFromEuler(e) {
        return this.x = e._x, this.y = e._y, this.z = e._z, this;
      }
      setFromColor(e) {
        return this.x = e.r, this.y = e.g, this.z = e.b, this;
      }
      equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z;
      }
      fromArray(e, t = 0) {
        return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
      }
      toArray(e = [], t = 0) {
        return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
      }
      fromBufferAttribute(e, t) {
        return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
      }
      random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
      }
      randomDirection() {
        const e = Math.random() * Math.PI * 2, t = Math.random() * 2 - 1, i = Math.sqrt(1 - t * t);
        return this.x = i * Math.cos(e), this.y = t, this.z = i * Math.sin(e), this;
      }
      *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z;
      }
    }
    const xc = new D(), ud = new Nr();
    class fr {
      constructor(e = new D(1 / 0, 1 / 0, 1 / 0), t = new D(-1 / 0, -1 / 0, -1 / 0)) {
        this.isBox3 = true, this.min = e, this.max = t;
      }
      set(e, t) {
        return this.min.copy(e), this.max.copy(t), this;
      }
      setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t += 3) this.expandByPoint(Hi.fromArray(e, t));
        return this;
      }
      setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, i = e.count; t < i; t++) this.expandByPoint(Hi.fromBufferAttribute(e, t));
        return this;
      }
      setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
        return this;
      }
      setFromCenterAndSize(e, t) {
        const i = Hi.copy(t).multiplyScalar(0.5);
        return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
      }
      setFromObject(e, t = false) {
        return this.makeEmpty(), this.expandByObject(e, t);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this;
      }
      makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
      }
      isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
      }
      getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
      getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
      }
      expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this;
      }
      expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this;
      }
      expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this;
      }
      expandByObject(e, t = false) {
        e.updateWorldMatrix(false, false);
        const i = e.geometry;
        if (i !== void 0) {
          const s = i.getAttribute("position");
          if (t === true && s !== void 0 && e.isInstancedMesh !== true) for (let a = 0, o = s.count; a < o; a++) e.isMesh === true ? e.getVertexPosition(a, Hi) : Hi.fromBufferAttribute(s, a), Hi.applyMatrix4(e.matrixWorld), this.expandByPoint(Hi);
          else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), mo.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), mo.copy(i.boundingBox)), mo.applyMatrix4(e.matrixWorld), this.union(mo);
        }
        const n = e.children;
        for (let s = 0, a = n.length; s < a; s++) this.expandByObject(n[s], t);
        return this;
      }
      containsPoint(e) {
        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
      }
      containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
      }
      getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z));
      }
      intersectsBox(e) {
        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
      }
      intersectsSphere(e) {
        return this.clampPoint(e.center, Hi), Hi.distanceToSquared(e.center) <= e.radius * e.radius;
      }
      intersectsPlane(e) {
        let t, i;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant;
      }
      intersectsTriangle(e) {
        if (this.isEmpty()) return false;
        this.getCenter(da), go.subVectors(this.max, da), ns.subVectors(e.a, da), ss.subVectors(e.b, da), as.subVectors(e.c, da), Fr.subVectors(ss, ns), Br.subVectors(as, ss), on.subVectors(ns, as);
        let t = [
          0,
          -Fr.z,
          Fr.y,
          0,
          -Br.z,
          Br.y,
          0,
          -on.z,
          on.y,
          Fr.z,
          0,
          -Fr.x,
          Br.z,
          0,
          -Br.x,
          on.z,
          0,
          -on.x,
          -Fr.y,
          Fr.x,
          0,
          -Br.y,
          Br.x,
          0,
          -on.y,
          on.x,
          0
        ];
        return !yc(t, ns, ss, as, go) || (t = [
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ], !yc(t, ns, ss, as, go)) ? false : (_o.crossVectors(Fr, Br), t = [
          _o.x,
          _o.y,
          _o.z
        ], yc(t, ns, ss, as, go));
      }
      clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max);
      }
      distanceToPoint(e) {
        return this.clampPoint(e, Hi).distanceTo(e);
      }
      getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Hi).length() * 0.5), e;
      }
      intersect(e) {
        return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
      }
      union(e) {
        return this.min.min(e.min), this.max.max(e.max), this;
      }
      applyMatrix4(e) {
        return this.isEmpty() ? this : (mr[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), mr[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), mr[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), mr[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), mr[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), mr[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), mr[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), mr[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(mr), this);
      }
      translate(e) {
        return this.min.add(e), this.max.add(e), this;
      }
      equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max);
      }
    }
    const mr = [
      new D(),
      new D(),
      new D(),
      new D(),
      new D(),
      new D(),
      new D(),
      new D()
    ], Hi = new D(), mo = new fr(), ns = new D(), ss = new D(), as = new D(), Fr = new D(), Br = new D(), on = new D(), da = new D(), go = new D(), _o = new D(), ln = new D();
    function yc(r, e, t, i, n) {
      for (let s = 0, a = r.length - 3; s <= a; s += 3) {
        ln.fromArray(r, s);
        const o = n.x * Math.abs(ln.x) + n.y * Math.abs(ln.y) + n.z * Math.abs(ln.z), l = e.dot(ln), c = t.dot(ln), u = i.dot(ln);
        if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > o) return false;
      }
      return true;
    }
    const h_ = new fr(), pa = new D(), Mc = new D();
    class Ki {
      constructor(e = new D(), t = -1) {
        this.isSphere = true, this.center = e, this.radius = t;
      }
      set(e, t) {
        return this.center.copy(e), this.radius = t, this;
      }
      setFromPoints(e, t) {
        const i = this.center;
        t !== void 0 ? i.copy(t) : h_.setFromPoints(e).getCenter(i);
        let n = 0;
        for (let s = 0, a = e.length; s < a; s++) n = Math.max(n, i.distanceToSquared(e[s]));
        return this.radius = Math.sqrt(n), this;
      }
      copy(e) {
        return this.center.copy(e.center), this.radius = e.radius, this;
      }
      isEmpty() {
        return this.radius < 0;
      }
      makeEmpty() {
        return this.center.set(0, 0, 0), this.radius = -1, this;
      }
      containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius;
      }
      distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius;
      }
      intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t;
      }
      intersectsBox(e) {
        return e.intersectsSphere(this);
      }
      intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
      }
      clampPoint(e, t) {
        const i = this.center.distanceToSquared(e);
        return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
      }
      getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
      }
      applyMatrix4(e) {
        return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
      }
      translate(e) {
        return this.center.add(e), this;
      }
      expandByPoint(e) {
        if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
        pa.subVectors(e, this.center);
        const t = pa.lengthSq();
        if (t > this.radius * this.radius) {
          const i = Math.sqrt(t), n = (i - this.radius) * 0.5;
          this.center.addScaledVector(pa, n / i), this.radius += n;
        }
        return this;
      }
      union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === true ? this.radius = Math.max(this.radius, e.radius) : (Mc.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(pa.copy(e.center).add(Mc)), this.expandByPoint(pa.copy(e.center).sub(Mc))), this);
      }
      equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    const gr = new D(), bc = new D(), vo = new D(), zr = new D(), Sc = new D(), xo = new D(), Ec = new D();
    class fa {
      constructor(e = new D(), t = new D(0, 0, -1)) {
        this.origin = e, this.direction = t;
      }
      set(e, t) {
        return this.origin.copy(e), this.direction.copy(t), this;
      }
      copy(e) {
        return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
      }
      at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e);
      }
      lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(), this;
      }
      recast(e) {
        return this.origin.copy(this.at(e, gr)), this;
      }
      closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const i = t.dot(this.direction);
        return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i);
      }
      distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e));
      }
      distanceSqToPoint(e) {
        const t = gr.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (gr.copy(this.origin).addScaledVector(this.direction, t), gr.distanceToSquared(e));
      }
      distanceSqToSegment(e, t, i, n) {
        bc.copy(e).add(t).multiplyScalar(0.5), vo.copy(t).sub(e).normalize(), zr.copy(this.origin).sub(bc);
        const s = e.distanceTo(t) * 0.5, a = -this.direction.dot(vo), o = zr.dot(this.direction), l = -zr.dot(vo), c = zr.lengthSq(), u = Math.abs(1 - a * a);
        let h, d, p, f;
        if (u > 0) if (h = a * l - o, d = a * o - l, f = s * u, h >= 0) if (d >= -f) if (d <= f) {
          const _ = 1 / u;
          h *= _, d *= _, p = h * (h + a * d + 2 * o) + d * (a * h + d + 2 * l) + c;
        } else d = s, h = Math.max(0, -(a * d + o)), p = -h * h + d * (d + 2 * l) + c;
        else d = -s, h = Math.max(0, -(a * d + o)), p = -h * h + d * (d + 2 * l) + c;
        else d <= -f ? (h = Math.max(0, -(-a * s + o)), d = h > 0 ? -s : Math.min(Math.max(-s, -l), s), p = -h * h + d * (d + 2 * l) + c) : d <= f ? (h = 0, d = Math.min(Math.max(-s, -l), s), p = d * (d + 2 * l) + c) : (h = Math.max(0, -(a * s + o)), d = h > 0 ? s : Math.min(Math.max(-s, -l), s), p = -h * h + d * (d + 2 * l) + c);
        else d = a > 0 ? -s : s, h = Math.max(0, -(a * d + o)), p = -h * h + d * (d + 2 * l) + c;
        return i && i.copy(this.origin).addScaledVector(this.direction, h), n && n.copy(bc).addScaledVector(vo, d), p;
      }
      intersectSphere(e, t) {
        gr.subVectors(e.center, this.origin);
        const i = gr.dot(this.direction), n = gr.dot(gr) - i * i, s = e.radius * e.radius;
        if (n > s) return null;
        const a = Math.sqrt(s - n), o = i - a, l = i + a;
        return l < 0 ? null : o < 0 ? this.at(l, t) : this.at(o, t);
      }
      intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
      }
      distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const i = -(this.origin.dot(e.normal) + e.constant) / t;
        return i >= 0 ? i : null;
      }
      intersectPlane(e, t) {
        const i = this.distanceToPlane(e);
        return i === null ? null : this.at(i, t);
      }
      intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0;
      }
      intersectBox(e, t) {
        let i, n, s, a, o, l;
        const c = 1 / this.direction.x, u = 1 / this.direction.y, h = 1 / this.direction.z, d = this.origin;
        return c >= 0 ? (i = (e.min.x - d.x) * c, n = (e.max.x - d.x) * c) : (i = (e.max.x - d.x) * c, n = (e.min.x - d.x) * c), u >= 0 ? (s = (e.min.y - d.y) * u, a = (e.max.y - d.y) * u) : (s = (e.max.y - d.y) * u, a = (e.min.y - d.y) * u), i > a || s > n || ((s > i || isNaN(i)) && (i = s), (a < n || isNaN(n)) && (n = a), h >= 0 ? (o = (e.min.z - d.z) * h, l = (e.max.z - d.z) * h) : (o = (e.max.z - d.z) * h, l = (e.min.z - d.z) * h), i > l || o > n) || ((o > i || i !== i) && (i = o), (l < n || n !== n) && (n = l), n < 0) ? null : this.at(i >= 0 ? i : n, t);
      }
      intersectsBox(e) {
        return this.intersectBox(e, gr) !== null;
      }
      intersectTriangle(e, t, i, n, s) {
        Sc.subVectors(t, e), xo.subVectors(i, e), Ec.crossVectors(Sc, xo);
        let a = this.direction.dot(Ec), o;
        if (a > 0) {
          if (n) return null;
          o = 1;
        } else if (a < 0) o = -1, a = -a;
        else return null;
        zr.subVectors(this.origin, e);
        const l = o * this.direction.dot(xo.crossVectors(zr, xo));
        if (l < 0) return null;
        const c = o * this.direction.dot(Sc.cross(zr));
        if (c < 0 || l + c > a) return null;
        const u = -o * zr.dot(Ec);
        return u < 0 ? null : this.at(u / a, s);
      }
      applyMatrix4(e) {
        return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
      }
      equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction);
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    class Fe {
      constructor(e, t, i, n, s, a, o, l, c, u, h, d, p, f, _, g) {
        Fe.prototype.isMatrix4 = true, this.elements = [
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ], e !== void 0 && this.set(e, t, i, n, s, a, o, l, c, u, h, d, p, f, _, g);
      }
      set(e, t, i, n, s, a, o, l, c, u, h, d, p, f, _, g) {
        const m = this.elements;
        return m[0] = e, m[4] = t, m[8] = i, m[12] = n, m[1] = s, m[5] = a, m[9] = o, m[13] = l, m[2] = c, m[6] = u, m[10] = h, m[14] = d, m[3] = p, m[7] = f, m[11] = _, m[15] = g, this;
      }
      identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      clone() {
        return new Fe().fromArray(this.elements);
      }
      copy(e) {
        const t = this.elements, i = e.elements;
        return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this;
      }
      copyPosition(e) {
        const t = this.elements, i = e.elements;
        return t[12] = i[12], t[13] = i[13], t[14] = i[14], this;
      }
      setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this;
      }
      extractBasis(e, t, i) {
        return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this;
      }
      makeBasis(e, t, i) {
        return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this;
      }
      extractRotation(e) {
        const t = this.elements, i = e.elements, n = 1 / os.setFromMatrixColumn(e, 0).length(), s = 1 / os.setFromMatrixColumn(e, 1).length(), a = 1 / os.setFromMatrixColumn(e, 2).length();
        return t[0] = i[0] * n, t[1] = i[1] * n, t[2] = i[2] * n, t[3] = 0, t[4] = i[4] * s, t[5] = i[5] * s, t[6] = i[6] * s, t[7] = 0, t[8] = i[8] * a, t[9] = i[9] * a, t[10] = i[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
      }
      makeRotationFromEuler(e) {
        const t = this.elements, i = e.x, n = e.y, s = e.z, a = Math.cos(i), o = Math.sin(i), l = Math.cos(n), c = Math.sin(n), u = Math.cos(s), h = Math.sin(s);
        if (e.order === "XYZ") {
          const d = a * u, p = a * h, f = o * u, _ = o * h;
          t[0] = l * u, t[4] = -l * h, t[8] = c, t[1] = p + f * c, t[5] = d - _ * c, t[9] = -o * l, t[2] = _ - d * c, t[6] = f + p * c, t[10] = a * l;
        } else if (e.order === "YXZ") {
          const d = l * u, p = l * h, f = c * u, _ = c * h;
          t[0] = d + _ * o, t[4] = f * o - p, t[8] = a * c, t[1] = a * h, t[5] = a * u, t[9] = -o, t[2] = p * o - f, t[6] = _ + d * o, t[10] = a * l;
        } else if (e.order === "ZXY") {
          const d = l * u, p = l * h, f = c * u, _ = c * h;
          t[0] = d - _ * o, t[4] = -a * h, t[8] = f + p * o, t[1] = p + f * o, t[5] = a * u, t[9] = _ - d * o, t[2] = -a * c, t[6] = o, t[10] = a * l;
        } else if (e.order === "ZYX") {
          const d = a * u, p = a * h, f = o * u, _ = o * h;
          t[0] = l * u, t[4] = f * c - p, t[8] = d * c + _, t[1] = l * h, t[5] = _ * c + d, t[9] = p * c - f, t[2] = -c, t[6] = o * l, t[10] = a * l;
        } else if (e.order === "YZX") {
          const d = a * l, p = a * c, f = o * l, _ = o * c;
          t[0] = l * u, t[4] = _ - d * h, t[8] = f * h + p, t[1] = h, t[5] = a * u, t[9] = -o * u, t[2] = -c * u, t[6] = p * h + f, t[10] = d - _ * h;
        } else if (e.order === "XZY") {
          const d = a * l, p = a * c, f = o * l, _ = o * c;
          t[0] = l * u, t[4] = -h, t[8] = c * u, t[1] = d * h + _, t[5] = a * u, t[9] = p * h - f, t[2] = f * h - p, t[6] = o * u, t[10] = _ * h + d;
        }
        return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
      }
      makeRotationFromQuaternion(e) {
        return this.compose(d_, e, p_);
      }
      lookAt(e, t, i) {
        const n = this.elements;
        return vi.subVectors(e, t), vi.lengthSq() === 0 && (vi.z = 1), vi.normalize(), kr.crossVectors(i, vi), kr.lengthSq() === 0 && (Math.abs(i.z) === 1 ? vi.x += 1e-4 : vi.z += 1e-4, vi.normalize(), kr.crossVectors(i, vi)), kr.normalize(), yo.crossVectors(vi, kr), n[0] = kr.x, n[4] = yo.x, n[8] = vi.x, n[1] = kr.y, n[5] = yo.y, n[9] = vi.y, n[2] = kr.z, n[6] = yo.z, n[10] = vi.z, this;
      }
      multiply(e) {
        return this.multiplyMatrices(this, e);
      }
      premultiply(e) {
        return this.multiplyMatrices(e, this);
      }
      multiplyMatrices(e, t) {
        const i = e.elements, n = t.elements, s = this.elements, a = i[0], o = i[4], l = i[8], c = i[12], u = i[1], h = i[5], d = i[9], p = i[13], f = i[2], _ = i[6], g = i[10], m = i[14], y = i[3], x = i[7], v = i[11], A = i[15], T = n[0], w = n[4], R = n[8], E = n[12], b = n[1], L = n[5], B = n[9], F = n[13], V = n[2], X = n[6], k = n[10], K = n[14], G = n[3], ie = n[7], ue = n[11], we = n[15];
        return s[0] = a * T + o * b + l * V + c * G, s[4] = a * w + o * L + l * X + c * ie, s[8] = a * R + o * B + l * k + c * ue, s[12] = a * E + o * F + l * K + c * we, s[1] = u * T + h * b + d * V + p * G, s[5] = u * w + h * L + d * X + p * ie, s[9] = u * R + h * B + d * k + p * ue, s[13] = u * E + h * F + d * K + p * we, s[2] = f * T + _ * b + g * V + m * G, s[6] = f * w + _ * L + g * X + m * ie, s[10] = f * R + _ * B + g * k + m * ue, s[14] = f * E + _ * F + g * K + m * we, s[3] = y * T + x * b + v * V + A * G, s[7] = y * w + x * L + v * X + A * ie, s[11] = y * R + x * B + v * k + A * ue, s[15] = y * E + x * F + v * K + A * we, this;
      }
      multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
      }
      determinant() {
        const e = this.elements, t = e[0], i = e[4], n = e[8], s = e[12], a = e[1], o = e[5], l = e[9], c = e[13], u = e[2], h = e[6], d = e[10], p = e[14], f = e[3], _ = e[7], g = e[11], m = e[15];
        return f * (+s * l * h - n * c * h - s * o * d + i * c * d + n * o * p - i * l * p) + _ * (+t * l * p - t * c * d + s * a * d - n * a * p + n * c * u - s * l * u) + g * (+t * c * h - t * o * p - s * a * h + i * a * p + s * o * u - i * c * u) + m * (-n * o * u - t * l * h + t * o * d + n * a * h - i * a * d + i * l * u);
      }
      transpose() {
        const e = this.elements;
        let t;
        return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
      }
      setPosition(e, t, i) {
        const n = this.elements;
        return e.isVector3 ? (n[12] = e.x, n[13] = e.y, n[14] = e.z) : (n[12] = e, n[13] = t, n[14] = i), this;
      }
      invert() {
        const e = this.elements, t = e[0], i = e[1], n = e[2], s = e[3], a = e[4], o = e[5], l = e[6], c = e[7], u = e[8], h = e[9], d = e[10], p = e[11], f = e[12], _ = e[13], g = e[14], m = e[15], y = h * g * c - _ * d * c + _ * l * p - o * g * p - h * l * m + o * d * m, x = f * d * c - u * g * c - f * l * p + a * g * p + u * l * m - a * d * m, v = u * _ * c - f * h * c + f * o * p - a * _ * p - u * o * m + a * h * m, A = f * h * l - u * _ * l - f * o * d + a * _ * d + u * o * g - a * h * g, T = t * y + i * x + n * v + s * A;
        if (T === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const w = 1 / T;
        return e[0] = y * w, e[1] = (_ * d * s - h * g * s - _ * n * p + i * g * p + h * n * m - i * d * m) * w, e[2] = (o * g * s - _ * l * s + _ * n * c - i * g * c - o * n * m + i * l * m) * w, e[3] = (h * l * s - o * d * s - h * n * c + i * d * c + o * n * p - i * l * p) * w, e[4] = x * w, e[5] = (u * g * s - f * d * s + f * n * p - t * g * p - u * n * m + t * d * m) * w, e[6] = (f * l * s - a * g * s - f * n * c + t * g * c + a * n * m - t * l * m) * w, e[7] = (a * d * s - u * l * s + u * n * c - t * d * c - a * n * p + t * l * p) * w, e[8] = v * w, e[9] = (f * h * s - u * _ * s - f * i * p + t * _ * p + u * i * m - t * h * m) * w, e[10] = (a * _ * s - f * o * s + f * i * c - t * _ * c - a * i * m + t * o * m) * w, e[11] = (u * o * s - a * h * s - u * i * c + t * h * c + a * i * p - t * o * p) * w, e[12] = A * w, e[13] = (u * _ * n - f * h * n + f * i * d - t * _ * d - u * i * g + t * h * g) * w, e[14] = (f * o * n - a * _ * n - f * i * l + t * _ * l + a * i * g - t * o * g) * w, e[15] = (a * h * n - u * o * n + u * i * l - t * h * l - a * i * d + t * o * d) * w, this;
      }
      scale(e) {
        const t = this.elements, i = e.x, n = e.y, s = e.z;
        return t[0] *= i, t[4] *= n, t[8] *= s, t[1] *= i, t[5] *= n, t[9] *= s, t[2] *= i, t[6] *= n, t[10] *= s, t[3] *= i, t[7] *= n, t[11] *= s, this;
      }
      getMaxScaleOnAxis() {
        const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, i, n));
      }
      makeTranslation(e, t, i) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this;
      }
      makeRotationX(e) {
        const t = Math.cos(e), i = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
      }
      makeRotationY(e) {
        const t = Math.cos(e), i = Math.sin(e);
        return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
      }
      makeRotationZ(e) {
        const t = Math.cos(e), i = Math.sin(e);
        return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      makeRotationAxis(e, t) {
        const i = Math.cos(t), n = Math.sin(t), s = 1 - i, a = e.x, o = e.y, l = e.z, c = s * a, u = s * o;
        return this.set(c * a + i, c * o - n * l, c * l + n * o, 0, c * o + n * l, u * o + i, u * l - n * a, 0, c * l - n * o, u * l + n * a, s * l * l + i, 0, 0, 0, 0, 1), this;
      }
      makeScale(e, t, i) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
      }
      makeShear(e, t, i, n, s, a) {
        return this.set(1, i, s, 0, e, 1, a, 0, t, n, 1, 0, 0, 0, 0, 1), this;
      }
      compose(e, t, i) {
        const n = this.elements, s = t._x, a = t._y, o = t._z, l = t._w, c = s + s, u = a + a, h = o + o, d = s * c, p = s * u, f = s * h, _ = a * u, g = a * h, m = o * h, y = l * c, x = l * u, v = l * h, A = i.x, T = i.y, w = i.z;
        return n[0] = (1 - (_ + m)) * A, n[1] = (p + v) * A, n[2] = (f - x) * A, n[3] = 0, n[4] = (p - v) * T, n[5] = (1 - (d + m)) * T, n[6] = (g + y) * T, n[7] = 0, n[8] = (f + x) * w, n[9] = (g - y) * w, n[10] = (1 - (d + _)) * w, n[11] = 0, n[12] = e.x, n[13] = e.y, n[14] = e.z, n[15] = 1, this;
      }
      decompose(e, t, i) {
        const n = this.elements;
        let s = os.set(n[0], n[1], n[2]).length();
        const a = os.set(n[4], n[5], n[6]).length(), o = os.set(n[8], n[9], n[10]).length();
        this.determinant() < 0 && (s = -s), e.x = n[12], e.y = n[13], e.z = n[14], Vi.copy(this);
        const l = 1 / s, c = 1 / a, u = 1 / o;
        return Vi.elements[0] *= l, Vi.elements[1] *= l, Vi.elements[2] *= l, Vi.elements[4] *= c, Vi.elements[5] *= c, Vi.elements[6] *= c, Vi.elements[8] *= u, Vi.elements[9] *= u, Vi.elements[10] *= u, t.setFromRotationMatrix(Vi), i.x = s, i.y = a, i.z = o, this;
      }
      makePerspective(e, t, i, n, s, a, o = dr) {
        const l = this.elements, c = 2 * s / (t - e), u = 2 * s / (i - n), h = (t + e) / (t - e), d = (i + n) / (i - n);
        let p, f;
        if (o === dr) p = -(a + s) / (a - s), f = -2 * a * s / (a - s);
        else if (o === fo) p = -a / (a - s), f = -a * s / (a - s);
        else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o);
        return l[0] = c, l[4] = 0, l[8] = h, l[12] = 0, l[1] = 0, l[5] = u, l[9] = d, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = p, l[14] = f, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this;
      }
      makeOrthographic(e, t, i, n, s, a, o = dr) {
        const l = this.elements, c = 1 / (t - e), u = 1 / (i - n), h = 1 / (a - s), d = (t + e) * c, p = (i + n) * u;
        let f, _;
        if (o === dr) f = (a + s) * h, _ = -2 * h;
        else if (o === fo) f = s * h, _ = -1 * h;
        else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o);
        return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -d, l[1] = 0, l[5] = 2 * u, l[9] = 0, l[13] = -p, l[2] = 0, l[6] = 0, l[10] = _, l[14] = -f, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this;
      }
      equals(e) {
        const t = this.elements, i = e.elements;
        for (let n = 0; n < 16; n++) if (t[n] !== i[n]) return false;
        return true;
      }
      fromArray(e, t = 0) {
        for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
        return this;
      }
      toArray(e = [], t = 0) {
        const i = this.elements;
        return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e;
      }
    }
    const os = new D(), Vi = new Fe(), d_ = new D(0, 0, 0), p_ = new D(1, 1, 1), kr = new D(), yo = new D(), vi = new D(), hd = new Fe(), dd = new Nr();
    class Zi {
      constructor(e = 0, t = 0, i = 0, n = Zi.DEFAULT_ORDER) {
        this.isEuler = true, this._x = e, this._y = t, this._z = i, this._order = n;
      }
      get x() {
        return this._x;
      }
      set x(e) {
        this._x = e, this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(e) {
        this._y = e, this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(e) {
        this._z = e, this._onChangeCallback();
      }
      get order() {
        return this._order;
      }
      set order(e) {
        this._order = e, this._onChangeCallback();
      }
      set(e, t, i, n = this._order) {
        return this._x = e, this._y = t, this._z = i, this._order = n, this._onChangeCallback(), this;
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      }
      copy(e) {
        return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
      }
      setFromRotationMatrix(e, t = this._order, i = true) {
        const n = e.elements, s = n[0], a = n[4], o = n[8], l = n[1], c = n[5], u = n[9], h = n[2], d = n[6], p = n[10];
        switch (t) {
          case "XYZ":
            this._y = Math.asin(Ge(o, -1, 1)), Math.abs(o) < 0.9999999 ? (this._x = Math.atan2(-u, p), this._z = Math.atan2(-a, s)) : (this._x = Math.atan2(d, c), this._z = 0);
            break;
          case "YXZ":
            this._x = Math.asin(-Ge(u, -1, 1)), Math.abs(u) < 0.9999999 ? (this._y = Math.atan2(o, p), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-h, s), this._z = 0);
            break;
          case "ZXY":
            this._x = Math.asin(Ge(d, -1, 1)), Math.abs(d) < 0.9999999 ? (this._y = Math.atan2(-h, p), this._z = Math.atan2(-a, c)) : (this._y = 0, this._z = Math.atan2(l, s));
            break;
          case "ZYX":
            this._y = Math.asin(-Ge(h, -1, 1)), Math.abs(h) < 0.9999999 ? (this._x = Math.atan2(d, p), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-a, c));
            break;
          case "YZX":
            this._z = Math.asin(Ge(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-h, s)) : (this._x = 0, this._y = Math.atan2(o, p));
            break;
          case "XZY":
            this._z = Math.asin(-Ge(a, -1, 1)), Math.abs(a) < 0.9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(o, s)) : (this._x = Math.atan2(-u, p), this._y = 0);
            break;
          default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
        }
        return this._order = t, i === true && this._onChangeCallback(), this;
      }
      setFromQuaternion(e, t, i) {
        return hd.makeRotationFromQuaternion(e), this.setFromRotationMatrix(hd, t, i);
      }
      setFromVector3(e, t = this._order) {
        return this.set(e.x, e.y, e.z, t);
      }
      reorder(e) {
        return dd.setFromEuler(this), this.setFromQuaternion(dd, e);
      }
      equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
      }
      fromArray(e) {
        return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
      }
      toArray(e = [], t = 0) {
        return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
      }
      _onChange(e) {
        return this._onChangeCallback = e, this;
      }
      _onChangeCallback() {
      }
      *[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._order;
      }
    }
    Zi.DEFAULT_ORDER = "XYZ";
    class Tc {
      constructor() {
        this.mask = 1;
      }
      set(e) {
        this.mask = (1 << e | 0) >>> 0;
      }
      enable(e) {
        this.mask |= 1 << e | 0;
      }
      enableAll() {
        this.mask = -1;
      }
      toggle(e) {
        this.mask ^= 1 << e | 0;
      }
      disable(e) {
        this.mask &= ~(1 << e | 0);
      }
      disableAll() {
        this.mask = 0;
      }
      test(e) {
        return (this.mask & e.mask) !== 0;
      }
      isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0;
      }
    }
    let f_ = 0;
    const pd = new D(), ls = new Nr(), _r = new Fe(), Mo = new D(), ma = new D(), m_ = new D(), g_ = new Nr(), fd = new D(1, 0, 0), md = new D(0, 1, 0), gd = new D(0, 0, 1), _d = {
      type: "added"
    }, __ = {
      type: "removed"
    }, cs = {
      type: "childadded",
      child: null
    }, wc = {
      type: "childremoved",
      child: null
    };
    class xt extends Qn {
      constructor() {
        super(), this.isObject3D = true, Object.defineProperty(this, "id", {
          value: f_++
        }), this.uuid = Ci(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = xt.DEFAULT_UP.clone();
        const e = new D(), t = new Zi(), i = new Nr(), n = new D(1, 1, 1);
        function s() {
          i.setFromEuler(t, false);
        }
        function a() {
          t.setFromQuaternion(i, void 0, false);
        }
        t._onChange(s), i._onChange(a), Object.defineProperties(this, {
          position: {
            configurable: true,
            enumerable: true,
            value: e
          },
          rotation: {
            configurable: true,
            enumerable: true,
            value: t
          },
          quaternion: {
            configurable: true,
            enumerable: true,
            value: i
          },
          scale: {
            configurable: true,
            enumerable: true,
            value: n
          },
          modelViewMatrix: {
            value: new Fe()
          },
          normalMatrix: {
            value: new ze()
          }
        }), this.matrix = new Fe(), this.matrixWorld = new Fe(), this.matrixAutoUpdate = xt.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = xt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = false, this.layers = new Tc(), this.visible = true, this.castShadow = false, this.receiveShadow = false, this.frustumCulled = true, this.renderOrder = 0, this.animations = [], this.userData = {};
      }
      onBeforeShadow() {
      }
      onAfterShadow() {
      }
      onBeforeRender() {
      }
      onAfterRender() {
      }
      applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
      }
      applyQuaternion(e) {
        return this.quaternion.premultiply(e), this;
      }
      setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t);
      }
      setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, true);
      }
      setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e);
      }
      setRotationFromQuaternion(e) {
        this.quaternion.copy(e);
      }
      rotateOnAxis(e, t) {
        return ls.setFromAxisAngle(e, t), this.quaternion.multiply(ls), this;
      }
      rotateOnWorldAxis(e, t) {
        return ls.setFromAxisAngle(e, t), this.quaternion.premultiply(ls), this;
      }
      rotateX(e) {
        return this.rotateOnAxis(fd, e);
      }
      rotateY(e) {
        return this.rotateOnAxis(md, e);
      }
      rotateZ(e) {
        return this.rotateOnAxis(gd, e);
      }
      translateOnAxis(e, t) {
        return pd.copy(e).applyQuaternion(this.quaternion), this.position.add(pd.multiplyScalar(t)), this;
      }
      translateX(e) {
        return this.translateOnAxis(fd, e);
      }
      translateY(e) {
        return this.translateOnAxis(md, e);
      }
      translateZ(e) {
        return this.translateOnAxis(gd, e);
      }
      localToWorld(e) {
        return this.updateWorldMatrix(true, false), e.applyMatrix4(this.matrixWorld);
      }
      worldToLocal(e) {
        return this.updateWorldMatrix(true, false), e.applyMatrix4(_r.copy(this.matrixWorld).invert());
      }
      lookAt(e, t, i) {
        e.isVector3 ? Mo.copy(e) : Mo.set(e, t, i);
        const n = this.parent;
        this.updateWorldMatrix(true, false), ma.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? _r.lookAt(ma, Mo, this.up) : _r.lookAt(Mo, ma, this.up), this.quaternion.setFromRotationMatrix(_r), n && (_r.extractRotation(n.matrixWorld), ls.setFromRotationMatrix(_r), this.quaternion.premultiply(ls.invert()));
      }
      add(e) {
        if (arguments.length > 1) {
          for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
          return this;
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(_d), cs.child = e, this.dispatchEvent(cs), cs.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
      }
      remove(e) {
        if (arguments.length > 1) {
          for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
          return this;
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(__), wc.child = e, this.dispatchEvent(wc), wc.child = null), this;
      }
      removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this), this;
      }
      clear() {
        return this.remove(...this.children);
      }
      attach(e) {
        return this.updateWorldMatrix(true, false), _r.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(true, false), _r.multiply(e.parent.matrixWorld)), e.applyMatrix4(_r), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(false, true), e.dispatchEvent(_d), cs.child = e, this.dispatchEvent(cs), cs.child = null, this;
      }
      getObjectById(e) {
        return this.getObjectByProperty("id", e);
      }
      getObjectByName(e) {
        return this.getObjectByProperty("name", e);
      }
      getObjectByProperty(e, t) {
        if (this[e] === t) return this;
        for (let i = 0, n = this.children.length; i < n; i++) {
          const s = this.children[i].getObjectByProperty(e, t);
          if (s !== void 0) return s;
        }
      }
      getObjectsByProperty(e, t, i = []) {
        this[e] === t && i.push(this);
        const n = this.children;
        for (let s = 0, a = n.length; s < a; s++) n[s].getObjectsByProperty(e, t, i);
        return i;
      }
      getWorldPosition(e) {
        return this.updateWorldMatrix(true, false), e.setFromMatrixPosition(this.matrixWorld);
      }
      getWorldQuaternion(e) {
        return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(ma, e, m_), e;
      }
      getWorldScale(e) {
        return this.updateWorldMatrix(true, false), this.matrixWorld.decompose(ma, g_, e), e;
      }
      getWorldDirection(e) {
        this.updateWorldMatrix(true, false);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize();
      }
      raycast() {
      }
      traverse(e) {
        e(this);
        const t = this.children;
        for (let i = 0, n = t.length; i < n; i++) t[i].traverse(e);
      }
      traverseVisible(e) {
        if (this.visible === false) return;
        e(this);
        const t = this.children;
        for (let i = 0, n = t.length; i < n; i++) t[i].traverseVisible(e);
      }
      traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t), t.traverseAncestors(e));
      }
      updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = true;
      }
      updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === true && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = false, e = true);
        const t = this.children;
        for (let i = 0, n = t.length; i < n; i++) t[i].updateMatrixWorld(e);
      }
      updateWorldMatrix(e, t) {
        const i = this.parent;
        if (e === true && i !== null && i.updateWorldMatrix(true, false), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === true && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === true) {
          const n = this.children;
          for (let s = 0, a = n.length; s < a; s++) n[s].updateWorldMatrix(false, true);
        }
      }
      toJSON(e) {
        const t = e === void 0 || typeof e == "string", i = {};
        t && (e = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {},
          skeletons: {},
          animations: {},
          nodes: {}
        }, i.metadata = {
          version: 4.6,
          type: "Object",
          generator: "Object3D.toJSON"
        });
        const n = {};
        n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.castShadow === true && (n.castShadow = true), this.receiveShadow === true && (n.receiveShadow = true), this.visible === false && (n.visible = false), this.frustumCulled === false && (n.frustumCulled = false), this.renderOrder !== 0 && (n.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (n.userData = this.userData), n.layers = this.layers.mask, n.matrix = this.matrix.toArray(), n.up = this.up.toArray(), this.matrixAutoUpdate === false && (n.matrixAutoUpdate = false), this.isInstancedMesh && (n.type = "InstancedMesh", n.count = this.count, n.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (n.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (n.type = "BatchedMesh", n.perObjectFrustumCulled = this.perObjectFrustumCulled, n.sortObjects = this.sortObjects, n.drawRanges = this._drawRanges, n.reservedRanges = this._reservedRanges, n.visibility = this._visibility, n.active = this._active, n.bounds = this._bounds.map((o) => ({
          boxInitialized: o.boxInitialized,
          boxMin: o.box.min.toArray(),
          boxMax: o.box.max.toArray(),
          sphereInitialized: o.sphereInitialized,
          sphereRadius: o.sphere.radius,
          sphereCenter: o.sphere.center.toArray()
        })), n.maxInstanceCount = this._maxInstanceCount, n.maxVertexCount = this._maxVertexCount, n.maxIndexCount = this._maxIndexCount, n.geometryInitialized = this._geometryInitialized, n.geometryCount = this._geometryCount, n.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (n.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (n.boundingSphere = {
          center: n.boundingSphere.center.toArray(),
          radius: n.boundingSphere.radius
        }), this.boundingBox !== null && (n.boundingBox = {
          min: n.boundingBox.min.toArray(),
          max: n.boundingBox.max.toArray()
        }));
        function s(o, l) {
          return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid;
        }
        if (this.isScene) this.background && (this.background.isColor ? n.background = this.background.toJSON() : this.background.isTexture && (n.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true && (n.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
          n.geometry = s(e.geometries, this.geometry);
          const o = this.geometry.parameters;
          if (o !== void 0 && o.shapes !== void 0) {
            const l = o.shapes;
            if (Array.isArray(l)) for (let c = 0, u = l.length; c < u; c++) {
              const h = l[c];
              s(e.shapes, h);
            }
            else s(e.shapes, l);
          }
        }
        if (this.isSkinnedMesh && (n.bindMode = this.bindMode, n.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), n.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) {
          const o = [];
          for (let l = 0, c = this.material.length; l < c; l++) o.push(s(e.materials, this.material[l]));
          n.material = o;
        } else n.material = s(e.materials, this.material);
        if (this.children.length > 0) {
          n.children = [];
          for (let o = 0; o < this.children.length; o++) n.children.push(this.children[o].toJSON(e).object);
        }
        if (this.animations.length > 0) {
          n.animations = [];
          for (let o = 0; o < this.animations.length; o++) {
            const l = this.animations[o];
            n.animations.push(s(e.animations, l));
          }
        }
        if (t) {
          const o = a(e.geometries), l = a(e.materials), c = a(e.textures), u = a(e.images), h = a(e.shapes), d = a(e.skeletons), p = a(e.animations), f = a(e.nodes);
          o.length > 0 && (i.geometries = o), l.length > 0 && (i.materials = l), c.length > 0 && (i.textures = c), u.length > 0 && (i.images = u), h.length > 0 && (i.shapes = h), d.length > 0 && (i.skeletons = d), p.length > 0 && (i.animations = p), f.length > 0 && (i.nodes = f);
        }
        return i.object = n, i;
        function a(o) {
          const l = [];
          for (const c in o) {
            const u = o[c];
            delete u.metadata, l.push(u);
          }
          return l;
        }
      }
      clone(e) {
        return new this.constructor().copy(this, e);
      }
      copy(e, t = true) {
        if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === true) for (let i = 0; i < e.children.length; i++) {
          const n = e.children[i];
          this.add(n.clone());
        }
        return this;
      }
    }
    xt.DEFAULT_UP = new D(0, 1, 0), xt.DEFAULT_MATRIX_AUTO_UPDATE = true, xt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
    const Gi = new D(), vr = new D(), Ac = new D(), xr = new D(), us = new D(), hs = new D(), vd = new D(), Rc = new D(), Cc = new D(), Pc = new D(), Lc = new it(), Dc = new it(), Ic = new it();
    class Wi {
      constructor(e = new D(), t = new D(), i = new D()) {
        this.a = e, this.b = t, this.c = i;
      }
      static getNormal(e, t, i, n) {
        n.subVectors(i, t), Gi.subVectors(e, t), n.cross(Gi);
        const s = n.lengthSq();
        return s > 0 ? n.multiplyScalar(1 / Math.sqrt(s)) : n.set(0, 0, 0);
      }
      static getBarycoord(e, t, i, n, s) {
        Gi.subVectors(n, t), vr.subVectors(i, t), Ac.subVectors(e, t);
        const a = Gi.dot(Gi), o = Gi.dot(vr), l = Gi.dot(Ac), c = vr.dot(vr), u = vr.dot(Ac), h = a * c - o * o;
        if (h === 0) return s.set(0, 0, 0), null;
        const d = 1 / h, p = (c * l - o * u) * d, f = (a * u - o * l) * d;
        return s.set(1 - p - f, f, p);
      }
      static containsPoint(e, t, i, n) {
        return this.getBarycoord(e, t, i, n, xr) === null ? false : xr.x >= 0 && xr.y >= 0 && xr.x + xr.y <= 1;
      }
      static getInterpolation(e, t, i, n, s, a, o, l) {
        return this.getBarycoord(e, t, i, n, xr) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(s, xr.x), l.addScaledVector(a, xr.y), l.addScaledVector(o, xr.z), l);
      }
      static getInterpolatedAttribute(e, t, i, n, s, a) {
        return Lc.setScalar(0), Dc.setScalar(0), Ic.setScalar(0), Lc.fromBufferAttribute(e, t), Dc.fromBufferAttribute(e, i), Ic.fromBufferAttribute(e, n), a.setScalar(0), a.addScaledVector(Lc, s.x), a.addScaledVector(Dc, s.y), a.addScaledVector(Ic, s.z), a;
      }
      static isFrontFacing(e, t, i, n) {
        return Gi.subVectors(i, t), vr.subVectors(e, t), Gi.cross(vr).dot(n) < 0;
      }
      set(e, t, i) {
        return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
      }
      setFromPointsAndIndices(e, t, i, n) {
        return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this;
      }
      setFromAttributeAndIndices(e, t, i, n) {
        return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, n), this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
      }
      getArea() {
        return Gi.subVectors(this.c, this.b), vr.subVectors(this.a, this.b), Gi.cross(vr).length() * 0.5;
      }
      getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
      }
      getNormal(e) {
        return Wi.getNormal(this.a, this.b, this.c, e);
      }
      getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c);
      }
      getBarycoord(e, t) {
        return Wi.getBarycoord(e, this.a, this.b, this.c, t);
      }
      getInterpolation(e, t, i, n, s) {
        return Wi.getInterpolation(e, this.a, this.b, this.c, t, i, n, s);
      }
      containsPoint(e) {
        return Wi.containsPoint(e, this.a, this.b, this.c);
      }
      isFrontFacing(e) {
        return Wi.isFrontFacing(this.a, this.b, this.c, e);
      }
      intersectsBox(e) {
        return e.intersectsTriangle(this);
      }
      closestPointToPoint(e, t) {
        const i = this.a, n = this.b, s = this.c;
        let a, o;
        us.subVectors(n, i), hs.subVectors(s, i), Rc.subVectors(e, i);
        const l = us.dot(Rc), c = hs.dot(Rc);
        if (l <= 0 && c <= 0) return t.copy(i);
        Cc.subVectors(e, n);
        const u = us.dot(Cc), h = hs.dot(Cc);
        if (u >= 0 && h <= u) return t.copy(n);
        const d = l * h - u * c;
        if (d <= 0 && l >= 0 && u <= 0) return a = l / (l - u), t.copy(i).addScaledVector(us, a);
        Pc.subVectors(e, s);
        const p = us.dot(Pc), f = hs.dot(Pc);
        if (f >= 0 && p <= f) return t.copy(s);
        const _ = p * c - l * f;
        if (_ <= 0 && c >= 0 && f <= 0) return o = c / (c - f), t.copy(i).addScaledVector(hs, o);
        const g = u * f - p * h;
        if (g <= 0 && h - u >= 0 && p - f >= 0) return vd.subVectors(s, n), o = (h - u) / (h - u + (p - f)), t.copy(n).addScaledVector(vd, o);
        const m = 1 / (g + _ + d);
        return a = _ * m, o = d * m, t.copy(i).addScaledVector(us, a).addScaledVector(hs, o);
      }
      equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
      }
    }
    const xd = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    }, Hr = {
      h: 0,
      s: 0,
      l: 0
    }, bo = {
      h: 0,
      s: 0,
      l: 0
    };
    function Uc(r, e, t) {
      return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? r + (e - r) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - t) : r;
    }
    class Ae {
      constructor(e, t, i) {
        return this.isColor = true, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, i);
      }
      set(e, t, i) {
        if (t === void 0 && i === void 0) {
          const n = e;
          n && n.isColor ? this.copy(n) : typeof n == "number" ? this.setHex(n) : typeof n == "string" && this.setStyle(n);
        } else this.setRGB(e, t, i);
        return this;
      }
      setScalar(e) {
        return this.r = e, this.g = e, this.b = e, this;
      }
      setHex(e, t = Gt) {
        return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Ke.toWorkingColorSpace(this, t), this;
      }
      setRGB(e, t, i, n = Ke.workingColorSpace) {
        return this.r = e, this.g = t, this.b = i, Ke.toWorkingColorSpace(this, n), this;
      }
      setHSL(e, t, i, n = Ke.workingColorSpace) {
        if (e = gc(e, 1), t = Ge(t, 0, 1), i = Ge(i, 0, 1), t === 0) this.r = this.g = this.b = i;
        else {
          const s = i <= 0.5 ? i * (1 + t) : i + t - i * t, a = 2 * i - s;
          this.r = Uc(a, s, e + 1 / 3), this.g = Uc(a, s, e), this.b = Uc(a, s, e - 1 / 3);
        }
        return Ke.toWorkingColorSpace(this, n), this;
      }
      setStyle(e, t = Gt) {
        function i(s) {
          s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
        }
        let n;
        if (n = /^(\w+)\(([^\)]*)\)/.exec(e)) {
          let s;
          const a = n[1], o = n[2];
          switch (a) {
            case "rgb":
            case "rgba":
              if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return i(s[4]), this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
              if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return i(s[4]), this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
              break;
            case "hsl":
            case "hsla":
              if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return i(s[4]), this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
              break;
            default:
              console.warn("THREE.Color: Unknown color model " + e);
          }
        } else if (n = /^\#([A-Fa-f\d]+)$/.exec(e)) {
          const s = n[1], a = s.length;
          if (a === 3) return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
          if (a === 6) return this.setHex(parseInt(s, 16), t);
          console.warn("THREE.Color: Invalid hex color " + e);
        } else if (e && e.length > 0) return this.setColorName(e, t);
        return this;
      }
      setColorName(e, t = Gt) {
        const i = xd[e.toLowerCase()];
        return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this;
      }
      clone() {
        return new this.constructor(this.r, this.g, this.b);
      }
      copy(e) {
        return this.r = e.r, this.g = e.g, this.b = e.b, this;
      }
      copySRGBToLinear(e) {
        return this.r = pr(e.r), this.g = pr(e.g), this.b = pr(e.b), this;
      }
      copyLinearToSRGB(e) {
        return this.r = is(e.r), this.g = is(e.g), this.b = is(e.b), this;
      }
      convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this;
      }
      convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this;
      }
      getHex(e = Gt) {
        return Ke.fromWorkingColorSpace(Kt.copy(this), e), Math.round(Ge(Kt.r * 255, 0, 255)) * 65536 + Math.round(Ge(Kt.g * 255, 0, 255)) * 256 + Math.round(Ge(Kt.b * 255, 0, 255));
      }
      getHexString(e = Gt) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6);
      }
      getHSL(e, t = Ke.workingColorSpace) {
        Ke.fromWorkingColorSpace(Kt.copy(this), t);
        const i = Kt.r, n = Kt.g, s = Kt.b, a = Math.max(i, n, s), o = Math.min(i, n, s);
        let l, c;
        const u = (o + a) / 2;
        if (o === a) l = 0, c = 0;
        else {
          const h = a - o;
          switch (c = u <= 0.5 ? h / (a + o) : h / (2 - a - o), a) {
            case i:
              l = (n - s) / h + (n < s ? 6 : 0);
              break;
            case n:
              l = (s - i) / h + 2;
              break;
            case s:
              l = (i - n) / h + 4;
              break;
          }
          l /= 6;
        }
        return e.h = l, e.s = c, e.l = u, e;
      }
      getRGB(e, t = Ke.workingColorSpace) {
        return Ke.fromWorkingColorSpace(Kt.copy(this), t), e.r = Kt.r, e.g = Kt.g, e.b = Kt.b, e;
      }
      getStyle(e = Gt) {
        Ke.fromWorkingColorSpace(Kt.copy(this), e);
        const t = Kt.r, i = Kt.g, n = Kt.b;
        return e !== Gt ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(i * 255)},${Math.round(n * 255)})`;
      }
      offsetHSL(e, t, i) {
        return this.getHSL(Hr), this.setHSL(Hr.h + e, Hr.s + t, Hr.l + i);
      }
      add(e) {
        return this.r += e.r, this.g += e.g, this.b += e.b, this;
      }
      addColors(e, t) {
        return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
      }
      addScalar(e) {
        return this.r += e, this.g += e, this.b += e, this;
      }
      sub(e) {
        return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
      }
      multiply(e) {
        return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
      }
      multiplyScalar(e) {
        return this.r *= e, this.g *= e, this.b *= e, this;
      }
      lerp(e, t) {
        return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
      }
      lerpColors(e, t, i) {
        return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this;
      }
      lerpHSL(e, t) {
        this.getHSL(Hr), e.getHSL(bo);
        const i = ua(Hr.h, bo.h, t), n = ua(Hr.s, bo.s, t), s = ua(Hr.l, bo.l, t);
        return this.setHSL(i, n, s), this;
      }
      setFromVector3(e) {
        return this.r = e.x, this.g = e.y, this.b = e.z, this;
      }
      applyMatrix3(e) {
        const t = this.r, i = this.g, n = this.b, s = e.elements;
        return this.r = s[0] * t + s[3] * i + s[6] * n, this.g = s[1] * t + s[4] * i + s[7] * n, this.b = s[2] * t + s[5] * i + s[8] * n, this;
      }
      equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b;
      }
      fromArray(e, t = 0) {
        return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
      }
      toArray(e = [], t = 0) {
        return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
      }
      fromBufferAttribute(e, t) {
        return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
      }
      toJSON() {
        return this.getHex();
      }
      *[Symbol.iterator]() {
        yield this.r, yield this.g, yield this.b;
      }
    }
    const Kt = new Ae();
    Ae.NAMES = xd;
    let v_ = 0;
    class Ji extends Qn {
      constructor() {
        super(), this.isMaterial = true, Object.defineProperty(this, "id", {
          value: v_++
        }), this.uuid = Ci(), this.name = "", this.type = "Material", this.blending = ii, this.side = Ot, this.vertexColors = false, this.opacity = 1, this.transparent = false, this.alphaHash = false, this.blendSrc = Sl, this.blendDst = El, this.blendEquation = sn, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new Ae(0, 0, 0), this.blendAlpha = 0, this.depthFunc = Xn, this.depthTest = true, this.depthWrite = true, this.stencilWriteMask = 255, this.stencilFunc = ed, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = $n, this.stencilZFail = $n, this.stencilZPass = $n, this.stencilWrite = false, this.clippingPlanes = null, this.clipIntersection = false, this.clipShadows = false, this.shadowSide = null, this.colorWrite = true, this.precision = null, this.polygonOffset = false, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = false, this.alphaToCoverage = false, this.premultipliedAlpha = false, this.forceSinglePass = false, this.visible = true, this.toneMapped = true, this.userData = {}, this.version = 0, this._alphaTest = 0;
      }
      get alphaTest() {
        return this._alphaTest;
      }
      set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
      }
      onBeforeRender() {
      }
      onBeforeCompile() {
      }
      customProgramCacheKey() {
        return this.onBeforeCompile.toString();
      }
      setValues(e) {
        if (e !== void 0) for (const t in e) {
          const i = e[t];
          if (i === void 0) {
            console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
            continue;
          }
          const n = this[t];
          if (n === void 0) {
            console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
            continue;
          }
          n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[t] = i;
        }
      }
      toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
          textures: {},
          images: {}
        });
        const i = {
          metadata: {
            version: 4.6,
            type: "Material",
            generator: "Material.toJSON"
          }
        };
        i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (i.dispersion = this.dispersion), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== ii && (i.blending = this.blending), this.side !== Ot && (i.side = this.side), this.vertexColors === true && (i.vertexColors = true), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === true && (i.transparent = true), this.blendSrc !== Sl && (i.blendSrc = this.blendSrc), this.blendDst !== El && (i.blendDst = this.blendDst), this.blendEquation !== sn && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== Xn && (i.depthFunc = this.depthFunc), this.depthTest === false && (i.depthTest = this.depthTest), this.depthWrite === false && (i.depthWrite = this.depthWrite), this.colorWrite === false && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== ed && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== $n && (i.stencilFail = this.stencilFail), this.stencilZFail !== $n && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== $n && (i.stencilZPass = this.stencilZPass), this.stencilWrite === true && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === true && (i.polygonOffset = true), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === true && (i.dithering = true), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === true && (i.alphaHash = true), this.alphaToCoverage === true && (i.alphaToCoverage = true), this.premultipliedAlpha === true && (i.premultipliedAlpha = true), this.forceSinglePass === true && (i.forceSinglePass = true), this.wireframe === true && (i.wireframe = true), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === true && (i.flatShading = true), this.visible === false && (i.visible = false), this.toneMapped === false && (i.toneMapped = false), this.fog === false && (i.fog = false), Object.keys(this.userData).length > 0 && (i.userData = this.userData);
        function n(s) {
          const a = [];
          for (const o in s) {
            const l = s[o];
            delete l.metadata, a.push(l);
          }
          return a;
        }
        if (t) {
          const s = n(e.textures), a = n(e.images);
          s.length > 0 && (i.textures = s), a.length > 0 && (i.images = a);
        }
        return i;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let i = null;
        if (t !== null) {
          const n = t.length;
          i = new Array(n);
          for (let s = 0; s !== n; ++s) i[s] = t[s].clone();
        }
        return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
      }
      dispose() {
        this.dispatchEvent({
          type: "dispose"
        });
      }
      set needsUpdate(e) {
        e === true && this.version++;
      }
      onBuild() {
        console.warn("Material: onBuild() has been removed.");
      }
    }
    class $i extends Ji {
      constructor(e) {
        super(), this.isMeshBasicMaterial = true, this.type = "MeshBasicMaterial", this.color = new Ae(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Zi(), this.combine = Nh, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = true, this.setValues(e);
      }
      copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
      }
    }
    const Lt = new D(), So = new ee();
    let x_ = 0;
    class si {
      constructor(e, t, i = false) {
        if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = true, Object.defineProperty(this, "id", {
          value: x_++
        }), this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i, this.usage = mc, this.updateRanges = [], this.gpuType = Bi, this.version = 0;
      }
      onUploadCallback() {
      }
      set needsUpdate(e) {
        e === true && this.version++;
      }
      setUsage(e) {
        return this.usage = e, this;
      }
      addUpdateRange(e, t) {
        this.updateRanges.push({
          start: e,
          count: t
        });
      }
      clearUpdateRanges() {
        this.updateRanges.length = 0;
      }
      copy(e) {
        return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
      }
      copyAt(e, t, i) {
        e *= this.itemSize, i *= t.itemSize;
        for (let n = 0, s = this.itemSize; n < s; n++) this.array[e + n] = t.array[i + n];
        return this;
      }
      copyArray(e) {
        return this.array.set(e), this;
      }
      applyMatrix3(e) {
        if (this.itemSize === 2) for (let t = 0, i = this.count; t < i; t++) So.fromBufferAttribute(this, t), So.applyMatrix3(e), this.setXY(t, So.x, So.y);
        else if (this.itemSize === 3) for (let t = 0, i = this.count; t < i; t++) Lt.fromBufferAttribute(this, t), Lt.applyMatrix3(e), this.setXYZ(t, Lt.x, Lt.y, Lt.z);
        return this;
      }
      applyMatrix4(e) {
        for (let t = 0, i = this.count; t < i; t++) Lt.fromBufferAttribute(this, t), Lt.applyMatrix4(e), this.setXYZ(t, Lt.x, Lt.y, Lt.z);
        return this;
      }
      applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++) Lt.fromBufferAttribute(this, t), Lt.applyNormalMatrix(e), this.setXYZ(t, Lt.x, Lt.y, Lt.z);
        return this;
      }
      transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++) Lt.fromBufferAttribute(this, t), Lt.transformDirection(e), this.setXYZ(t, Lt.x, Lt.y, Lt.z);
        return this;
      }
      set(e, t = 0) {
        return this.array.set(e, t), this;
      }
      getComponent(e, t) {
        let i = this.array[e * this.itemSize + t];
        return this.normalized && (i = zi(i, this.array)), i;
      }
      setComponent(e, t, i) {
        return this.normalized && (i = nt(i, this.array)), this.array[e * this.itemSize + t] = i, this;
      }
      getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = zi(t, this.array)), t;
      }
      setX(e, t) {
        return this.normalized && (t = nt(t, this.array)), this.array[e * this.itemSize] = t, this;
      }
      getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = zi(t, this.array)), t;
      }
      setY(e, t) {
        return this.normalized && (t = nt(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
      }
      getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = zi(t, this.array)), t;
      }
      setZ(e, t) {
        return this.normalized && (t = nt(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
      }
      getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = zi(t, this.array)), t;
      }
      setW(e, t) {
        return this.normalized && (t = nt(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
      }
      setXY(e, t, i) {
        return e *= this.itemSize, this.normalized && (t = nt(t, this.array), i = nt(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this;
      }
      setXYZ(e, t, i, n) {
        return e *= this.itemSize, this.normalized && (t = nt(t, this.array), i = nt(i, this.array), n = nt(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this;
      }
      setXYZW(e, t, i, n, s) {
        return e *= this.itemSize, this.normalized && (t = nt(t, this.array), i = nt(i, this.array), n = nt(n, this.array), s = nt(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = n, this.array[e + 3] = s, this;
      }
      onUpload(e) {
        return this.onUploadCallback = e, this;
      }
      clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
      }
      toJSON() {
        const e = {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: Array.from(this.array),
          normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name), this.usage !== mc && (e.usage = this.usage), e;
      }
    }
    class yd extends si {
      constructor(e, t, i) {
        super(new Uint16Array(e), t, i);
      }
    }
    class Md extends si {
      constructor(e, t, i) {
        super(new Uint32Array(e), t, i);
      }
    }
    class Wt extends si {
      constructor(e, t, i) {
        super(new Float32Array(e), t, i);
      }
    }
    let y_ = 0;
    const Pi = new Fe(), Oc = new xt(), ds = new D(), xi = new fr(), ga = new fr(), Ht = new D();
    class hi extends Qn {
      constructor() {
        super(), this.isBufferGeometry = true, Object.defineProperty(this, "id", {
          value: y_++
        }), this.uuid = Ci(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = false, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
          start: 0,
          count: 1 / 0
        }, this.userData = {};
      }
      getIndex() {
        return this.index;
      }
      setIndex(e) {
        return Array.isArray(e) ? this.index = new (nd(e) ? Md : yd)(e, 1) : this.index = e, this;
      }
      setIndirect(e) {
        return this.indirect = e, this;
      }
      getIndirect() {
        return this.indirect;
      }
      getAttribute(e) {
        return this.attributes[e];
      }
      setAttribute(e, t) {
        return this.attributes[e] = t, this;
      }
      deleteAttribute(e) {
        return delete this.attributes[e], this;
      }
      hasAttribute(e) {
        return this.attributes[e] !== void 0;
      }
      addGroup(e, t, i = 0) {
        this.groups.push({
          start: e,
          count: t,
          materialIndex: i
        });
      }
      clearGroups() {
        this.groups = [];
      }
      setDrawRange(e, t) {
        this.drawRange.start = e, this.drawRange.count = t;
      }
      applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = true);
        const i = this.attributes.normal;
        if (i !== void 0) {
          const s = new ze().getNormalMatrix(e);
          i.applyNormalMatrix(s), i.needsUpdate = true;
        }
        const n = this.attributes.tangent;
        return n !== void 0 && (n.transformDirection(e), n.needsUpdate = true), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
      }
      applyQuaternion(e) {
        return Pi.makeRotationFromQuaternion(e), this.applyMatrix4(Pi), this;
      }
      rotateX(e) {
        return Pi.makeRotationX(e), this.applyMatrix4(Pi), this;
      }
      rotateY(e) {
        return Pi.makeRotationY(e), this.applyMatrix4(Pi), this;
      }
      rotateZ(e) {
        return Pi.makeRotationZ(e), this.applyMatrix4(Pi), this;
      }
      translate(e, t, i) {
        return Pi.makeTranslation(e, t, i), this.applyMatrix4(Pi), this;
      }
      scale(e, t, i) {
        return Pi.makeScale(e, t, i), this.applyMatrix4(Pi), this;
      }
      lookAt(e) {
        return Oc.lookAt(e), Oc.updateMatrix(), this.applyMatrix4(Oc.matrix), this;
      }
      center() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(ds).negate(), this.translate(ds.x, ds.y, ds.z), this;
      }
      setFromPoints(e) {
        const t = this.getAttribute("position");
        if (t === void 0) {
          const i = [];
          for (let n = 0, s = e.length; n < s; n++) {
            const a = e[n];
            i.push(a.x, a.y, a.z || 0);
          }
          this.setAttribute("position", new Wt(i, 3));
        } else {
          const i = Math.min(e.length, t.count);
          for (let n = 0; n < i; n++) {
            const s = e[n];
            t.setXYZ(n, s.x, s.y, s.z || 0);
          }
          e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), t.needsUpdate = true;
        }
        return this;
      }
      computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new fr());
        const e = this.attributes.position, t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
          console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new D(-1 / 0, -1 / 0, -1 / 0), new D(1 / 0, 1 / 0, 1 / 0));
          return;
        }
        if (e !== void 0) {
          if (this.boundingBox.setFromBufferAttribute(e), t) for (let i = 0, n = t.length; i < n; i++) {
            const s = t[i];
            xi.setFromBufferAttribute(s), this.morphTargetsRelative ? (Ht.addVectors(this.boundingBox.min, xi.min), this.boundingBox.expandByPoint(Ht), Ht.addVectors(this.boundingBox.max, xi.max), this.boundingBox.expandByPoint(Ht)) : (this.boundingBox.expandByPoint(xi.min), this.boundingBox.expandByPoint(xi.max));
          }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
      }
      computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new Ki());
        const e = this.attributes.position, t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
          console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new D(), 1 / 0);
          return;
        }
        if (e) {
          const i = this.boundingSphere.center;
          if (xi.setFromBufferAttribute(e), t) for (let s = 0, a = t.length; s < a; s++) {
            const o = t[s];
            ga.setFromBufferAttribute(o), this.morphTargetsRelative ? (Ht.addVectors(xi.min, ga.min), xi.expandByPoint(Ht), Ht.addVectors(xi.max, ga.max), xi.expandByPoint(Ht)) : (xi.expandByPoint(ga.min), xi.expandByPoint(ga.max));
          }
          xi.getCenter(i);
          let n = 0;
          for (let s = 0, a = e.count; s < a; s++) Ht.fromBufferAttribute(e, s), n = Math.max(n, i.distanceToSquared(Ht));
          if (t) for (let s = 0, a = t.length; s < a; s++) {
            const o = t[s], l = this.morphTargetsRelative;
            for (let c = 0, u = o.count; c < u; c++) Ht.fromBufferAttribute(o, c), l && (ds.fromBufferAttribute(e, c), Ht.add(ds)), n = Math.max(n, i.distanceToSquared(Ht));
          }
          this.boundingSphere.radius = Math.sqrt(n), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
        }
      }
      computeTangents() {
        const e = this.index, t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
          console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
          return;
        }
        const i = t.position, n = t.normal, s = t.uv;
        this.hasAttribute("tangent") === false && this.setAttribute("tangent", new si(new Float32Array(4 * i.count), 4));
        const a = this.getAttribute("tangent"), o = [], l = [];
        for (let R = 0; R < i.count; R++) o[R] = new D(), l[R] = new D();
        const c = new D(), u = new D(), h = new D(), d = new ee(), p = new ee(), f = new ee(), _ = new D(), g = new D();
        function m(R, E, b) {
          c.fromBufferAttribute(i, R), u.fromBufferAttribute(i, E), h.fromBufferAttribute(i, b), d.fromBufferAttribute(s, R), p.fromBufferAttribute(s, E), f.fromBufferAttribute(s, b), u.sub(c), h.sub(c), p.sub(d), f.sub(d);
          const L = 1 / (p.x * f.y - f.x * p.y);
          isFinite(L) && (_.copy(u).multiplyScalar(f.y).addScaledVector(h, -p.y).multiplyScalar(L), g.copy(h).multiplyScalar(p.x).addScaledVector(u, -f.x).multiplyScalar(L), o[R].add(_), o[E].add(_), o[b].add(_), l[R].add(g), l[E].add(g), l[b].add(g));
        }
        let y = this.groups;
        y.length === 0 && (y = [
          {
            start: 0,
            count: e.count
          }
        ]);
        for (let R = 0, E = y.length; R < E; ++R) {
          const b = y[R], L = b.start, B = b.count;
          for (let F = L, V = L + B; F < V; F += 3) m(e.getX(F + 0), e.getX(F + 1), e.getX(F + 2));
        }
        const x = new D(), v = new D(), A = new D(), T = new D();
        function w(R) {
          A.fromBufferAttribute(n, R), T.copy(A);
          const E = o[R];
          x.copy(E), x.sub(A.multiplyScalar(A.dot(E))).normalize(), v.crossVectors(T, E);
          const b = v.dot(l[R]) < 0 ? -1 : 1;
          a.setXYZW(R, x.x, x.y, x.z, b);
        }
        for (let R = 0, E = y.length; R < E; ++R) {
          const b = y[R], L = b.start, B = b.count;
          for (let F = L, V = L + B; F < V; F += 3) w(e.getX(F + 0)), w(e.getX(F + 1)), w(e.getX(F + 2));
        }
      }
      computeVertexNormals() {
        const e = this.index, t = this.getAttribute("position");
        if (t !== void 0) {
          let i = this.getAttribute("normal");
          if (i === void 0) i = new si(new Float32Array(t.count * 3), 3), this.setAttribute("normal", i);
          else for (let d = 0, p = i.count; d < p; d++) i.setXYZ(d, 0, 0, 0);
          const n = new D(), s = new D(), a = new D(), o = new D(), l = new D(), c = new D(), u = new D(), h = new D();
          if (e) for (let d = 0, p = e.count; d < p; d += 3) {
            const f = e.getX(d + 0), _ = e.getX(d + 1), g = e.getX(d + 2);
            n.fromBufferAttribute(t, f), s.fromBufferAttribute(t, _), a.fromBufferAttribute(t, g), u.subVectors(a, s), h.subVectors(n, s), u.cross(h), o.fromBufferAttribute(i, f), l.fromBufferAttribute(i, _), c.fromBufferAttribute(i, g), o.add(u), l.add(u), c.add(u), i.setXYZ(f, o.x, o.y, o.z), i.setXYZ(_, l.x, l.y, l.z), i.setXYZ(g, c.x, c.y, c.z);
          }
          else for (let d = 0, p = t.count; d < p; d += 3) n.fromBufferAttribute(t, d + 0), s.fromBufferAttribute(t, d + 1), a.fromBufferAttribute(t, d + 2), u.subVectors(a, s), h.subVectors(n, s), u.cross(h), i.setXYZ(d + 0, u.x, u.y, u.z), i.setXYZ(d + 1, u.x, u.y, u.z), i.setXYZ(d + 2, u.x, u.y, u.z);
          this.normalizeNormals(), i.needsUpdate = true;
        }
      }
      normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, i = e.count; t < i; t++) Ht.fromBufferAttribute(e, t), Ht.normalize(), e.setXYZ(t, Ht.x, Ht.y, Ht.z);
      }
      toNonIndexed() {
        function e(o, l) {
          const c = o.array, u = o.itemSize, h = o.normalized, d = new c.constructor(l.length * u);
          let p = 0, f = 0;
          for (let _ = 0, g = l.length; _ < g; _++) {
            o.isInterleavedBufferAttribute ? p = l[_] * o.data.stride + o.offset : p = l[_] * u;
            for (let m = 0; m < u; m++) d[f++] = c[p++];
          }
          return new si(d, u, h);
        }
        if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
        const t = new hi(), i = this.index.array, n = this.attributes;
        for (const o in n) {
          const l = n[o], c = e(l, i);
          t.setAttribute(o, c);
        }
        const s = this.morphAttributes;
        for (const o in s) {
          const l = [], c = s[o];
          for (let u = 0, h = c.length; u < h; u++) {
            const d = c[u], p = e(d, i);
            l.push(p);
          }
          t.morphAttributes[o] = l;
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const a = this.groups;
        for (let o = 0, l = a.length; o < l; o++) {
          const c = a[o];
          t.addGroup(c.start, c.count, c.materialIndex);
        }
        return t;
      }
      toJSON() {
        const e = {
          metadata: {
            version: 4.6,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON"
          }
        };
        if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
          const l = this.parameters;
          for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
          return e;
        }
        e.data = {
          attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
          type: t.array.constructor.name,
          array: Array.prototype.slice.call(t.array)
        });
        const i = this.attributes;
        for (const l in i) {
          const c = i[l];
          e.data.attributes[l] = c.toJSON(e.data);
        }
        const n = {};
        let s = false;
        for (const l in this.morphAttributes) {
          const c = this.morphAttributes[l], u = [];
          for (let h = 0, d = c.length; h < d; h++) {
            const p = c[h];
            u.push(p.toJSON(e.data));
          }
          u.length > 0 && (n[l] = u, s = true);
        }
        s && (e.data.morphAttributes = n, e.data.morphTargetsRelative = this.morphTargetsRelative);
        const a = this.groups;
        a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
        const o = this.boundingSphere;
        return o !== null && (e.data.boundingSphere = {
          center: o.center.toArray(),
          radius: o.radius
        }), e;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const i = e.index;
        i !== null && this.setIndex(i.clone(t));
        const n = e.attributes;
        for (const c in n) {
          const u = n[c];
          this.setAttribute(c, u.clone(t));
        }
        const s = e.morphAttributes;
        for (const c in s) {
          const u = [], h = s[c];
          for (let d = 0, p = h.length; d < p; d++) u.push(h[d].clone(t));
          this.morphAttributes[c] = u;
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const a = e.groups;
        for (let c = 0, u = a.length; c < u; c++) {
          const h = a[c];
          this.addGroup(h.start, h.count, h.materialIndex);
        }
        const o = e.boundingBox;
        o !== null && (this.boundingBox = o.clone());
        const l = e.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
      }
      dispose() {
        this.dispatchEvent({
          type: "dispose"
        });
      }
    }
    const bd = new Fe(), cn = new fa(), Eo = new Ki(), Sd = new D(), To = new D(), wo = new D(), Ao = new D(), Nc = new D(), Ro = new D(), Ed = new D(), Co = new D();
    class Rt extends xt {
      constructor(e = new hi(), t = new $i()) {
        super(), this.isMesh = true, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets();
      }
      copy(e, t) {
        return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
      }
      updateMorphTargets() {
        const e = this.geometry.morphAttributes, t = Object.keys(e);
        if (t.length > 0) {
          const i = e[t[0]];
          if (i !== void 0) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let n = 0, s = i.length; n < s; n++) {
              const a = i[n].name || String(n);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = n;
            }
          }
        }
      }
      getVertexPosition(e, t) {
        const i = this.geometry, n = i.attributes.position, s = i.morphAttributes.position, a = i.morphTargetsRelative;
        t.fromBufferAttribute(n, e);
        const o = this.morphTargetInfluences;
        if (s && o) {
          Ro.set(0, 0, 0);
          for (let l = 0, c = s.length; l < c; l++) {
            const u = o[l], h = s[l];
            u !== 0 && (Nc.fromBufferAttribute(h, e), a ? Ro.addScaledVector(Nc, u) : Ro.addScaledVector(Nc.sub(t), u));
          }
          t.add(Ro);
        }
        return t;
      }
      raycast(e, t) {
        const i = this.geometry, n = this.material, s = this.matrixWorld;
        n !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), Eo.copy(i.boundingSphere), Eo.applyMatrix4(s), cn.copy(e.ray).recast(e.near), !(Eo.containsPoint(cn.origin) === false && (cn.intersectSphere(Eo, Sd) === null || cn.origin.distanceToSquared(Sd) > (e.far - e.near) ** 2)) && (bd.copy(s).invert(), cn.copy(e.ray).applyMatrix4(bd), !(i.boundingBox !== null && cn.intersectsBox(i.boundingBox) === false) && this._computeIntersections(e, t, cn)));
      }
      _computeIntersections(e, t, i) {
        let n;
        const s = this.geometry, a = this.material, o = s.index, l = s.attributes.position, c = s.attributes.uv, u = s.attributes.uv1, h = s.attributes.normal, d = s.groups, p = s.drawRange;
        if (o !== null) if (Array.isArray(a)) for (let f = 0, _ = d.length; f < _; f++) {
          const g = d[f], m = a[g.materialIndex], y = Math.max(g.start, p.start), x = Math.min(o.count, Math.min(g.start + g.count, p.start + p.count));
          for (let v = y, A = x; v < A; v += 3) {
            const T = o.getX(v), w = o.getX(v + 1), R = o.getX(v + 2);
            n = Po(this, m, e, i, c, u, h, T, w, R), n && (n.faceIndex = Math.floor(v / 3), n.face.materialIndex = g.materialIndex, t.push(n));
          }
        }
        else {
          const f = Math.max(0, p.start), _ = Math.min(o.count, p.start + p.count);
          for (let g = f, m = _; g < m; g += 3) {
            const y = o.getX(g), x = o.getX(g + 1), v = o.getX(g + 2);
            n = Po(this, a, e, i, c, u, h, y, x, v), n && (n.faceIndex = Math.floor(g / 3), t.push(n));
          }
        }
        else if (l !== void 0) if (Array.isArray(a)) for (let f = 0, _ = d.length; f < _; f++) {
          const g = d[f], m = a[g.materialIndex], y = Math.max(g.start, p.start), x = Math.min(l.count, Math.min(g.start + g.count, p.start + p.count));
          for (let v = y, A = x; v < A; v += 3) {
            const T = v, w = v + 1, R = v + 2;
            n = Po(this, m, e, i, c, u, h, T, w, R), n && (n.faceIndex = Math.floor(v / 3), n.face.materialIndex = g.materialIndex, t.push(n));
          }
        }
        else {
          const f = Math.max(0, p.start), _ = Math.min(l.count, p.start + p.count);
          for (let g = f, m = _; g < m; g += 3) {
            const y = g, x = g + 1, v = g + 2;
            n = Po(this, a, e, i, c, u, h, y, x, v), n && (n.faceIndex = Math.floor(g / 3), t.push(n));
          }
        }
      }
    }
    function M_(r, e, t, i, n, s, a, o) {
      let l;
      if (e.side === vt ? l = i.intersectTriangle(a, s, n, true, o) : l = i.intersectTriangle(n, s, a, e.side === Ot, o), l === null) return null;
      Co.copy(o), Co.applyMatrix4(r.matrixWorld);
      const c = t.ray.origin.distanceTo(Co);
      return c < t.near || c > t.far ? null : {
        distance: c,
        point: Co.clone(),
        object: r
      };
    }
    function Po(r, e, t, i, n, s, a, o, l, c) {
      r.getVertexPosition(o, To), r.getVertexPosition(l, wo), r.getVertexPosition(c, Ao);
      const u = M_(r, e, t, i, To, wo, Ao, Ed);
      if (u) {
        const h = new D();
        Wi.getBarycoord(Ed, To, wo, Ao, h), n && (u.uv = Wi.getInterpolatedAttribute(n, o, l, c, h, new ee())), s && (u.uv1 = Wi.getInterpolatedAttribute(s, o, l, c, h, new ee())), a && (u.normal = Wi.getInterpolatedAttribute(a, o, l, c, h, new D()), u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
        const d = {
          a: o,
          b: l,
          c,
          normal: new D(),
          materialIndex: 0
        };
        Wi.getNormal(To, wo, Ao, d.normal), u.face = d, u.barycoord = h;
      }
      return u;
    }
    class un extends hi {
      constructor(e = 1, t = 1, i = 1, n = 1, s = 1, a = 1) {
        super(), this.type = "BoxGeometry", this.parameters = {
          width: e,
          height: t,
          depth: i,
          widthSegments: n,
          heightSegments: s,
          depthSegments: a
        };
        const o = this;
        n = Math.floor(n), s = Math.floor(s), a = Math.floor(a);
        const l = [], c = [], u = [], h = [];
        let d = 0, p = 0;
        f("z", "y", "x", -1, -1, i, t, e, a, s, 0), f("z", "y", "x", 1, -1, i, t, -e, a, s, 1), f("x", "z", "y", 1, 1, e, i, t, n, a, 2), f("x", "z", "y", 1, -1, e, i, -t, n, a, 3), f("x", "y", "z", 1, -1, e, t, i, n, s, 4), f("x", "y", "z", -1, -1, e, t, -i, n, s, 5), this.setIndex(l), this.setAttribute("position", new Wt(c, 3)), this.setAttribute("normal", new Wt(u, 3)), this.setAttribute("uv", new Wt(h, 2));
        function f(_, g, m, y, x, v, A, T, w, R, E) {
          const b = v / w, L = A / R, B = v / 2, F = A / 2, V = T / 2, X = w + 1, k = R + 1;
          let K = 0, G = 0;
          const ie = new D();
          for (let ue = 0; ue < k; ue++) {
            const we = ue * L - F;
            for (let Be = 0; Be < X; Be++) {
              const We = Be * b - B;
              ie[_] = We * y, ie[g] = we * x, ie[m] = V, c.push(ie.x, ie.y, ie.z), ie[_] = 0, ie[g] = 0, ie[m] = T > 0 ? 1 : -1, u.push(ie.x, ie.y, ie.z), h.push(Be / w), h.push(1 - ue / R), K += 1;
            }
          }
          for (let ue = 0; ue < R; ue++) for (let we = 0; we < w; we++) {
            const Be = d + we + X * ue, We = d + we + X * (ue + 1), j = d + (we + 1) + X * (ue + 1), re = d + (we + 1) + X * ue;
            l.push(Be, We, re), l.push(We, j, re), G += 6;
          }
          o.addGroup(p, G, E), p += G, d += K;
        }
      }
      copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
      }
      static fromJSON(e) {
        return new un(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
      }
    }
    function ps(r) {
      const e = {};
      for (const t in r) {
        e[t] = {};
        for (const i in r[t]) {
          const n = r[t][i];
          n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture || n.isQuaternion) ? n.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][i] = null) : e[t][i] = n.clone() : Array.isArray(n) ? e[t][i] = n.slice() : e[t][i] = n;
        }
      }
      return e;
    }
    function ai(r) {
      const e = {};
      for (let t = 0; t < r.length; t++) {
        const i = ps(r[t]);
        for (const n in i) e[n] = i[n];
      }
      return e;
    }
    function b_(r) {
      const e = [];
      for (let t = 0; t < r.length; t++) e.push(r[t].clone());
      return e;
    }
    function Td(r) {
      const e = r.getRenderTarget();
      return e === null ? r.outputColorSpace : e.isXRRenderTarget === true ? e.texture.colorSpace : Ke.workingColorSpace;
    }
    const Lo = {
      clone: ps,
      merge: ai
    };
    var S_ = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, E_ = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
    class Zt extends Ji {
      constructor(e) {
        super(), this.isShaderMaterial = true, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = S_, this.fragmentShader = E_, this.linewidth = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.fog = false, this.lights = false, this.clipping = false, this.forceSinglePass = true, this.extensions = {
          clipCullDistance: false,
          multiDraw: false
        }, this.defaultAttributeValues = {
          color: [
            1,
            1,
            1
          ],
          uv: [
            0,
            0
          ],
          uv1: [
            0,
            0
          ]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = false, this.glslVersion = null, e !== void 0 && this.setValues(e);
      }
      copy(e) {
        return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = ps(e.uniforms), this.uniformsGroups = b_(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
      }
      toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion, t.uniforms = {};
        for (const n in this.uniforms) {
          const s = this.uniforms[n].value;
          s && s.isTexture ? t.uniforms[n] = {
            type: "t",
            value: s.toJSON(e).uuid
          } : s && s.isColor ? t.uniforms[n] = {
            type: "c",
            value: s.getHex()
          } : s && s.isVector2 ? t.uniforms[n] = {
            type: "v2",
            value: s.toArray()
          } : s && s.isVector3 ? t.uniforms[n] = {
            type: "v3",
            value: s.toArray()
          } : s && s.isVector4 ? t.uniforms[n] = {
            type: "v4",
            value: s.toArray()
          } : s && s.isMatrix3 ? t.uniforms[n] = {
            type: "m3",
            value: s.toArray()
          } : s && s.isMatrix4 ? t.uniforms[n] = {
            type: "m4",
            value: s.toArray()
          } : t.uniforms[n] = {
            value: s
          };
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
        const i = {};
        for (const n in this.extensions) this.extensions[n] === true && (i[n] = true);
        return Object.keys(i).length > 0 && (t.extensions = i), t;
      }
    }
    class wd extends xt {
      constructor() {
        super(), this.isCamera = true, this.type = "Camera", this.matrixWorldInverse = new Fe(), this.projectionMatrix = new Fe(), this.projectionMatrixInverse = new Fe(), this.coordinateSystem = dr;
      }
      copy(e, t) {
        return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
      }
      getWorldDirection(e) {
        return super.getWorldDirection(e).negate();
      }
      updateMatrixWorld(e) {
        super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    const Vr = new D(), Ad = new ee(), Rd = new ee();
    class oi extends wd {
      constructor(e = 50, t = 1, i = 0.1, n = 2e3) {
        super(), this.isPerspectiveCamera = true, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = n, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
      }
      copy(e, t) {
        return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
      }
      setFocalLength(e) {
        const t = 0.5 * this.getFilmHeight() / e;
        this.fov = es * 2 * Math.atan(t), this.updateProjectionMatrix();
      }
      getFocalLength() {
        const e = Math.tan(ca * 0.5 * this.fov);
        return 0.5 * this.getFilmHeight() / e;
      }
      getEffectiveFOV() {
        return es * 2 * Math.atan(Math.tan(ca * 0.5 * this.fov) / this.zoom);
      }
      getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
      }
      getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
      }
      getViewBounds(e, t, i) {
        Vr.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(Vr.x, Vr.y).multiplyScalar(-e / Vr.z), Vr.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), i.set(Vr.x, Vr.y).multiplyScalar(-e / Vr.z);
      }
      getViewSize(e, t) {
        return this.getViewBounds(e, Ad, Rd), t.subVectors(Rd, Ad);
      }
      setViewOffset(e, t, i, n, s, a) {
        this.aspect = e / t, this.view === null && (this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
      }
      clearViewOffset() {
        this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(ca * 0.5 * this.fov) / this.zoom, i = 2 * t, n = this.aspect * i, s = -0.5 * n;
        const a = this.view;
        if (this.view !== null && this.view.enabled) {
          const l = a.fullWidth, c = a.fullHeight;
          s += a.offsetX * n / l, t -= a.offsetY * i / c, n *= a.width / l, i *= a.height / c;
        }
        const o = this.filmOffset;
        o !== 0 && (s += e * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + n, t, t - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
      }
    }
    const fs = -90, ms = 1;
    class T_ extends xt {
      constructor(e, t, i) {
        super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
        const n = new oi(fs, ms, e, t);
        n.layers = this.layers, this.add(n);
        const s = new oi(fs, ms, e, t);
        s.layers = this.layers, this.add(s);
        const a = new oi(fs, ms, e, t);
        a.layers = this.layers, this.add(a);
        const o = new oi(fs, ms, e, t);
        o.layers = this.layers, this.add(o);
        const l = new oi(fs, ms, e, t);
        l.layers = this.layers, this.add(l);
        const c = new oi(fs, ms, e, t);
        c.layers = this.layers, this.add(c);
      }
      updateCoordinateSystem() {
        const e = this.coordinateSystem, t = this.children.concat(), [i, n, s, a, o, l] = t;
        for (const c of t) this.remove(c);
        if (e === dr) i.up.set(0, 1, 0), i.lookAt(1, 0, 0), n.up.set(0, 1, 0), n.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), o.up.set(0, 1, 0), o.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
        else if (e === fo) i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), n.up.set(0, -1, 0), n.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), o.up.set(0, -1, 0), o.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
        else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
        for (const c of t) this.add(c), c.updateMatrixWorld();
      }
      update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const { renderTarget: i, activeMipmapLevel: n } = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
        const [s, a, o, l, c, u] = this.children, h = e.getRenderTarget(), d = e.getActiveCubeFace(), p = e.getActiveMipmapLevel(), f = e.xr.enabled;
        e.xr.enabled = false;
        const _ = i.texture.generateMipmaps;
        i.texture.generateMipmaps = false, e.setRenderTarget(i, 0, n), e.render(t, s), e.setRenderTarget(i, 1, n), e.render(t, a), e.setRenderTarget(i, 2, n), e.render(t, o), e.setRenderTarget(i, 3, n), e.render(t, l), e.setRenderTarget(i, 4, n), e.render(t, c), i.texture.generateMipmaps = _, e.setRenderTarget(i, 5, n), e.render(t, u), e.setRenderTarget(h, d, p), e.xr.enabled = f, i.texture.needsPMREMUpdate = true;
      }
    }
    class Cd extends Nt {
      constructor(e, t, i, n, s, a, o, l, c, u) {
        e = e !== void 0 ? e : [], t = t !== void 0 ? t : jn, super(e, t, i, n, s, a, o, l, c, u), this.isCubeTexture = true, this.flipY = false;
      }
      get images() {
        return this.image;
      }
      set images(e) {
        this.image = e;
      }
    }
    class w_ extends ki {
      constructor(e = 1, t = {}) {
        super(e, e, t), this.isWebGLCubeRenderTarget = true;
        const i = {
          width: e,
          height: e,
          depth: 1
        }, n = [
          i,
          i,
          i,
          i,
          i,
          i
        ];
        this.texture = new Cd(n, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = true, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : false, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : _i;
      }
      fromEquirectangularTexture(e, t) {
        this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
        const i = {
          uniforms: {
            tEquirect: {
              value: null
            }
          },
          vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
          fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }, n = new un(5, 5, 5), s = new Zt({
          name: "CubemapFromEquirect",
          uniforms: ps(i.uniforms),
          vertexShader: i.vertexShader,
          fragmentShader: i.fragmentShader,
          side: vt,
          blending: Fi
        });
        s.uniforms.tEquirect.value = t;
        const a = new Rt(n, s), o = t.minFilter;
        return t.minFilter === cr && (t.minFilter = _i), new T_(1, 10, this).update(e, a), t.minFilter = o, a.geometry.dispose(), a.material.dispose(), this;
      }
      clear(e, t, i, n) {
        const s = e.getRenderTarget();
        for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, i, n);
        e.setRenderTarget(s);
      }
    }
    class Gr extends xt {
      constructor() {
        super(), this.isGroup = true, this.type = "Group";
      }
    }
    const A_ = {
      type: "move"
    };
    class Fc {
      constructor() {
        this._targetRay = null, this._grip = null, this._hand = null;
      }
      getHandSpace() {
        return this._hand === null && (this._hand = new Gr(), this._hand.matrixAutoUpdate = false, this._hand.visible = false, this._hand.joints = {}, this._hand.inputState = {
          pinching: false
        }), this._hand;
      }
      getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new Gr(), this._targetRay.matrixAutoUpdate = false, this._targetRay.visible = false, this._targetRay.hasLinearVelocity = false, this._targetRay.linearVelocity = new D(), this._targetRay.hasAngularVelocity = false, this._targetRay.angularVelocity = new D()), this._targetRay;
      }
      getGripSpace() {
        return this._grip === null && (this._grip = new Gr(), this._grip.matrixAutoUpdate = false, this._grip.visible = false, this._grip.hasLinearVelocity = false, this._grip.linearVelocity = new D(), this._grip.hasAngularVelocity = false, this._grip.angularVelocity = new D()), this._grip;
      }
      dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
      }
      connect(e) {
        if (e && e.hand) {
          const t = this._hand;
          if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
        }
        return this.dispatchEvent({
          type: "connected",
          data: e
        }), this;
      }
      disconnect(e) {
        return this.dispatchEvent({
          type: "disconnected",
          data: e
        }), this._targetRay !== null && (this._targetRay.visible = false), this._grip !== null && (this._grip.visible = false), this._hand !== null && (this._hand.visible = false), this;
      }
      update(e, t, i) {
        let n = null, s = null, a = null;
        const o = this._targetRay, l = this._grip, c = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
          if (c && e.hand) {
            a = true;
            for (const _ of e.hand.values()) {
              const g = t.getJointPose(_, i), m = this._getHandJoint(c, _);
              g !== null && (m.matrix.fromArray(g.transform.matrix), m.matrix.decompose(m.position, m.rotation, m.scale), m.matrixWorldNeedsUpdate = true, m.jointRadius = g.radius), m.visible = g !== null;
            }
            const u = c.joints["index-finger-tip"], h = c.joints["thumb-tip"], d = u.position.distanceTo(h.position), p = 0.02, f = 5e-3;
            c.inputState.pinching && d > p + f ? (c.inputState.pinching = false, this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this
            })) : !c.inputState.pinching && d <= p - f && (c.inputState.pinching = true, this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this
            }));
          } else l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, i), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = true, s.linearVelocity ? (l.hasLinearVelocity = true, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = false, s.angularVelocity ? (l.hasAngularVelocity = true, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = false));
          o !== null && (n = t.getPose(e.targetRaySpace, i), n === null && s !== null && (n = s), n !== null && (o.matrix.fromArray(n.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.matrixWorldNeedsUpdate = true, n.linearVelocity ? (o.hasLinearVelocity = true, o.linearVelocity.copy(n.linearVelocity)) : o.hasLinearVelocity = false, n.angularVelocity ? (o.hasAngularVelocity = true, o.angularVelocity.copy(n.angularVelocity)) : o.hasAngularVelocity = false, this.dispatchEvent(A_)));
        }
        return o !== null && (o.visible = n !== null), l !== null && (l.visible = s !== null), c !== null && (c.visible = a !== null), this;
      }
      _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
          const i = new Gr();
          i.matrixAutoUpdate = false, i.visible = false, e.joints[t.jointName] = i, e.add(i);
        }
        return e.joints[t.jointName];
      }
    }
    class R_ extends xt {
      constructor() {
        super(), this.isScene = true, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new Zi(), this.environmentIntensity = 1, this.environmentRotation = new Zi(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
          detail: this
        }));
      }
      copy(e, t) {
        return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
      }
    }
    class C_ {
      constructor(e, t) {
        this.isInterleavedBuffer = true, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = mc, this.updateRanges = [], this.version = 0, this.uuid = Ci();
      }
      onUploadCallback() {
      }
      set needsUpdate(e) {
        e === true && this.version++;
      }
      setUsage(e) {
        return this.usage = e, this;
      }
      addUpdateRange(e, t) {
        this.updateRanges.push({
          start: e,
          count: t
        });
      }
      clearUpdateRanges() {
        this.updateRanges.length = 0;
      }
      copy(e) {
        return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
      }
      copyAt(e, t, i) {
        e *= this.stride, i *= t.stride;
        for (let n = 0, s = this.stride; n < s; n++) this.array[e + n] = t.array[i + n];
        return this;
      }
      set(e, t = 0) {
        return this.array.set(e, t), this;
      }
      clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ci()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), i = new this.constructor(t, this.stride);
        return i.setUsage(this.usage), i;
      }
      onUpload(e) {
        return this.onUploadCallback = e, this;
      }
      toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Ci()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
          uuid: this.uuid,
          buffer: this.array.buffer._uuid,
          type: this.array.constructor.name,
          stride: this.stride
        };
      }
    }
    const li = new D();
    class Bc {
      constructor(e, t, i, n = false) {
        this.isInterleavedBufferAttribute = true, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = n;
      }
      get count() {
        return this.data.count;
      }
      get array() {
        return this.data.array;
      }
      set needsUpdate(e) {
        this.data.needsUpdate = e;
      }
      applyMatrix4(e) {
        for (let t = 0, i = this.data.count; t < i; t++) li.fromBufferAttribute(this, t), li.applyMatrix4(e), this.setXYZ(t, li.x, li.y, li.z);
        return this;
      }
      applyNormalMatrix(e) {
        for (let t = 0, i = this.count; t < i; t++) li.fromBufferAttribute(this, t), li.applyNormalMatrix(e), this.setXYZ(t, li.x, li.y, li.z);
        return this;
      }
      transformDirection(e) {
        for (let t = 0, i = this.count; t < i; t++) li.fromBufferAttribute(this, t), li.transformDirection(e), this.setXYZ(t, li.x, li.y, li.z);
        return this;
      }
      getComponent(e, t) {
        let i = this.array[e * this.data.stride + this.offset + t];
        return this.normalized && (i = zi(i, this.array)), i;
      }
      setComponent(e, t, i) {
        return this.normalized && (i = nt(i, this.array)), this.data.array[e * this.data.stride + this.offset + t] = i, this;
      }
      setX(e, t) {
        return this.normalized && (t = nt(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
      }
      setY(e, t) {
        return this.normalized && (t = nt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
      }
      setZ(e, t) {
        return this.normalized && (t = nt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
      }
      setW(e, t) {
        return this.normalized && (t = nt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
      }
      getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = zi(t, this.array)), t;
      }
      getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = zi(t, this.array)), t;
      }
      getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = zi(t, this.array)), t;
      }
      getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = zi(t, this.array)), t;
      }
      setXY(e, t, i) {
        return e = e * this.data.stride + this.offset, this.normalized && (t = nt(t, this.array), i = nt(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this;
      }
      setXYZ(e, t, i, n) {
        return e = e * this.data.stride + this.offset, this.normalized && (t = nt(t, this.array), i = nt(i, this.array), n = nt(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this;
      }
      setXYZW(e, t, i, n, s) {
        return e = e * this.data.stride + this.offset, this.normalized && (t = nt(t, this.array), i = nt(i, this.array), n = nt(n, this.array), s = nt(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = n, this.data.array[e + 3] = s, this;
      }
      clone(e) {
        if (e === void 0) {
          console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
          const t = [];
          for (let i = 0; i < this.count; i++) {
            const n = i * this.data.stride + this.offset;
            for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[n + s]);
          }
          return new si(new this.array.constructor(t), this.itemSize, this.normalized);
        } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Bc(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
      }
      toJSON(e) {
        if (e === void 0) {
          console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
          const t = [];
          for (let i = 0; i < this.count; i++) {
            const n = i * this.data.stride + this.offset;
            for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[n + s]);
          }
          return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: t,
            normalized: this.normalized
          };
        } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
          isInterleavedBufferAttribute: true,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized
        };
      }
    }
    const Pd = new D(), Ld = new it(), Dd = new it(), P_ = new D(), Id = new Fe(), Do = new D(), zc = new Ki(), Ud = new Fe(), kc = new fa();
    class L_ extends Rt {
      constructor(e, t) {
        super(e, t), this.isSkinnedMesh = true, this.type = "SkinnedMesh", this.bindMode = Fh, this.bindMatrix = new Fe(), this.bindMatrixInverse = new Fe(), this.boundingBox = null, this.boundingSphere = null;
      }
      computeBoundingBox() {
        const e = this.geometry;
        this.boundingBox === null && (this.boundingBox = new fr()), this.boundingBox.makeEmpty();
        const t = e.getAttribute("position");
        for (let i = 0; i < t.count; i++) this.getVertexPosition(i, Do), this.boundingBox.expandByPoint(Do);
      }
      computeBoundingSphere() {
        const e = this.geometry;
        this.boundingSphere === null && (this.boundingSphere = new Ki()), this.boundingSphere.makeEmpty();
        const t = e.getAttribute("position");
        for (let i = 0; i < t.count; i++) this.getVertexPosition(i, Do), this.boundingSphere.expandByPoint(Do);
      }
      copy(e, t) {
        return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
      }
      raycast(e, t) {
        const i = this.material, n = this.matrixWorld;
        i !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), zc.copy(this.boundingSphere), zc.applyMatrix4(n), e.ray.intersectsSphere(zc) !== false && (Ud.copy(n).invert(), kc.copy(e.ray).applyMatrix4(Ud), !(this.boundingBox !== null && kc.intersectsBox(this.boundingBox) === false) && this._computeIntersections(e, t, kc)));
      }
      getVertexPosition(e, t) {
        return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
      }
      bind(e, t) {
        this.skeleton = e, t === void 0 && (this.updateMatrixWorld(true), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert();
      }
      pose() {
        this.skeleton.pose();
      }
      normalizeSkinWeights() {
        const e = new it(), t = this.geometry.attributes.skinWeight;
        for (let i = 0, n = t.count; i < n; i++) {
          e.fromBufferAttribute(t, i);
          const s = 1 / e.manhattanLength();
          s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w);
        }
      }
      updateMatrixWorld(e) {
        super.updateMatrixWorld(e), this.bindMode === Fh ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === Tg ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
      }
      applyBoneTransform(e, t) {
        const i = this.skeleton, n = this.geometry;
        Ld.fromBufferAttribute(n.attributes.skinIndex, e), Dd.fromBufferAttribute(n.attributes.skinWeight, e), Pd.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
        for (let s = 0; s < 4; s++) {
          const a = Dd.getComponent(s);
          if (a !== 0) {
            const o = Ld.getComponent(s);
            Id.multiplyMatrices(i.bones[o].matrixWorld, i.boneInverses[o]), t.addScaledVector(P_.copy(Pd).applyMatrix4(Id), a);
          }
        }
        return t.applyMatrix4(this.bindMatrixInverse);
      }
    }
    class Od extends xt {
      constructor() {
        super(), this.isBone = true, this.type = "Bone";
      }
    }
    class Nd extends Nt {
      constructor(e = null, t = 1, i = 1, n, s, a, o, l, c = ri, u = ri, h, d) {
        super(null, a, o, l, c, u, n, s, h, d), this.isDataTexture = true, this.image = {
          data: e,
          width: t,
          height: i
        }, this.generateMipmaps = false, this.flipY = false, this.unpackAlignment = 1;
      }
    }
    const Fd = new Fe(), D_ = new Fe();
    class Hc {
      constructor(e = [], t = []) {
        this.uuid = Ci(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init();
      }
      init() {
        const e = this.bones, t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
        else if (e.length !== t.length) {
          console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
          for (let i = 0, n = this.bones.length; i < n; i++) this.boneInverses.push(new Fe());
        }
      }
      calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
          const i = new Fe();
          this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i);
        }
      }
      pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
          const i = this.bones[e];
          i && i.matrixWorld.copy(this.boneInverses[e]).invert();
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
          const i = this.bones[e];
          i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld), i.matrix.decompose(i.position, i.quaternion, i.scale));
        }
      }
      update() {
        const e = this.bones, t = this.boneInverses, i = this.boneMatrices, n = this.boneTexture;
        for (let s = 0, a = e.length; s < a; s++) {
          const o = e[s] ? e[s].matrixWorld : D_;
          Fd.multiplyMatrices(o, t[s]), Fd.toArray(i, s * 16);
        }
        n !== null && (n.needsUpdate = true);
      }
      clone() {
        return new Hc(this.bones, this.boneInverses);
      }
      computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const i = new Nd(t, e, e, Ri, Bi);
        return i.needsUpdate = true, this.boneMatrices = t, this.boneTexture = i, this;
      }
      getBoneByName(e) {
        for (let t = 0, i = this.bones.length; t < i; t++) {
          const n = this.bones[t];
          if (n.name === e) return n;
        }
      }
      dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null);
      }
      fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let i = 0, n = e.bones.length; i < n; i++) {
          const s = e.bones[i];
          let a = t[s];
          a === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), a = new Od()), this.bones.push(a), this.boneInverses.push(new Fe().fromArray(e.boneInverses[i]));
        }
        return this.init(), this;
      }
      toJSON() {
        const e = {
          metadata: {
            version: 4.6,
            type: "Skeleton",
            generator: "Skeleton.toJSON"
          },
          bones: [],
          boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones, i = this.boneInverses;
        for (let n = 0, s = t.length; n < s; n++) {
          const a = t[n];
          e.bones.push(a.uuid);
          const o = i[n];
          e.boneInverses.push(o.toArray());
        }
        return e;
      }
    }
    class Vc extends si {
      constructor(e, t, i, n = 1) {
        super(e, t, i), this.isInstancedBufferAttribute = true, this.meshPerAttribute = n;
      }
      copy(e) {
        return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
      }
      toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = true, e;
      }
    }
    const gs = new Fe(), Bd = new Fe(), Io = [], zd = new fr(), I_ = new Fe(), _a = new Rt(), va = new Ki();
    class U_ extends Rt {
      constructor(e, t, i) {
        super(e, t), this.isInstancedMesh = true, this.instanceMatrix = new Vc(new Float32Array(i * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = i, this.boundingBox = null, this.boundingSphere = null;
        for (let n = 0; n < i; n++) this.setMatrixAt(n, I_);
      }
      computeBoundingBox() {
        const e = this.geometry, t = this.count;
        this.boundingBox === null && (this.boundingBox = new fr()), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
        for (let i = 0; i < t; i++) this.getMatrixAt(i, gs), zd.copy(e.boundingBox).applyMatrix4(gs), this.boundingBox.union(zd);
      }
      computeBoundingSphere() {
        const e = this.geometry, t = this.count;
        this.boundingSphere === null && (this.boundingSphere = new Ki()), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
        for (let i = 0; i < t; i++) this.getMatrixAt(i, gs), va.copy(e.boundingSphere).applyMatrix4(gs), this.boundingSphere.union(va);
      }
      copy(e, t) {
        return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this;
      }
      getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3);
      }
      getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16);
      }
      getMorphAt(e, t) {
        const i = t.morphTargetInfluences, n = this.morphTexture.source.data.data, s = i.length + 1, a = e * s + 1;
        for (let o = 0; o < i.length; o++) i[o] = n[a + o];
      }
      raycast(e, t) {
        const i = this.matrixWorld, n = this.count;
        if (_a.geometry = this.geometry, _a.material = this.material, _a.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), va.copy(this.boundingSphere), va.applyMatrix4(i), e.ray.intersectsSphere(va) !== false)) for (let s = 0; s < n; s++) {
          this.getMatrixAt(s, gs), Bd.multiplyMatrices(i, gs), _a.matrixWorld = Bd, _a.raycast(e, Io);
          for (let a = 0, o = Io.length; a < o; a++) {
            const l = Io[a];
            l.instanceId = s, l.object = this, t.push(l);
          }
          Io.length = 0;
        }
      }
      setColorAt(e, t) {
        this.instanceColor === null && (this.instanceColor = new Vc(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), t.toArray(this.instanceColor.array, e * 3);
      }
      setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16);
      }
      setMorphAt(e, t) {
        const i = t.morphTargetInfluences, n = i.length + 1;
        this.morphTexture === null && (this.morphTexture = new Nd(new Float32Array(n * this.count), n, this.count, Fl, Bi));
        const s = this.morphTexture.source.data.data;
        let a = 0;
        for (let c = 0; c < i.length; c++) a += i[c];
        const o = this.geometry.morphTargetsRelative ? 1 : 1 - a, l = n * e;
        s[l] = o, s.set(i, l + 1);
      }
      updateMorphTargets() {
      }
      dispose() {
        return this.dispatchEvent({
          type: "dispose"
        }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this;
      }
    }
    const Gc = new D(), O_ = new D(), N_ = new ze();
    class hn {
      constructor(e = new D(1, 0, 0), t = 0) {
        this.isPlane = true, this.normal = e, this.constant = t;
      }
      set(e, t) {
        return this.normal.copy(e), this.constant = t, this;
      }
      setComponents(e, t, i, n) {
        return this.normal.set(e, t, i), this.constant = n, this;
      }
      setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
      }
      setFromCoplanarPoints(e, t, i) {
        const n = Gc.subVectors(i, t).cross(O_.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(n, e), this;
      }
      copy(e) {
        return this.normal.copy(e.normal), this.constant = e.constant, this;
      }
      normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e), this.constant *= e, this;
      }
      negate() {
        return this.constant *= -1, this.normal.negate(), this;
      }
      distanceToPoint(e) {
        return this.normal.dot(e) + this.constant;
      }
      distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius;
      }
      projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
      }
      intersectLine(e, t) {
        const i = e.delta(Gc), n = this.normal.dot(i);
        if (n === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / n;
        return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s);
      }
      intersectsLine(e) {
        const t = this.distanceToPoint(e.start), i = this.distanceToPoint(e.end);
        return t < 0 && i > 0 || i < 0 && t > 0;
      }
      intersectsBox(e) {
        return e.intersectsPlane(this);
      }
      intersectsSphere(e) {
        return e.intersectsPlane(this);
      }
      coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant);
      }
      applyMatrix4(e, t) {
        const i = t || N_.getNormalMatrix(e), n = this.coplanarPoint(Gc).applyMatrix4(e), s = this.normal.applyMatrix3(i).normalize();
        return this.constant = -n.dot(s), this;
      }
      translate(e) {
        return this.constant -= e.dot(this.normal), this;
      }
      equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    const dn = new Ki(), Uo = new D();
    class Wc {
      constructor(e = new hn(), t = new hn(), i = new hn(), n = new hn(), s = new hn(), a = new hn()) {
        this.planes = [
          e,
          t,
          i,
          n,
          s,
          a
        ];
      }
      set(e, t, i, n, s, a) {
        const o = this.planes;
        return o[0].copy(e), o[1].copy(t), o[2].copy(i), o[3].copy(n), o[4].copy(s), o[5].copy(a), this;
      }
      copy(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
        return this;
      }
      setFromProjectionMatrix(e, t = dr) {
        const i = this.planes, n = e.elements, s = n[0], a = n[1], o = n[2], l = n[3], c = n[4], u = n[5], h = n[6], d = n[7], p = n[8], f = n[9], _ = n[10], g = n[11], m = n[12], y = n[13], x = n[14], v = n[15];
        if (i[0].setComponents(l - s, d - c, g - p, v - m).normalize(), i[1].setComponents(l + s, d + c, g + p, v + m).normalize(), i[2].setComponents(l + a, d + u, g + f, v + y).normalize(), i[3].setComponents(l - a, d - u, g - f, v - y).normalize(), i[4].setComponents(l - o, d - h, g - _, v - x).normalize(), t === dr) i[5].setComponents(l + o, d + h, g + _, v + x).normalize();
        else if (t === fo) i[5].setComponents(o, h, _, x).normalize();
        else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
        return this;
      }
      intersectsObject(e) {
        if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), dn.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
          const t = e.geometry;
          t.boundingSphere === null && t.computeBoundingSphere(), dn.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
        }
        return this.intersectsSphere(dn);
      }
      intersectsSprite(e) {
        return dn.center.set(0, 0, 0), dn.radius = 0.7071067811865476, dn.applyMatrix4(e.matrixWorld), this.intersectsSphere(dn);
      }
      intersectsSphere(e) {
        const t = this.planes, i = e.center, n = -e.radius;
        for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(i) < n) return false;
        return true;
      }
      intersectsBox(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) {
          const n = t[i];
          if (Uo.x = n.normal.x > 0 ? e.max.x : e.min.x, Uo.y = n.normal.y > 0 ? e.max.y : e.min.y, Uo.z = n.normal.z > 0 ? e.max.z : e.min.z, n.distanceToPoint(Uo) < 0) return false;
        }
        return true;
      }
      containsPoint(e) {
        const t = this.planes;
        for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return false;
        return true;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    class kd extends Ji {
      constructor(e) {
        super(), this.isLineBasicMaterial = true, this.type = "LineBasicMaterial", this.color = new Ae(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = true, this.setValues(e);
      }
      copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
      }
    }
    const Oo = new D(), No = new D(), Hd = new Fe(), xa = new fa(), Fo = new Ki(), Xc = new D(), Vd = new D();
    class jc extends xt {
      constructor(e = new hi(), t = new kd()) {
        super(), this.isLine = true, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets();
      }
      copy(e, t) {
        return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
      }
      computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
          const t = e.attributes.position, i = [
            0
          ];
          for (let n = 1, s = t.count; n < s; n++) Oo.fromBufferAttribute(t, n - 1), No.fromBufferAttribute(t, n), i[n] = i[n - 1], i[n] += Oo.distanceTo(No);
          e.setAttribute("lineDistance", new Wt(i, 1));
        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this;
      }
      raycast(e, t) {
        const i = this.geometry, n = this.matrixWorld, s = e.params.Line.threshold, a = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(), Fo.copy(i.boundingSphere), Fo.applyMatrix4(n), Fo.radius += s, e.ray.intersectsSphere(Fo) === false) return;
        Hd.copy(n).invert(), xa.copy(e.ray).applyMatrix4(Hd);
        const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, c = this.isLineSegments ? 2 : 1, u = i.index, h = i.attributes.position;
        if (u !== null) {
          const d = Math.max(0, a.start), p = Math.min(u.count, a.start + a.count);
          for (let f = d, _ = p - 1; f < _; f += c) {
            const g = u.getX(f), m = u.getX(f + 1), y = Bo(this, e, xa, l, g, m, f);
            y && t.push(y);
          }
          if (this.isLineLoop) {
            const f = u.getX(p - 1), _ = u.getX(d), g = Bo(this, e, xa, l, f, _, p - 1);
            g && t.push(g);
          }
        } else {
          const d = Math.max(0, a.start), p = Math.min(h.count, a.start + a.count);
          for (let f = d, _ = p - 1; f < _; f += c) {
            const g = Bo(this, e, xa, l, f, f + 1, f);
            g && t.push(g);
          }
          if (this.isLineLoop) {
            const f = Bo(this, e, xa, l, p - 1, d, p - 1);
            f && t.push(f);
          }
        }
      }
      updateMorphTargets() {
        const e = this.geometry.morphAttributes, t = Object.keys(e);
        if (t.length > 0) {
          const i = e[t[0]];
          if (i !== void 0) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let n = 0, s = i.length; n < s; n++) {
              const a = i[n].name || String(n);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = n;
            }
          }
        }
      }
    }
    function Bo(r, e, t, i, n, s, a) {
      const o = r.geometry.attributes.position;
      if (Oo.fromBufferAttribute(o, n), No.fromBufferAttribute(o, s), t.distanceSqToSegment(Oo, No, Xc, Vd) > i) return;
      Xc.applyMatrix4(r.matrixWorld);
      const l = e.ray.origin.distanceTo(Xc);
      if (!(l < e.near || l > e.far)) return {
        distance: l,
        point: Vd.clone().applyMatrix4(r.matrixWorld),
        index: a,
        face: null,
        faceIndex: null,
        barycoord: null,
        object: r
      };
    }
    const Gd = new D(), Wd = new D();
    class F_ extends jc {
      constructor(e, t) {
        super(e, t), this.isLineSegments = true, this.type = "LineSegments";
      }
      computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
          const t = e.attributes.position, i = [];
          for (let n = 0, s = t.count; n < s; n += 2) Gd.fromBufferAttribute(t, n), Wd.fromBufferAttribute(t, n + 1), i[n] = n === 0 ? 0 : i[n - 1], i[n + 1] = i[n] + Gd.distanceTo(Wd);
          e.setAttribute("lineDistance", new Wt(i, 1));
        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this;
      }
    }
    class B_ extends jc {
      constructor(e, t) {
        super(e, t), this.isLineLoop = true, this.type = "LineLoop";
      }
    }
    class qc extends Ji {
      constructor(e) {
        super(), this.isPointsMaterial = true, this.type = "PointsMaterial", this.color = new Ae(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = true, this.fog = true, this.setValues(e);
      }
      copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
      }
    }
    const Xd = new Fe(), Yc = new fa(), zo = new Ki(), ko = new D();
    class jd extends xt {
      constructor(e = new hi(), t = new qc()) {
        super(), this.isPoints = true, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets();
      }
      copy(e, t) {
        return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
      }
      raycast(e, t) {
        const i = this.geometry, n = this.matrixWorld, s = e.params.Points.threshold, a = i.drawRange;
        if (i.boundingSphere === null && i.computeBoundingSphere(), zo.copy(i.boundingSphere), zo.applyMatrix4(n), zo.radius += s, e.ray.intersectsSphere(zo) === false) return;
        Xd.copy(n).invert(), Yc.copy(e.ray).applyMatrix4(Xd);
        const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = o * o, c = i.index, u = i.attributes.position;
        if (c !== null) {
          const h = Math.max(0, a.start), d = Math.min(c.count, a.start + a.count);
          for (let p = h, f = d; p < f; p++) {
            const _ = c.getX(p);
            ko.fromBufferAttribute(u, _), qd(ko, _, l, n, e, t, this);
          }
        } else {
          const h = Math.max(0, a.start), d = Math.min(u.count, a.start + a.count);
          for (let p = h, f = d; p < f; p++) ko.fromBufferAttribute(u, p), qd(ko, p, l, n, e, t, this);
        }
      }
      updateMorphTargets() {
        const e = this.geometry.morphAttributes, t = Object.keys(e);
        if (t.length > 0) {
          const i = e[t[0]];
          if (i !== void 0) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let n = 0, s = i.length; n < s; n++) {
              const a = i[n].name || String(n);
              this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = n;
            }
          }
        }
      }
    }
    function qd(r, e, t, i, n, s, a) {
      const o = Yc.distanceSqToPoint(r);
      if (o < t) {
        const l = new D();
        Yc.closestPointToPoint(r, l), l.applyMatrix4(i);
        const c = n.ray.origin.distanceTo(l);
        if (c < n.near || c > n.far) return;
        s.push({
          distance: c,
          distanceToRay: Math.sqrt(o),
          point: l,
          index: e,
          face: null,
          faceIndex: null,
          barycoord: null,
          object: a
        });
      }
    }
    class z_ extends Nt {
      constructor(e, t, i, n, s, a, o, l, c) {
        super(e, t, i, n, s, a, o, l, c), this.isCanvasTexture = true, this.needsUpdate = true;
      }
    }
    class Yd extends Nt {
      constructor(e, t, i, n, s, a, o, l, c, u = Zn) {
        if (u !== Zn && u !== Jn) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        i === void 0 && u === Zn && (i = an), i === void 0 && u === Jn && (i = Kn), super(null, n, s, a, o, l, u, i, c), this.isDepthTexture = true, this.image = {
          width: e,
          height: t
        }, this.magFilter = o !== void 0 ? o : ri, this.minFilter = l !== void 0 ? l : ri, this.flipY = false, this.generateMipmaps = false, this.compareFunction = null;
      }
      copy(e) {
        return super.copy(e), this.compareFunction = e.compareFunction, this;
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
      }
    }
    class Qi {
      constructor() {
        this.type = "Curve", this.arcLengthDivisions = 200;
      }
      getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null;
      }
      getPointAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getPoint(i, t);
      }
      getPoints(e = 5) {
        const t = [];
        for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
        return t;
      }
      getSpacedPoints(e = 5) {
        const t = [];
        for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
        return t;
      }
      getLength() {
        const e = this.getLengths();
        return e[e.length - 1];
      }
      getLengths(e = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = false;
        const t = [];
        let i, n = this.getPoint(0), s = 0;
        t.push(0);
        for (let a = 1; a <= e; a++) i = this.getPoint(a / e), s += i.distanceTo(n), t.push(s), n = i;
        return this.cacheArcLengths = t, t;
      }
      updateArcLengths() {
        this.needsUpdate = true, this.getLengths();
      }
      getUtoTmapping(e, t) {
        const i = this.getLengths();
        let n = 0;
        const s = i.length;
        let a;
        t ? a = t : a = e * i[s - 1];
        let o = 0, l = s - 1, c;
        for (; o <= l; ) if (n = Math.floor(o + (l - o) / 2), c = i[n] - a, c < 0) o = n + 1;
        else if (c > 0) l = n - 1;
        else {
          l = n;
          break;
        }
        if (n = l, i[n] === a) return n / (s - 1);
        const u = i[n], h = i[n + 1] - u, d = (a - u) / h;
        return (n + d) / (s - 1);
      }
      getTangent(e, t) {
        let i = e - 1e-4, n = e + 1e-4;
        i < 0 && (i = 0), n > 1 && (n = 1);
        const s = this.getPoint(i), a = this.getPoint(n), o = t || (s.isVector2 ? new ee() : new D());
        return o.copy(a).sub(s).normalize(), o;
      }
      getTangentAt(e, t) {
        const i = this.getUtoTmapping(e);
        return this.getTangent(i, t);
      }
      computeFrenetFrames(e, t) {
        const i = new D(), n = [], s = [], a = [], o = new D(), l = new Fe();
        for (let p = 0; p <= e; p++) {
          const f = p / e;
          n[p] = this.getTangentAt(f, new D());
        }
        s[0] = new D(), a[0] = new D();
        let c = Number.MAX_VALUE;
        const u = Math.abs(n[0].x), h = Math.abs(n[0].y), d = Math.abs(n[0].z);
        u <= c && (c = u, i.set(1, 0, 0)), h <= c && (c = h, i.set(0, 1, 0)), d <= c && i.set(0, 0, 1), o.crossVectors(n[0], i).normalize(), s[0].crossVectors(n[0], o), a[0].crossVectors(n[0], s[0]);
        for (let p = 1; p <= e; p++) {
          if (s[p] = s[p - 1].clone(), a[p] = a[p - 1].clone(), o.crossVectors(n[p - 1], n[p]), o.length() > Number.EPSILON) {
            o.normalize();
            const f = Math.acos(Ge(n[p - 1].dot(n[p]), -1, 1));
            s[p].applyMatrix4(l.makeRotationAxis(o, f));
          }
          a[p].crossVectors(n[p], s[p]);
        }
        if (t === true) {
          let p = Math.acos(Ge(s[0].dot(s[e]), -1, 1));
          p /= e, n[0].dot(o.crossVectors(s[0], s[e])) > 0 && (p = -p);
          for (let f = 1; f <= e; f++) s[f].applyMatrix4(l.makeRotationAxis(n[f], p * f)), a[f].crossVectors(n[f], s[f]);
        }
        return {
          tangents: n,
          normals: s,
          binormals: a
        };
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions, this;
      }
      toJSON() {
        const e = {
          metadata: {
            version: 4.6,
            type: "Curve",
            generator: "Curve.toJSON"
          }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e;
      }
      fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions, this;
      }
    }
    class Kc extends Qi {
      constructor(e = 0, t = 0, i = 1, n = 1, s = 0, a = Math.PI * 2, o = false, l = 0) {
        super(), this.isEllipseCurve = true, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = n, this.aStartAngle = s, this.aEndAngle = a, this.aClockwise = o, this.aRotation = l;
      }
      getPoint(e, t = new ee()) {
        const i = t, n = Math.PI * 2;
        let s = this.aEndAngle - this.aStartAngle;
        const a = Math.abs(s) < Number.EPSILON;
        for (; s < 0; ) s += n;
        for (; s > n; ) s -= n;
        s < Number.EPSILON && (a ? s = 0 : s = n), this.aClockwise === true && !a && (s === n ? s = -n : s = s - n);
        const o = this.aStartAngle + e * s;
        let l = this.aX + this.xRadius * Math.cos(o), c = this.aY + this.yRadius * Math.sin(o);
        if (this.aRotation !== 0) {
          const u = Math.cos(this.aRotation), h = Math.sin(this.aRotation), d = l - this.aX, p = c - this.aY;
          l = d * u - p * h + this.aX, c = d * h + p * u + this.aY;
        }
        return i.set(l, c);
      }
      copy(e) {
        return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
      }
      toJSON() {
        const e = super.toJSON();
        return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e;
      }
      fromJSON(e) {
        return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this;
      }
    }
    class k_ extends Kc {
      constructor(e, t, i, n, s, a) {
        super(e, t, i, i, n, s, a), this.isArcCurve = true, this.type = "ArcCurve";
      }
    }
    function Zc() {
      let r = 0, e = 0, t = 0, i = 0;
      function n(s, a, o, l) {
        r = s, e = o, t = -3 * s + 3 * a - 2 * o - l, i = 2 * s - 2 * a + o + l;
      }
      return {
        initCatmullRom: function(s, a, o, l, c) {
          n(a, o, c * (o - s), c * (l - a));
        },
        initNonuniformCatmullRom: function(s, a, o, l, c, u, h) {
          let d = (a - s) / c - (o - s) / (c + u) + (o - a) / u, p = (o - a) / u - (l - a) / (u + h) + (l - o) / h;
          d *= u, p *= u, n(a, o, d, p);
        },
        calc: function(s) {
          const a = s * s, o = a * s;
          return r + e * s + t * a + i * o;
        }
      };
    }
    const Ho = new D(), Jc = new Zc(), $c = new Zc(), Qc = new Zc();
    class H_ extends Qi {
      constructor(e = [], t = false, i = "centripetal", n = 0.5) {
        super(), this.isCatmullRomCurve3 = true, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = n;
      }
      getPoint(e, t = new D()) {
        const i = t, n = this.points, s = n.length, a = (s - (this.closed ? 0 : 1)) * e;
        let o = Math.floor(a), l = a - o;
        this.closed ? o += o > 0 ? 0 : (Math.floor(Math.abs(o) / s) + 1) * s : l === 0 && o === s - 1 && (o = s - 2, l = 1);
        let c, u;
        this.closed || o > 0 ? c = n[(o - 1) % s] : (Ho.subVectors(n[0], n[1]).add(n[0]), c = Ho);
        const h = n[o % s], d = n[(o + 1) % s];
        if (this.closed || o + 2 < s ? u = n[(o + 2) % s] : (Ho.subVectors(n[s - 1], n[s - 2]).add(n[s - 1]), u = Ho), this.curveType === "centripetal" || this.curveType === "chordal") {
          const p = this.curveType === "chordal" ? 0.5 : 0.25;
          let f = Math.pow(c.distanceToSquared(h), p), _ = Math.pow(h.distanceToSquared(d), p), g = Math.pow(d.distanceToSquared(u), p);
          _ < 1e-4 && (_ = 1), f < 1e-4 && (f = _), g < 1e-4 && (g = _), Jc.initNonuniformCatmullRom(c.x, h.x, d.x, u.x, f, _, g), $c.initNonuniformCatmullRom(c.y, h.y, d.y, u.y, f, _, g), Qc.initNonuniformCatmullRom(c.z, h.z, d.z, u.z, f, _, g);
        } else this.curveType === "catmullrom" && (Jc.initCatmullRom(c.x, h.x, d.x, u.x, this.tension), $c.initCatmullRom(c.y, h.y, d.y, u.y, this.tension), Qc.initCatmullRom(c.z, h.z, d.z, u.z, this.tension));
        return i.set(Jc.calc(l), $c.calc(l), Qc.calc(l)), i;
      }
      copy(e) {
        super.copy(e), this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
          const n = e.points[t];
          this.points.push(n.clone());
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
      }
      toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
          const n = this.points[t];
          e.points.push(n.toArray());
        }
        return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e;
      }
      fromJSON(e) {
        super.fromJSON(e), this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
          const n = e.points[t];
          this.points.push(new D().fromArray(n));
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this;
      }
    }
    function Kd(r, e, t, i, n) {
      const s = (i - e) * 0.5, a = (n - t) * 0.5, o = r * r, l = r * o;
      return (2 * t - 2 * i + s + a) * l + (-3 * t + 3 * i - 2 * s - a) * o + s * r + t;
    }
    function V_(r, e) {
      const t = 1 - r;
      return t * t * e;
    }
    function G_(r, e) {
      return 2 * (1 - r) * r * e;
    }
    function W_(r, e) {
      return r * r * e;
    }
    function ya(r, e, t, i) {
      return V_(r, e) + G_(r, t) + W_(r, i);
    }
    function X_(r, e) {
      const t = 1 - r;
      return t * t * t * e;
    }
    function j_(r, e) {
      const t = 1 - r;
      return 3 * t * t * r * e;
    }
    function q_(r, e) {
      return 3 * (1 - r) * r * r * e;
    }
    function Y_(r, e) {
      return r * r * r * e;
    }
    function Ma(r, e, t, i, n) {
      return X_(r, e) + j_(r, t) + q_(r, i) + Y_(r, n);
    }
    class Zd extends Qi {
      constructor(e = new ee(), t = new ee(), i = new ee(), n = new ee()) {
        super(), this.isCubicBezierCurve = true, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n;
      }
      getPoint(e, t = new ee()) {
        const i = t, n = this.v0, s = this.v1, a = this.v2, o = this.v3;
        return i.set(Ma(e, n.x, s.x, a.x, o.x), Ma(e, n.y, s.y, a.y, o.y)), i;
      }
      copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
      }
      toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
      }
      fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
      }
    }
    class K_ extends Qi {
      constructor(e = new D(), t = new D(), i = new D(), n = new D()) {
        super(), this.isCubicBezierCurve3 = true, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = n;
      }
      getPoint(e, t = new D()) {
        const i = t, n = this.v0, s = this.v1, a = this.v2, o = this.v3;
        return i.set(Ma(e, n.x, s.x, a.x, o.x), Ma(e, n.y, s.y, a.y, o.y), Ma(e, n.z, s.z, a.z, o.z)), i;
      }
      copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this;
      }
      toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e;
      }
      fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this;
      }
    }
    class Jd extends Qi {
      constructor(e = new ee(), t = new ee()) {
        super(), this.isLineCurve = true, this.type = "LineCurve", this.v1 = e, this.v2 = t;
      }
      getPoint(e, t = new ee()) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
      }
      getPointAt(e, t) {
        return this.getPoint(e, t);
      }
      getTangent(e, t = new ee()) {
        return t.subVectors(this.v2, this.v1).normalize();
      }
      getTangentAt(e, t) {
        return this.getTangent(e, t);
      }
      copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
      }
      toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
      }
      fromJSON(e) {
        return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
      }
    }
    class Z_ extends Qi {
      constructor(e = new D(), t = new D()) {
        super(), this.isLineCurve3 = true, this.type = "LineCurve3", this.v1 = e, this.v2 = t;
      }
      getPoint(e, t = new D()) {
        const i = t;
        return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i;
      }
      getPointAt(e, t) {
        return this.getPoint(e, t);
      }
      getTangent(e, t = new D()) {
        return t.subVectors(this.v2, this.v1).normalize();
      }
      getTangentAt(e, t) {
        return this.getTangent(e, t);
      }
      copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
      }
      toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
      }
      fromJSON(e) {
        return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
      }
    }
    class $d extends Qi {
      constructor(e = new ee(), t = new ee(), i = new ee()) {
        super(), this.isQuadraticBezierCurve = true, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i;
      }
      getPoint(e, t = new ee()) {
        const i = t, n = this.v0, s = this.v1, a = this.v2;
        return i.set(ya(e, n.x, s.x, a.x), ya(e, n.y, s.y, a.y)), i;
      }
      copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
      }
      toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
      }
      fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
      }
    }
    class J_ extends Qi {
      constructor(e = new D(), t = new D(), i = new D()) {
        super(), this.isQuadraticBezierCurve3 = true, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i;
      }
      getPoint(e, t = new D()) {
        const i = t, n = this.v0, s = this.v1, a = this.v2;
        return i.set(ya(e, n.x, s.x, a.x), ya(e, n.y, s.y, a.y), ya(e, n.z, s.z, a.z)), i;
      }
      copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
      }
      toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e;
      }
      fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this;
      }
    }
    class Qd extends Qi {
      constructor(e = []) {
        super(), this.isSplineCurve = true, this.type = "SplineCurve", this.points = e;
      }
      getPoint(e, t = new ee()) {
        const i = t, n = this.points, s = (n.length - 1) * e, a = Math.floor(s), o = s - a, l = n[a === 0 ? a : a - 1], c = n[a], u = n[a > n.length - 2 ? n.length - 1 : a + 1], h = n[a > n.length - 3 ? n.length - 1 : a + 2];
        return i.set(Kd(o, l.x, c.x, u.x, h.x), Kd(o, l.y, c.y, u.y, h.y)), i;
      }
      copy(e) {
        super.copy(e), this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
          const n = e.points[t];
          this.points.push(n.clone());
        }
        return this;
      }
      toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, i = this.points.length; t < i; t++) {
          const n = this.points[t];
          e.points.push(n.toArray());
        }
        return e;
      }
      fromJSON(e) {
        super.fromJSON(e), this.points = [];
        for (let t = 0, i = e.points.length; t < i; t++) {
          const n = e.points[t];
          this.points.push(new ee().fromArray(n));
        }
        return this;
      }
    }
    var eu = Object.freeze({
      __proto__: null,
      ArcCurve: k_,
      CatmullRomCurve3: H_,
      CubicBezierCurve: Zd,
      CubicBezierCurve3: K_,
      EllipseCurve: Kc,
      LineCurve: Jd,
      LineCurve3: Z_,
      QuadraticBezierCurve: $d,
      QuadraticBezierCurve3: J_,
      SplineCurve: Qd
    });
    class $_ extends Qi {
      constructor() {
        super(), this.type = "CurvePath", this.curves = [], this.autoClose = false;
      }
      add(e) {
        this.curves.push(e);
      }
      closePath() {
        const e = this.curves[0].getPoint(0), t = this.curves[this.curves.length - 1].getPoint(1);
        if (!e.equals(t)) {
          const i = e.isVector2 === true ? "LineCurve" : "LineCurve3";
          this.curves.push(new eu[i](t, e));
        }
        return this;
      }
      getPoint(e, t) {
        const i = e * this.getLength(), n = this.getCurveLengths();
        let s = 0;
        for (; s < n.length; ) {
          if (n[s] >= i) {
            const a = n[s] - i, o = this.curves[s], l = o.getLength(), c = l === 0 ? 0 : 1 - a / l;
            return o.getPointAt(c, t);
          }
          s++;
        }
        return null;
      }
      getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1];
      }
      updateArcLengths() {
        this.needsUpdate = true, this.cacheLengths = null, this.getCurveLengths();
      }
      getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let i = 0, n = this.curves.length; i < n; i++) t += this.curves[i].getLength(), e.push(t);
        return this.cacheLengths = e, e;
      }
      getSpacedPoints(e = 40) {
        const t = [];
        for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
        return this.autoClose && t.push(t[0]), t;
      }
      getPoints(e = 12) {
        const t = [];
        let i;
        for (let n = 0, s = this.curves; n < s.length; n++) {
          const a = s[n], o = a.isEllipseCurve ? e * 2 : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e, l = a.getPoints(o);
          for (let c = 0; c < l.length; c++) {
            const u = l[c];
            i && i.equals(u) || (t.push(u), i = u);
          }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t;
      }
      copy(e) {
        super.copy(e), this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
          const n = e.curves[t];
          this.curves.push(n.clone());
        }
        return this.autoClose = e.autoClose, this;
      }
      toJSON() {
        const e = super.toJSON();
        e.autoClose = this.autoClose, e.curves = [];
        for (let t = 0, i = this.curves.length; t < i; t++) {
          const n = this.curves[t];
          e.curves.push(n.toJSON());
        }
        return e;
      }
      fromJSON(e) {
        super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
        for (let t = 0, i = e.curves.length; t < i; t++) {
          const n = e.curves[t];
          this.curves.push(new eu[n.type]().fromJSON(n));
        }
        return this;
      }
    }
    class tu extends $_ {
      constructor(e) {
        super(), this.type = "Path", this.currentPoint = new ee(), e && this.setFromPoints(e);
      }
      setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
        return this;
      }
      moveTo(e, t) {
        return this.currentPoint.set(e, t), this;
      }
      lineTo(e, t) {
        const i = new Jd(this.currentPoint.clone(), new ee(e, t));
        return this.curves.push(i), this.currentPoint.set(e, t), this;
      }
      quadraticCurveTo(e, t, i, n) {
        const s = new $d(this.currentPoint.clone(), new ee(e, t), new ee(i, n));
        return this.curves.push(s), this.currentPoint.set(i, n), this;
      }
      bezierCurveTo(e, t, i, n, s, a) {
        const o = new Zd(this.currentPoint.clone(), new ee(e, t), new ee(i, n), new ee(s, a));
        return this.curves.push(o), this.currentPoint.set(s, a), this;
      }
      splineThru(e) {
        const t = [
          this.currentPoint.clone()
        ].concat(e), i = new Qd(t);
        return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
      }
      arc(e, t, i, n, s, a) {
        const o = this.currentPoint.x, l = this.currentPoint.y;
        return this.absarc(e + o, t + l, i, n, s, a), this;
      }
      absarc(e, t, i, n, s, a) {
        return this.absellipse(e, t, i, i, n, s, a), this;
      }
      ellipse(e, t, i, n, s, a, o, l) {
        const c = this.currentPoint.x, u = this.currentPoint.y;
        return this.absellipse(e + c, t + u, i, n, s, a, o, l), this;
      }
      absellipse(e, t, i, n, s, a, o, l) {
        const c = new Kc(e, t, i, n, s, a, o, l);
        if (this.curves.length > 0) {
          const h = c.getPoint(0);
          h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
        }
        this.curves.push(c);
        const u = c.getPoint(1);
        return this.currentPoint.copy(u), this;
      }
      copy(e) {
        return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
      }
      toJSON() {
        const e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(), e;
      }
      fromJSON(e) {
        return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
      }
    }
    class Vo extends tu {
      constructor(e) {
        super(e), this.uuid = Ci(), this.type = "Shape", this.holes = [];
      }
      getPointsHoles(e) {
        const t = [];
        for (let i = 0, n = this.holes.length; i < n; i++) t[i] = this.holes[i].getPoints(e);
        return t;
      }
      extractPoints(e) {
        return {
          shape: this.getPoints(e),
          holes: this.getPointsHoles(e)
        };
      }
      copy(e) {
        super.copy(e), this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
          const n = e.holes[t];
          this.holes.push(n.clone());
        }
        return this;
      }
      toJSON() {
        const e = super.toJSON();
        e.uuid = this.uuid, e.holes = [];
        for (let t = 0, i = this.holes.length; t < i; t++) {
          const n = this.holes[t];
          e.holes.push(n.toJSON());
        }
        return e;
      }
      fromJSON(e) {
        super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
        for (let t = 0, i = e.holes.length; t < i; t++) {
          const n = e.holes[t];
          this.holes.push(new tu().fromJSON(n));
        }
        return this;
      }
    }
    const Q_ = {
      triangulate: function(r, e, t = 2) {
        const i = e && e.length, n = i ? e[0] * t : r.length;
        let s = ep(r, 0, n, t, true);
        const a = [];
        if (!s || s.next === s.prev) return a;
        let o, l, c, u, h, d, p;
        if (i && (s = nv(r, e, s, t)), r.length > 80 * t) {
          o = c = r[0], l = u = r[1];
          for (let f = t; f < n; f += t) h = r[f], d = r[f + 1], h < o && (o = h), d < l && (l = d), h > c && (c = h), d > u && (u = d);
          p = Math.max(c - o, u - l), p = p !== 0 ? 32767 / p : 0;
        }
        return ba(s, a, t, o, l, p, 0), a;
      }
    };
    function ep(r, e, t, i, n) {
      let s, a;
      if (n === mv(r, e, t, i) > 0) for (s = e; s < t; s += i) a = rp(s, r[s], r[s + 1], a);
      else for (s = t - i; s >= e; s -= i) a = rp(s, r[s], r[s + 1], a);
      return a && Go(a, a.next) && (Ea(a), a = a.next), a;
    }
    function pn(r, e) {
      if (!r) return r;
      e || (e = r);
      let t = r, i;
      do
        if (i = false, !t.steiner && (Go(t, t.next) || yt(t.prev, t, t.next) === 0)) {
          if (Ea(t), t = e = t.prev, t === t.next) break;
          i = true;
        } else t = t.next;
      while (i || t !== e);
      return e;
    }
    function ba(r, e, t, i, n, s, a) {
      if (!r) return;
      !a && s && cv(r, i, n, s);
      let o = r, l, c;
      for (; r.prev !== r.next; ) {
        if (l = r.prev, c = r.next, s ? tv(r, i, n, s) : ev(r)) {
          e.push(l.i / t | 0), e.push(r.i / t | 0), e.push(c.i / t | 0), Ea(r), r = c.next, o = c.next;
          continue;
        }
        if (r = c, r === o) {
          a ? a === 1 ? (r = iv(pn(r), e, t), ba(r, e, t, i, n, s, 2)) : a === 2 && rv(r, e, t, i, n, s) : ba(pn(r), e, t, i, n, s, 1);
          break;
        }
      }
    }
    function ev(r) {
      const e = r.prev, t = r, i = r.next;
      if (yt(e, t, i) >= 0) return false;
      const n = e.x, s = t.x, a = i.x, o = e.y, l = t.y, c = i.y, u = n < s ? n < a ? n : a : s < a ? s : a, h = o < l ? o < c ? o : c : l < c ? l : c, d = n > s ? n > a ? n : a : s > a ? s : a, p = o > l ? o > c ? o : c : l > c ? l : c;
      let f = i.next;
      for (; f !== e; ) {
        if (f.x >= u && f.x <= d && f.y >= h && f.y <= p && _s(n, o, s, l, a, c, f.x, f.y) && yt(f.prev, f, f.next) >= 0) return false;
        f = f.next;
      }
      return true;
    }
    function tv(r, e, t, i) {
      const n = r.prev, s = r, a = r.next;
      if (yt(n, s, a) >= 0) return false;
      const o = n.x, l = s.x, c = a.x, u = n.y, h = s.y, d = a.y, p = o < l ? o < c ? o : c : l < c ? l : c, f = u < h ? u < d ? u : d : h < d ? h : d, _ = o > l ? o > c ? o : c : l > c ? l : c, g = u > h ? u > d ? u : d : h > d ? h : d, m = iu(p, f, e, t, i), y = iu(_, g, e, t, i);
      let x = r.prevZ, v = r.nextZ;
      for (; x && x.z >= m && v && v.z <= y; ) {
        if (x.x >= p && x.x <= _ && x.y >= f && x.y <= g && x !== n && x !== a && _s(o, u, l, h, c, d, x.x, x.y) && yt(x.prev, x, x.next) >= 0 || (x = x.prevZ, v.x >= p && v.x <= _ && v.y >= f && v.y <= g && v !== n && v !== a && _s(o, u, l, h, c, d, v.x, v.y) && yt(v.prev, v, v.next) >= 0)) return false;
        v = v.nextZ;
      }
      for (; x && x.z >= m; ) {
        if (x.x >= p && x.x <= _ && x.y >= f && x.y <= g && x !== n && x !== a && _s(o, u, l, h, c, d, x.x, x.y) && yt(x.prev, x, x.next) >= 0) return false;
        x = x.prevZ;
      }
      for (; v && v.z <= y; ) {
        if (v.x >= p && v.x <= _ && v.y >= f && v.y <= g && v !== n && v !== a && _s(o, u, l, h, c, d, v.x, v.y) && yt(v.prev, v, v.next) >= 0) return false;
        v = v.nextZ;
      }
      return true;
    }
    function iv(r, e, t) {
      let i = r;
      do {
        const n = i.prev, s = i.next.next;
        !Go(n, s) && tp(n, i, i.next, s) && Sa(n, s) && Sa(s, n) && (e.push(n.i / t | 0), e.push(i.i / t | 0), e.push(s.i / t | 0), Ea(i), Ea(i.next), i = r = s), i = i.next;
      } while (i !== r);
      return pn(i);
    }
    function rv(r, e, t, i, n, s) {
      let a = r;
      do {
        let o = a.next.next;
        for (; o !== a.prev; ) {
          if (a.i !== o.i && dv(a, o)) {
            let l = ip(a, o);
            a = pn(a, a.next), l = pn(l, l.next), ba(a, e, t, i, n, s, 0), ba(l, e, t, i, n, s, 0);
            return;
          }
          o = o.next;
        }
        a = a.next;
      } while (a !== r);
    }
    function nv(r, e, t, i) {
      const n = [];
      let s, a, o, l, c;
      for (s = 0, a = e.length; s < a; s++) o = e[s] * i, l = s < a - 1 ? e[s + 1] * i : r.length, c = ep(r, o, l, i, false), c === c.next && (c.steiner = true), n.push(hv(c));
      for (n.sort(sv), s = 0; s < n.length; s++) t = av(n[s], t);
      return t;
    }
    function sv(r, e) {
      return r.x - e.x;
    }
    function av(r, e) {
      const t = ov(r, e);
      if (!t) return e;
      const i = ip(t, r);
      return pn(i, i.next), pn(t, t.next);
    }
    function ov(r, e) {
      let t = e, i = -1 / 0, n;
      const s = r.x, a = r.y;
      do {
        if (a <= t.y && a >= t.next.y && t.next.y !== t.y) {
          const d = t.x + (a - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
          if (d <= s && d > i && (i = d, n = t.x < t.next.x ? t : t.next, d === s)) return n;
        }
        t = t.next;
      } while (t !== e);
      if (!n) return null;
      const o = n, l = n.x, c = n.y;
      let u = 1 / 0, h;
      t = n;
      do
        s >= t.x && t.x >= l && s !== t.x && _s(a < c ? s : i, a, l, c, a < c ? i : s, a, t.x, t.y) && (h = Math.abs(a - t.y) / (s - t.x), Sa(t, r) && (h < u || h === u && (t.x > n.x || t.x === n.x && lv(n, t))) && (n = t, u = h)), t = t.next;
      while (t !== o);
      return n;
    }
    function lv(r, e) {
      return yt(r.prev, r, e.prev) < 0 && yt(e.next, r, r.next) < 0;
    }
    function cv(r, e, t, i) {
      let n = r;
      do
        n.z === 0 && (n.z = iu(n.x, n.y, e, t, i)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next;
      while (n !== r);
      n.prevZ.nextZ = null, n.prevZ = null, uv(n);
    }
    function uv(r) {
      let e, t, i, n, s, a, o, l, c = 1;
      do {
        for (t = r, r = null, s = null, a = 0; t; ) {
          for (a++, i = t, o = 0, e = 0; e < c && (o++, i = i.nextZ, !!i); e++) ;
          for (l = c; o > 0 || l > 0 && i; ) o !== 0 && (l === 0 || !i || t.z <= i.z) ? (n = t, t = t.nextZ, o--) : (n = i, i = i.nextZ, l--), s ? s.nextZ = n : r = n, n.prevZ = s, s = n;
          t = i;
        }
        s.nextZ = null, c *= 2;
      } while (a > 1);
      return r;
    }
    function iu(r, e, t, i, n) {
      return r = (r - t) * n | 0, e = (e - i) * n | 0, r = (r | r << 8) & 16711935, r = (r | r << 4) & 252645135, r = (r | r << 2) & 858993459, r = (r | r << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, r | e << 1;
    }
    function hv(r) {
      let e = r, t = r;
      do
        (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next;
      while (e !== r);
      return t;
    }
    function _s(r, e, t, i, n, s, a, o) {
      return (n - a) * (e - o) >= (r - a) * (s - o) && (r - a) * (i - o) >= (t - a) * (e - o) && (t - a) * (s - o) >= (n - a) * (i - o);
    }
    function dv(r, e) {
      return r.next.i !== e.i && r.prev.i !== e.i && !pv(r, e) && (Sa(r, e) && Sa(e, r) && fv(r, e) && (yt(r.prev, r, e.prev) || yt(r, e.prev, e)) || Go(r, e) && yt(r.prev, r, r.next) > 0 && yt(e.prev, e, e.next) > 0);
    }
    function yt(r, e, t) {
      return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y);
    }
    function Go(r, e) {
      return r.x === e.x && r.y === e.y;
    }
    function tp(r, e, t, i) {
      const n = Xo(yt(r, e, t)), s = Xo(yt(r, e, i)), a = Xo(yt(t, i, r)), o = Xo(yt(t, i, e));
      return !!(n !== s && a !== o || n === 0 && Wo(r, t, e) || s === 0 && Wo(r, i, e) || a === 0 && Wo(t, r, i) || o === 0 && Wo(t, e, i));
    }
    function Wo(r, e, t) {
      return e.x <= Math.max(r.x, t.x) && e.x >= Math.min(r.x, t.x) && e.y <= Math.max(r.y, t.y) && e.y >= Math.min(r.y, t.y);
    }
    function Xo(r) {
      return r > 0 ? 1 : r < 0 ? -1 : 0;
    }
    function pv(r, e) {
      let t = r;
      do {
        if (t.i !== r.i && t.next.i !== r.i && t.i !== e.i && t.next.i !== e.i && tp(t, t.next, r, e)) return true;
        t = t.next;
      } while (t !== r);
      return false;
    }
    function Sa(r, e) {
      return yt(r.prev, r, r.next) < 0 ? yt(r, e, r.next) >= 0 && yt(r, r.prev, e) >= 0 : yt(r, e, r.prev) < 0 || yt(r, r.next, e) < 0;
    }
    function fv(r, e) {
      let t = r, i = false;
      const n = (r.x + e.x) / 2, s = (r.y + e.y) / 2;
      do
        t.y > s != t.next.y > s && t.next.y !== t.y && n < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next;
      while (t !== r);
      return i;
    }
    function ip(r, e) {
      const t = new ru(r.i, r.x, r.y), i = new ru(e.i, e.x, e.y), n = r.next, s = e.prev;
      return r.next = e, e.prev = r, t.next = n, n.prev = t, i.next = t, t.prev = i, s.next = i, i.prev = s, i;
    }
    function rp(r, e, t, i) {
      const n = new ru(r, e, t);
      return i ? (n.next = i.next, n.prev = i, i.next.prev = n, i.next = n) : (n.prev = n, n.next = n), n;
    }
    function Ea(r) {
      r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ);
    }
    function ru(r, e, t) {
      this.i = r, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
    }
    function mv(r, e, t, i) {
      let n = 0;
      for (let s = e, a = t - i; s < t; s += i) n += (r[a] - r[s]) * (r[s + 1] + r[a + 1]), a = s;
      return n;
    }
    class vs {
      static area(e) {
        const t = e.length;
        let i = 0;
        for (let n = t - 1, s = 0; s < t; n = s++) i += e[n].x * e[s].y - e[s].x * e[n].y;
        return i * 0.5;
      }
      static isClockWise(e) {
        return vs.area(e) < 0;
      }
      static triangulateShape(e, t) {
        const i = [], n = [], s = [];
        np(e), sp(i, e);
        let a = e.length;
        t.forEach(np);
        for (let l = 0; l < t.length; l++) n.push(a), a += t[l].length, sp(i, t[l]);
        const o = Q_.triangulate(i, n);
        for (let l = 0; l < o.length; l += 3) s.push(o.slice(l, l + 3));
        return s;
      }
    }
    function np(r) {
      const e = r.length;
      e > 2 && r[e - 1].equals(r[0]) && r.pop();
    }
    function sp(r, e) {
      for (let t = 0; t < e.length; t++) r.push(e[t].x), r.push(e[t].y);
    }
    class nu extends hi {
      constructor(e = new Vo([
        new ee(0.5, 0.5),
        new ee(-0.5, 0.5),
        new ee(-0.5, -0.5),
        new ee(0.5, -0.5)
      ]), t = {}) {
        super(), this.type = "ExtrudeGeometry", this.parameters = {
          shapes: e,
          options: t
        }, e = Array.isArray(e) ? e : [
          e
        ];
        const i = this, n = [], s = [];
        for (let o = 0, l = e.length; o < l; o++) {
          const c = e[o];
          a(c);
        }
        this.setAttribute("position", new Wt(n, 3)), this.setAttribute("uv", new Wt(s, 2)), this.computeVertexNormals();
        function a(o) {
          const l = [], c = t.curveSegments !== void 0 ? t.curveSegments : 12, u = t.steps !== void 0 ? t.steps : 1, h = t.depth !== void 0 ? t.depth : 1;
          let d = t.bevelEnabled !== void 0 ? t.bevelEnabled : true, p = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2, f = t.bevelSize !== void 0 ? t.bevelSize : p - 0.1, _ = t.bevelOffset !== void 0 ? t.bevelOffset : 0, g = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
          const m = t.extrudePath, y = t.UVGenerator !== void 0 ? t.UVGenerator : gv;
          let x, v = false, A, T, w, R;
          m && (x = m.getSpacedPoints(u), v = true, d = false, A = m.computeFrenetFrames(u, false), T = new D(), w = new D(), R = new D()), d || (g = 0, p = 0, f = 0, _ = 0);
          const E = o.extractPoints(c);
          let b = E.shape;
          const L = E.holes;
          if (!vs.isClockWise(b)) {
            b = b.reverse();
            for (let te = 0, $ = L.length; te < $; te++) {
              const se = L[te];
              vs.isClockWise(se) && (L[te] = se.reverse());
            }
          }
          const B = vs.triangulateShape(b, L), F = b;
          for (let te = 0, $ = L.length; te < $; te++) {
            const se = L[te];
            b = b.concat(se);
          }
          function V(te, $, se) {
            return $ || console.error("THREE.ExtrudeGeometry: vec does not exist"), te.clone().addScaledVector($, se);
          }
          const X = b.length, k = B.length;
          function K(te, $, se) {
            let P, fe, xe;
            const Me = te.x - $.x, oe = te.y - $.y, ke = se.x - te.x, de = se.y - te.y, C = Me * Me + oe * oe, M = Me * de - oe * ke;
            if (Math.abs(M) > Number.EPSILON) {
              const N = Math.sqrt(C), Y = Math.sqrt(ke * ke + de * de), J = $.x - oe / N, q = $.y + Me / N, Te = se.x - de / Y, he = se.y + ke / Y, ye = ((Te - J) * de - (he - q) * ke) / (Me * de - oe * ke);
              P = J + Me * ye - te.x, fe = q + oe * ye - te.y;
              const je = P * P + fe * fe;
              if (je <= 2) return new ee(P, fe);
              xe = Math.sqrt(je / 2);
            } else {
              let N = false;
              Me > Number.EPSILON ? ke > Number.EPSILON && (N = true) : Me < -Number.EPSILON ? ke < -Number.EPSILON && (N = true) : Math.sign(oe) === Math.sign(de) && (N = true), N ? (P = -oe, fe = Me, xe = Math.sqrt(C)) : (P = Me, fe = oe, xe = Math.sqrt(C / 2));
            }
            return new ee(P / xe, fe / xe);
          }
          const G = [];
          for (let te = 0, $ = F.length, se = $ - 1, P = te + 1; te < $; te++, se++, P++) se === $ && (se = 0), P === $ && (P = 0), G[te] = K(F[te], F[se], F[P]);
          const ie = [];
          let ue, we = G.concat();
          for (let te = 0, $ = L.length; te < $; te++) {
            const se = L[te];
            ue = [];
            for (let P = 0, fe = se.length, xe = fe - 1, Me = P + 1; P < fe; P++, xe++, Me++) xe === fe && (xe = 0), Me === fe && (Me = 0), ue[P] = K(se[P], se[xe], se[Me]);
            ie.push(ue), we = we.concat(ue);
          }
          for (let te = 0; te < g; te++) {
            const $ = te / g, se = p * Math.cos($ * Math.PI / 2), P = f * Math.sin($ * Math.PI / 2) + _;
            for (let fe = 0, xe = F.length; fe < xe; fe++) {
              const Me = V(F[fe], G[fe], P);
              _e(Me.x, Me.y, -se);
            }
            for (let fe = 0, xe = L.length; fe < xe; fe++) {
              const Me = L[fe];
              ue = ie[fe];
              for (let oe = 0, ke = Me.length; oe < ke; oe++) {
                const de = V(Me[oe], ue[oe], P);
                _e(de.x, de.y, -se);
              }
            }
          }
          const Be = f + _;
          for (let te = 0; te < X; te++) {
            const $ = d ? V(b[te], we[te], Be) : b[te];
            v ? (w.copy(A.normals[0]).multiplyScalar($.x), T.copy(A.binormals[0]).multiplyScalar($.y), R.copy(x[0]).add(w).add(T), _e(R.x, R.y, R.z)) : _e($.x, $.y, 0);
          }
          for (let te = 1; te <= u; te++) for (let $ = 0; $ < X; $++) {
            const se = d ? V(b[$], we[$], Be) : b[$];
            v ? (w.copy(A.normals[te]).multiplyScalar(se.x), T.copy(A.binormals[te]).multiplyScalar(se.y), R.copy(x[te]).add(w).add(T), _e(R.x, R.y, R.z)) : _e(se.x, se.y, h / u * te);
          }
          for (let te = g - 1; te >= 0; te--) {
            const $ = te / g, se = p * Math.cos($ * Math.PI / 2), P = f * Math.sin($ * Math.PI / 2) + _;
            for (let fe = 0, xe = F.length; fe < xe; fe++) {
              const Me = V(F[fe], G[fe], P);
              _e(Me.x, Me.y, h + se);
            }
            for (let fe = 0, xe = L.length; fe < xe; fe++) {
              const Me = L[fe];
              ue = ie[fe];
              for (let oe = 0, ke = Me.length; oe < ke; oe++) {
                const de = V(Me[oe], ue[oe], P);
                v ? _e(de.x, de.y + x[u - 1].y, x[u - 1].x + se) : _e(de.x, de.y, h + se);
              }
            }
          }
          We(), j();
          function We() {
            const te = n.length / 3;
            if (d) {
              let $ = 0, se = X * $;
              for (let P = 0; P < k; P++) {
                const fe = B[P];
                ae(fe[2] + se, fe[1] + se, fe[0] + se);
              }
              $ = u + g * 2, se = X * $;
              for (let P = 0; P < k; P++) {
                const fe = B[P];
                ae(fe[0] + se, fe[1] + se, fe[2] + se);
              }
            } else {
              for (let $ = 0; $ < k; $++) {
                const se = B[$];
                ae(se[2], se[1], se[0]);
              }
              for (let $ = 0; $ < k; $++) {
                const se = B[$];
                ae(se[0] + X * u, se[1] + X * u, se[2] + X * u);
              }
            }
            i.addGroup(te, n.length / 3 - te, 0);
          }
          function j() {
            const te = n.length / 3;
            let $ = 0;
            re(F, $), $ += F.length;
            for (let se = 0, P = L.length; se < P; se++) {
              const fe = L[se];
              re(fe, $), $ += fe.length;
            }
            i.addGroup(te, n.length / 3 - te, 1);
          }
          function re(te, $) {
            let se = te.length;
            for (; --se >= 0; ) {
              const P = se;
              let fe = se - 1;
              fe < 0 && (fe = te.length - 1);
              for (let xe = 0, Me = u + g * 2; xe < Me; xe++) {
                const oe = X * xe, ke = X * (xe + 1), de = $ + P + oe, C = $ + fe + oe, M = $ + fe + ke, N = $ + P + ke;
                Pe(de, C, M, N);
              }
            }
          }
          function _e(te, $, se) {
            l.push(te), l.push($), l.push(se);
          }
          function ae(te, $, se) {
            Re(te), Re($), Re(se);
            const P = n.length / 3, fe = y.generateTopUV(i, n, P - 3, P - 2, P - 1);
            De(fe[0]), De(fe[1]), De(fe[2]);
          }
          function Pe(te, $, se, P) {
            Re(te), Re($), Re(P), Re($), Re(se), Re(P);
            const fe = n.length / 3, xe = y.generateSideWallUV(i, n, fe - 6, fe - 3, fe - 2, fe - 1);
            De(xe[0]), De(xe[1]), De(xe[3]), De(xe[1]), De(xe[2]), De(xe[3]);
          }
          function Re(te) {
            n.push(l[te * 3 + 0]), n.push(l[te * 3 + 1]), n.push(l[te * 3 + 2]);
          }
          function De(te) {
            s.push(te.x), s.push(te.y);
          }
        }
      }
      copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
      }
      toJSON() {
        const e = super.toJSON(), t = this.parameters.shapes, i = this.parameters.options;
        return _v(t, i, e);
      }
      static fromJSON(e, t) {
        const i = [];
        for (let s = 0, a = e.shapes.length; s < a; s++) {
          const o = t[e.shapes[s]];
          i.push(o);
        }
        const n = e.options.extrudePath;
        return n !== void 0 && (e.options.extrudePath = new eu[n.type]().fromJSON(n)), new nu(i, e.options);
      }
    }
    const gv = {
      generateTopUV: function(r, e, t, i, n) {
        const s = e[t * 3], a = e[t * 3 + 1], o = e[i * 3], l = e[i * 3 + 1], c = e[n * 3], u = e[n * 3 + 1];
        return [
          new ee(s, a),
          new ee(o, l),
          new ee(c, u)
        ];
      },
      generateSideWallUV: function(r, e, t, i, n, s) {
        const a = e[t * 3], o = e[t * 3 + 1], l = e[t * 3 + 2], c = e[i * 3], u = e[i * 3 + 1], h = e[i * 3 + 2], d = e[n * 3], p = e[n * 3 + 1], f = e[n * 3 + 2], _ = e[s * 3], g = e[s * 3 + 1], m = e[s * 3 + 2];
        return Math.abs(o - u) < Math.abs(a - c) ? [
          new ee(a, 1 - l),
          new ee(c, 1 - h),
          new ee(d, 1 - f),
          new ee(_, 1 - m)
        ] : [
          new ee(o, 1 - l),
          new ee(u, 1 - h),
          new ee(p, 1 - f),
          new ee(g, 1 - m)
        ];
      }
    };
    function _v(r, e, t) {
      if (t.shapes = [], Array.isArray(r)) for (let i = 0, n = r.length; i < n; i++) {
        const s = r[i];
        t.shapes.push(s.uuid);
      }
      else t.shapes.push(r.uuid);
      return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t;
    }
    class Ta extends hi {
      constructor(e = 1, t = 1, i = 1, n = 1) {
        super(), this.type = "PlaneGeometry", this.parameters = {
          width: e,
          height: t,
          widthSegments: i,
          heightSegments: n
        };
        const s = e / 2, a = t / 2, o = Math.floor(i), l = Math.floor(n), c = o + 1, u = l + 1, h = e / o, d = t / l, p = [], f = [], _ = [], g = [];
        for (let m = 0; m < u; m++) {
          const y = m * d - a;
          for (let x = 0; x < c; x++) {
            const v = x * h - s;
            f.push(v, -y, 0), _.push(0, 0, 1), g.push(x / o), g.push(1 - m / l);
          }
        }
        for (let m = 0; m < l; m++) for (let y = 0; y < o; y++) {
          const x = y + c * m, v = y + c * (m + 1), A = y + 1 + c * (m + 1), T = y + 1 + c * m;
          p.push(x, v, T), p.push(v, A, T);
        }
        this.setIndex(p), this.setAttribute("position", new Wt(f, 3)), this.setAttribute("normal", new Wt(_, 3)), this.setAttribute("uv", new Wt(g, 2));
      }
      copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
      }
      static fromJSON(e) {
        return new Ta(e.width, e.height, e.widthSegments, e.heightSegments);
      }
    }
    class su extends hi {
      constructor(e = 1, t = 32, i = 16, n = 0, s = Math.PI * 2, a = 0, o = Math.PI) {
        super(), this.type = "SphereGeometry", this.parameters = {
          radius: e,
          widthSegments: t,
          heightSegments: i,
          phiStart: n,
          phiLength: s,
          thetaStart: a,
          thetaLength: o
        }, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i));
        const l = Math.min(a + o, Math.PI);
        let c = 0;
        const u = [], h = new D(), d = new D(), p = [], f = [], _ = [], g = [];
        for (let m = 0; m <= i; m++) {
          const y = [], x = m / i;
          let v = 0;
          m === 0 && a === 0 ? v = 0.5 / t : m === i && l === Math.PI && (v = -0.5 / t);
          for (let A = 0; A <= t; A++) {
            const T = A / t;
            h.x = -e * Math.cos(n + T * s) * Math.sin(a + x * o), h.y = e * Math.cos(a + x * o), h.z = e * Math.sin(n + T * s) * Math.sin(a + x * o), f.push(h.x, h.y, h.z), d.copy(h).normalize(), _.push(d.x, d.y, d.z), g.push(T + v, 1 - x), y.push(c++);
          }
          u.push(y);
        }
        for (let m = 0; m < i; m++) for (let y = 0; y < t; y++) {
          const x = u[m][y + 1], v = u[m][y], A = u[m + 1][y], T = u[m + 1][y + 1];
          (m !== 0 || a > 0) && p.push(x, v, T), (m !== i - 1 || l < Math.PI) && p.push(v, A, T);
        }
        this.setIndex(p), this.setAttribute("position", new Wt(f, 3)), this.setAttribute("normal", new Wt(_, 3)), this.setAttribute("uv", new Wt(g, 2));
      }
      copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
      }
      static fromJSON(e) {
        return new su(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
      }
    }
    class xs extends Ji {
      constructor(e) {
        super(), this.isMeshStandardMaterial = true, this.type = "MeshStandardMaterial", this.defines = {
          STANDARD: ""
        }, this.color = new Ae(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Ae(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Qh, this.normalScale = new ee(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new Zi(), this.envMapIntensity = 1, this.wireframe = false, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = false, this.fog = true, this.setValues(e);
      }
      copy(e) {
        return super.copy(e), this.defines = {
          STANDARD: ""
        }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
      }
    }
    class er extends xs {
      constructor(e) {
        super(), this.isMeshPhysicalMaterial = true, this.defines = {
          STANDARD: "",
          PHYSICAL: ""
        }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new ee(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
          get: function() {
            return Ge(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
          },
          set: function(t) {
            this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
          }
        }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [
          100,
          400
        ], this.iridescenceThicknessMap = null, this.sheenColor = new Ae(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new Ae(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Ae(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
      }
      get anisotropy() {
        return this._anisotropy;
      }
      set anisotropy(e) {
        this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
      }
      get clearcoat() {
        return this._clearcoat;
      }
      set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
      }
      get iridescence() {
        return this._iridescence;
      }
      set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
      }
      get dispersion() {
        return this._dispersion;
      }
      set dispersion(e) {
        this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
      }
      get sheen() {
        return this._sheen;
      }
      set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
      }
      get transmission() {
        return this._transmission;
      }
      set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
      }
      copy(e) {
        return super.copy(e), this.defines = {
          STANDARD: "",
          PHYSICAL: ""
        }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [
          ...e.iridescenceThicknessRange
        ], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
      }
    }
    class vv extends Ji {
      constructor(e) {
        super(), this.isMeshDepthMaterial = true, this.type = "MeshDepthMaterial", this.depthPacking = Rg, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = false, this.wireframeLinewidth = 1, this.setValues(e);
      }
      copy(e) {
        return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this;
      }
    }
    class xv extends Ji {
      constructor(e) {
        super(), this.isMeshDistanceMaterial = true, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e);
      }
      copy(e) {
        return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this;
      }
    }
    function jo(r, e, t) {
      return !r || r.constructor === e ? r : typeof e.BYTES_PER_ELEMENT == "number" ? new e(r) : Array.prototype.slice.call(r);
    }
    function yv(r) {
      return ArrayBuffer.isView(r) && !(r instanceof DataView);
    }
    function Mv(r) {
      function e(n, s) {
        return r[n] - r[s];
      }
      const t = r.length, i = new Array(t);
      for (let n = 0; n !== t; ++n) i[n] = n;
      return i.sort(e), i;
    }
    function ap(r, e, t) {
      const i = r.length, n = new r.constructor(i);
      for (let s = 0, a = 0; a !== i; ++s) {
        const o = t[s] * e;
        for (let l = 0; l !== e; ++l) n[a++] = r[o + l];
      }
      return n;
    }
    function op(r, e, t, i) {
      let n = 1, s = r[0];
      for (; s !== void 0 && s[i] === void 0; ) s = r[n++];
      if (s === void 0) return;
      let a = s[i];
      if (a !== void 0) if (Array.isArray(a)) do
        a = s[i], a !== void 0 && (e.push(s.time), t.push.apply(t, a)), s = r[n++];
      while (s !== void 0);
      else if (a.toArray !== void 0) do
        a = s[i], a !== void 0 && (e.push(s.time), a.toArray(t, t.length)), s = r[n++];
      while (s !== void 0);
      else do
        a = s[i], a !== void 0 && (e.push(s.time), t.push(a)), s = r[n++];
      while (s !== void 0);
    }
    class wa {
      constructor(e, t, i, n) {
        this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = n !== void 0 ? n : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {};
      }
      evaluate(e) {
        const t = this.parameterPositions;
        let i = this._cachedIndex, n = t[i], s = t[i - 1];
        i: {
          e: {
            let a;
            t: {
              r: if (!(e < n)) {
                for (let o = i + 2; ; ) {
                  if (n === void 0) {
                    if (e < s) break r;
                    return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
                  }
                  if (i === o) break;
                  if (s = n, n = t[++i], e < n) break e;
                }
                a = t.length;
                break t;
              }
              if (!(e >= s)) {
                const o = t[1];
                e < o && (i = 2, s = o);
                for (let l = i - 2; ; ) {
                  if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                  if (i === l) break;
                  if (n = s, s = t[--i - 1], e >= s) break e;
                }
                a = i, i = 0;
                break t;
              }
              break i;
            }
            for (; i < a; ) {
              const o = i + a >>> 1;
              e < t[o] ? a = o : i = o + 1;
            }
            if (n = t[i], s = t[i - 1], s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
            if (n === void 0) return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1);
          }
          this._cachedIndex = i, this.intervalChanged_(i, s, n);
        }
        return this.interpolate_(i, s, e, n);
      }
      getSettings_() {
        return this.settings || this.DefaultSettings_;
      }
      copySampleValue_(e) {
        const t = this.resultBuffer, i = this.sampleValues, n = this.valueSize, s = e * n;
        for (let a = 0; a !== n; ++a) t[a] = i[s + a];
        return t;
      }
      interpolate_() {
        throw new Error("call to abstract method");
      }
      intervalChanged_() {
      }
    }
    class bv extends wa {
      constructor(e, t, i, n) {
        super(e, t, i, n), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
          endingStart: Kh,
          endingEnd: Kh
        };
      }
      intervalChanged_(e, t, i) {
        const n = this.parameterPositions;
        let s = e - 2, a = e + 1, o = n[s], l = n[a];
        if (o === void 0) switch (this.getSettings_().endingStart) {
          case Zh:
            s = e, o = 2 * t - i;
            break;
          case Jh:
            s = n.length - 2, o = t + n[s] - n[s + 1];
            break;
          default:
            s = e, o = i;
        }
        if (l === void 0) switch (this.getSettings_().endingEnd) {
          case Zh:
            a = e, l = 2 * i - t;
            break;
          case Jh:
            a = 1, l = i + n[1] - n[0];
            break;
          default:
            a = e - 1, l = t;
        }
        const c = (i - t) * 0.5, u = this.valueSize;
        this._weightPrev = c / (t - o), this._weightNext = c / (l - i), this._offsetPrev = s * u, this._offsetNext = a * u;
      }
      interpolate_(e, t, i, n) {
        const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = e * o, c = l - o, u = this._offsetPrev, h = this._offsetNext, d = this._weightPrev, p = this._weightNext, f = (i - t) / (n - t), _ = f * f, g = _ * f, m = -d * g + 2 * d * _ - d * f, y = (1 + d) * g + (-1.5 - 2 * d) * _ + (-0.5 + d) * f + 1, x = (-1 - p) * g + (1.5 + p) * _ + 0.5 * f, v = p * g - p * _;
        for (let A = 0; A !== o; ++A) s[A] = m * a[u + A] + y * a[c + A] + x * a[l + A] + v * a[h + A];
        return s;
      }
    }
    class Sv extends wa {
      constructor(e, t, i, n) {
        super(e, t, i, n);
      }
      interpolate_(e, t, i, n) {
        const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = e * o, c = l - o, u = (i - t) / (n - t), h = 1 - u;
        for (let d = 0; d !== o; ++d) s[d] = a[c + d] * h + a[l + d] * u;
        return s;
      }
    }
    class Ev extends wa {
      constructor(e, t, i, n) {
        super(e, t, i, n);
      }
      interpolate_(e) {
        return this.copySampleValue_(e - 1);
      }
    }
    class tr {
      constructor(e, t, i, n) {
        if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e, this.times = jo(t, this.TimeBufferType), this.values = jo(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation);
      }
      static toJSON(e) {
        const t = e.constructor;
        let i;
        if (t.toJSON !== this.toJSON) i = t.toJSON(e);
        else {
          i = {
            name: e.name,
            times: jo(e.times, Array),
            values: jo(e.values, Array)
          };
          const n = e.getInterpolation();
          n !== e.DefaultInterpolation && (i.interpolation = n);
        }
        return i.type = e.ValueTypeName, i;
      }
      InterpolantFactoryMethodDiscrete(e) {
        return new Ev(this.times, this.values, this.getValueSize(), e);
      }
      InterpolantFactoryMethodLinear(e) {
        return new Sv(this.times, this.values, this.getValueSize(), e);
      }
      InterpolantFactoryMethodSmooth(e) {
        return new bv(this.times, this.values, this.getValueSize(), e);
      }
      setInterpolation(e) {
        let t;
        switch (e) {
          case oa:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
          case la:
            t = this.InterpolantFactoryMethodLinear;
            break;
          case pc:
            t = this.InterpolantFactoryMethodSmooth;
            break;
        }
        if (t === void 0) {
          const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
          if (this.createInterpolant === void 0) if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
          else throw new Error(i);
          return console.warn("THREE.KeyframeTrack:", i), this;
        }
        return this.createInterpolant = t, this;
      }
      getInterpolation() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return oa;
          case this.InterpolantFactoryMethodLinear:
            return la;
          case this.InterpolantFactoryMethodSmooth:
            return pc;
        }
      }
      getValueSize() {
        return this.values.length / this.times.length;
      }
      shift(e) {
        if (e !== 0) {
          const t = this.times;
          for (let i = 0, n = t.length; i !== n; ++i) t[i] += e;
        }
        return this;
      }
      scale(e) {
        if (e !== 1) {
          const t = this.times;
          for (let i = 0, n = t.length; i !== n; ++i) t[i] *= e;
        }
        return this;
      }
      trim(e, t) {
        const i = this.times, n = i.length;
        let s = 0, a = n - 1;
        for (; s !== n && i[s] < e; ) ++s;
        for (; a !== -1 && i[a] > t; ) --a;
        if (++a, s !== 0 || a !== n) {
          s >= a && (a = Math.max(a, 1), s = a - 1);
          const o = this.getValueSize();
          this.times = i.slice(s, a), this.values = this.values.slice(s * o, a * o);
        }
        return this;
      }
      validate() {
        let e = true;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = false);
        const i = this.times, n = this.values, s = i.length;
        s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = false);
        let a = null;
        for (let o = 0; o !== s; o++) {
          const l = i[o];
          if (typeof l == "number" && isNaN(l)) {
            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, l), e = false;
            break;
          }
          if (a !== null && a > l) {
            console.error("THREE.KeyframeTrack: Out of order keys.", this, o, l, a), e = false;
            break;
          }
          a = l;
        }
        if (n !== void 0 && yv(n)) for (let o = 0, l = n.length; o !== l; ++o) {
          const c = n[o];
          if (isNaN(c)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, c), e = false;
            break;
          }
        }
        return e;
      }
      optimize() {
        const e = this.times.slice(), t = this.values.slice(), i = this.getValueSize(), n = this.getInterpolation() === pc, s = e.length - 1;
        let a = 1;
        for (let o = 1; o < s; ++o) {
          let l = false;
          const c = e[o], u = e[o + 1];
          if (c !== u && (o !== 1 || c !== e[0])) if (n) l = true;
          else {
            const h = o * i, d = h - i, p = h + i;
            for (let f = 0; f !== i; ++f) {
              const _ = t[h + f];
              if (_ !== t[d + f] || _ !== t[p + f]) {
                l = true;
                break;
              }
            }
          }
          if (l) {
            if (o !== a) {
              e[a] = e[o];
              const h = o * i, d = a * i;
              for (let p = 0; p !== i; ++p) t[d + p] = t[h + p];
            }
            ++a;
          }
        }
        if (s > 0) {
          e[a] = e[s];
          for (let o = s * i, l = a * i, c = 0; c !== i; ++c) t[l + c] = t[o + c];
          ++a;
        }
        return a !== e.length ? (this.times = e.slice(0, a), this.values = t.slice(0, a * i)) : (this.times = e, this.values = t), this;
      }
      clone() {
        const e = this.times.slice(), t = this.values.slice(), i = this.constructor, n = new i(this.name, e, t);
        return n.createInterpolant = this.createInterpolant, n;
      }
    }
    tr.prototype.TimeBufferType = Float32Array, tr.prototype.ValueBufferType = Float32Array, tr.prototype.DefaultInterpolation = la;
    class ys extends tr {
      constructor(e, t, i) {
        super(e, t, i);
      }
    }
    ys.prototype.ValueTypeName = "bool", ys.prototype.ValueBufferType = Array, ys.prototype.DefaultInterpolation = oa, ys.prototype.InterpolantFactoryMethodLinear = void 0, ys.prototype.InterpolantFactoryMethodSmooth = void 0;
    class lp extends tr {
    }
    lp.prototype.ValueTypeName = "color";
    class Ms extends tr {
    }
    Ms.prototype.ValueTypeName = "number";
    class Tv extends wa {
      constructor(e, t, i, n) {
        super(e, t, i, n);
      }
      interpolate_(e, t, i, n) {
        const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = (i - t) / (n - t);
        let c = e * o;
        for (let u = c + o; c !== u; c += 4) Nr.slerpFlat(s, 0, a, c - o, a, c, l);
        return s;
      }
    }
    class bs extends tr {
      InterpolantFactoryMethodLinear(e) {
        return new Tv(this.times, this.values, this.getValueSize(), e);
      }
    }
    bs.prototype.ValueTypeName = "quaternion", bs.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Ss extends tr {
      constructor(e, t, i) {
        super(e, t, i);
      }
    }
    Ss.prototype.ValueTypeName = "string", Ss.prototype.ValueBufferType = Array, Ss.prototype.DefaultInterpolation = oa, Ss.prototype.InterpolantFactoryMethodLinear = void 0, Ss.prototype.InterpolantFactoryMethodSmooth = void 0;
    class Es extends tr {
    }
    Es.prototype.ValueTypeName = "vector";
    class wv {
      constructor(e = "", t = -1, i = [], n = wg) {
        this.name = e, this.tracks = i, this.duration = t, this.blendMode = n, this.uuid = Ci(), this.duration < 0 && this.resetDuration();
      }
      static parse(e) {
        const t = [], i = e.tracks, n = 1 / (e.fps || 1);
        for (let a = 0, o = i.length; a !== o; ++a) t.push(Rv(i[a]).scale(n));
        const s = new this(e.name, e.duration, t, e.blendMode);
        return s.uuid = e.uuid, s;
      }
      static toJSON(e) {
        const t = [], i = e.tracks, n = {
          name: e.name,
          duration: e.duration,
          tracks: t,
          uuid: e.uuid,
          blendMode: e.blendMode
        };
        for (let s = 0, a = i.length; s !== a; ++s) t.push(tr.toJSON(i[s]));
        return n;
      }
      static CreateFromMorphTargetSequence(e, t, i, n) {
        const s = t.length, a = [];
        for (let o = 0; o < s; o++) {
          let l = [], c = [];
          l.push((o + s - 1) % s, o, (o + 1) % s), c.push(0, 1, 0);
          const u = Mv(l);
          l = ap(l, 1, u), c = ap(c, 1, u), !n && l[0] === 0 && (l.push(s), c.push(c[0])), a.push(new Ms(".morphTargetInfluences[" + t[o].name + "]", l, c).scale(1 / i));
        }
        return new this(e, -1, a);
      }
      static findByName(e, t) {
        let i = e;
        if (!Array.isArray(e)) {
          const n = e;
          i = n.geometry && n.geometry.animations || n.animations;
        }
        for (let n = 0; n < i.length; n++) if (i[n].name === t) return i[n];
        return null;
      }
      static CreateClipsFromMorphTargetSequences(e, t, i) {
        const n = {}, s = /^([\w-]*?)([\d]+)$/;
        for (let o = 0, l = e.length; o < l; o++) {
          const c = e[o], u = c.name.match(s);
          if (u && u.length > 1) {
            const h = u[1];
            let d = n[h];
            d || (n[h] = d = []), d.push(c);
          }
        }
        const a = [];
        for (const o in n) a.push(this.CreateFromMorphTargetSequence(o, n[o], t, i));
        return a;
      }
      static parseAnimation(e, t) {
        if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
        const i = function(u, h, d, p, f) {
          if (d.length !== 0) {
            const _ = [], g = [];
            op(d, _, g, p), _.length !== 0 && f.push(new u(h, _, g));
          }
        }, n = [], s = e.name || "default", a = e.fps || 30, o = e.blendMode;
        let l = e.length || -1;
        const c = e.hierarchy || [];
        for (let u = 0; u < c.length; u++) {
          const h = c[u].keys;
          if (!(!h || h.length === 0)) if (h[0].morphTargets) {
            const d = {};
            let p;
            for (p = 0; p < h.length; p++) if (h[p].morphTargets) for (let f = 0; f < h[p].morphTargets.length; f++) d[h[p].morphTargets[f]] = -1;
            for (const f in d) {
              const _ = [], g = [];
              for (let m = 0; m !== h[p].morphTargets.length; ++m) {
                const y = h[p];
                _.push(y.time), g.push(y.morphTarget === f ? 1 : 0);
              }
              n.push(new Ms(".morphTargetInfluence[" + f + "]", _, g));
            }
            l = d.length * a;
          } else {
            const d = ".bones[" + t[u].name + "]";
            i(Es, d + ".position", h, "pos", n), i(bs, d + ".quaternion", h, "rot", n), i(Es, d + ".scale", h, "scl", n);
          }
        }
        return n.length === 0 ? null : new this(s, l, n, o);
      }
      resetDuration() {
        const e = this.tracks;
        let t = 0;
        for (let i = 0, n = e.length; i !== n; ++i) {
          const s = this.tracks[i];
          t = Math.max(t, s.times[s.times.length - 1]);
        }
        return this.duration = t, this;
      }
      trim() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
        return this;
      }
      validate() {
        let e = true;
        for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
        return e;
      }
      optimize() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
        return this;
      }
      clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
        return new this.constructor(this.name, this.duration, e, this.blendMode);
      }
      toJSON() {
        return this.constructor.toJSON(this);
      }
    }
    function Av(r) {
      switch (r.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
          return Ms;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
          return Es;
        case "color":
          return lp;
        case "quaternion":
          return bs;
        case "bool":
        case "boolean":
          return ys;
        case "string":
          return Ss;
      }
      throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r);
    }
    function Rv(r) {
      if (r.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
      const e = Av(r.type);
      if (r.times === void 0) {
        const t = [], i = [];
        op(r.keys, t, i, "value"), r.times = t, r.values = i;
      }
      return e.parse !== void 0 ? e.parse(r) : new e(r.name, r.times, r.values, r.interpolation);
    }
    const Wr = {
      enabled: false,
      files: {},
      add: function(r, e) {
        this.enabled !== false && (this.files[r] = e);
      },
      get: function(r) {
        if (this.enabled !== false) return this.files[r];
      },
      remove: function(r) {
        delete this.files[r];
      },
      clear: function() {
        this.files = {};
      }
    };
    class Cv {
      constructor(e, t, i) {
        const n = this;
        let s = false, a = 0, o = 0, l;
        const c = [];
        this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function(u) {
          o++, s === false && n.onStart !== void 0 && n.onStart(u, a, o), s = true;
        }, this.itemEnd = function(u) {
          a++, n.onProgress !== void 0 && n.onProgress(u, a, o), a === o && (s = false, n.onLoad !== void 0 && n.onLoad());
        }, this.itemError = function(u) {
          n.onError !== void 0 && n.onError(u);
        }, this.resolveURL = function(u) {
          return l ? l(u) : u;
        }, this.setURLModifier = function(u) {
          return l = u, this;
        }, this.addHandler = function(u, h) {
          return c.push(u, h), this;
        }, this.removeHandler = function(u) {
          const h = c.indexOf(u);
          return h !== -1 && c.splice(h, 2), this;
        }, this.getHandler = function(u) {
          for (let h = 0, d = c.length; h < d; h += 2) {
            const p = c[h], f = c[h + 1];
            if (p.global && (p.lastIndex = 0), p.test(u)) return f;
          }
          return null;
        };
      }
    }
    const Pv = new Cv();
    class fn {
      constructor(e) {
        this.manager = e !== void 0 ? e : Pv, this.crossOrigin = "anonymous", this.withCredentials = false, this.path = "", this.resourcePath = "", this.requestHeader = {};
      }
      load() {
      }
      loadAsync(e, t) {
        const i = this;
        return new Promise(function(n, s) {
          i.load(e, n, t, s);
        });
      }
      parse() {
      }
      setCrossOrigin(e) {
        return this.crossOrigin = e, this;
      }
      setWithCredentials(e) {
        return this.withCredentials = e, this;
      }
      setPath(e) {
        return this.path = e, this;
      }
      setResourcePath(e) {
        return this.resourcePath = e, this;
      }
      setRequestHeader(e) {
        return this.requestHeader = e, this;
      }
    }
    fn.DEFAULT_MATERIAL_NAME = "__DEFAULT";
    const yr = {};
    class Lv extends Error {
      constructor(e, t) {
        super(e), this.response = t;
      }
    }
    class au extends fn {
      constructor(e) {
        super(e);
      }
      load(e, t, i, n) {
        e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
        const s = Wr.get(e);
        if (s !== void 0) return this.manager.itemStart(e), setTimeout(() => {
          t && t(s), this.manager.itemEnd(e);
        }, 0), s;
        if (yr[e] !== void 0) {
          yr[e].push({
            onLoad: t,
            onProgress: i,
            onError: n
          });
          return;
        }
        yr[e] = [], yr[e].push({
          onLoad: t,
          onProgress: i,
          onError: n
        });
        const a = new Request(e, {
          headers: new Headers(this.requestHeader),
          credentials: this.withCredentials ? "include" : "same-origin"
        }), o = this.mimeType, l = this.responseType;
        fetch(a).then((c) => {
          if (c.status === 200 || c.status === 0) {
            if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0) return c;
            const u = yr[e], h = c.body.getReader(), d = c.headers.get("X-File-Size") || c.headers.get("Content-Length"), p = d ? parseInt(d) : 0, f = p !== 0;
            let _ = 0;
            const g = new ReadableStream({
              start(m) {
                y();
                function y() {
                  h.read().then(({ done: x, value: v }) => {
                    if (x) m.close();
                    else {
                      _ += v.byteLength;
                      const A = new ProgressEvent("progress", {
                        lengthComputable: f,
                        loaded: _,
                        total: p
                      });
                      for (let T = 0, w = u.length; T < w; T++) {
                        const R = u[T];
                        R.onProgress && R.onProgress(A);
                      }
                      m.enqueue(v), y();
                    }
                  }, (x) => {
                    m.error(x);
                  });
                }
              }
            });
            return new Response(g);
          } else throw new Lv(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c);
        }).then((c) => {
          switch (l) {
            case "arraybuffer":
              return c.arrayBuffer();
            case "blob":
              return c.blob();
            case "document":
              return c.text().then((u) => new DOMParser().parseFromString(u, o));
            case "json":
              return c.json();
            default:
              if (o === void 0) return c.text();
              {
                const u = /charset="?([^;"\s]*)"?/i.exec(o), h = u && u[1] ? u[1].toLowerCase() : void 0, d = new TextDecoder(h);
                return c.arrayBuffer().then((p) => d.decode(p));
              }
          }
        }).then((c) => {
          Wr.add(e, c);
          const u = yr[e];
          delete yr[e];
          for (let h = 0, d = u.length; h < d; h++) {
            const p = u[h];
            p.onLoad && p.onLoad(c);
          }
        }).catch((c) => {
          const u = yr[e];
          if (u === void 0) throw this.manager.itemError(e), c;
          delete yr[e];
          for (let h = 0, d = u.length; h < d; h++) {
            const p = u[h];
            p.onError && p.onError(c);
          }
          this.manager.itemError(e);
        }).finally(() => {
          this.manager.itemEnd(e);
        }), this.manager.itemStart(e);
      }
      setResponseType(e) {
        return this.responseType = e, this;
      }
      setMimeType(e) {
        return this.mimeType = e, this;
      }
    }
    class Dv extends fn {
      constructor(e) {
        super(e);
      }
      load(e, t, i, n) {
        this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
        const s = this, a = Wr.get(e);
        if (a !== void 0) return s.manager.itemStart(e), setTimeout(function() {
          t && t(a), s.manager.itemEnd(e);
        }, 0), a;
        const o = ha("img");
        function l() {
          u(), Wr.add(e, this), t && t(this), s.manager.itemEnd(e);
        }
        function c(h) {
          u(), n && n(h), s.manager.itemError(e), s.manager.itemEnd(e);
        }
        function u() {
          o.removeEventListener("load", l, false), o.removeEventListener("error", c, false);
        }
        return o.addEventListener("load", l, false), o.addEventListener("error", c, false), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (o.crossOrigin = this.crossOrigin), s.manager.itemStart(e), o.src = e, o;
      }
    }
    class Iv extends fn {
      constructor(e) {
        super(e);
      }
      load(e, t, i, n) {
        const s = new Nt(), a = new Dv(this.manager);
        return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function(o) {
          s.image = o, s.needsUpdate = true, t !== void 0 && t(s);
        }, i, n), s;
      }
    }
    class qo extends xt {
      constructor(e, t = 1) {
        super(), this.isLight = true, this.type = "Light", this.color = new Ae(e), this.intensity = t;
      }
      dispose() {
      }
      copy(e, t) {
        return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (t.object.target = this.target.uuid), t;
      }
    }
    const ou = new Fe(), cp = new D(), up = new D();
    class lu {
      constructor(e) {
        this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new ee(512, 512), this.map = null, this.mapPass = null, this.matrix = new Fe(), this.autoUpdate = true, this.needsUpdate = false, this._frustum = new Wc(), this._frameExtents = new ee(1, 1), this._viewportCount = 1, this._viewports = [
          new it(0, 0, 1, 1)
        ];
      }
      getViewportCount() {
        return this._viewportCount;
      }
      getFrustum() {
        return this._frustum;
      }
      updateMatrices(e) {
        const t = this.camera, i = this.matrix;
        cp.setFromMatrixPosition(e.matrixWorld), t.position.copy(cp), up.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(up), t.updateMatrixWorld(), ou.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(ou), i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1), i.multiply(ou);
      }
      getViewport(e) {
        return this._viewports[e];
      }
      getFrameExtents() {
        return this._frameExtents;
      }
      dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
      }
      copy(e) {
        return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      toJSON() {
        const e = {};
        return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(false).object, delete e.camera.matrix, e;
      }
    }
    class Uv extends lu {
      constructor() {
        super(new oi(50, 1, 0.5, 500)), this.isSpotLightShadow = true, this.focus = 1;
      }
      updateMatrices(e) {
        const t = this.camera, i = es * 2 * e.angle * this.focus, n = this.mapSize.width / this.mapSize.height, s = e.distance || t.far;
        (i !== t.fov || n !== t.aspect || s !== t.far) && (t.fov = i, t.aspect = n, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e);
      }
      copy(e) {
        return super.copy(e), this.focus = e.focus, this;
      }
    }
    class Ov extends qo {
      constructor(e, t, i = 0, n = Math.PI / 3, s = 0, a = 2) {
        super(e, t), this.isSpotLight = true, this.type = "SpotLight", this.position.copy(xt.DEFAULT_UP), this.updateMatrix(), this.target = new xt(), this.distance = i, this.angle = n, this.penumbra = s, this.decay = a, this.map = null, this.shadow = new Uv();
      }
      get power() {
        return this.intensity * Math.PI;
      }
      set power(e) {
        this.intensity = e / Math.PI;
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(e, t) {
        return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
      }
    }
    const hp = new Fe(), Aa = new D(), cu = new D();
    class Nv extends lu {
      constructor() {
        super(new oi(90, 1, 0.5, 500)), this.isPointLightShadow = true, this._frameExtents = new ee(4, 2), this._viewportCount = 6, this._viewports = [
          new it(2, 1, 1, 1),
          new it(0, 1, 1, 1),
          new it(3, 1, 1, 1),
          new it(1, 1, 1, 1),
          new it(3, 0, 1, 1),
          new it(1, 0, 1, 1)
        ], this._cubeDirections = [
          new D(1, 0, 0),
          new D(-1, 0, 0),
          new D(0, 0, 1),
          new D(0, 0, -1),
          new D(0, 1, 0),
          new D(0, -1, 0)
        ], this._cubeUps = [
          new D(0, 1, 0),
          new D(0, 1, 0),
          new D(0, 1, 0),
          new D(0, 1, 0),
          new D(0, 0, 1),
          new D(0, 0, -1)
        ];
      }
      updateMatrices(e, t = 0) {
        const i = this.camera, n = this.matrix, s = e.distance || i.far;
        s !== i.far && (i.far = s, i.updateProjectionMatrix()), Aa.setFromMatrixPosition(e.matrixWorld), i.position.copy(Aa), cu.copy(i.position), cu.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(cu), i.updateMatrixWorld(), n.makeTranslation(-Aa.x, -Aa.y, -Aa.z), hp.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(hp);
      }
    }
    class uu extends qo {
      constructor(e, t, i = 0, n = 2) {
        super(e, t), this.isPointLight = true, this.type = "PointLight", this.distance = i, this.decay = n, this.shadow = new Nv();
      }
      get power() {
        return this.intensity * 4 * Math.PI;
      }
      set power(e) {
        this.intensity = e / (4 * Math.PI);
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(e, t) {
        return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
      }
    }
    class Yo extends wd {
      constructor(e = -1, t = 1, i = 1, n = -1, s = 0.1, a = 2e3) {
        super(), this.isOrthographicCamera = true, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = n, this.near = s, this.far = a, this.updateProjectionMatrix();
      }
      copy(e, t) {
        return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
      }
      setViewOffset(e, t, i, n, s, a) {
        this.view === null && (this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        }), this.view.enabled = true, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = n, this.view.width = s, this.view.height = a, this.updateProjectionMatrix();
      }
      clearViewOffset() {
        this.view !== null && (this.view.enabled = false), this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2;
        let s = i - e, a = i + e, o = n + t, l = n - t;
        if (this.view !== null && this.view.enabled) {
          const c = (this.right - this.left) / this.view.fullWidth / this.zoom, u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          s += c * this.view.offsetX, a = s + c * this.view.width, o -= u * this.view.offsetY, l = o - u * this.view.height;
        }
        this.projectionMatrix.makeOrthographic(s, a, o, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
      }
    }
    class Fv extends lu {
      constructor() {
        super(new Yo(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = true;
      }
    }
    class dp extends qo {
      constructor(e, t) {
        super(e, t), this.isDirectionalLight = true, this.type = "DirectionalLight", this.position.copy(xt.DEFAULT_UP), this.updateMatrix(), this.target = new xt(), this.shadow = new Fv();
      }
      dispose() {
        this.shadow.dispose();
      }
      copy(e) {
        return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
      }
    }
    class pp extends qo {
      constructor(e, t) {
        super(e, t), this.isAmbientLight = true, this.type = "AmbientLight";
      }
    }
    class Ra {
      static decodeText(e) {
        if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."), typeof TextDecoder < "u") return new TextDecoder().decode(e);
        let t = "";
        for (let i = 0, n = e.length; i < n; i++) t += String.fromCharCode(e[i]);
        try {
          return decodeURIComponent(escape(t));
        } catch {
          return t;
        }
      }
      static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return t === -1 ? "./" : e.slice(0, t + 1);
      }
      static resolveURL(e, t) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e);
      }
    }
    class Bv extends fn {
      constructor(e) {
        super(e), this.isImageBitmapLoader = true, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
          premultiplyAlpha: "none"
        };
      }
      setOptions(e) {
        return this.options = e, this;
      }
      load(e, t, i, n) {
        e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
        const s = this, a = Wr.get(e);
        if (a !== void 0) {
          if (s.manager.itemStart(e), a.then) {
            a.then((c) => {
              t && t(c), s.manager.itemEnd(e);
            }).catch((c) => {
              n && n(c);
            });
            return;
          }
          return setTimeout(function() {
            t && t(a), s.manager.itemEnd(e);
          }, 0), a;
        }
        const o = {};
        o.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", o.headers = this.requestHeader;
        const l = fetch(e, o).then(function(c) {
          return c.blob();
        }).then(function(c) {
          return createImageBitmap(c, Object.assign(s.options, {
            colorSpaceConversion: "none"
          }));
        }).then(function(c) {
          return Wr.add(e, c), t && t(c), s.manager.itemEnd(e), c;
        }).catch(function(c) {
          n && n(c), Wr.remove(e), s.manager.itemError(e), s.manager.itemEnd(e);
        });
        Wr.add(e, l), s.manager.itemStart(e);
      }
    }
    class zv extends oi {
      constructor(e = []) {
        super(), this.isArrayCamera = true, this.cameras = e, this.index = 0;
      }
    }
    class kv {
      constructor(e = true) {
        this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = false;
      }
      start() {
        this.startTime = fp(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = true;
      }
      stop() {
        this.getElapsedTime(), this.running = false, this.autoStart = false;
      }
      getElapsedTime() {
        return this.getDelta(), this.elapsedTime;
      }
      getDelta() {
        let e = 0;
        if (this.autoStart && !this.running) return this.start(), 0;
        if (this.running) {
          const t = fp();
          e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e;
        }
        return e;
      }
    }
    function fp() {
      return performance.now();
    }
    const hu = "\\[\\]\\.:\\/", Hv = new RegExp("[" + hu + "]", "g"), du = "[^" + hu + "]", Vv = "[^" + hu.replace("\\.", "") + "]", Gv = /((?:WC+[\/:])*)/.source.replace("WC", du), Wv = /(WCOD+)?/.source.replace("WCOD", Vv), Xv = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", du), jv = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", du), qv = new RegExp("^" + Gv + Wv + Xv + jv + "$"), Yv = [
      "material",
      "materials",
      "bones",
      "map"
    ];
    class Kv {
      constructor(e, t, i) {
        const n = i || st.parseTrackName(t);
        this._targetGroup = e, this._bindings = e.subscribe_(t, n);
      }
      getValue(e, t) {
        this.bind();
        const i = this._targetGroup.nCachedObjects_, n = this._bindings[i];
        n !== void 0 && n.getValue(e, t);
      }
      setValue(e, t) {
        const i = this._bindings;
        for (let n = this._targetGroup.nCachedObjects_, s = i.length; n !== s; ++n) i[n].setValue(e, t);
      }
      bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind();
      }
      unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind();
      }
    }
    class st {
      constructor(e, t, i) {
        this.path = t, this.parsedPath = i || st.parseTrackName(t), this.node = st.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
      }
      static create(e, t, i) {
        return e && e.isAnimationObjectGroup ? new st.Composite(e, t, i) : new st(e, t, i);
      }
      static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(Hv, "");
      }
      static parseTrackName(e) {
        const t = qv.exec(e);
        if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const i = {
          nodeName: t[2],
          objectName: t[3],
          objectIndex: t[4],
          propertyName: t[5],
          propertyIndex: t[6]
        }, n = i.nodeName && i.nodeName.lastIndexOf(".");
        if (n !== void 0 && n !== -1) {
          const s = i.nodeName.substring(n + 1);
          Yv.indexOf(s) !== -1 && (i.nodeName = i.nodeName.substring(0, n), i.objectName = s);
        }
        if (i.propertyName === null || i.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return i;
      }
      static findNode(e, t) {
        if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
        if (e.skeleton) {
          const i = e.skeleton.getBoneByName(t);
          if (i !== void 0) return i;
        }
        if (e.children) {
          const i = function(s) {
            for (let a = 0; a < s.length; a++) {
              const o = s[a];
              if (o.name === t || o.uuid === t) return o;
              const l = i(o.children);
              if (l) return l;
            }
            return null;
          }, n = i(e.children);
          if (n) return n;
        }
        return null;
      }
      _getValue_unavailable() {
      }
      _setValue_unavailable() {
      }
      _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName];
      }
      _getValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let n = 0, s = i.length; n !== s; ++n) e[t++] = i[n];
      }
      _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex];
      }
      _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t);
      }
      _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t];
      }
      _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = true;
      }
      _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _setValue_array(e, t) {
        const i = this.resolvedProperty;
        for (let n = 0, s = i.length; n !== s; ++n) i[n] = e[t++];
      }
      _setValue_array_setNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let n = 0, s = i.length; n !== s; ++n) i[n] = e[t++];
        this.targetObject.needsUpdate = true;
      }
      _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const i = this.resolvedProperty;
        for (let n = 0, s = i.length; n !== s; ++n) i[n] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t];
      }
      _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = true;
      }
      _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t);
      }
      _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = true;
      }
      _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = true;
      }
      _getValue_unbound(e, t) {
        this.bind(), this.getValue(e, t);
      }
      _setValue_unbound(e, t) {
        this.bind(), this.setValue(e, t);
      }
      bind() {
        let e = this.node;
        const t = this.parsedPath, i = t.objectName, n = t.propertyName;
        let s = t.propertyIndex;
        if (e || (e = st.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
          console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
          return;
        }
        if (i) {
          let c = t.objectIndex;
          switch (i) {
            case "materials":
              if (!e.material) {
                console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                return;
              }
              if (!e.material.materials) {
                console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                return;
              }
              e = e.material.materials;
              break;
            case "bones":
              if (!e.skeleton) {
                console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                return;
              }
              e = e.skeleton.bones;
              for (let u = 0; u < e.length; u++) if (e[u].name === c) {
                c = u;
                break;
              }
              break;
            case "map":
              if ("map" in e) {
                e = e.map;
                break;
              }
              if (!e.material) {
                console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                return;
              }
              if (!e.material.map) {
                console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                return;
              }
              e = e.material.map;
              break;
            default:
              if (e[i] === void 0) {
                console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                return;
              }
              e = e[i];
          }
          if (c !== void 0) {
            if (e[c] === void 0) {
              console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
              return;
            }
            e = e[c];
          }
        }
        const a = e[n];
        if (a === void 0) {
          const c = t.nodeName;
          console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + n + " but it wasn't found.", e);
          return;
        }
        let o = this.Versioning.None;
        this.targetObject = e, e.isMaterial === true ? o = this.Versioning.NeedsUpdate : e.isObject3D === true && (o = this.Versioning.MatrixWorldNeedsUpdate);
        let l = this.BindingType.Direct;
        if (s !== void 0) {
          if (n === "morphTargetInfluences") {
            if (!e.geometry) {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
              return;
            }
            if (!e.geometry.morphAttributes) {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
              return;
            }
            e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s]);
          }
          l = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = s;
        } else a.fromArray !== void 0 && a.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (l = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = n;
        this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][o];
      }
      unbind() {
        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound;
      }
    }
    st.Composite = Kv, st.prototype.BindingType = {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3
    }, st.prototype.Versioning = {
      None: 0,
      NeedsUpdate: 1,
      MatrixWorldNeedsUpdate: 2
    }, st.prototype.GetterByBindingType = [
      st.prototype._getValue_direct,
      st.prototype._getValue_array,
      st.prototype._getValue_arrayElement,
      st.prototype._getValue_toArray
    ], st.prototype.SetterByBindingTypeAndVersioning = [
      [
        st.prototype._setValue_direct,
        st.prototype._setValue_direct_setNeedsUpdate,
        st.prototype._setValue_direct_setMatrixWorldNeedsUpdate
      ],
      [
        st.prototype._setValue_array,
        st.prototype._setValue_array_setNeedsUpdate,
        st.prototype._setValue_array_setMatrixWorldNeedsUpdate
      ],
      [
        st.prototype._setValue_arrayElement,
        st.prototype._setValue_arrayElement_setNeedsUpdate,
        st.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
      ],
      [
        st.prototype._setValue_fromArray,
        st.prototype._setValue_fromArray_setNeedsUpdate,
        st.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
      ]
    ];
    const mp = new Fe();
    class mn {
      constructor(e, t, i = 0, n = 1 / 0) {
        this.ray = new fa(e, t), this.near = i, this.far = n, this.camera = null, this.layers = new Tc(), this.params = {
          Mesh: {},
          Line: {
            threshold: 1
          },
          LOD: {},
          Points: {
            threshold: 1
          },
          Sprite: {}
        };
      }
      set(e, t) {
        this.ray.set(e, t);
      }
      setFromCamera(e, t) {
        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, 0.5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
      }
      setFromXRController(e) {
        return mp.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(mp), this;
      }
      intersectObject(e, t = true, i = []) {
        return pu(e, this, i, t), i.sort(gp), i;
      }
      intersectObjects(e, t = true, i = []) {
        for (let n = 0, s = e.length; n < s; n++) pu(e[n], this, i, t);
        return i.sort(gp), i;
      }
    }
    function gp(r, e) {
      return r.distance - e.distance;
    }
    function pu(r, e, t, i) {
      let n = true;
      if (r.layers.test(e.layers) && r.raycast(e, t) === false && (n = false), n === true && i === true) {
        const s = r.children;
        for (let a = 0, o = s.length; a < o; a++) pu(s[a], e, t, true);
      }
    }
    class Zv {
      constructor() {
        this.type = "ShapePath", this.color = new Ae(), this.subPaths = [], this.currentPath = null;
      }
      moveTo(e, t) {
        return this.currentPath = new tu(), this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this;
      }
      lineTo(e, t) {
        return this.currentPath.lineTo(e, t), this;
      }
      quadraticCurveTo(e, t, i, n) {
        return this.currentPath.quadraticCurveTo(e, t, i, n), this;
      }
      bezierCurveTo(e, t, i, n, s, a) {
        return this.currentPath.bezierCurveTo(e, t, i, n, s, a), this;
      }
      splineThru(e) {
        return this.currentPath.splineThru(e), this;
      }
      toShapes(e) {
        function t(m) {
          const y = [];
          for (let x = 0, v = m.length; x < v; x++) {
            const A = m[x], T = new Vo();
            T.curves = A.curves, y.push(T);
          }
          return y;
        }
        function i(m, y) {
          const x = y.length;
          let v = false;
          for (let A = x - 1, T = 0; T < x; A = T++) {
            let w = y[A], R = y[T], E = R.x - w.x, b = R.y - w.y;
            if (Math.abs(b) > Number.EPSILON) {
              if (b < 0 && (w = y[T], E = -E, R = y[A], b = -b), m.y < w.y || m.y > R.y) continue;
              if (m.y === w.y) {
                if (m.x === w.x) return true;
              } else {
                const L = b * (m.x - w.x) - E * (m.y - w.y);
                if (L === 0) return true;
                if (L < 0) continue;
                v = !v;
              }
            } else {
              if (m.y !== w.y) continue;
              if (R.x <= m.x && m.x <= w.x || w.x <= m.x && m.x <= R.x) return true;
            }
          }
          return v;
        }
        const n = vs.isClockWise, s = this.subPaths;
        if (s.length === 0) return [];
        let a, o, l;
        const c = [];
        if (s.length === 1) return o = s[0], l = new Vo(), l.curves = o.curves, c.push(l), c;
        let u = !n(s[0].getPoints());
        u = e ? !u : u;
        const h = [], d = [];
        let p = [], f = 0, _;
        d[f] = void 0, p[f] = [];
        for (let m = 0, y = s.length; m < y; m++) o = s[m], _ = o.getPoints(), a = n(_), a = e ? !a : a, a ? (!u && d[f] && f++, d[f] = {
          s: new Vo(),
          p: _
        }, d[f].s.curves = o.curves, u && f++, p[f] = []) : p[f].push({
          h: o,
          p: _[0]
        });
        if (!d[0]) return t(s);
        if (d.length > 1) {
          let m = false, y = 0;
          for (let x = 0, v = d.length; x < v; x++) h[x] = [];
          for (let x = 0, v = d.length; x < v; x++) {
            const A = p[x];
            for (let T = 0; T < A.length; T++) {
              const w = A[T];
              let R = true;
              for (let E = 0; E < d.length; E++) i(w.p, d[E].p) && (x !== E && y++, R ? (R = false, h[E].push(w)) : m = true);
              R && h[x].push(w);
            }
          }
          y > 0 && m === false && (p = h);
        }
        let g;
        for (let m = 0, y = d.length; m < y; m++) {
          l = d[m].s, c.push(l), g = p[m];
          for (let x = 0, v = g.length; x < v; x++) l.holes.push(g[x].h);
        }
        return c;
      }
    }
    function _p(r, e, t, i) {
      const n = Jv(i);
      switch (t) {
        case Gh:
          return r * e;
        case Xh:
          return r * e;
        case jh:
          return r * e * 2;
        case Fl:
          return r * e / n.components * n.byteLength;
        case Bl:
          return r * e / n.components * n.byteLength;
        case qh:
          return r * e * 2 / n.components * n.byteLength;
        case zl:
          return r * e * 2 / n.components * n.byteLength;
        case Wh:
          return r * e * 3 / n.components * n.byteLength;
        case Ri:
          return r * e * 4 / n.components * n.byteLength;
        case kl:
          return r * e * 4 / n.components * n.byteLength;
        case oo:
        case lo:
          return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
        case co:
        case uo:
          return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
        case Vl:
        case Wl:
          return Math.max(r, 16) * Math.max(e, 8) / 4;
        case Hl:
        case Gl:
          return Math.max(r, 8) * Math.max(e, 8) / 2;
        case Xl:
        case jl:
          return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
        case ql:
          return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
        case Yl:
          return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
        case Kl:
          return Math.floor((r + 4) / 5) * Math.floor((e + 3) / 4) * 16;
        case Zl:
          return Math.floor((r + 4) / 5) * Math.floor((e + 4) / 5) * 16;
        case Jl:
          return Math.floor((r + 5) / 6) * Math.floor((e + 4) / 5) * 16;
        case $l:
          return Math.floor((r + 5) / 6) * Math.floor((e + 5) / 6) * 16;
        case Ql:
          return Math.floor((r + 7) / 8) * Math.floor((e + 4) / 5) * 16;
        case ec:
          return Math.floor((r + 7) / 8) * Math.floor((e + 5) / 6) * 16;
        case tc:
          return Math.floor((r + 7) / 8) * Math.floor((e + 7) / 8) * 16;
        case ic:
          return Math.floor((r + 9) / 10) * Math.floor((e + 4) / 5) * 16;
        case rc:
          return Math.floor((r + 9) / 10) * Math.floor((e + 5) / 6) * 16;
        case nc:
          return Math.floor((r + 9) / 10) * Math.floor((e + 7) / 8) * 16;
        case sc:
          return Math.floor((r + 9) / 10) * Math.floor((e + 9) / 10) * 16;
        case ac:
          return Math.floor((r + 11) / 12) * Math.floor((e + 9) / 10) * 16;
        case oc:
          return Math.floor((r + 11) / 12) * Math.floor((e + 11) / 12) * 16;
        case ho:
        case lc:
        case cc:
          return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
        case Yh:
        case uc:
          return Math.ceil(r / 4) * Math.ceil(e / 4) * 8;
        case hc:
        case dc:
          return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
      }
      throw new Error(`Unable to determine texture byte length for ${t} format.`);
    }
    function Jv(r) {
      switch (r) {
        case ur:
        case kh:
          return {
            byteLength: 1,
            components: 1
          };
        case aa:
        case Hh:
        case hr:
          return {
            byteLength: 2,
            components: 1
          };
        case Ol:
        case Nl:
          return {
            byteLength: 2,
            components: 4
          };
        case an:
        case Ul:
        case Bi:
          return {
            byteLength: 4,
            components: 1
          };
        case Vh:
          return {
            byteLength: 4,
            components: 3
          };
      }
      throw new Error(`Unknown texture type ${r}.`);
    }
    typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
      detail: {
        revision: rn
      }
    })), typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = rn);
    function vp() {
      let r = null, e = false, t = null, i = null;
      function n(s, a) {
        t(s, a), i = r.requestAnimationFrame(n);
      }
      return {
        start: function() {
          e !== true && t !== null && (i = r.requestAnimationFrame(n), e = true);
        },
        stop: function() {
          r.cancelAnimationFrame(i), e = false;
        },
        setAnimationLoop: function(s) {
          t = s;
        },
        setContext: function(s) {
          r = s;
        }
      };
    }
    function $v(r) {
      const e = /* @__PURE__ */ new WeakMap();
      function t(o, l) {
        const c = o.array, u = o.usage, h = c.byteLength, d = r.createBuffer();
        r.bindBuffer(l, d), r.bufferData(l, c, u), o.onUploadCallback();
        let p;
        if (c instanceof Float32Array) p = r.FLOAT;
        else if (c instanceof Uint16Array) o.isFloat16BufferAttribute ? p = r.HALF_FLOAT : p = r.UNSIGNED_SHORT;
        else if (c instanceof Int16Array) p = r.SHORT;
        else if (c instanceof Uint32Array) p = r.UNSIGNED_INT;
        else if (c instanceof Int32Array) p = r.INT;
        else if (c instanceof Int8Array) p = r.BYTE;
        else if (c instanceof Uint8Array) p = r.UNSIGNED_BYTE;
        else if (c instanceof Uint8ClampedArray) p = r.UNSIGNED_BYTE;
        else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
        return {
          buffer: d,
          type: p,
          bytesPerElement: c.BYTES_PER_ELEMENT,
          version: o.version,
          size: h
        };
      }
      function i(o, l, c) {
        const u = l.array, h = l.updateRanges;
        if (r.bindBuffer(c, o), h.length === 0) r.bufferSubData(c, 0, u);
        else {
          h.sort((p, f) => p.start - f.start);
          let d = 0;
          for (let p = 1; p < h.length; p++) {
            const f = h[d], _ = h[p];
            _.start <= f.start + f.count + 1 ? f.count = Math.max(f.count, _.start + _.count - f.start) : (++d, h[d] = _);
          }
          h.length = d + 1;
          for (let p = 0, f = h.length; p < f; p++) {
            const _ = h[p];
            r.bufferSubData(c, _.start * u.BYTES_PER_ELEMENT, u, _.start, _.count);
          }
          l.clearUpdateRanges();
        }
        l.onUploadCallback();
      }
      function n(o) {
        return o.isInterleavedBufferAttribute && (o = o.data), e.get(o);
      }
      function s(o) {
        o.isInterleavedBufferAttribute && (o = o.data);
        const l = e.get(o);
        l && (r.deleteBuffer(l.buffer), e.delete(o));
      }
      function a(o, l) {
        if (o.isInterleavedBufferAttribute && (o = o.data), o.isGLBufferAttribute) {
          const u = e.get(o);
          (!u || u.version < o.version) && e.set(o, {
            buffer: o.buffer,
            type: o.type,
            bytesPerElement: o.elementSize,
            version: o.version
          });
          return;
        }
        const c = e.get(o);
        if (c === void 0) e.set(o, t(o, l));
        else if (c.version < o.version) {
          if (c.size !== o.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
          i(c.buffer, o, l), c.version = o.version;
        }
      }
      return {
        get: n,
        remove: s,
        update: a
      };
    }
    var Qv = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`, e0 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`, t0 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`, i0 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, r0 = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`, n0 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, s0 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, a0 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, o0 = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`, l0 = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`, c0 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`, u0 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, h0 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`, d0 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, p0 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, f0 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`, m0 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, g0 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, _0 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, v0 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, x0 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, y0 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`, M0 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`, b0 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`, S0 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, E0 = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, T0 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, w0 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`, A0 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, R0 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, C0 = "gl_FragColor = linearToOutputTexel( gl_FragColor );", P0 = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, L0 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, D0 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, I0 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, U0 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, O0 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, N0 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, F0 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, B0 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, z0 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, k0 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, H0 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, V0 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, G0 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, W0 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, X0 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`, j0 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, q0 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, Y0 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, K0 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, Z0 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`, J0 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, $0 = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, Q0 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, ex = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`, tx = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, ix = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, rx = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, nx = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`, sx = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, ax = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, ox = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, lx = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, cx = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`, ux = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, hx = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`, dx = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, px = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, fx = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`, mx = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`, gx = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`, _x = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, vx = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, xx = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, yx = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, Mx = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`, bx = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`, Sx = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`, Ex = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`, Tx = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, wx = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, Ax = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`, Rx = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, Cx = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, Px = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, Lx = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, Dx = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`, Ix = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, Ux = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`, Ox = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, Nx = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, Fx = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, Bx = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, zx = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`, kx = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, Hx = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, Vx = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, Gx = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, Wx = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, Xx = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, jx = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`, qx = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`, Yx = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Kx = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`, Zx = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`, Jx = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
    const $x = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, Qx = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, ey = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, ty = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, iy = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, ry = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, ny = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, sy = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`, ay = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, oy = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, ly = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, cy = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`, uy = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, hy = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, dy = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, py = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, fy = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, my = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, gy = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, _y = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, vy = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`, xy = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, yy = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, My = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, by = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, Sy = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, Ey = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Ty = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, wy = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, Ay = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, Ry = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, Cy = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, Py = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, Ly = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`, He = {
      alphahash_fragment: Qv,
      alphahash_pars_fragment: e0,
      alphamap_fragment: t0,
      alphamap_pars_fragment: i0,
      alphatest_fragment: r0,
      alphatest_pars_fragment: n0,
      aomap_fragment: s0,
      aomap_pars_fragment: a0,
      batching_pars_vertex: o0,
      batching_vertex: l0,
      begin_vertex: c0,
      beginnormal_vertex: u0,
      bsdfs: h0,
      iridescence_fragment: d0,
      bumpmap_pars_fragment: p0,
      clipping_planes_fragment: f0,
      clipping_planes_pars_fragment: m0,
      clipping_planes_pars_vertex: g0,
      clipping_planes_vertex: _0,
      color_fragment: v0,
      color_pars_fragment: x0,
      color_pars_vertex: y0,
      color_vertex: M0,
      common: b0,
      cube_uv_reflection_fragment: S0,
      defaultnormal_vertex: E0,
      displacementmap_pars_vertex: T0,
      displacementmap_vertex: w0,
      emissivemap_fragment: A0,
      emissivemap_pars_fragment: R0,
      colorspace_fragment: C0,
      colorspace_pars_fragment: P0,
      envmap_fragment: L0,
      envmap_common_pars_fragment: D0,
      envmap_pars_fragment: I0,
      envmap_pars_vertex: U0,
      envmap_physical_pars_fragment: X0,
      envmap_vertex: O0,
      fog_vertex: N0,
      fog_pars_vertex: F0,
      fog_fragment: B0,
      fog_pars_fragment: z0,
      gradientmap_pars_fragment: k0,
      lightmap_pars_fragment: H0,
      lights_lambert_fragment: V0,
      lights_lambert_pars_fragment: G0,
      lights_pars_begin: W0,
      lights_toon_fragment: j0,
      lights_toon_pars_fragment: q0,
      lights_phong_fragment: Y0,
      lights_phong_pars_fragment: K0,
      lights_physical_fragment: Z0,
      lights_physical_pars_fragment: J0,
      lights_fragment_begin: $0,
      lights_fragment_maps: Q0,
      lights_fragment_end: ex,
      logdepthbuf_fragment: tx,
      logdepthbuf_pars_fragment: ix,
      logdepthbuf_pars_vertex: rx,
      logdepthbuf_vertex: nx,
      map_fragment: sx,
      map_pars_fragment: ax,
      map_particle_fragment: ox,
      map_particle_pars_fragment: lx,
      metalnessmap_fragment: cx,
      metalnessmap_pars_fragment: ux,
      morphinstance_vertex: hx,
      morphcolor_vertex: dx,
      morphnormal_vertex: px,
      morphtarget_pars_vertex: fx,
      morphtarget_vertex: mx,
      normal_fragment_begin: gx,
      normal_fragment_maps: _x,
      normal_pars_fragment: vx,
      normal_pars_vertex: xx,
      normal_vertex: yx,
      normalmap_pars_fragment: Mx,
      clearcoat_normal_fragment_begin: bx,
      clearcoat_normal_fragment_maps: Sx,
      clearcoat_pars_fragment: Ex,
      iridescence_pars_fragment: Tx,
      opaque_fragment: wx,
      packing: Ax,
      premultiplied_alpha_fragment: Rx,
      project_vertex: Cx,
      dithering_fragment: Px,
      dithering_pars_fragment: Lx,
      roughnessmap_fragment: Dx,
      roughnessmap_pars_fragment: Ix,
      shadowmap_pars_fragment: Ux,
      shadowmap_pars_vertex: Ox,
      shadowmap_vertex: Nx,
      shadowmask_pars_fragment: Fx,
      skinbase_vertex: Bx,
      skinning_pars_vertex: zx,
      skinning_vertex: kx,
      skinnormal_vertex: Hx,
      specularmap_fragment: Vx,
      specularmap_pars_fragment: Gx,
      tonemapping_fragment: Wx,
      tonemapping_pars_fragment: Xx,
      transmission_fragment: jx,
      transmission_pars_fragment: qx,
      uv_pars_fragment: Yx,
      uv_pars_vertex: Kx,
      uv_vertex: Zx,
      worldpos_vertex: Jx,
      background_vert: $x,
      background_frag: Qx,
      backgroundCube_vert: ey,
      backgroundCube_frag: ty,
      cube_vert: iy,
      cube_frag: ry,
      depth_vert: ny,
      depth_frag: sy,
      distanceRGBA_vert: ay,
      distanceRGBA_frag: oy,
      equirect_vert: ly,
      equirect_frag: cy,
      linedashed_vert: uy,
      linedashed_frag: hy,
      meshbasic_vert: dy,
      meshbasic_frag: py,
      meshlambert_vert: fy,
      meshlambert_frag: my,
      meshmatcap_vert: gy,
      meshmatcap_frag: _y,
      meshnormal_vert: vy,
      meshnormal_frag: xy,
      meshphong_vert: yy,
      meshphong_frag: My,
      meshphysical_vert: by,
      meshphysical_frag: Sy,
      meshtoon_vert: Ey,
      meshtoon_frag: Ty,
      points_vert: wy,
      points_frag: Ay,
      shadow_vert: Ry,
      shadow_frag: Cy,
      sprite_vert: Py,
      sprite_frag: Ly
    }, ce = {
      common: {
        diffuse: {
          value: new Ae(16777215)
        },
        opacity: {
          value: 1
        },
        map: {
          value: null
        },
        mapTransform: {
          value: new ze()
        },
        alphaMap: {
          value: null
        },
        alphaMapTransform: {
          value: new ze()
        },
        alphaTest: {
          value: 0
        }
      },
      specularmap: {
        specularMap: {
          value: null
        },
        specularMapTransform: {
          value: new ze()
        }
      },
      envmap: {
        envMap: {
          value: null
        },
        envMapRotation: {
          value: new ze()
        },
        flipEnvMap: {
          value: -1
        },
        reflectivity: {
          value: 1
        },
        ior: {
          value: 1.5
        },
        refractionRatio: {
          value: 0.98
        }
      },
      aomap: {
        aoMap: {
          value: null
        },
        aoMapIntensity: {
          value: 1
        },
        aoMapTransform: {
          value: new ze()
        }
      },
      lightmap: {
        lightMap: {
          value: null
        },
        lightMapIntensity: {
          value: 1
        },
        lightMapTransform: {
          value: new ze()
        }
      },
      bumpmap: {
        bumpMap: {
          value: null
        },
        bumpMapTransform: {
          value: new ze()
        },
        bumpScale: {
          value: 1
        }
      },
      normalmap: {
        normalMap: {
          value: null
        },
        normalMapTransform: {
          value: new ze()
        },
        normalScale: {
          value: new ee(1, 1)
        }
      },
      displacementmap: {
        displacementMap: {
          value: null
        },
        displacementMapTransform: {
          value: new ze()
        },
        displacementScale: {
          value: 1
        },
        displacementBias: {
          value: 0
        }
      },
      emissivemap: {
        emissiveMap: {
          value: null
        },
        emissiveMapTransform: {
          value: new ze()
        }
      },
      metalnessmap: {
        metalnessMap: {
          value: null
        },
        metalnessMapTransform: {
          value: new ze()
        }
      },
      roughnessmap: {
        roughnessMap: {
          value: null
        },
        roughnessMapTransform: {
          value: new ze()
        }
      },
      gradientmap: {
        gradientMap: {
          value: null
        }
      },
      fog: {
        fogDensity: {
          value: 25e-5
        },
        fogNear: {
          value: 1
        },
        fogFar: {
          value: 2e3
        },
        fogColor: {
          value: new Ae(16777215)
        }
      },
      lights: {
        ambientLightColor: {
          value: []
        },
        lightProbe: {
          value: []
        },
        directionalLights: {
          value: [],
          properties: {
            direction: {},
            color: {}
          }
        },
        directionalLightShadows: {
          value: [],
          properties: {
            shadowIntensity: 1,
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          }
        },
        directionalShadowMap: {
          value: []
        },
        directionalShadowMatrix: {
          value: []
        },
        spotLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {}
          }
        },
        spotLightShadows: {
          value: [],
          properties: {
            shadowIntensity: 1,
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          }
        },
        spotLightMap: {
          value: []
        },
        spotShadowMap: {
          value: []
        },
        spotLightMatrix: {
          value: []
        },
        pointLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            decay: {},
            distance: {}
          }
        },
        pointLightShadows: {
          value: [],
          properties: {
            shadowIntensity: 1,
            shadowBias: {},
            shadowNormalBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {}
          }
        },
        pointShadowMap: {
          value: []
        },
        pointShadowMatrix: {
          value: []
        },
        hemisphereLights: {
          value: [],
          properties: {
            direction: {},
            skyColor: {},
            groundColor: {}
          }
        },
        rectAreaLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            width: {},
            height: {}
          }
        },
        ltc_1: {
          value: null
        },
        ltc_2: {
          value: null
        }
      },
      points: {
        diffuse: {
          value: new Ae(16777215)
        },
        opacity: {
          value: 1
        },
        size: {
          value: 1
        },
        scale: {
          value: 1
        },
        map: {
          value: null
        },
        alphaMap: {
          value: null
        },
        alphaMapTransform: {
          value: new ze()
        },
        alphaTest: {
          value: 0
        },
        uvTransform: {
          value: new ze()
        }
      },
      sprite: {
        diffuse: {
          value: new Ae(16777215)
        },
        opacity: {
          value: 1
        },
        center: {
          value: new ee(0.5, 0.5)
        },
        rotation: {
          value: 0
        },
        map: {
          value: null
        },
        mapTransform: {
          value: new ze()
        },
        alphaMap: {
          value: null
        },
        alphaMapTransform: {
          value: new ze()
        },
        alphaTest: {
          value: 0
        }
      }
    }, ir = {
      basic: {
        uniforms: ai([
          ce.common,
          ce.specularmap,
          ce.envmap,
          ce.aomap,
          ce.lightmap,
          ce.fog
        ]),
        vertexShader: He.meshbasic_vert,
        fragmentShader: He.meshbasic_frag
      },
      lambert: {
        uniforms: ai([
          ce.common,
          ce.specularmap,
          ce.envmap,
          ce.aomap,
          ce.lightmap,
          ce.emissivemap,
          ce.bumpmap,
          ce.normalmap,
          ce.displacementmap,
          ce.fog,
          ce.lights,
          {
            emissive: {
              value: new Ae(0)
            }
          }
        ]),
        vertexShader: He.meshlambert_vert,
        fragmentShader: He.meshlambert_frag
      },
      phong: {
        uniforms: ai([
          ce.common,
          ce.specularmap,
          ce.envmap,
          ce.aomap,
          ce.lightmap,
          ce.emissivemap,
          ce.bumpmap,
          ce.normalmap,
          ce.displacementmap,
          ce.fog,
          ce.lights,
          {
            emissive: {
              value: new Ae(0)
            },
            specular: {
              value: new Ae(1118481)
            },
            shininess: {
              value: 30
            }
          }
        ]),
        vertexShader: He.meshphong_vert,
        fragmentShader: He.meshphong_frag
      },
      standard: {
        uniforms: ai([
          ce.common,
          ce.envmap,
          ce.aomap,
          ce.lightmap,
          ce.emissivemap,
          ce.bumpmap,
          ce.normalmap,
          ce.displacementmap,
          ce.roughnessmap,
          ce.metalnessmap,
          ce.fog,
          ce.lights,
          {
            emissive: {
              value: new Ae(0)
            },
            roughness: {
              value: 1
            },
            metalness: {
              value: 0
            },
            envMapIntensity: {
              value: 1
            }
          }
        ]),
        vertexShader: He.meshphysical_vert,
        fragmentShader: He.meshphysical_frag
      },
      toon: {
        uniforms: ai([
          ce.common,
          ce.aomap,
          ce.lightmap,
          ce.emissivemap,
          ce.bumpmap,
          ce.normalmap,
          ce.displacementmap,
          ce.gradientmap,
          ce.fog,
          ce.lights,
          {
            emissive: {
              value: new Ae(0)
            }
          }
        ]),
        vertexShader: He.meshtoon_vert,
        fragmentShader: He.meshtoon_frag
      },
      matcap: {
        uniforms: ai([
          ce.common,
          ce.bumpmap,
          ce.normalmap,
          ce.displacementmap,
          ce.fog,
          {
            matcap: {
              value: null
            }
          }
        ]),
        vertexShader: He.meshmatcap_vert,
        fragmentShader: He.meshmatcap_frag
      },
      points: {
        uniforms: ai([
          ce.points,
          ce.fog
        ]),
        vertexShader: He.points_vert,
        fragmentShader: He.points_frag
      },
      dashed: {
        uniforms: ai([
          ce.common,
          ce.fog,
          {
            scale: {
              value: 1
            },
            dashSize: {
              value: 1
            },
            totalSize: {
              value: 2
            }
          }
        ]),
        vertexShader: He.linedashed_vert,
        fragmentShader: He.linedashed_frag
      },
      depth: {
        uniforms: ai([
          ce.common,
          ce.displacementmap
        ]),
        vertexShader: He.depth_vert,
        fragmentShader: He.depth_frag
      },
      normal: {
        uniforms: ai([
          ce.common,
          ce.bumpmap,
          ce.normalmap,
          ce.displacementmap,
          {
            opacity: {
              value: 1
            }
          }
        ]),
        vertexShader: He.meshnormal_vert,
        fragmentShader: He.meshnormal_frag
      },
      sprite: {
        uniforms: ai([
          ce.sprite,
          ce.fog
        ]),
        vertexShader: He.sprite_vert,
        fragmentShader: He.sprite_frag
      },
      background: {
        uniforms: {
          uvTransform: {
            value: new ze()
          },
          t2D: {
            value: null
          },
          backgroundIntensity: {
            value: 1
          }
        },
        vertexShader: He.background_vert,
        fragmentShader: He.background_frag
      },
      backgroundCube: {
        uniforms: {
          envMap: {
            value: null
          },
          flipEnvMap: {
            value: -1
          },
          backgroundBlurriness: {
            value: 0
          },
          backgroundIntensity: {
            value: 1
          },
          backgroundRotation: {
            value: new ze()
          }
        },
        vertexShader: He.backgroundCube_vert,
        fragmentShader: He.backgroundCube_frag
      },
      cube: {
        uniforms: {
          tCube: {
            value: null
          },
          tFlip: {
            value: -1
          },
          opacity: {
            value: 1
          }
        },
        vertexShader: He.cube_vert,
        fragmentShader: He.cube_frag
      },
      equirect: {
        uniforms: {
          tEquirect: {
            value: null
          }
        },
        vertexShader: He.equirect_vert,
        fragmentShader: He.equirect_frag
      },
      distanceRGBA: {
        uniforms: ai([
          ce.common,
          ce.displacementmap,
          {
            referencePosition: {
              value: new D()
            },
            nearDistance: {
              value: 1
            },
            farDistance: {
              value: 1e3
            }
          }
        ]),
        vertexShader: He.distanceRGBA_vert,
        fragmentShader: He.distanceRGBA_frag
      },
      shadow: {
        uniforms: ai([
          ce.lights,
          ce.fog,
          {
            color: {
              value: new Ae(0)
            },
            opacity: {
              value: 1
            }
          }
        ]),
        vertexShader: He.shadow_vert,
        fragmentShader: He.shadow_frag
      }
    };
    ir.physical = {
      uniforms: ai([
        ir.standard.uniforms,
        {
          clearcoat: {
            value: 0
          },
          clearcoatMap: {
            value: null
          },
          clearcoatMapTransform: {
            value: new ze()
          },
          clearcoatNormalMap: {
            value: null
          },
          clearcoatNormalMapTransform: {
            value: new ze()
          },
          clearcoatNormalScale: {
            value: new ee(1, 1)
          },
          clearcoatRoughness: {
            value: 0
          },
          clearcoatRoughnessMap: {
            value: null
          },
          clearcoatRoughnessMapTransform: {
            value: new ze()
          },
          dispersion: {
            value: 0
          },
          iridescence: {
            value: 0
          },
          iridescenceMap: {
            value: null
          },
          iridescenceMapTransform: {
            value: new ze()
          },
          iridescenceIOR: {
            value: 1.3
          },
          iridescenceThicknessMinimum: {
            value: 100
          },
          iridescenceThicknessMaximum: {
            value: 400
          },
          iridescenceThicknessMap: {
            value: null
          },
          iridescenceThicknessMapTransform: {
            value: new ze()
          },
          sheen: {
            value: 0
          },
          sheenColor: {
            value: new Ae(0)
          },
          sheenColorMap: {
            value: null
          },
          sheenColorMapTransform: {
            value: new ze()
          },
          sheenRoughness: {
            value: 1
          },
          sheenRoughnessMap: {
            value: null
          },
          sheenRoughnessMapTransform: {
            value: new ze()
          },
          transmission: {
            value: 0
          },
          transmissionMap: {
            value: null
          },
          transmissionMapTransform: {
            value: new ze()
          },
          transmissionSamplerSize: {
            value: new ee()
          },
          transmissionSamplerMap: {
            value: null
          },
          thickness: {
            value: 0
          },
          thicknessMap: {
            value: null
          },
          thicknessMapTransform: {
            value: new ze()
          },
          attenuationDistance: {
            value: 0
          },
          attenuationColor: {
            value: new Ae(0)
          },
          specularColor: {
            value: new Ae(1, 1, 1)
          },
          specularColorMap: {
            value: null
          },
          specularColorMapTransform: {
            value: new ze()
          },
          specularIntensity: {
            value: 1
          },
          specularIntensityMap: {
            value: null
          },
          specularIntensityMapTransform: {
            value: new ze()
          },
          anisotropyVector: {
            value: new ee()
          },
          anisotropyMap: {
            value: null
          },
          anisotropyMapTransform: {
            value: new ze()
          }
        }
      ]),
      vertexShader: He.meshphysical_vert,
      fragmentShader: He.meshphysical_frag
    };
    const Ko = {
      r: 0,
      b: 0,
      g: 0
    }, gn = new Zi(), Dy = new Fe();
    function Iy(r, e, t, i, n, s, a) {
      const o = new Ae(0);
      let l = s === true ? 0 : 1, c, u, h = null, d = 0, p = null;
      function f(x) {
        let v = x.isScene === true ? x.background : null;
        return v && v.isTexture && (v = (x.backgroundBlurriness > 0 ? t : e).get(v)), v;
      }
      function _(x) {
        let v = false;
        const A = f(x);
        A === null ? m(o, l) : A && A.isColor && (m(A, 1), v = true);
        const T = r.xr.getEnvironmentBlendMode();
        T === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, a) : T === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, a), (r.autoClear || v) && (i.buffers.depth.setTest(true), i.buffers.depth.setMask(true), i.buffers.color.setMask(true), r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil));
      }
      function g(x, v) {
        const A = f(v);
        A && (A.isCubeTexture || A.mapping === no) ? (u === void 0 && (u = new Rt(new un(1, 1, 1), new Zt({
          name: "BackgroundCubeMaterial",
          uniforms: ps(ir.backgroundCube.uniforms),
          vertexShader: ir.backgroundCube.vertexShader,
          fragmentShader: ir.backgroundCube.fragmentShader,
          side: vt,
          depthTest: false,
          depthWrite: false,
          fog: false
        })), u.geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function(T, w, R) {
          this.matrixWorld.copyPosition(R.matrixWorld);
        }, Object.defineProperty(u.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        }), n.update(u)), gn.copy(v.backgroundRotation), gn.x *= -1, gn.y *= -1, gn.z *= -1, A.isCubeTexture && A.isRenderTargetTexture === false && (gn.y *= -1, gn.z *= -1), u.material.uniforms.envMap.value = A, u.material.uniforms.flipEnvMap.value = A.isCubeTexture && A.isRenderTargetTexture === false ? -1 : 1, u.material.uniforms.backgroundBlurriness.value = v.backgroundBlurriness, u.material.uniforms.backgroundIntensity.value = v.backgroundIntensity, u.material.uniforms.backgroundRotation.value.setFromMatrix4(Dy.makeRotationFromEuler(gn)), u.material.toneMapped = Ke.getTransfer(A.colorSpace) !== ot, (h !== A || d !== A.version || p !== r.toneMapping) && (u.material.needsUpdate = true, h = A, d = A.version, p = r.toneMapping), u.layers.enableAll(), x.unshift(u, u.geometry, u.material, 0, 0, null)) : A && A.isTexture && (c === void 0 && (c = new Rt(new Ta(2, 2), new Zt({
          name: "BackgroundMaterial",
          uniforms: ps(ir.background.uniforms),
          vertexShader: ir.background.vertexShader,
          fragmentShader: ir.background.fragmentShader,
          side: Ot,
          depthTest: false,
          depthWrite: false,
          fog: false
        })), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        }), n.update(c)), c.material.uniforms.t2D.value = A, c.material.uniforms.backgroundIntensity.value = v.backgroundIntensity, c.material.toneMapped = Ke.getTransfer(A.colorSpace) !== ot, A.matrixAutoUpdate === true && A.updateMatrix(), c.material.uniforms.uvTransform.value.copy(A.matrix), (h !== A || d !== A.version || p !== r.toneMapping) && (c.material.needsUpdate = true, h = A, d = A.version, p = r.toneMapping), c.layers.enableAll(), x.unshift(c, c.geometry, c.material, 0, 0, null));
      }
      function m(x, v) {
        x.getRGB(Ko, Td(r)), i.buffers.color.setClear(Ko.r, Ko.g, Ko.b, v, a);
      }
      function y() {
        u !== void 0 && (u.geometry.dispose(), u.material.dispose(), u = void 0), c !== void 0 && (c.geometry.dispose(), c.material.dispose(), c = void 0);
      }
      return {
        getClearColor: function() {
          return o;
        },
        setClearColor: function(x, v = 1) {
          o.set(x), l = v, m(o, l);
        },
        getClearAlpha: function() {
          return l;
        },
        setClearAlpha: function(x) {
          l = x, m(o, l);
        },
        render: _,
        addToRenderList: g,
        dispose: y
      };
    }
    function Uy(r, e) {
      const t = r.getParameter(r.MAX_VERTEX_ATTRIBS), i = {}, n = d(null);
      let s = n, a = false;
      function o(b, L, B, F, V) {
        let X = false;
        const k = h(F, B, L);
        s !== k && (s = k, c(s.object)), X = p(b, F, B, V), X && f(b, F, B, V), V !== null && e.update(V, r.ELEMENT_ARRAY_BUFFER), (X || a) && (a = false, v(b, L, B, F), V !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e.get(V).buffer));
      }
      function l() {
        return r.createVertexArray();
      }
      function c(b) {
        return r.bindVertexArray(b);
      }
      function u(b) {
        return r.deleteVertexArray(b);
      }
      function h(b, L, B) {
        const F = B.wireframe === true;
        let V = i[b.id];
        V === void 0 && (V = {}, i[b.id] = V);
        let X = V[L.id];
        X === void 0 && (X = {}, V[L.id] = X);
        let k = X[F];
        return k === void 0 && (k = d(l()), X[F] = k), k;
      }
      function d(b) {
        const L = [], B = [], F = [];
        for (let V = 0; V < t; V++) L[V] = 0, B[V] = 0, F[V] = 0;
        return {
          geometry: null,
          program: null,
          wireframe: false,
          newAttributes: L,
          enabledAttributes: B,
          attributeDivisors: F,
          object: b,
          attributes: {},
          index: null
        };
      }
      function p(b, L, B, F) {
        const V = s.attributes, X = L.attributes;
        let k = 0;
        const K = B.getAttributes();
        for (const G in K) if (K[G].location >= 0) {
          const ie = V[G];
          let ue = X[G];
          if (ue === void 0 && (G === "instanceMatrix" && b.instanceMatrix && (ue = b.instanceMatrix), G === "instanceColor" && b.instanceColor && (ue = b.instanceColor)), ie === void 0 || ie.attribute !== ue || ue && ie.data !== ue.data) return true;
          k++;
        }
        return s.attributesNum !== k || s.index !== F;
      }
      function f(b, L, B, F) {
        const V = {}, X = L.attributes;
        let k = 0;
        const K = B.getAttributes();
        for (const G in K) if (K[G].location >= 0) {
          let ie = X[G];
          ie === void 0 && (G === "instanceMatrix" && b.instanceMatrix && (ie = b.instanceMatrix), G === "instanceColor" && b.instanceColor && (ie = b.instanceColor));
          const ue = {};
          ue.attribute = ie, ie && ie.data && (ue.data = ie.data), V[G] = ue, k++;
        }
        s.attributes = V, s.attributesNum = k, s.index = F;
      }
      function _() {
        const b = s.newAttributes;
        for (let L = 0, B = b.length; L < B; L++) b[L] = 0;
      }
      function g(b) {
        m(b, 0);
      }
      function m(b, L) {
        const B = s.newAttributes, F = s.enabledAttributes, V = s.attributeDivisors;
        B[b] = 1, F[b] === 0 && (r.enableVertexAttribArray(b), F[b] = 1), V[b] !== L && (r.vertexAttribDivisor(b, L), V[b] = L);
      }
      function y() {
        const b = s.newAttributes, L = s.enabledAttributes;
        for (let B = 0, F = L.length; B < F; B++) L[B] !== b[B] && (r.disableVertexAttribArray(B), L[B] = 0);
      }
      function x(b, L, B, F, V, X, k) {
        k === true ? r.vertexAttribIPointer(b, L, B, V, X) : r.vertexAttribPointer(b, L, B, F, V, X);
      }
      function v(b, L, B, F) {
        _();
        const V = F.attributes, X = B.getAttributes(), k = L.defaultAttributeValues;
        for (const K in X) {
          const G = X[K];
          if (G.location >= 0) {
            let ie = V[K];
            if (ie === void 0 && (K === "instanceMatrix" && b.instanceMatrix && (ie = b.instanceMatrix), K === "instanceColor" && b.instanceColor && (ie = b.instanceColor)), ie !== void 0) {
              const ue = ie.normalized, we = ie.itemSize, Be = e.get(ie);
              if (Be === void 0) continue;
              const We = Be.buffer, j = Be.type, re = Be.bytesPerElement, _e = j === r.INT || j === r.UNSIGNED_INT || ie.gpuType === Ul;
              if (ie.isInterleavedBufferAttribute) {
                const ae = ie.data, Pe = ae.stride, Re = ie.offset;
                if (ae.isInstancedInterleavedBuffer) {
                  for (let De = 0; De < G.locationSize; De++) m(G.location + De, ae.meshPerAttribute);
                  b.isInstancedMesh !== true && F._maxInstanceCount === void 0 && (F._maxInstanceCount = ae.meshPerAttribute * ae.count);
                } else for (let De = 0; De < G.locationSize; De++) g(G.location + De);
                r.bindBuffer(r.ARRAY_BUFFER, We);
                for (let De = 0; De < G.locationSize; De++) x(G.location + De, we / G.locationSize, j, ue, Pe * re, (Re + we / G.locationSize * De) * re, _e);
              } else {
                if (ie.isInstancedBufferAttribute) {
                  for (let ae = 0; ae < G.locationSize; ae++) m(G.location + ae, ie.meshPerAttribute);
                  b.isInstancedMesh !== true && F._maxInstanceCount === void 0 && (F._maxInstanceCount = ie.meshPerAttribute * ie.count);
                } else for (let ae = 0; ae < G.locationSize; ae++) g(G.location + ae);
                r.bindBuffer(r.ARRAY_BUFFER, We);
                for (let ae = 0; ae < G.locationSize; ae++) x(G.location + ae, we / G.locationSize, j, ue, we * re, we / G.locationSize * ae * re, _e);
              }
            } else if (k !== void 0) {
              const ue = k[K];
              if (ue !== void 0) switch (ue.length) {
                case 2:
                  r.vertexAttrib2fv(G.location, ue);
                  break;
                case 3:
                  r.vertexAttrib3fv(G.location, ue);
                  break;
                case 4:
                  r.vertexAttrib4fv(G.location, ue);
                  break;
                default:
                  r.vertexAttrib1fv(G.location, ue);
              }
            }
          }
        }
        y();
      }
      function A() {
        R();
        for (const b in i) {
          const L = i[b];
          for (const B in L) {
            const F = L[B];
            for (const V in F) u(F[V].object), delete F[V];
            delete L[B];
          }
          delete i[b];
        }
      }
      function T(b) {
        if (i[b.id] === void 0) return;
        const L = i[b.id];
        for (const B in L) {
          const F = L[B];
          for (const V in F) u(F[V].object), delete F[V];
          delete L[B];
        }
        delete i[b.id];
      }
      function w(b) {
        for (const L in i) {
          const B = i[L];
          if (B[b.id] === void 0) continue;
          const F = B[b.id];
          for (const V in F) u(F[V].object), delete F[V];
          delete B[b.id];
        }
      }
      function R() {
        E(), a = true, s !== n && (s = n, c(s.object));
      }
      function E() {
        n.geometry = null, n.program = null, n.wireframe = false;
      }
      return {
        setup: o,
        reset: R,
        resetDefaultState: E,
        dispose: A,
        releaseStatesOfGeometry: T,
        releaseStatesOfProgram: w,
        initAttributes: _,
        enableAttribute: g,
        disableUnusedAttributes: y
      };
    }
    function Oy(r, e, t) {
      let i;
      function n(c) {
        i = c;
      }
      function s(c, u) {
        r.drawArrays(i, c, u), t.update(u, i, 1);
      }
      function a(c, u, h) {
        h !== 0 && (r.drawArraysInstanced(i, c, u, h), t.update(u, i, h));
      }
      function o(c, u, h) {
        if (h === 0) return;
        e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, c, 0, u, 0, h);
        let d = 0;
        for (let p = 0; p < h; p++) d += u[p];
        t.update(d, i, 1);
      }
      function l(c, u, h, d) {
        if (h === 0) return;
        const p = e.get("WEBGL_multi_draw");
        if (p === null) for (let f = 0; f < c.length; f++) a(c[f], u[f], d[f]);
        else {
          p.multiDrawArraysInstancedWEBGL(i, c, 0, u, 0, d, 0, h);
          let f = 0;
          for (let _ = 0; _ < h; _++) f += u[_] * d[_];
          t.update(f, i, 1);
        }
      }
      this.setMode = n, this.render = s, this.renderInstances = a, this.renderMultiDraw = o, this.renderMultiDrawInstances = l;
    }
    function Ny(r, e, t, i) {
      let n;
      function s() {
        if (n !== void 0) return n;
        if (e.has("EXT_texture_filter_anisotropic") === true) {
          const w = e.get("EXT_texture_filter_anisotropic");
          n = r.getParameter(w.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else n = 0;
        return n;
      }
      function a(w) {
        return !(w !== Ri && i.convert(w) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT));
      }
      function o(w) {
        const R = w === hr && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
        return !(w !== ur && i.convert(w) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) && w !== Bi && !R);
      }
      function l(w) {
        if (w === "highp") {
          if (r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0) return "highp";
          w = "mediump";
        }
        return w === "mediump" && r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp";
      }
      let c = t.precision !== void 0 ? t.precision : "highp";
      const u = l(c);
      u !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", u, "instead."), c = u);
      const h = t.logarithmicDepthBuffer === true, d = t.reverseDepthBuffer === true && e.has("EXT_clip_control"), p = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS), f = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS), _ = r.getParameter(r.MAX_TEXTURE_SIZE), g = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE), m = r.getParameter(r.MAX_VERTEX_ATTRIBS), y = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS), x = r.getParameter(r.MAX_VARYING_VECTORS), v = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS), A = f > 0, T = r.getParameter(r.MAX_SAMPLES);
      return {
        isWebGL2: true,
        getMaxAnisotropy: s,
        getMaxPrecision: l,
        textureFormatReadable: a,
        textureTypeReadable: o,
        precision: c,
        logarithmicDepthBuffer: h,
        reverseDepthBuffer: d,
        maxTextures: p,
        maxVertexTextures: f,
        maxTextureSize: _,
        maxCubemapSize: g,
        maxAttributes: m,
        maxVertexUniforms: y,
        maxVaryings: x,
        maxFragmentUniforms: v,
        vertexTextures: A,
        maxSamples: T
      };
    }
    function Fy(r) {
      const e = this;
      let t = null, i = 0, n = false, s = false;
      const a = new hn(), o = new ze(), l = {
        value: null,
        needsUpdate: false
      };
      this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(h, d) {
        const p = h.length !== 0 || d || i !== 0 || n;
        return n = d, i = h.length, p;
      }, this.beginShadows = function() {
        s = true, u(null);
      }, this.endShadows = function() {
        s = false;
      }, this.setGlobalState = function(h, d) {
        t = u(h, d, 0);
      }, this.setState = function(h, d, p) {
        const f = h.clippingPlanes, _ = h.clipIntersection, g = h.clipShadows, m = r.get(h);
        if (!n || f === null || f.length === 0 || s && !g) s ? u(null) : c();
        else {
          const y = s ? 0 : i, x = y * 4;
          let v = m.clippingState || null;
          l.value = v, v = u(f, d, x, p);
          for (let A = 0; A !== x; ++A) v[A] = t[A];
          m.clippingState = v, this.numIntersection = _ ? this.numPlanes : 0, this.numPlanes += y;
        }
      };
      function c() {
        l.value !== t && (l.value = t, l.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0;
      }
      function u(h, d, p, f) {
        const _ = h !== null ? h.length : 0;
        let g = null;
        if (_ !== 0) {
          if (g = l.value, f !== true || g === null) {
            const m = p + _ * 4, y = d.matrixWorldInverse;
            o.getNormalMatrix(y), (g === null || g.length < m) && (g = new Float32Array(m));
            for (let x = 0, v = p; x !== _; ++x, v += 4) a.copy(h[x]).applyMatrix4(y, o), a.normal.toArray(g, v), g[v + 3] = a.constant;
          }
          l.value = g, l.needsUpdate = true;
        }
        return e.numPlanes = _, e.numIntersection = 0, g;
      }
    }
    function By(r) {
      let e = /* @__PURE__ */ new WeakMap();
      function t(a, o) {
        return o === Dl ? a.mapping = jn : o === Il && (a.mapping = qn), a;
      }
      function i(a) {
        if (a && a.isTexture) {
          const o = a.mapping;
          if (o === Dl || o === Il) if (e.has(a)) {
            const l = e.get(a).texture;
            return t(l, a.mapping);
          } else {
            const l = a.image;
            if (l && l.height > 0) {
              const c = new w_(l.height);
              return c.fromEquirectangularTexture(r, a), e.set(a, c), a.addEventListener("dispose", n), t(c.texture, a.mapping);
            } else return null;
          }
        }
        return a;
      }
      function n(a) {
        const o = a.target;
        o.removeEventListener("dispose", n);
        const l = e.get(o);
        l !== void 0 && (e.delete(o), l.dispose());
      }
      function s() {
        e = /* @__PURE__ */ new WeakMap();
      }
      return {
        get: i,
        dispose: s
      };
    }
    const Ts = 4, xp = [
      0.125,
      0.215,
      0.35,
      0.446,
      0.526,
      0.582
    ], _n = 20, fu = new Yo(), yp = new Ae();
    let mu = null, gu = 0, _u = 0, vu = false;
    const vn = (1 + Math.sqrt(5)) / 2, ws = 1 / vn, Mp = [
      new D(-vn, ws, 0),
      new D(vn, ws, 0),
      new D(-ws, 0, vn),
      new D(ws, 0, vn),
      new D(0, vn, -ws),
      new D(0, vn, ws),
      new D(-1, 1, -1),
      new D(1, 1, -1),
      new D(-1, 1, 1),
      new D(1, 1, 1)
    ];
    class bp {
      constructor(e) {
        this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial);
      }
      fromScene(e, t = 0, i = 0.1, n = 100) {
        mu = this._renderer.getRenderTarget(), gu = this._renderer.getActiveCubeFace(), _u = this._renderer.getActiveMipmapLevel(), vu = this._renderer.xr.enabled, this._renderer.xr.enabled = false, this._setSize(256);
        const s = this._allocateTargets();
        return s.depthBuffer = true, this._sceneToCubeUV(e, i, n, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s;
      }
      fromEquirectangular(e, t = null) {
        return this._fromTexture(e, t);
      }
      fromCubemap(e, t = null) {
        return this._fromTexture(e, t);
      }
      compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = Tp(), this._compileMaterial(this._cubemapMaterial));
      }
      compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = Ep(), this._compileMaterial(this._equirectMaterial));
      }
      dispose() {
        this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose();
      }
      _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
      }
      _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose();
      }
      _cleanup(e) {
        this._renderer.setRenderTarget(mu, gu, _u), this._renderer.xr.enabled = vu, e.scissorTest = false, Zo(e, 0, 0, e.width, e.height);
      }
      _fromTexture(e, t) {
        e.mapping === jn || e.mapping === qn ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), mu = this._renderer.getRenderTarget(), gu = this._renderer.getActiveCubeFace(), _u = this._renderer.getActiveMipmapLevel(), vu = this._renderer.xr.enabled, this._renderer.xr.enabled = false;
        const i = t || this._allocateTargets();
        return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i;
      }
      _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize, i = {
          magFilter: _i,
          minFilter: _i,
          generateMipmaps: false,
          type: hr,
          format: Ri,
          colorSpace: ni,
          depthBuffer: false
        }, n = Sp(e, t, i);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
          this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = Sp(e, t, i);
          const { _lodMax: s } = this;
          ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = zy(s)), this._blurMaterial = ky(s, e, t);
        }
        return n;
      }
      _compileMaterial(e) {
        const t = new Rt(this._lodPlanes[0], e);
        this._renderer.compile(t, fu);
      }
      _sceneToCubeUV(e, t, i, n) {
        const s = new oi(90, 1, t, i), a = [
          1,
          -1,
          1,
          1,
          1,
          1
        ], o = [
          1,
          1,
          1,
          -1,
          -1,
          -1
        ], l = this._renderer, c = l.autoClear, u = l.toneMapping;
        l.getClearColor(yp), l.toneMapping = Ir, l.autoClear = false;
        const h = new $i({
          name: "PMREM.Background",
          side: vt,
          depthWrite: false,
          depthTest: false
        }), d = new Rt(new un(), h);
        let p = false;
        const f = e.background;
        f ? f.isColor && (h.color.copy(f), e.background = null, p = true) : (h.color.copy(yp), p = true);
        for (let _ = 0; _ < 6; _++) {
          const g = _ % 3;
          g === 0 ? (s.up.set(0, a[_], 0), s.lookAt(o[_], 0, 0)) : g === 1 ? (s.up.set(0, 0, a[_]), s.lookAt(0, o[_], 0)) : (s.up.set(0, a[_], 0), s.lookAt(0, 0, o[_]));
          const m = this._cubeSize;
          Zo(n, g * m, _ > 2 ? m : 0, m, m), l.setRenderTarget(n), p && l.render(d, s), l.render(e, s);
        }
        d.geometry.dispose(), d.material.dispose(), l.toneMapping = u, l.autoClear = c, e.background = f;
      }
      _textureToCubeUV(e, t) {
        const i = this._renderer, n = e.mapping === jn || e.mapping === qn;
        n ? (this._cubemapMaterial === null && (this._cubemapMaterial = Tp()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === false ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Ep());
        const s = n ? this._cubemapMaterial : this._equirectMaterial, a = new Rt(this._lodPlanes[0], s), o = s.uniforms;
        o.envMap.value = e;
        const l = this._cubeSize;
        Zo(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(a, fu);
      }
      _applyPMREM(e) {
        const t = this._renderer, i = t.autoClear;
        t.autoClear = false;
        const n = this._lodPlanes.length;
        for (let s = 1; s < n; s++) {
          const a = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1]), o = Mp[(n - s - 1) % Mp.length];
          this._blur(e, s - 1, s, a, o);
        }
        t.autoClear = i;
      }
      _blur(e, t, i, n, s) {
        const a = this._pingPongRenderTarget;
        this._halfBlur(e, a, t, i, n, "latitudinal", s), this._halfBlur(a, e, i, i, n, "longitudinal", s);
      }
      _halfBlur(e, t, i, n, s, a, o) {
        const l = this._renderer, c = this._blurMaterial;
        a !== "latitudinal" && a !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const u = 3, h = new Rt(this._lodPlanes[n], c), d = c.uniforms, p = this._sizeLods[i] - 1, f = isFinite(s) ? Math.PI / (2 * p) : 2 * Math.PI / (2 * _n - 1), _ = s / f, g = isFinite(s) ? 1 + Math.floor(u * _) : _n;
        g > _n && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${_n}`);
        const m = [];
        let y = 0;
        for (let w = 0; w < _n; ++w) {
          const R = w / _, E = Math.exp(-R * R / 2);
          m.push(E), w === 0 ? y += E : w < g && (y += 2 * E);
        }
        for (let w = 0; w < m.length; w++) m[w] = m[w] / y;
        d.envMap.value = e.texture, d.samples.value = g, d.weights.value = m, d.latitudinal.value = a === "latitudinal", o && (d.poleAxis.value = o);
        const { _lodMax: x } = this;
        d.dTheta.value = f, d.mipInt.value = x - i;
        const v = this._sizeLods[n], A = 3 * v * (n > x - Ts ? n - x + Ts : 0), T = 4 * (this._cubeSize - v);
        Zo(t, A, T, 3 * v, 2 * v), l.setRenderTarget(t), l.render(h, fu);
      }
    }
    function zy(r) {
      const e = [], t = [], i = [];
      let n = r;
      const s = r - Ts + 1 + xp.length;
      for (let a = 0; a < s; a++) {
        const o = Math.pow(2, n);
        t.push(o);
        let l = 1 / o;
        a > r - Ts ? l = xp[a - r + Ts - 1] : a === 0 && (l = 0), i.push(l);
        const c = 1 / (o - 2), u = -c, h = 1 + c, d = [
          u,
          u,
          h,
          u,
          h,
          h,
          u,
          u,
          h,
          h,
          u,
          h
        ], p = 6, f = 6, _ = 3, g = 2, m = 1, y = new Float32Array(_ * f * p), x = new Float32Array(g * f * p), v = new Float32Array(m * f * p);
        for (let T = 0; T < p; T++) {
          const w = T % 3 * 2 / 3 - 1, R = T > 2 ? 0 : -1, E = [
            w,
            R,
            0,
            w + 2 / 3,
            R,
            0,
            w + 2 / 3,
            R + 1,
            0,
            w,
            R,
            0,
            w + 2 / 3,
            R + 1,
            0,
            w,
            R + 1,
            0
          ];
          y.set(E, _ * f * T), x.set(d, g * f * T);
          const b = [
            T,
            T,
            T,
            T,
            T,
            T
          ];
          v.set(b, m * f * T);
        }
        const A = new hi();
        A.setAttribute("position", new si(y, _)), A.setAttribute("uv", new si(x, g)), A.setAttribute("faceIndex", new si(v, m)), e.push(A), n > Ts && n--;
      }
      return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: i
      };
    }
    function Sp(r, e, t) {
      const i = new ki(r, e, t);
      return i.texture.mapping = no, i.texture.name = "PMREM.cubeUv", i.scissorTest = true, i;
    }
    function Zo(r, e, t, i, n) {
      r.viewport.set(e, t, i, n), r.scissor.set(e, t, i, n);
    }
    function ky(r, e, t) {
      const i = new Float32Array(_n), n = new D(0, 1, 0);
      return new Zt({
        name: "SphericalGaussianBlur",
        defines: {
          n: _n,
          CUBEUV_TEXEL_WIDTH: 1 / e,
          CUBEUV_TEXEL_HEIGHT: 1 / t,
          CUBEUV_MAX_MIP: `${r}.0`
        },
        uniforms: {
          envMap: {
            value: null
          },
          samples: {
            value: 1
          },
          weights: {
            value: i
          },
          latitudinal: {
            value: false
          },
          dTheta: {
            value: 0
          },
          mipInt: {
            value: 0
          },
          poleAxis: {
            value: n
          }
        },
        vertexShader: xu(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: Fi,
        depthTest: false,
        depthWrite: false
      });
    }
    function Ep() {
      return new Zt({
        name: "EquirectangularToCubeUV",
        uniforms: {
          envMap: {
            value: null
          }
        },
        vertexShader: xu(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: Fi,
        depthTest: false,
        depthWrite: false
      });
    }
    function Tp() {
      return new Zt({
        name: "CubemapToCubeUV",
        uniforms: {
          envMap: {
            value: null
          },
          flipEnvMap: {
            value: -1
          }
        },
        vertexShader: xu(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: Fi,
        depthTest: false,
        depthWrite: false
      });
    }
    function xu() {
      return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
    }
    function Hy(r) {
      let e = /* @__PURE__ */ new WeakMap(), t = null;
      function i(o) {
        if (o && o.isTexture) {
          const l = o.mapping, c = l === Dl || l === Il, u = l === jn || l === qn;
          if (c || u) {
            let h = e.get(o);
            const d = h !== void 0 ? h.texture.pmremVersion : 0;
            if (o.isRenderTargetTexture && o.pmremVersion !== d) return t === null && (t = new bp(r)), h = c ? t.fromEquirectangular(o, h) : t.fromCubemap(o, h), h.texture.pmremVersion = o.pmremVersion, e.set(o, h), h.texture;
            if (h !== void 0) return h.texture;
            {
              const p = o.image;
              return c && p && p.height > 0 || u && p && n(p) ? (t === null && (t = new bp(r)), h = c ? t.fromEquirectangular(o) : t.fromCubemap(o), h.texture.pmremVersion = o.pmremVersion, e.set(o, h), o.addEventListener("dispose", s), h.texture) : null;
            }
          }
        }
        return o;
      }
      function n(o) {
        let l = 0;
        const c = 6;
        for (let u = 0; u < c; u++) o[u] !== void 0 && l++;
        return l === c;
      }
      function s(o) {
        const l = o.target;
        l.removeEventListener("dispose", s);
        const c = e.get(l);
        c !== void 0 && (e.delete(l), c.dispose());
      }
      function a() {
        e = /* @__PURE__ */ new WeakMap(), t !== null && (t.dispose(), t = null);
      }
      return {
        get: i,
        dispose: a
      };
    }
    function Vy(r) {
      const e = {};
      function t(i) {
        if (e[i] !== void 0) return e[i];
        let n;
        switch (i) {
          case "WEBGL_depth_texture":
            n = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
          case "EXT_texture_filter_anisotropic":
            n = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case "WEBGL_compressed_texture_s3tc":
            n = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "WEBGL_compressed_texture_pvrtc":
            n = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            n = r.getExtension(i);
        }
        return e[i] = n, n;
      }
      return {
        has: function(i) {
          return t(i) !== null;
        },
        init: function() {
          t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent");
        },
        get: function(i) {
          const n = t(i);
          return n === null && ts("THREE.WebGLRenderer: " + i + " extension not supported."), n;
        }
      };
    }
    function Gy(r, e, t, i) {
      const n = {}, s = /* @__PURE__ */ new WeakMap();
      function a(h) {
        const d = h.target;
        d.index !== null && e.remove(d.index);
        for (const f in d.attributes) e.remove(d.attributes[f]);
        d.removeEventListener("dispose", a), delete n[d.id];
        const p = s.get(d);
        p && (e.remove(p), s.delete(d)), i.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === true && delete d._maxInstanceCount, t.memory.geometries--;
      }
      function o(h, d) {
        return n[d.id] === true || (d.addEventListener("dispose", a), n[d.id] = true, t.memory.geometries++), d;
      }
      function l(h) {
        const d = h.attributes;
        for (const p in d) e.update(d[p], r.ARRAY_BUFFER);
      }
      function c(h) {
        const d = [], p = h.index, f = h.attributes.position;
        let _ = 0;
        if (p !== null) {
          const y = p.array;
          _ = p.version;
          for (let x = 0, v = y.length; x < v; x += 3) {
            const A = y[x + 0], T = y[x + 1], w = y[x + 2];
            d.push(A, T, T, w, w, A);
          }
        } else if (f !== void 0) {
          const y = f.array;
          _ = f.version;
          for (let x = 0, v = y.length / 3 - 1; x < v; x += 3) {
            const A = x + 0, T = x + 1, w = x + 2;
            d.push(A, T, T, w, w, A);
          }
        } else return;
        const g = new (nd(d) ? Md : yd)(d, 1);
        g.version = _;
        const m = s.get(h);
        m && e.remove(m), s.set(h, g);
      }
      function u(h) {
        const d = s.get(h);
        if (d) {
          const p = h.index;
          p !== null && d.version < p.version && c(h);
        } else c(h);
        return s.get(h);
      }
      return {
        get: o,
        update: l,
        getWireframeAttribute: u
      };
    }
    function Wy(r, e, t) {
      let i;
      function n(d) {
        i = d;
      }
      let s, a;
      function o(d) {
        s = d.type, a = d.bytesPerElement;
      }
      function l(d, p) {
        r.drawElements(i, p, s, d * a), t.update(p, i, 1);
      }
      function c(d, p, f) {
        f !== 0 && (r.drawElementsInstanced(i, p, s, d * a, f), t.update(p, i, f));
      }
      function u(d, p, f) {
        if (f === 0) return;
        e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, p, 0, s, d, 0, f);
        let _ = 0;
        for (let g = 0; g < f; g++) _ += p[g];
        t.update(_, i, 1);
      }
      function h(d, p, f, _) {
        if (f === 0) return;
        const g = e.get("WEBGL_multi_draw");
        if (g === null) for (let m = 0; m < d.length; m++) c(d[m] / a, p[m], _[m]);
        else {
          g.multiDrawElementsInstancedWEBGL(i, p, 0, s, d, 0, _, 0, f);
          let m = 0;
          for (let y = 0; y < f; y++) m += p[y] * _[y];
          t.update(m, i, 1);
        }
      }
      this.setMode = n, this.setIndex = o, this.render = l, this.renderInstances = c, this.renderMultiDraw = u, this.renderMultiDrawInstances = h;
    }
    function Xy(r) {
      const e = {
        geometries: 0,
        textures: 0
      }, t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
      };
      function i(s, a, o) {
        switch (t.calls++, a) {
          case r.TRIANGLES:
            t.triangles += o * (s / 3);
            break;
          case r.LINES:
            t.lines += o * (s / 2);
            break;
          case r.LINE_STRIP:
            t.lines += o * (s - 1);
            break;
          case r.LINE_LOOP:
            t.lines += o * s;
            break;
          case r.POINTS:
            t.points += o * s;
            break;
          default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", a);
            break;
        }
      }
      function n() {
        t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0;
      }
      return {
        memory: e,
        render: t,
        programs: null,
        autoReset: true,
        reset: n,
        update: i
      };
    }
    function jy(r, e, t) {
      const i = /* @__PURE__ */ new WeakMap(), n = new it();
      function s(a, o, l) {
        const c = a.morphTargetInfluences, u = o.morphAttributes.position || o.morphAttributes.normal || o.morphAttributes.color, h = u !== void 0 ? u.length : 0;
        let d = i.get(o);
        if (d === void 0 || d.count !== h) {
          let p = function() {
            R.dispose(), i.delete(o), o.removeEventListener("dispose", p);
          };
          d !== void 0 && d.texture.dispose();
          const f = o.morphAttributes.position !== void 0, _ = o.morphAttributes.normal !== void 0, g = o.morphAttributes.color !== void 0, m = o.morphAttributes.position || [], y = o.morphAttributes.normal || [], x = o.morphAttributes.color || [];
          let v = 0;
          f === true && (v = 1), _ === true && (v = 2), g === true && (v = 3);
          let A = o.attributes.position.count * v, T = 1;
          A > e.maxTextureSize && (T = Math.ceil(A / e.maxTextureSize), A = e.maxTextureSize);
          const w = new Float32Array(A * T * 4 * h), R = new cd(w, A, T, h);
          R.type = Bi, R.needsUpdate = true;
          const E = v * 4;
          for (let b = 0; b < h; b++) {
            const L = m[b], B = y[b], F = x[b], V = A * T * 4 * b;
            for (let X = 0; X < L.count; X++) {
              const k = X * E;
              f === true && (n.fromBufferAttribute(L, X), w[V + k + 0] = n.x, w[V + k + 1] = n.y, w[V + k + 2] = n.z, w[V + k + 3] = 0), _ === true && (n.fromBufferAttribute(B, X), w[V + k + 4] = n.x, w[V + k + 5] = n.y, w[V + k + 6] = n.z, w[V + k + 7] = 0), g === true && (n.fromBufferAttribute(F, X), w[V + k + 8] = n.x, w[V + k + 9] = n.y, w[V + k + 10] = n.z, w[V + k + 11] = F.itemSize === 4 ? n.w : 1);
            }
          }
          d = {
            count: h,
            texture: R,
            size: new ee(A, T)
          }, i.set(o, d), o.addEventListener("dispose", p);
        }
        if (a.isInstancedMesh === true && a.morphTexture !== null) l.getUniforms().setValue(r, "morphTexture", a.morphTexture, t);
        else {
          let p = 0;
          for (let _ = 0; _ < c.length; _++) p += c[_];
          const f = o.morphTargetsRelative ? 1 : 1 - p;
          l.getUniforms().setValue(r, "morphTargetBaseInfluence", f), l.getUniforms().setValue(r, "morphTargetInfluences", c);
        }
        l.getUniforms().setValue(r, "morphTargetsTexture", d.texture, t), l.getUniforms().setValue(r, "morphTargetsTextureSize", d.size);
      }
      return {
        update: s
      };
    }
    function qy(r, e, t, i) {
      let n = /* @__PURE__ */ new WeakMap();
      function s(l) {
        const c = i.render.frame, u = l.geometry, h = e.get(l, u);
        if (n.get(h) !== c && (e.update(h), n.set(h, c)), l.isInstancedMesh && (l.hasEventListener("dispose", o) === false && l.addEventListener("dispose", o), n.get(l) !== c && (t.update(l.instanceMatrix, r.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, r.ARRAY_BUFFER), n.set(l, c))), l.isSkinnedMesh) {
          const d = l.skeleton;
          n.get(d) !== c && (d.update(), n.set(d, c));
        }
        return h;
      }
      function a() {
        n = /* @__PURE__ */ new WeakMap();
      }
      function o(l) {
        const c = l.target;
        c.removeEventListener("dispose", o), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor);
      }
      return {
        update: s,
        dispose: a
      };
    }
    const wp = new Nt(), Ap = new Yd(1, 1), Rp = new cd(), Cp = new u_(), Pp = new Cd(), Lp = [], Dp = [], Ip = new Float32Array(16), Up = new Float32Array(9), Op = new Float32Array(4);
    function As(r, e, t) {
      const i = r[0];
      if (i <= 0 || i > 0) return r;
      const n = e * t;
      let s = Lp[n];
      if (s === void 0 && (s = new Float32Array(n), Lp[n] = s), e !== 0) {
        i.toArray(s, 0);
        for (let a = 1, o = 0; a !== e; ++a) o += t, r[a].toArray(s, o);
      }
      return s;
    }
    function Ft(r, e) {
      if (r.length !== e.length) return false;
      for (let t = 0, i = r.length; t < i; t++) if (r[t] !== e[t]) return false;
      return true;
    }
    function Bt(r, e) {
      for (let t = 0, i = e.length; t < i; t++) r[t] = e[t];
    }
    function Jo(r, e) {
      let t = Dp[e];
      t === void 0 && (t = new Int32Array(e), Dp[e] = t);
      for (let i = 0; i !== e; ++i) t[i] = r.allocateTextureUnit();
      return t;
    }
    function Yy(r, e) {
      const t = this.cache;
      t[0] !== e && (r.uniform1f(this.addr, e), t[0] = e);
    }
    function Ky(r, e) {
      const t = this.cache;
      if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (r.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
      else {
        if (Ft(t, e)) return;
        r.uniform2fv(this.addr, e), Bt(t, e);
      }
    }
    function Zy(r, e) {
      const t = this.cache;
      if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
      else if (e.r !== void 0) (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (r.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
      else {
        if (Ft(t, e)) return;
        r.uniform3fv(this.addr, e), Bt(t, e);
      }
    }
    function Jy(r, e) {
      const t = this.cache;
      if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
      else {
        if (Ft(t, e)) return;
        r.uniform4fv(this.addr, e), Bt(t, e);
      }
    }
    function $y(r, e) {
      const t = this.cache, i = e.elements;
      if (i === void 0) {
        if (Ft(t, e)) return;
        r.uniformMatrix2fv(this.addr, false, e), Bt(t, e);
      } else {
        if (Ft(t, i)) return;
        Op.set(i), r.uniformMatrix2fv(this.addr, false, Op), Bt(t, i);
      }
    }
    function Qy(r, e) {
      const t = this.cache, i = e.elements;
      if (i === void 0) {
        if (Ft(t, e)) return;
        r.uniformMatrix3fv(this.addr, false, e), Bt(t, e);
      } else {
        if (Ft(t, i)) return;
        Up.set(i), r.uniformMatrix3fv(this.addr, false, Up), Bt(t, i);
      }
    }
    function eM(r, e) {
      const t = this.cache, i = e.elements;
      if (i === void 0) {
        if (Ft(t, e)) return;
        r.uniformMatrix4fv(this.addr, false, e), Bt(t, e);
      } else {
        if (Ft(t, i)) return;
        Ip.set(i), r.uniformMatrix4fv(this.addr, false, Ip), Bt(t, i);
      }
    }
    function tM(r, e) {
      const t = this.cache;
      t[0] !== e && (r.uniform1i(this.addr, e), t[0] = e);
    }
    function iM(r, e) {
      const t = this.cache;
      if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (r.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
      else {
        if (Ft(t, e)) return;
        r.uniform2iv(this.addr, e), Bt(t, e);
      }
    }
    function rM(r, e) {
      const t = this.cache;
      if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
      else {
        if (Ft(t, e)) return;
        r.uniform3iv(this.addr, e), Bt(t, e);
      }
    }
    function nM(r, e) {
      const t = this.cache;
      if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
      else {
        if (Ft(t, e)) return;
        r.uniform4iv(this.addr, e), Bt(t, e);
      }
    }
    function sM(r, e) {
      const t = this.cache;
      t[0] !== e && (r.uniform1ui(this.addr, e), t[0] = e);
    }
    function aM(r, e) {
      const t = this.cache;
      if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y) && (r.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
      else {
        if (Ft(t, e)) return;
        r.uniform2uiv(this.addr, e), Bt(t, e);
      }
    }
    function oM(r, e) {
      const t = this.cache;
      if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
      else {
        if (Ft(t, e)) return;
        r.uniform3uiv(this.addr, e), Bt(t, e);
      }
    }
    function lM(r, e) {
      const t = this.cache;
      if (e.x !== void 0) (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
      else {
        if (Ft(t, e)) return;
        r.uniform4uiv(this.addr, e), Bt(t, e);
      }
    }
    function cM(r, e, t) {
      const i = this.cache, n = t.allocateTextureUnit();
      i[0] !== n && (r.uniform1i(this.addr, n), i[0] = n);
      let s;
      this.type === r.SAMPLER_2D_SHADOW ? (Ap.compareFunction = td, s = Ap) : s = wp, t.setTexture2D(e || s, n);
    }
    function uM(r, e, t) {
      const i = this.cache, n = t.allocateTextureUnit();
      i[0] !== n && (r.uniform1i(this.addr, n), i[0] = n), t.setTexture3D(e || Cp, n);
    }
    function hM(r, e, t) {
      const i = this.cache, n = t.allocateTextureUnit();
      i[0] !== n && (r.uniform1i(this.addr, n), i[0] = n), t.setTextureCube(e || Pp, n);
    }
    function dM(r, e, t) {
      const i = this.cache, n = t.allocateTextureUnit();
      i[0] !== n && (r.uniform1i(this.addr, n), i[0] = n), t.setTexture2DArray(e || Rp, n);
    }
    function pM(r) {
      switch (r) {
        case 5126:
          return Yy;
        case 35664:
          return Ky;
        case 35665:
          return Zy;
        case 35666:
          return Jy;
        case 35674:
          return $y;
        case 35675:
          return Qy;
        case 35676:
          return eM;
        case 5124:
        case 35670:
          return tM;
        case 35667:
        case 35671:
          return iM;
        case 35668:
        case 35672:
          return rM;
        case 35669:
        case 35673:
          return nM;
        case 5125:
          return sM;
        case 36294:
          return aM;
        case 36295:
          return oM;
        case 36296:
          return lM;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return cM;
        case 35679:
        case 36299:
        case 36307:
          return uM;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return hM;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return dM;
      }
    }
    function fM(r, e) {
      r.uniform1fv(this.addr, e);
    }
    function mM(r, e) {
      const t = As(e, this.size, 2);
      r.uniform2fv(this.addr, t);
    }
    function gM(r, e) {
      const t = As(e, this.size, 3);
      r.uniform3fv(this.addr, t);
    }
    function _M(r, e) {
      const t = As(e, this.size, 4);
      r.uniform4fv(this.addr, t);
    }
    function vM(r, e) {
      const t = As(e, this.size, 4);
      r.uniformMatrix2fv(this.addr, false, t);
    }
    function xM(r, e) {
      const t = As(e, this.size, 9);
      r.uniformMatrix3fv(this.addr, false, t);
    }
    function yM(r, e) {
      const t = As(e, this.size, 16);
      r.uniformMatrix4fv(this.addr, false, t);
    }
    function MM(r, e) {
      r.uniform1iv(this.addr, e);
    }
    function bM(r, e) {
      r.uniform2iv(this.addr, e);
    }
    function SM(r, e) {
      r.uniform3iv(this.addr, e);
    }
    function EM(r, e) {
      r.uniform4iv(this.addr, e);
    }
    function TM(r, e) {
      r.uniform1uiv(this.addr, e);
    }
    function wM(r, e) {
      r.uniform2uiv(this.addr, e);
    }
    function AM(r, e) {
      r.uniform3uiv(this.addr, e);
    }
    function RM(r, e) {
      r.uniform4uiv(this.addr, e);
    }
    function CM(r, e, t) {
      const i = this.cache, n = e.length, s = Jo(t, n);
      Ft(i, s) || (r.uniform1iv(this.addr, s), Bt(i, s));
      for (let a = 0; a !== n; ++a) t.setTexture2D(e[a] || wp, s[a]);
    }
    function PM(r, e, t) {
      const i = this.cache, n = e.length, s = Jo(t, n);
      Ft(i, s) || (r.uniform1iv(this.addr, s), Bt(i, s));
      for (let a = 0; a !== n; ++a) t.setTexture3D(e[a] || Cp, s[a]);
    }
    function LM(r, e, t) {
      const i = this.cache, n = e.length, s = Jo(t, n);
      Ft(i, s) || (r.uniform1iv(this.addr, s), Bt(i, s));
      for (let a = 0; a !== n; ++a) t.setTextureCube(e[a] || Pp, s[a]);
    }
    function DM(r, e, t) {
      const i = this.cache, n = e.length, s = Jo(t, n);
      Ft(i, s) || (r.uniform1iv(this.addr, s), Bt(i, s));
      for (let a = 0; a !== n; ++a) t.setTexture2DArray(e[a] || Rp, s[a]);
    }
    function IM(r) {
      switch (r) {
        case 5126:
          return fM;
        case 35664:
          return mM;
        case 35665:
          return gM;
        case 35666:
          return _M;
        case 35674:
          return vM;
        case 35675:
          return xM;
        case 35676:
          return yM;
        case 5124:
        case 35670:
          return MM;
        case 35667:
        case 35671:
          return bM;
        case 35668:
        case 35672:
          return SM;
        case 35669:
        case 35673:
          return EM;
        case 5125:
          return TM;
        case 36294:
          return wM;
        case 36295:
          return AM;
        case 36296:
          return RM;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
          return CM;
        case 35679:
        case 36299:
        case 36307:
          return PM;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
          return LM;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
          return DM;
      }
    }
    class UM {
      constructor(e, t, i) {
        this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.setValue = pM(t.type);
      }
    }
    class OM {
      constructor(e, t, i) {
        this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = IM(t.type);
      }
    }
    class NM {
      constructor(e) {
        this.id = e, this.seq = [], this.map = {};
      }
      setValue(e, t, i) {
        const n = this.seq;
        for (let s = 0, a = n.length; s !== a; ++s) {
          const o = n[s];
          o.setValue(e, t[o.id], i);
        }
      }
    }
    const yu = /(\w+)(\])?(\[|\.)?/g;
    function Np(r, e) {
      r.seq.push(e), r.map[e.id] = e;
    }
    function FM(r, e, t) {
      const i = r.name, n = i.length;
      for (yu.lastIndex = 0; ; ) {
        const s = yu.exec(i), a = yu.lastIndex;
        let o = s[1];
        const l = s[2] === "]", c = s[3];
        if (l && (o = o | 0), c === void 0 || c === "[" && a + 2 === n) {
          Np(t, c === void 0 ? new UM(o, r, e) : new OM(o, r, e));
          break;
        } else {
          let u = t.map[o];
          u === void 0 && (u = new NM(o), Np(t, u)), t = u;
        }
      }
    }
    class $o {
      constructor(e, t) {
        this.seq = [], this.map = {};
        const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let n = 0; n < i; ++n) {
          const s = e.getActiveUniform(t, n), a = e.getUniformLocation(t, s.name);
          FM(s, a, this);
        }
      }
      setValue(e, t, i, n) {
        const s = this.map[t];
        s !== void 0 && s.setValue(e, i, n);
      }
      setOptional(e, t, i) {
        const n = t[i];
        n !== void 0 && this.setValue(e, i, n);
      }
      static upload(e, t, i, n) {
        for (let s = 0, a = t.length; s !== a; ++s) {
          const o = t[s], l = i[o.id];
          l.needsUpdate !== false && o.setValue(e, l.value, n);
        }
      }
      static seqWithValue(e, t) {
        const i = [];
        for (let n = 0, s = e.length; n !== s; ++n) {
          const a = e[n];
          a.id in t && i.push(a);
        }
        return i;
      }
    }
    function Fp(r, e, t) {
      const i = r.createShader(e);
      return r.shaderSource(i, t), r.compileShader(i), i;
    }
    const BM = 37297;
    let zM = 0;
    function kM(r, e) {
      const t = r.split(`
`), i = [], n = Math.max(e - 6, 0), s = Math.min(e + 6, t.length);
      for (let a = n; a < s; a++) {
        const o = a + 1;
        i.push(`${o === e ? ">" : " "} ${o}: ${t[a]}`);
      }
      return i.join(`
`);
    }
    const Bp = new ze();
    function HM(r) {
      Ke._getMatrix(Bp, Ke.workingColorSpace, r);
      const e = `mat3( ${Bp.elements.map((t) => t.toFixed(4))} )`;
      switch (Ke.getTransfer(r)) {
        case po:
          return [
            e,
            "LinearTransferOETF"
          ];
        case ot:
          return [
            e,
            "sRGBTransferOETF"
          ];
        default:
          return console.warn("THREE.WebGLProgram: Unsupported color space: ", r), [
            e,
            "LinearTransferOETF"
          ];
      }
    }
    function zp(r, e, t) {
      const i = r.getShaderParameter(e, r.COMPILE_STATUS), n = r.getShaderInfoLog(e).trim();
      if (i && n === "") return "";
      const s = /ERROR: 0:(\d+)/.exec(n);
      if (s) {
        const a = parseInt(s[1]);
        return t.toUpperCase() + `

` + n + `

` + kM(r.getShaderSource(e), a);
      } else return n;
    }
    function VM(r, e) {
      const t = HM(e);
      return [
        `vec4 ${r}( vec4 value ) {`,
        `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`,
        "}"
      ].join(`
`);
    }
    function GM(r, e) {
      let t;
      switch (e) {
        case vg:
          t = "Linear";
          break;
        case xg:
          t = "Reinhard";
          break;
        case yg:
          t = "Cineon";
          break;
        case Mg:
          t = "ACESFilmic";
          break;
        case Sg:
          t = "AgX";
          break;
        case Eg:
          t = "Neutral";
          break;
        case bg:
          t = "Custom";
          break;
        default:
          console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear";
      }
      return "vec3 " + r + "( vec3 color ) { return " + t + "ToneMapping( color ); }";
    }
    const Qo = new D();
    function WM() {
      Ke.getLuminanceCoefficients(Qo);
      const r = Qo.x.toFixed(4), e = Qo.y.toFixed(4), t = Qo.z.toFixed(4);
      return [
        "float luminance( const in vec3 rgb ) {",
        `	const vec3 weights = vec3( ${r}, ${e}, ${t} );`,
        "	return dot( weights, rgb );",
        "}"
      ].join(`
`);
    }
    function XM(r) {
      return [
        r.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
        r.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
      ].filter(Ca).join(`
`);
    }
    function jM(r) {
      const e = [];
      for (const t in r) {
        const i = r[t];
        i !== false && e.push("#define " + t + " " + i);
      }
      return e.join(`
`);
    }
    function qM(r, e) {
      const t = {}, i = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
      for (let n = 0; n < i; n++) {
        const s = r.getActiveAttrib(e, n), a = s.name;
        let o = 1;
        s.type === r.FLOAT_MAT2 && (o = 2), s.type === r.FLOAT_MAT3 && (o = 3), s.type === r.FLOAT_MAT4 && (o = 4), t[a] = {
          type: s.type,
          location: r.getAttribLocation(e, a),
          locationSize: o
        };
      }
      return t;
    }
    function Ca(r) {
      return r !== "";
    }
    function kp(r, e) {
      const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
      return r.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
    }
    function Hp(r, e) {
      return r.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
    }
    const YM = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function Mu(r) {
      return r.replace(YM, ZM);
    }
    const KM = /* @__PURE__ */ new Map();
    function ZM(r, e) {
      let t = He[e];
      if (t === void 0) {
        const i = KM.get(e);
        if (i !== void 0) t = He[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
        else throw new Error("Can not resolve #include <" + e + ">");
      }
      return Mu(t);
    }
    const JM = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    function Vp(r) {
      return r.replace(JM, $M);
    }
    function $M(r, e, t, i) {
      let n = "";
      for (let s = parseInt(e); s < parseInt(t); s++) n += i.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
      return n;
    }
    function Gp(r) {
      let e = `precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`;
      return r.precision === "highp" ? e += `
#define HIGH_PRECISION` : r.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : r.precision === "lowp" && (e += `
#define LOW_PRECISION`), e;
    }
    function QM(r) {
      let e = "SHADOWMAP_TYPE_BASIC";
      return r.shadowMapType === wt ? e = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === qt ? e = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === At && (e = "SHADOWMAP_TYPE_VSM"), e;
    }
    function eb(r) {
      let e = "ENVMAP_TYPE_CUBE";
      if (r.envMap) switch (r.envMapMode) {
        case jn:
        case qn:
          e = "ENVMAP_TYPE_CUBE";
          break;
        case no:
          e = "ENVMAP_TYPE_CUBE_UV";
          break;
      }
      return e;
    }
    function tb(r) {
      let e = "ENVMAP_MODE_REFLECTION";
      if (r.envMap) switch (r.envMapMode) {
        case qn:
          e = "ENVMAP_MODE_REFRACTION";
          break;
      }
      return e;
    }
    function ib(r) {
      let e = "ENVMAP_BLENDING_NONE";
      if (r.envMap) switch (r.combine) {
        case Nh:
          e = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case gg:
          e = "ENVMAP_BLENDING_MIX";
          break;
        case _g:
          e = "ENVMAP_BLENDING_ADD";
          break;
      }
      return e;
    }
    function rb(r) {
      const e = r.envMapCubeUVHeight;
      if (e === null) return null;
      const t = Math.log2(e) - 2, i = 1 / e;
      return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: i,
        maxMip: t
      };
    }
    function nb(r, e, t, i) {
      const n = r.getContext(), s = t.defines;
      let a = t.vertexShader, o = t.fragmentShader;
      const l = QM(t), c = eb(t), u = tb(t), h = ib(t), d = rb(t), p = XM(t), f = jM(s), _ = n.createProgram();
      let g, m, y = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
      t.isRawShaderMaterial ? (g = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        f
      ].filter(Ca).join(`
`), g.length > 0 && (g += `
`), m = [
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        f
      ].filter(Ca).join(`
`), m.length > 0 && (m += `
`)) : (g = [
        Gp(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        f,
        t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        t.batching ? "#define USE_BATCHING" : "",
        t.batchingColor ? "#define USE_BATCHING_COLOR" : "",
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + u : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "",
        t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "",
        t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "",
        t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "",
        t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "",
        t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "",
        t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "",
        t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents && t.flatShading === false ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === false ? "#define USE_MORPHNORMALS" : "",
        t.morphColors ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "",
        t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`
      ].filter(Ca).join(`
`), m = [
        Gp(t),
        "#define SHADER_TYPE " + t.shaderType,
        "#define SHADER_NAME " + t.shaderName,
        f,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + c : "",
        t.envMap ? "#define " + u : "",
        t.envMap ? "#define " + h : "",
        d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
        d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
        d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.anisotropy ? "#define USE_ANISOTROPY" : "",
        t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.dispersion ? "#define USE_DISPERSION" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.alphaHash ? "#define USE_ALPHAHASH" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents && t.flatShading === false ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== Ir ? "#define TONE_MAPPING" : "",
        t.toneMapping !== Ir ? He.tonemapping_pars_fragment : "",
        t.toneMapping !== Ir ? GM("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        He.colorspace_pars_fragment,
        VM("linearToOutputTexel", t.outputColorSpace),
        WM(),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`
      ].filter(Ca).join(`
`)), a = Mu(a), a = kp(a, t), a = Hp(a, t), o = Mu(o), o = kp(o, t), o = Hp(o, t), a = Vp(a), o = Vp(o), t.isRawShaderMaterial !== true && (y = `#version 300 es
`, g = [
        p,
        "#define attribute in",
        "#define varying out",
        "#define texture2D texture"
      ].join(`
`) + `
` + g, m = [
        "#define varying in",
        t.glslVersion === id ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
        t.glslVersion === id ? "" : "#define gl_FragColor pc_fragColor",
        "#define gl_FragDepthEXT gl_FragDepth",
        "#define texture2D texture",
        "#define textureCube texture",
        "#define texture2DProj textureProj",
        "#define texture2DLodEXT textureLod",
        "#define texture2DProjLodEXT textureProjLod",
        "#define textureCubeLodEXT textureLod",
        "#define texture2DGradEXT textureGrad",
        "#define texture2DProjGradEXT textureProjGrad",
        "#define textureCubeGradEXT textureGrad"
      ].join(`
`) + `
` + m);
      const x = y + g + a, v = y + m + o, A = Fp(n, n.VERTEX_SHADER, x), T = Fp(n, n.FRAGMENT_SHADER, v);
      n.attachShader(_, A), n.attachShader(_, T), t.index0AttributeName !== void 0 ? n.bindAttribLocation(_, 0, t.index0AttributeName) : t.morphTargets === true && n.bindAttribLocation(_, 0, "position"), n.linkProgram(_);
      function w(L) {
        if (r.debug.checkShaderErrors) {
          const B = n.getProgramInfoLog(_).trim(), F = n.getShaderInfoLog(A).trim(), V = n.getShaderInfoLog(T).trim();
          let X = true, k = true;
          if (n.getProgramParameter(_, n.LINK_STATUS) === false) if (X = false, typeof r.debug.onShaderError == "function") r.debug.onShaderError(n, _, A, T);
          else {
            const K = zp(n, A, "vertex"), G = zp(n, T, "fragment");
            console.error("THREE.WebGLProgram: Shader Error " + n.getError() + " - VALIDATE_STATUS " + n.getProgramParameter(_, n.VALIDATE_STATUS) + `

Material Name: ` + L.name + `
Material Type: ` + L.type + `

Program Info Log: ` + B + `
` + K + `
` + G);
          }
          else B !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", B) : (F === "" || V === "") && (k = false);
          k && (L.diagnostics = {
            runnable: X,
            programLog: B,
            vertexShader: {
              log: F,
              prefix: g
            },
            fragmentShader: {
              log: V,
              prefix: m
            }
          });
        }
        n.deleteShader(A), n.deleteShader(T), R = new $o(n, _), E = qM(n, _);
      }
      let R;
      this.getUniforms = function() {
        return R === void 0 && w(this), R;
      };
      let E;
      this.getAttributes = function() {
        return E === void 0 && w(this), E;
      };
      let b = t.rendererExtensionParallelShaderCompile === false;
      return this.isReady = function() {
        return b === false && (b = n.getProgramParameter(_, BM)), b;
      }, this.destroy = function() {
        i.releaseStatesOfProgram(this), n.deleteProgram(_), this.program = void 0;
      }, this.type = t.shaderType, this.name = t.shaderName, this.id = zM++, this.cacheKey = e, this.usedTimes = 1, this.program = _, this.vertexShader = A, this.fragmentShader = T, this;
    }
    let sb = 0;
    class ab {
      constructor() {
        this.shaderCache = /* @__PURE__ */ new Map(), this.materialCache = /* @__PURE__ */ new Map();
      }
      update(e) {
        const t = e.vertexShader, i = e.fragmentShader, n = this._getShaderStage(t), s = this._getShaderStage(i), a = this._getShaderCacheForMaterial(e);
        return a.has(n) === false && (a.add(n), n.usedTimes++), a.has(s) === false && (a.add(s), s.usedTimes++), this;
      }
      remove(e) {
        const t = this.materialCache.get(e);
        for (const i of t) i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
        return this.materialCache.delete(e), this;
      }
      getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id;
      }
      getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id;
      }
      dispose() {
        this.shaderCache.clear(), this.materialCache.clear();
      }
      _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let i = t.get(e);
        return i === void 0 && (i = /* @__PURE__ */ new Set(), t.set(e, i)), i;
      }
      _getShaderStage(e) {
        const t = this.shaderCache;
        let i = t.get(e);
        return i === void 0 && (i = new ob(e), t.set(e, i)), i;
      }
    }
    class ob {
      constructor(e) {
        this.id = sb++, this.code = e, this.usedTimes = 0;
      }
    }
    function lb(r, e, t, i, n, s, a) {
      const o = new Tc(), l = new ab(), c = /* @__PURE__ */ new Set(), u = [], h = n.logarithmicDepthBuffer, d = n.vertexTextures;
      let p = n.precision;
      const f = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
      };
      function _(E) {
        return c.add(E), E === 0 ? "uv" : `uv${E}`;
      }
      function g(E, b, L, B, F) {
        const V = B.fog, X = F.geometry, k = E.isMeshStandardMaterial ? B.environment : null, K = (E.isMeshStandardMaterial ? t : e).get(E.envMap || k), G = K && K.mapping === no ? K.image.height : null, ie = f[E.type];
        E.precision !== null && (p = n.getMaxPrecision(E.precision), p !== E.precision && console.warn("THREE.WebGLProgram.getParameters:", E.precision, "not supported, using", p, "instead."));
        const ue = X.morphAttributes.position || X.morphAttributes.normal || X.morphAttributes.color, we = ue !== void 0 ? ue.length : 0;
        let Be = 0;
        X.morphAttributes.position !== void 0 && (Be = 1), X.morphAttributes.normal !== void 0 && (Be = 2), X.morphAttributes.color !== void 0 && (Be = 3);
        let We, j, re, _e;
        if (ie) {
          const at = ir[ie];
          We = at.vertexShader, j = at.fragmentShader;
        } else We = E.vertexShader, j = E.fragmentShader, l.update(E), re = l.getVertexShaderID(E), _e = l.getFragmentShaderID(E);
        const ae = r.getRenderTarget(), Pe = r.state.buffers.depth.getReversed(), Re = F.isInstancedMesh === true, De = F.isBatchedMesh === true, te = !!E.map, $ = !!E.matcap, se = !!K, P = !!E.aoMap, fe = !!E.lightMap, xe = !!E.bumpMap, Me = !!E.normalMap, oe = !!E.displacementMap, ke = !!E.emissiveMap, de = !!E.metalnessMap, C = !!E.roughnessMap, M = E.anisotropy > 0, N = E.clearcoat > 0, Y = E.dispersion > 0, J = E.iridescence > 0, q = E.sheen > 0, Te = E.transmission > 0, he = M && !!E.anisotropyMap, ye = N && !!E.clearcoatMap, je = N && !!E.clearcoatNormalMap, ne = N && !!E.clearcoatRoughnessMap, be = J && !!E.iridescenceMap, Le = J && !!E.iridescenceThicknessMap, Ie = q && !!E.sheenColorMap, Se = q && !!E.sheenRoughnessMap, Ze = !!E.specularMap, Ve = !!E.specularColorMap, pt = !!E.specularIntensityMap, I = Te && !!E.transmissionMap, pe = Te && !!E.thicknessMap, W = !!E.gradientMap, Z = !!E.alphaMap, me = E.alphaTest > 0, le = !!E.alphaHash, Je = !!E.extensions;
        let Tt = Ir;
        E.toneMapped && (ae === null || ae.isXRRenderTarget === true) && (Tt = r.toneMapping);
        const ei = {
          shaderID: ie,
          shaderType: E.type,
          shaderName: E.name,
          vertexShader: We,
          fragmentShader: j,
          defines: E.defines,
          customVertexShaderID: re,
          customFragmentShaderID: _e,
          isRawShaderMaterial: E.isRawShaderMaterial === true,
          glslVersion: E.glslVersion,
          precision: p,
          batching: De,
          batchingColor: De && F._colorsTexture !== null,
          instancing: Re,
          instancingColor: Re && F.instanceColor !== null,
          instancingMorph: Re && F.morphTexture !== null,
          supportsVertexTextures: d,
          outputColorSpace: ae === null ? r.outputColorSpace : ae.isXRRenderTarget === true ? ae.texture.colorSpace : ni,
          alphaToCoverage: !!E.alphaToCoverage,
          map: te,
          matcap: $,
          envMap: se,
          envMapMode: se && K.mapping,
          envMapCubeUVHeight: G,
          aoMap: P,
          lightMap: fe,
          bumpMap: xe,
          normalMap: Me,
          displacementMap: d && oe,
          emissiveMap: ke,
          normalMapObjectSpace: Me && E.normalMapType === Pg,
          normalMapTangentSpace: Me && E.normalMapType === Qh,
          metalnessMap: de,
          roughnessMap: C,
          anisotropy: M,
          anisotropyMap: he,
          clearcoat: N,
          clearcoatMap: ye,
          clearcoatNormalMap: je,
          clearcoatRoughnessMap: ne,
          dispersion: Y,
          iridescence: J,
          iridescenceMap: be,
          iridescenceThicknessMap: Le,
          sheen: q,
          sheenColorMap: Ie,
          sheenRoughnessMap: Se,
          specularMap: Ze,
          specularColorMap: Ve,
          specularIntensityMap: pt,
          transmission: Te,
          transmissionMap: I,
          thicknessMap: pe,
          gradientMap: W,
          opaque: E.transparent === false && E.blending === ii && E.alphaToCoverage === false,
          alphaMap: Z,
          alphaTest: me,
          alphaHash: le,
          combine: E.combine,
          mapUv: te && _(E.map.channel),
          aoMapUv: P && _(E.aoMap.channel),
          lightMapUv: fe && _(E.lightMap.channel),
          bumpMapUv: xe && _(E.bumpMap.channel),
          normalMapUv: Me && _(E.normalMap.channel),
          displacementMapUv: oe && _(E.displacementMap.channel),
          emissiveMapUv: ke && _(E.emissiveMap.channel),
          metalnessMapUv: de && _(E.metalnessMap.channel),
          roughnessMapUv: C && _(E.roughnessMap.channel),
          anisotropyMapUv: he && _(E.anisotropyMap.channel),
          clearcoatMapUv: ye && _(E.clearcoatMap.channel),
          clearcoatNormalMapUv: je && _(E.clearcoatNormalMap.channel),
          clearcoatRoughnessMapUv: ne && _(E.clearcoatRoughnessMap.channel),
          iridescenceMapUv: be && _(E.iridescenceMap.channel),
          iridescenceThicknessMapUv: Le && _(E.iridescenceThicknessMap.channel),
          sheenColorMapUv: Ie && _(E.sheenColorMap.channel),
          sheenRoughnessMapUv: Se && _(E.sheenRoughnessMap.channel),
          specularMapUv: Ze && _(E.specularMap.channel),
          specularColorMapUv: Ve && _(E.specularColorMap.channel),
          specularIntensityMapUv: pt && _(E.specularIntensityMap.channel),
          transmissionMapUv: I && _(E.transmissionMap.channel),
          thicknessMapUv: pe && _(E.thicknessMap.channel),
          alphaMapUv: Z && _(E.alphaMap.channel),
          vertexTangents: !!X.attributes.tangent && (Me || M),
          vertexColors: E.vertexColors,
          vertexAlphas: E.vertexColors === true && !!X.attributes.color && X.attributes.color.itemSize === 4,
          pointsUvs: F.isPoints === true && !!X.attributes.uv && (te || Z),
          fog: !!V,
          useFog: E.fog === true,
          fogExp2: !!V && V.isFogExp2,
          flatShading: E.flatShading === true,
          sizeAttenuation: E.sizeAttenuation === true,
          logarithmicDepthBuffer: h,
          reverseDepthBuffer: Pe,
          skinning: F.isSkinnedMesh === true,
          morphTargets: X.morphAttributes.position !== void 0,
          morphNormals: X.morphAttributes.normal !== void 0,
          morphColors: X.morphAttributes.color !== void 0,
          morphTargetsCount: we,
          morphTextureStride: Be,
          numDirLights: b.directional.length,
          numPointLights: b.point.length,
          numSpotLights: b.spot.length,
          numSpotLightMaps: b.spotLightMap.length,
          numRectAreaLights: b.rectArea.length,
          numHemiLights: b.hemi.length,
          numDirLightShadows: b.directionalShadowMap.length,
          numPointLightShadows: b.pointShadowMap.length,
          numSpotLightShadows: b.spotShadowMap.length,
          numSpotLightShadowsWithMaps: b.numSpotLightShadowsWithMaps,
          numLightProbes: b.numLightProbes,
          numClippingPlanes: a.numPlanes,
          numClipIntersection: a.numIntersection,
          dithering: E.dithering,
          shadowMapEnabled: r.shadowMap.enabled && L.length > 0,
          shadowMapType: r.shadowMap.type,
          toneMapping: Tt,
          decodeVideoTexture: te && E.map.isVideoTexture === true && Ke.getTransfer(E.map.colorSpace) === ot,
          decodeVideoTextureEmissive: ke && E.emissiveMap.isVideoTexture === true && Ke.getTransfer(E.emissiveMap.colorSpace) === ot,
          premultipliedAlpha: E.premultipliedAlpha,
          doubleSided: E.side === ti,
          flipSided: E.side === vt,
          useDepthPacking: E.depthPacking >= 0,
          depthPacking: E.depthPacking || 0,
          index0AttributeName: E.index0AttributeName,
          extensionClipCullDistance: Je && E.extensions.clipCullDistance === true && i.has("WEBGL_clip_cull_distance"),
          extensionMultiDraw: (Je && E.extensions.multiDraw === true || De) && i.has("WEBGL_multi_draw"),
          rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
          customProgramCacheKey: E.customProgramCacheKey()
        };
        return ei.vertexUv1s = c.has(1), ei.vertexUv2s = c.has(2), ei.vertexUv3s = c.has(3), c.clear(), ei;
      }
      function m(E) {
        const b = [];
        if (E.shaderID ? b.push(E.shaderID) : (b.push(E.customVertexShaderID), b.push(E.customFragmentShaderID)), E.defines !== void 0) for (const L in E.defines) b.push(L), b.push(E.defines[L]);
        return E.isRawShaderMaterial === false && (y(b, E), x(b, E), b.push(r.outputColorSpace)), b.push(E.customProgramCacheKey), b.join();
      }
      function y(E, b) {
        E.push(b.precision), E.push(b.outputColorSpace), E.push(b.envMapMode), E.push(b.envMapCubeUVHeight), E.push(b.mapUv), E.push(b.alphaMapUv), E.push(b.lightMapUv), E.push(b.aoMapUv), E.push(b.bumpMapUv), E.push(b.normalMapUv), E.push(b.displacementMapUv), E.push(b.emissiveMapUv), E.push(b.metalnessMapUv), E.push(b.roughnessMapUv), E.push(b.anisotropyMapUv), E.push(b.clearcoatMapUv), E.push(b.clearcoatNormalMapUv), E.push(b.clearcoatRoughnessMapUv), E.push(b.iridescenceMapUv), E.push(b.iridescenceThicknessMapUv), E.push(b.sheenColorMapUv), E.push(b.sheenRoughnessMapUv), E.push(b.specularMapUv), E.push(b.specularColorMapUv), E.push(b.specularIntensityMapUv), E.push(b.transmissionMapUv), E.push(b.thicknessMapUv), E.push(b.combine), E.push(b.fogExp2), E.push(b.sizeAttenuation), E.push(b.morphTargetsCount), E.push(b.morphAttributeCount), E.push(b.numDirLights), E.push(b.numPointLights), E.push(b.numSpotLights), E.push(b.numSpotLightMaps), E.push(b.numHemiLights), E.push(b.numRectAreaLights), E.push(b.numDirLightShadows), E.push(b.numPointLightShadows), E.push(b.numSpotLightShadows), E.push(b.numSpotLightShadowsWithMaps), E.push(b.numLightProbes), E.push(b.shadowMapType), E.push(b.toneMapping), E.push(b.numClippingPlanes), E.push(b.numClipIntersection), E.push(b.depthPacking);
      }
      function x(E, b) {
        o.disableAll(), b.supportsVertexTextures && o.enable(0), b.instancing && o.enable(1), b.instancingColor && o.enable(2), b.instancingMorph && o.enable(3), b.matcap && o.enable(4), b.envMap && o.enable(5), b.normalMapObjectSpace && o.enable(6), b.normalMapTangentSpace && o.enable(7), b.clearcoat && o.enable(8), b.iridescence && o.enable(9), b.alphaTest && o.enable(10), b.vertexColors && o.enable(11), b.vertexAlphas && o.enable(12), b.vertexUv1s && o.enable(13), b.vertexUv2s && o.enable(14), b.vertexUv3s && o.enable(15), b.vertexTangents && o.enable(16), b.anisotropy && o.enable(17), b.alphaHash && o.enable(18), b.batching && o.enable(19), b.dispersion && o.enable(20), b.batchingColor && o.enable(21), E.push(o.mask), o.disableAll(), b.fog && o.enable(0), b.useFog && o.enable(1), b.flatShading && o.enable(2), b.logarithmicDepthBuffer && o.enable(3), b.reverseDepthBuffer && o.enable(4), b.skinning && o.enable(5), b.morphTargets && o.enable(6), b.morphNormals && o.enable(7), b.morphColors && o.enable(8), b.premultipliedAlpha && o.enable(9), b.shadowMapEnabled && o.enable(10), b.doubleSided && o.enable(11), b.flipSided && o.enable(12), b.useDepthPacking && o.enable(13), b.dithering && o.enable(14), b.transmission && o.enable(15), b.sheen && o.enable(16), b.opaque && o.enable(17), b.pointsUvs && o.enable(18), b.decodeVideoTexture && o.enable(19), b.decodeVideoTextureEmissive && o.enable(20), b.alphaToCoverage && o.enable(21), E.push(o.mask);
      }
      function v(E) {
        const b = f[E.type];
        let L;
        if (b) {
          const B = ir[b];
          L = Lo.clone(B.uniforms);
        } else L = E.uniforms;
        return L;
      }
      function A(E, b) {
        let L;
        for (let B = 0, F = u.length; B < F; B++) {
          const V = u[B];
          if (V.cacheKey === b) {
            L = V, ++L.usedTimes;
            break;
          }
        }
        return L === void 0 && (L = new nb(r, b, E, s), u.push(L)), L;
      }
      function T(E) {
        if (--E.usedTimes === 0) {
          const b = u.indexOf(E);
          u[b] = u[u.length - 1], u.pop(), E.destroy();
        }
      }
      function w(E) {
        l.remove(E);
      }
      function R() {
        l.dispose();
      }
      return {
        getParameters: g,
        getProgramCacheKey: m,
        getUniforms: v,
        acquireProgram: A,
        releaseProgram: T,
        releaseShaderCache: w,
        programs: u,
        dispose: R
      };
    }
    function cb() {
      let r = /* @__PURE__ */ new WeakMap();
      function e(a) {
        return r.has(a);
      }
      function t(a) {
        let o = r.get(a);
        return o === void 0 && (o = {}, r.set(a, o)), o;
      }
      function i(a) {
        r.delete(a);
      }
      function n(a, o, l) {
        r.get(a)[o] = l;
      }
      function s() {
        r = /* @__PURE__ */ new WeakMap();
      }
      return {
        has: e,
        get: t,
        remove: i,
        update: n,
        dispose: s
      };
    }
    function ub(r, e) {
      return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id;
    }
    function Wp(r, e) {
      return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id;
    }
    function Xp() {
      const r = [];
      let e = 0;
      const t = [], i = [], n = [];
      function s() {
        e = 0, t.length = 0, i.length = 0, n.length = 0;
      }
      function a(h, d, p, f, _, g) {
        let m = r[e];
        return m === void 0 ? (m = {
          id: h.id,
          object: h,
          geometry: d,
          material: p,
          groupOrder: f,
          renderOrder: h.renderOrder,
          z: _,
          group: g
        }, r[e] = m) : (m.id = h.id, m.object = h, m.geometry = d, m.material = p, m.groupOrder = f, m.renderOrder = h.renderOrder, m.z = _, m.group = g), e++, m;
      }
      function o(h, d, p, f, _, g) {
        const m = a(h, d, p, f, _, g);
        p.transmission > 0 ? i.push(m) : p.transparent === true ? n.push(m) : t.push(m);
      }
      function l(h, d, p, f, _, g) {
        const m = a(h, d, p, f, _, g);
        p.transmission > 0 ? i.unshift(m) : p.transparent === true ? n.unshift(m) : t.unshift(m);
      }
      function c(h, d) {
        t.length > 1 && t.sort(h || ub), i.length > 1 && i.sort(d || Wp), n.length > 1 && n.sort(d || Wp);
      }
      function u() {
        for (let h = e, d = r.length; h < d; h++) {
          const p = r[h];
          if (p.id === null) break;
          p.id = null, p.object = null, p.geometry = null, p.material = null, p.group = null;
        }
      }
      return {
        opaque: t,
        transmissive: i,
        transparent: n,
        init: s,
        push: o,
        unshift: l,
        finish: u,
        sort: c
      };
    }
    function hb() {
      let r = /* @__PURE__ */ new WeakMap();
      function e(i, n) {
        const s = r.get(i);
        let a;
        return s === void 0 ? (a = new Xp(), r.set(i, [
          a
        ])) : n >= s.length ? (a = new Xp(), s.push(a)) : a = s[n], a;
      }
      function t() {
        r = /* @__PURE__ */ new WeakMap();
      }
      return {
        get: e,
        dispose: t
      };
    }
    function db() {
      const r = {};
      return {
        get: function(e) {
          if (r[e.id] !== void 0) return r[e.id];
          let t;
          switch (e.type) {
            case "DirectionalLight":
              t = {
                direction: new D(),
                color: new Ae()
              };
              break;
            case "SpotLight":
              t = {
                position: new D(),
                direction: new D(),
                color: new Ae(),
                distance: 0,
                coneCos: 0,
                penumbraCos: 0,
                decay: 0
              };
              break;
            case "PointLight":
              t = {
                position: new D(),
                color: new Ae(),
                distance: 0,
                decay: 0
              };
              break;
            case "HemisphereLight":
              t = {
                direction: new D(),
                skyColor: new Ae(),
                groundColor: new Ae()
              };
              break;
            case "RectAreaLight":
              t = {
                color: new Ae(),
                position: new D(),
                halfWidth: new D(),
                halfHeight: new D()
              };
              break;
          }
          return r[e.id] = t, t;
        }
      };
    }
    function pb() {
      const r = {};
      return {
        get: function(e) {
          if (r[e.id] !== void 0) return r[e.id];
          let t;
          switch (e.type) {
            case "DirectionalLight":
              t = {
                shadowIntensity: 1,
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new ee()
              };
              break;
            case "SpotLight":
              t = {
                shadowIntensity: 1,
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new ee()
              };
              break;
            case "PointLight":
              t = {
                shadowIntensity: 1,
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new ee(),
                shadowCameraNear: 1,
                shadowCameraFar: 1e3
              };
              break;
          }
          return r[e.id] = t, t;
        }
      };
    }
    let fb = 0;
    function mb(r, e) {
      return (e.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (r.map ? 1 : 0);
    }
    function gb(r) {
      const e = new db(), t = pb(), i = {
        version: 0,
        hash: {
          directionalLength: -1,
          pointLength: -1,
          spotLength: -1,
          rectAreaLength: -1,
          hemiLength: -1,
          numDirectionalShadows: -1,
          numPointShadows: -1,
          numSpotShadows: -1,
          numSpotMaps: -1,
          numLightProbes: -1
        },
        ambient: [
          0,
          0,
          0
        ],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
        numLightProbes: 0
      };
      for (let c = 0; c < 9; c++) i.probe.push(new D());
      const n = new D(), s = new Fe(), a = new Fe();
      function o(c) {
        let u = 0, h = 0, d = 0;
        for (let E = 0; E < 9; E++) i.probe[E].set(0, 0, 0);
        let p = 0, f = 0, _ = 0, g = 0, m = 0, y = 0, x = 0, v = 0, A = 0, T = 0, w = 0;
        c.sort(mb);
        for (let E = 0, b = c.length; E < b; E++) {
          const L = c[E], B = L.color, F = L.intensity, V = L.distance, X = L.shadow && L.shadow.map ? L.shadow.map.texture : null;
          if (L.isAmbientLight) u += B.r * F, h += B.g * F, d += B.b * F;
          else if (L.isLightProbe) {
            for (let k = 0; k < 9; k++) i.probe[k].addScaledVector(L.sh.coefficients[k], F);
            w++;
          } else if (L.isDirectionalLight) {
            const k = e.get(L);
            if (k.color.copy(L.color).multiplyScalar(L.intensity), L.castShadow) {
              const K = L.shadow, G = t.get(L);
              G.shadowIntensity = K.intensity, G.shadowBias = K.bias, G.shadowNormalBias = K.normalBias, G.shadowRadius = K.radius, G.shadowMapSize = K.mapSize, i.directionalShadow[p] = G, i.directionalShadowMap[p] = X, i.directionalShadowMatrix[p] = L.shadow.matrix, y++;
            }
            i.directional[p] = k, p++;
          } else if (L.isSpotLight) {
            const k = e.get(L);
            k.position.setFromMatrixPosition(L.matrixWorld), k.color.copy(B).multiplyScalar(F), k.distance = V, k.coneCos = Math.cos(L.angle), k.penumbraCos = Math.cos(L.angle * (1 - L.penumbra)), k.decay = L.decay, i.spot[_] = k;
            const K = L.shadow;
            if (L.map && (i.spotLightMap[A] = L.map, A++, K.updateMatrices(L), L.castShadow && T++), i.spotLightMatrix[_] = K.matrix, L.castShadow) {
              const G = t.get(L);
              G.shadowIntensity = K.intensity, G.shadowBias = K.bias, G.shadowNormalBias = K.normalBias, G.shadowRadius = K.radius, G.shadowMapSize = K.mapSize, i.spotShadow[_] = G, i.spotShadowMap[_] = X, v++;
            }
            _++;
          } else if (L.isRectAreaLight) {
            const k = e.get(L);
            k.color.copy(B).multiplyScalar(F), k.halfWidth.set(L.width * 0.5, 0, 0), k.halfHeight.set(0, L.height * 0.5, 0), i.rectArea[g] = k, g++;
          } else if (L.isPointLight) {
            const k = e.get(L);
            if (k.color.copy(L.color).multiplyScalar(L.intensity), k.distance = L.distance, k.decay = L.decay, L.castShadow) {
              const K = L.shadow, G = t.get(L);
              G.shadowIntensity = K.intensity, G.shadowBias = K.bias, G.shadowNormalBias = K.normalBias, G.shadowRadius = K.radius, G.shadowMapSize = K.mapSize, G.shadowCameraNear = K.camera.near, G.shadowCameraFar = K.camera.far, i.pointShadow[f] = G, i.pointShadowMap[f] = X, i.pointShadowMatrix[f] = L.shadow.matrix, x++;
            }
            i.point[f] = k, f++;
          } else if (L.isHemisphereLight) {
            const k = e.get(L);
            k.skyColor.copy(L.color).multiplyScalar(F), k.groundColor.copy(L.groundColor).multiplyScalar(F), i.hemi[m] = k, m++;
          }
        }
        g > 0 && (r.has("OES_texture_float_linear") === true ? (i.rectAreaLTC1 = ce.LTC_FLOAT_1, i.rectAreaLTC2 = ce.LTC_FLOAT_2) : (i.rectAreaLTC1 = ce.LTC_HALF_1, i.rectAreaLTC2 = ce.LTC_HALF_2)), i.ambient[0] = u, i.ambient[1] = h, i.ambient[2] = d;
        const R = i.hash;
        (R.directionalLength !== p || R.pointLength !== f || R.spotLength !== _ || R.rectAreaLength !== g || R.hemiLength !== m || R.numDirectionalShadows !== y || R.numPointShadows !== x || R.numSpotShadows !== v || R.numSpotMaps !== A || R.numLightProbes !== w) && (i.directional.length = p, i.spot.length = _, i.rectArea.length = g, i.point.length = f, i.hemi.length = m, i.directionalShadow.length = y, i.directionalShadowMap.length = y, i.pointShadow.length = x, i.pointShadowMap.length = x, i.spotShadow.length = v, i.spotShadowMap.length = v, i.directionalShadowMatrix.length = y, i.pointShadowMatrix.length = x, i.spotLightMatrix.length = v + A - T, i.spotLightMap.length = A, i.numSpotLightShadowsWithMaps = T, i.numLightProbes = w, R.directionalLength = p, R.pointLength = f, R.spotLength = _, R.rectAreaLength = g, R.hemiLength = m, R.numDirectionalShadows = y, R.numPointShadows = x, R.numSpotShadows = v, R.numSpotMaps = A, R.numLightProbes = w, i.version = fb++);
      }
      function l(c, u) {
        let h = 0, d = 0, p = 0, f = 0, _ = 0;
        const g = u.matrixWorldInverse;
        for (let m = 0, y = c.length; m < y; m++) {
          const x = c[m];
          if (x.isDirectionalLight) {
            const v = i.directional[h];
            v.direction.setFromMatrixPosition(x.matrixWorld), n.setFromMatrixPosition(x.target.matrixWorld), v.direction.sub(n), v.direction.transformDirection(g), h++;
          } else if (x.isSpotLight) {
            const v = i.spot[p];
            v.position.setFromMatrixPosition(x.matrixWorld), v.position.applyMatrix4(g), v.direction.setFromMatrixPosition(x.matrixWorld), n.setFromMatrixPosition(x.target.matrixWorld), v.direction.sub(n), v.direction.transformDirection(g), p++;
          } else if (x.isRectAreaLight) {
            const v = i.rectArea[f];
            v.position.setFromMatrixPosition(x.matrixWorld), v.position.applyMatrix4(g), a.identity(), s.copy(x.matrixWorld), s.premultiply(g), a.extractRotation(s), v.halfWidth.set(x.width * 0.5, 0, 0), v.halfHeight.set(0, x.height * 0.5, 0), v.halfWidth.applyMatrix4(a), v.halfHeight.applyMatrix4(a), f++;
          } else if (x.isPointLight) {
            const v = i.point[d];
            v.position.setFromMatrixPosition(x.matrixWorld), v.position.applyMatrix4(g), d++;
          } else if (x.isHemisphereLight) {
            const v = i.hemi[_];
            v.direction.setFromMatrixPosition(x.matrixWorld), v.direction.transformDirection(g), _++;
          }
        }
      }
      return {
        setup: o,
        setupView: l,
        state: i
      };
    }
    function jp(r) {
      const e = new gb(r), t = [], i = [];
      function n(u) {
        c.camera = u, t.length = 0, i.length = 0;
      }
      function s(u) {
        t.push(u);
      }
      function a(u) {
        i.push(u);
      }
      function o() {
        e.setup(t);
      }
      function l(u) {
        e.setupView(t, u);
      }
      const c = {
        lightsArray: t,
        shadowsArray: i,
        camera: null,
        lights: e,
        transmissionRenderTarget: {}
      };
      return {
        init: n,
        state: c,
        setupLights: o,
        setupLightsView: l,
        pushLight: s,
        pushShadow: a
      };
    }
    function _b(r) {
      let e = /* @__PURE__ */ new WeakMap();
      function t(n, s = 0) {
        const a = e.get(n);
        let o;
        return a === void 0 ? (o = new jp(r), e.set(n, [
          o
        ])) : s >= a.length ? (o = new jp(r), a.push(o)) : o = a[s], o;
      }
      function i() {
        e = /* @__PURE__ */ new WeakMap();
      }
      return {
        get: t,
        dispose: i
      };
    }
    const vb = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, xb = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
    function yb(r, e, t) {
      let i = new Wc();
      const n = new ee(), s = new ee(), a = new it(), o = new vv({
        depthPacking: Cg
      }), l = new xv(), c = {}, u = t.maxTextureSize, h = {
        [Ot]: vt,
        [vt]: Ot,
        [ti]: ti
      }, d = new Zt({
        defines: {
          VSM_SAMPLES: 8
        },
        uniforms: {
          shadow_pass: {
            value: null
          },
          resolution: {
            value: new ee()
          },
          radius: {
            value: 4
          }
        },
        vertexShader: vb,
        fragmentShader: xb
      }), p = d.clone();
      p.defines.HORIZONTAL_PASS = 1;
      const f = new hi();
      f.setAttribute("position", new si(new Float32Array([
        -1,
        -1,
        0.5,
        3,
        -1,
        0.5,
        -1,
        3,
        0.5
      ]), 3));
      const _ = new Rt(f, d), g = this;
      this.enabled = false, this.autoUpdate = true, this.needsUpdate = false, this.type = wt;
      let m = this.type;
      this.render = function(T, w, R) {
        if (g.enabled === false || g.autoUpdate === false && g.needsUpdate === false || T.length === 0) return;
        const E = r.getRenderTarget(), b = r.getActiveCubeFace(), L = r.getActiveMipmapLevel(), B = r.state;
        B.setBlending(Fi), B.buffers.color.setClear(1, 1, 1, 1), B.buffers.depth.setTest(true), B.setScissorTest(false);
        const F = m !== At && this.type === At, V = m === At && this.type !== At;
        for (let X = 0, k = T.length; X < k; X++) {
          const K = T[X], G = K.shadow;
          if (G === void 0) {
            console.warn("THREE.WebGLShadowMap:", K, "has no shadow.");
            continue;
          }
          if (G.autoUpdate === false && G.needsUpdate === false) continue;
          n.copy(G.mapSize);
          const ie = G.getFrameExtents();
          if (n.multiply(ie), s.copy(G.mapSize), (n.x > u || n.y > u) && (n.x > u && (s.x = Math.floor(u / ie.x), n.x = s.x * ie.x, G.mapSize.x = s.x), n.y > u && (s.y = Math.floor(u / ie.y), n.y = s.y * ie.y, G.mapSize.y = s.y)), G.map === null || F === true || V === true) {
            const we = this.type !== At ? {
              minFilter: ri,
              magFilter: ri
            } : {};
            G.map !== null && G.map.dispose(), G.map = new ki(n.x, n.y, we), G.map.texture.name = K.name + ".shadowMap", G.camera.updateProjectionMatrix();
          }
          r.setRenderTarget(G.map), r.clear();
          const ue = G.getViewportCount();
          for (let we = 0; we < ue; we++) {
            const Be = G.getViewport(we);
            a.set(s.x * Be.x, s.y * Be.y, s.x * Be.z, s.y * Be.w), B.viewport(a), G.updateMatrices(K, we), i = G.getFrustum(), v(w, R, G.camera, K, this.type);
          }
          G.isPointLightShadow !== true && this.type === At && y(G, R), G.needsUpdate = false;
        }
        m = this.type, g.needsUpdate = false, r.setRenderTarget(E, b, L);
      };
      function y(T, w) {
        const R = e.update(_);
        d.defines.VSM_SAMPLES !== T.blurSamples && (d.defines.VSM_SAMPLES = T.blurSamples, p.defines.VSM_SAMPLES = T.blurSamples, d.needsUpdate = true, p.needsUpdate = true), T.mapPass === null && (T.mapPass = new ki(n.x, n.y)), d.uniforms.shadow_pass.value = T.map.texture, d.uniforms.resolution.value = T.mapSize, d.uniforms.radius.value = T.radius, r.setRenderTarget(T.mapPass), r.clear(), r.renderBufferDirect(w, null, R, d, _, null), p.uniforms.shadow_pass.value = T.mapPass.texture, p.uniforms.resolution.value = T.mapSize, p.uniforms.radius.value = T.radius, r.setRenderTarget(T.map), r.clear(), r.renderBufferDirect(w, null, R, p, _, null);
      }
      function x(T, w, R, E) {
        let b = null;
        const L = R.isPointLight === true ? T.customDistanceMaterial : T.customDepthMaterial;
        if (L !== void 0) b = L;
        else if (b = R.isPointLight === true ? l : o, r.localClippingEnabled && w.clipShadows === true && Array.isArray(w.clippingPlanes) && w.clippingPlanes.length !== 0 || w.displacementMap && w.displacementScale !== 0 || w.alphaMap && w.alphaTest > 0 || w.map && w.alphaTest > 0) {
          const B = b.uuid, F = w.uuid;
          let V = c[B];
          V === void 0 && (V = {}, c[B] = V);
          let X = V[F];
          X === void 0 && (X = b.clone(), V[F] = X, w.addEventListener("dispose", A)), b = X;
        }
        if (b.visible = w.visible, b.wireframe = w.wireframe, E === At ? b.side = w.shadowSide !== null ? w.shadowSide : w.side : b.side = w.shadowSide !== null ? w.shadowSide : h[w.side], b.alphaMap = w.alphaMap, b.alphaTest = w.alphaTest, b.map = w.map, b.clipShadows = w.clipShadows, b.clippingPlanes = w.clippingPlanes, b.clipIntersection = w.clipIntersection, b.displacementMap = w.displacementMap, b.displacementScale = w.displacementScale, b.displacementBias = w.displacementBias, b.wireframeLinewidth = w.wireframeLinewidth, b.linewidth = w.linewidth, R.isPointLight === true && b.isMeshDistanceMaterial === true) {
          const B = r.properties.get(b);
          B.light = R;
        }
        return b;
      }
      function v(T, w, R, E, b) {
        if (T.visible === false) return;
        if (T.layers.test(w.layers) && (T.isMesh || T.isLine || T.isPoints) && (T.castShadow || T.receiveShadow && b === At) && (!T.frustumCulled || i.intersectsObject(T))) {
          T.modelViewMatrix.multiplyMatrices(R.matrixWorldInverse, T.matrixWorld);
          const B = e.update(T), F = T.material;
          if (Array.isArray(F)) {
            const V = B.groups;
            for (let X = 0, k = V.length; X < k; X++) {
              const K = V[X], G = F[K.materialIndex];
              if (G && G.visible) {
                const ie = x(T, G, E, b);
                T.onBeforeShadow(r, T, w, R, B, ie, K), r.renderBufferDirect(R, null, B, ie, T, K), T.onAfterShadow(r, T, w, R, B, ie, K);
              }
            }
          } else if (F.visible) {
            const V = x(T, F, E, b);
            T.onBeforeShadow(r, T, w, R, B, V, null), r.renderBufferDirect(R, null, B, V, T, null), T.onAfterShadow(r, T, w, R, B, V, null);
          }
        }
        const L = T.children;
        for (let B = 0, F = L.length; B < F; B++) v(L[B], w, R, E, b);
      }
      function A(T) {
        T.target.removeEventListener("dispose", A);
        for (const w in c) {
          const R = c[w], E = T.target.uuid;
          E in R && (R[E].dispose(), delete R[E]);
        }
      }
    }
    const Mb = {
      [Tl]: wl,
      [Al]: Pl,
      [Rl]: Ll,
      [Xn]: Cl,
      [wl]: Tl,
      [Pl]: Al,
      [Ll]: Rl,
      [Cl]: Xn
    };
    function bb(r, e) {
      function t() {
        let I = false;
        const pe = new it();
        let W = null;
        const Z = new it(0, 0, 0, 0);
        return {
          setMask: function(me) {
            W !== me && !I && (r.colorMask(me, me, me, me), W = me);
          },
          setLocked: function(me) {
            I = me;
          },
          setClear: function(me, le, Je, Tt, ei) {
            ei === true && (me *= Tt, le *= Tt, Je *= Tt), pe.set(me, le, Je, Tt), Z.equals(pe) === false && (r.clearColor(me, le, Je, Tt), Z.copy(pe));
          },
          reset: function() {
            I = false, W = null, Z.set(-1, 0, 0, 0);
          }
        };
      }
      function i() {
        let I = false, pe = false, W = null, Z = null, me = null;
        return {
          setReversed: function(le) {
            if (pe !== le) {
              const Je = e.get("EXT_clip_control");
              pe ? Je.clipControlEXT(Je.LOWER_LEFT_EXT, Je.ZERO_TO_ONE_EXT) : Je.clipControlEXT(Je.LOWER_LEFT_EXT, Je.NEGATIVE_ONE_TO_ONE_EXT);
              const Tt = me;
              me = null, this.setClear(Tt);
            }
            pe = le;
          },
          getReversed: function() {
            return pe;
          },
          setTest: function(le) {
            le ? ae(r.DEPTH_TEST) : Pe(r.DEPTH_TEST);
          },
          setMask: function(le) {
            W !== le && !I && (r.depthMask(le), W = le);
          },
          setFunc: function(le) {
            if (pe && (le = Mb[le]), Z !== le) {
              switch (le) {
                case Tl:
                  r.depthFunc(r.NEVER);
                  break;
                case wl:
                  r.depthFunc(r.ALWAYS);
                  break;
                case Al:
                  r.depthFunc(r.LESS);
                  break;
                case Xn:
                  r.depthFunc(r.LEQUAL);
                  break;
                case Rl:
                  r.depthFunc(r.EQUAL);
                  break;
                case Cl:
                  r.depthFunc(r.GEQUAL);
                  break;
                case Pl:
                  r.depthFunc(r.GREATER);
                  break;
                case Ll:
                  r.depthFunc(r.NOTEQUAL);
                  break;
                default:
                  r.depthFunc(r.LEQUAL);
              }
              Z = le;
            }
          },
          setLocked: function(le) {
            I = le;
          },
          setClear: function(le) {
            me !== le && (pe && (le = 1 - le), r.clearDepth(le), me = le);
          },
          reset: function() {
            I = false, W = null, Z = null, me = null, pe = false;
          }
        };
      }
      function n() {
        let I = false, pe = null, W = null, Z = null, me = null, le = null, Je = null, Tt = null, ei = null;
        return {
          setTest: function(at) {
            I || (at ? ae(r.STENCIL_TEST) : Pe(r.STENCIL_TEST));
          },
          setMask: function(at) {
            pe !== at && !I && (r.stencilMask(at), pe = at);
          },
          setFunc: function(at, ji, Lr) {
            (W !== at || Z !== ji || me !== Lr) && (r.stencilFunc(at, ji, Lr), W = at, Z = ji, me = Lr);
          },
          setOp: function(at, ji, Lr) {
            (le !== at || Je !== ji || Tt !== Lr) && (r.stencilOp(at, ji, Lr), le = at, Je = ji, Tt = Lr);
          },
          setLocked: function(at) {
            I = at;
          },
          setClear: function(at) {
            ei !== at && (r.clearStencil(at), ei = at);
          },
          reset: function() {
            I = false, pe = null, W = null, Z = null, me = null, le = null, Je = null, Tt = null, ei = null;
          }
        };
      }
      const s = new t(), a = new i(), o = new n(), l = /* @__PURE__ */ new WeakMap(), c = /* @__PURE__ */ new WeakMap();
      let u = {}, h = {}, d = /* @__PURE__ */ new WeakMap(), p = [], f = null, _ = false, g = null, m = null, y = null, x = null, v = null, A = null, T = null, w = new Ae(0, 0, 0), R = 0, E = false, b = null, L = null, B = null, F = null, V = null;
      const X = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
      let k = false, K = 0;
      const G = r.getParameter(r.VERSION);
      G.indexOf("WebGL") !== -1 ? (K = parseFloat(/^WebGL (\d)/.exec(G)[1]), k = K >= 1) : G.indexOf("OpenGL ES") !== -1 && (K = parseFloat(/^OpenGL ES (\d)/.exec(G)[1]), k = K >= 2);
      let ie = null, ue = {};
      const we = r.getParameter(r.SCISSOR_BOX), Be = r.getParameter(r.VIEWPORT), We = new it().fromArray(we), j = new it().fromArray(Be);
      function re(I, pe, W, Z) {
        const me = new Uint8Array(4), le = r.createTexture();
        r.bindTexture(I, le), r.texParameteri(I, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(I, r.TEXTURE_MAG_FILTER, r.NEAREST);
        for (let Je = 0; Je < W; Je++) I === r.TEXTURE_3D || I === r.TEXTURE_2D_ARRAY ? r.texImage3D(pe, 0, r.RGBA, 1, 1, Z, 0, r.RGBA, r.UNSIGNED_BYTE, me) : r.texImage2D(pe + Je, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, me);
        return le;
      }
      const _e = {};
      _e[r.TEXTURE_2D] = re(r.TEXTURE_2D, r.TEXTURE_2D, 1), _e[r.TEXTURE_CUBE_MAP] = re(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6), _e[r.TEXTURE_2D_ARRAY] = re(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1), _e[r.TEXTURE_3D] = re(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1), s.setClear(0, 0, 0, 1), a.setClear(1), o.setClear(0), ae(r.DEPTH_TEST), a.setFunc(Xn), xe(false), Me(Dr), ae(r.CULL_FACE), P(Fi);
      function ae(I) {
        u[I] !== true && (r.enable(I), u[I] = true);
      }
      function Pe(I) {
        u[I] !== false && (r.disable(I), u[I] = false);
      }
      function Re(I, pe) {
        return h[I] !== pe ? (r.bindFramebuffer(I, pe), h[I] = pe, I === r.DRAW_FRAMEBUFFER && (h[r.FRAMEBUFFER] = pe), I === r.FRAMEBUFFER && (h[r.DRAW_FRAMEBUFFER] = pe), true) : false;
      }
      function De(I, pe) {
        let W = p, Z = false;
        if (I) {
          W = d.get(pe), W === void 0 && (W = [], d.set(pe, W));
          const me = I.textures;
          if (W.length !== me.length || W[0] !== r.COLOR_ATTACHMENT0) {
            for (let le = 0, Je = me.length; le < Je; le++) W[le] = r.COLOR_ATTACHMENT0 + le;
            W.length = me.length, Z = true;
          }
        } else W[0] !== r.BACK && (W[0] = r.BACK, Z = true);
        Z && r.drawBuffers(W);
      }
      function te(I) {
        return f !== I ? (r.useProgram(I), f = I, true) : false;
      }
      const $ = {
        [sn]: r.FUNC_ADD,
        [Qm]: r.FUNC_SUBTRACT,
        [eg]: r.FUNC_REVERSE_SUBTRACT
      };
      $[tg] = r.MIN, $[ig] = r.MAX;
      const se = {
        [rg]: r.ZERO,
        [ng]: r.ONE,
        [sg]: r.SRC_COLOR,
        [Sl]: r.SRC_ALPHA,
        [hg]: r.SRC_ALPHA_SATURATE,
        [cg]: r.DST_COLOR,
        [og]: r.DST_ALPHA,
        [ag]: r.ONE_MINUS_SRC_COLOR,
        [El]: r.ONE_MINUS_SRC_ALPHA,
        [ug]: r.ONE_MINUS_DST_COLOR,
        [lg]: r.ONE_MINUS_DST_ALPHA,
        [dg]: r.CONSTANT_COLOR,
        [pg]: r.ONE_MINUS_CONSTANT_COLOR,
        [fg]: r.CONSTANT_ALPHA,
        [mg]: r.ONE_MINUS_CONSTANT_ALPHA
      };
      function P(I, pe, W, Z, me, le, Je, Tt, ei, at) {
        if (I === Fi) {
          _ === true && (Pe(r.BLEND), _ = false);
          return;
        }
        if (_ === false && (ae(r.BLEND), _ = true), I !== $m) {
          if (I !== g || at !== E) {
            if ((m !== sn || v !== sn) && (r.blendEquation(r.FUNC_ADD), m = sn, v = sn), at) switch (I) {
              case ii:
                r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
                break;
              case Wn:
                r.blendFunc(r.ONE, r.ONE);
                break;
              case ro:
                r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
                break;
              case Oh:
                r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", I);
                break;
            }
            else switch (I) {
              case ii:
                r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
                break;
              case Wn:
                r.blendFunc(r.SRC_ALPHA, r.ONE);
                break;
              case ro:
                r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
                break;
              case Oh:
                r.blendFunc(r.ZERO, r.SRC_COLOR);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", I);
                break;
            }
            y = null, x = null, A = null, T = null, w.set(0, 0, 0), R = 0, g = I, E = at;
          }
          return;
        }
        me = me || pe, le = le || W, Je = Je || Z, (pe !== m || me !== v) && (r.blendEquationSeparate($[pe], $[me]), m = pe, v = me), (W !== y || Z !== x || le !== A || Je !== T) && (r.blendFuncSeparate(se[W], se[Z], se[le], se[Je]), y = W, x = Z, A = le, T = Je), (Tt.equals(w) === false || ei !== R) && (r.blendColor(Tt.r, Tt.g, Tt.b, ei), w.copy(Tt), R = ei), g = I, E = false;
      }
      function fe(I, pe) {
        I.side === ti ? Pe(r.CULL_FACE) : ae(r.CULL_FACE);
        let W = I.side === vt;
        pe && (W = !W), xe(W), I.blending === ii && I.transparent === false ? P(Fi) : P(I.blending, I.blendEquation, I.blendSrc, I.blendDst, I.blendEquationAlpha, I.blendSrcAlpha, I.blendDstAlpha, I.blendColor, I.blendAlpha, I.premultipliedAlpha), a.setFunc(I.depthFunc), a.setTest(I.depthTest), a.setMask(I.depthWrite), s.setMask(I.colorWrite);
        const Z = I.stencilWrite;
        o.setTest(Z), Z && (o.setMask(I.stencilWriteMask), o.setFunc(I.stencilFunc, I.stencilRef, I.stencilFuncMask), o.setOp(I.stencilFail, I.stencilZFail, I.stencilZPass)), ke(I.polygonOffset, I.polygonOffsetFactor, I.polygonOffsetUnits), I.alphaToCoverage === true ? ae(r.SAMPLE_ALPHA_TO_COVERAGE) : Pe(r.SAMPLE_ALPHA_TO_COVERAGE);
      }
      function xe(I) {
        b !== I && (I ? r.frontFace(r.CW) : r.frontFace(r.CCW), b = I);
      }
      function Me(I) {
        I !== nn ? (ae(r.CULL_FACE), I !== L && (I === Dr ? r.cullFace(r.BACK) : I === na ? r.cullFace(r.FRONT) : r.cullFace(r.FRONT_AND_BACK))) : Pe(r.CULL_FACE), L = I;
      }
      function oe(I) {
        I !== B && (k && r.lineWidth(I), B = I);
      }
      function ke(I, pe, W) {
        I ? (ae(r.POLYGON_OFFSET_FILL), (F !== pe || V !== W) && (r.polygonOffset(pe, W), F = pe, V = W)) : Pe(r.POLYGON_OFFSET_FILL);
      }
      function de(I) {
        I ? ae(r.SCISSOR_TEST) : Pe(r.SCISSOR_TEST);
      }
      function C(I) {
        I === void 0 && (I = r.TEXTURE0 + X - 1), ie !== I && (r.activeTexture(I), ie = I);
      }
      function M(I, pe, W) {
        W === void 0 && (ie === null ? W = r.TEXTURE0 + X - 1 : W = ie);
        let Z = ue[W];
        Z === void 0 && (Z = {
          type: void 0,
          texture: void 0
        }, ue[W] = Z), (Z.type !== I || Z.texture !== pe) && (ie !== W && (r.activeTexture(W), ie = W), r.bindTexture(I, pe || _e[I]), Z.type = I, Z.texture = pe);
      }
      function N() {
        const I = ue[ie];
        I !== void 0 && I.type !== void 0 && (r.bindTexture(I.type, null), I.type = void 0, I.texture = void 0);
      }
      function Y() {
        try {
          r.compressedTexImage2D.apply(r, arguments);
        } catch (I) {
          console.error("THREE.WebGLState:", I);
        }
      }
      function J() {
        try {
          r.compressedTexImage3D.apply(r, arguments);
        } catch (I) {
          console.error("THREE.WebGLState:", I);
        }
      }
      function q() {
        try {
          r.texSubImage2D.apply(r, arguments);
        } catch (I) {
          console.error("THREE.WebGLState:", I);
        }
      }
      function Te() {
        try {
          r.texSubImage3D.apply(r, arguments);
        } catch (I) {
          console.error("THREE.WebGLState:", I);
        }
      }
      function he() {
        try {
          r.compressedTexSubImage2D.apply(r, arguments);
        } catch (I) {
          console.error("THREE.WebGLState:", I);
        }
      }
      function ye() {
        try {
          r.compressedTexSubImage3D.apply(r, arguments);
        } catch (I) {
          console.error("THREE.WebGLState:", I);
        }
      }
      function je() {
        try {
          r.texStorage2D.apply(r, arguments);
        } catch (I) {
          console.error("THREE.WebGLState:", I);
        }
      }
      function ne() {
        try {
          r.texStorage3D.apply(r, arguments);
        } catch (I) {
          console.error("THREE.WebGLState:", I);
        }
      }
      function be() {
        try {
          r.texImage2D.apply(r, arguments);
        } catch (I) {
          console.error("THREE.WebGLState:", I);
        }
      }
      function Le() {
        try {
          r.texImage3D.apply(r, arguments);
        } catch (I) {
          console.error("THREE.WebGLState:", I);
        }
      }
      function Ie(I) {
        We.equals(I) === false && (r.scissor(I.x, I.y, I.z, I.w), We.copy(I));
      }
      function Se(I) {
        j.equals(I) === false && (r.viewport(I.x, I.y, I.z, I.w), j.copy(I));
      }
      function Ze(I, pe) {
        let W = c.get(pe);
        W === void 0 && (W = /* @__PURE__ */ new WeakMap(), c.set(pe, W));
        let Z = W.get(I);
        Z === void 0 && (Z = r.getUniformBlockIndex(pe, I.name), W.set(I, Z));
      }
      function Ve(I, pe) {
        const W = c.get(pe).get(I);
        l.get(pe) !== W && (r.uniformBlockBinding(pe, W, I.__bindingPointIndex), l.set(pe, W));
      }
      function pt() {
        r.disable(r.BLEND), r.disable(r.CULL_FACE), r.disable(r.DEPTH_TEST), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SCISSOR_TEST), r.disable(r.STENCIL_TEST), r.disable(r.SAMPLE_ALPHA_TO_COVERAGE), r.blendEquation(r.FUNC_ADD), r.blendFunc(r.ONE, r.ZERO), r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO), r.blendColor(0, 0, 0, 0), r.colorMask(true, true, true, true), r.clearColor(0, 0, 0, 0), r.depthMask(true), r.depthFunc(r.LESS), a.setReversed(false), r.clearDepth(1), r.stencilMask(4294967295), r.stencilFunc(r.ALWAYS, 0, 4294967295), r.stencilOp(r.KEEP, r.KEEP, r.KEEP), r.clearStencil(0), r.cullFace(r.BACK), r.frontFace(r.CCW), r.polygonOffset(0, 0), r.activeTexture(r.TEXTURE0), r.bindFramebuffer(r.FRAMEBUFFER, null), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), r.bindFramebuffer(r.READ_FRAMEBUFFER, null), r.useProgram(null), r.lineWidth(1), r.scissor(0, 0, r.canvas.width, r.canvas.height), r.viewport(0, 0, r.canvas.width, r.canvas.height), u = {}, ie = null, ue = {}, h = {}, d = /* @__PURE__ */ new WeakMap(), p = [], f = null, _ = false, g = null, m = null, y = null, x = null, v = null, A = null, T = null, w = new Ae(0, 0, 0), R = 0, E = false, b = null, L = null, B = null, F = null, V = null, We.set(0, 0, r.canvas.width, r.canvas.height), j.set(0, 0, r.canvas.width, r.canvas.height), s.reset(), a.reset(), o.reset();
      }
      return {
        buffers: {
          color: s,
          depth: a,
          stencil: o
        },
        enable: ae,
        disable: Pe,
        bindFramebuffer: Re,
        drawBuffers: De,
        useProgram: te,
        setBlending: P,
        setMaterial: fe,
        setFlipSided: xe,
        setCullFace: Me,
        setLineWidth: oe,
        setPolygonOffset: ke,
        setScissorTest: de,
        activeTexture: C,
        bindTexture: M,
        unbindTexture: N,
        compressedTexImage2D: Y,
        compressedTexImage3D: J,
        texImage2D: be,
        texImage3D: Le,
        updateUBOMapping: Ze,
        uniformBlockBinding: Ve,
        texStorage2D: je,
        texStorage3D: ne,
        texSubImage2D: q,
        texSubImage3D: Te,
        compressedTexSubImage2D: he,
        compressedTexSubImage3D: ye,
        scissor: Ie,
        viewport: Se,
        reset: pt
      };
    }
    function Sb(r, e, t, i, n, s, a) {
      const o = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null, l = typeof navigator > "u" ? false : /OculusBrowser/g.test(navigator.userAgent), c = new ee(), u = /* @__PURE__ */ new WeakMap();
      let h;
      const d = /* @__PURE__ */ new WeakMap();
      let p = false;
      try {
        p = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
      } catch {
      }
      function f(C, M) {
        return p ? new OffscreenCanvas(C, M) : ha("canvas");
      }
      function _(C, M, N) {
        let Y = 1;
        const J = de(C);
        if ((J.width > N || J.height > N) && (Y = N / Math.max(J.width, J.height)), Y < 1) if (typeof HTMLImageElement < "u" && C instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && C instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && C instanceof ImageBitmap || typeof VideoFrame < "u" && C instanceof VideoFrame) {
          const q = Math.floor(Y * J.width), Te = Math.floor(Y * J.height);
          h === void 0 && (h = f(q, Te));
          const he = M ? f(q, Te) : h;
          return he.width = q, he.height = Te, he.getContext("2d").drawImage(C, 0, 0, q, Te), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + J.width + "x" + J.height + ") to (" + q + "x" + Te + ")."), he;
        } else return "data" in C && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + J.width + "x" + J.height + ")."), C;
        return C;
      }
      function g(C) {
        return C.generateMipmaps;
      }
      function m(C) {
        r.generateMipmap(C);
      }
      function y(C) {
        return C.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : C.isWebGL3DRenderTarget ? r.TEXTURE_3D : C.isWebGLArrayRenderTarget || C.isCompressedArrayTexture ? r.TEXTURE_2D_ARRAY : r.TEXTURE_2D;
      }
      function x(C, M, N, Y, J = false) {
        if (C !== null) {
          if (r[C] !== void 0) return r[C];
          console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + C + "'");
        }
        let q = M;
        if (M === r.RED && (N === r.FLOAT && (q = r.R32F), N === r.HALF_FLOAT && (q = r.R16F), N === r.UNSIGNED_BYTE && (q = r.R8)), M === r.RED_INTEGER && (N === r.UNSIGNED_BYTE && (q = r.R8UI), N === r.UNSIGNED_SHORT && (q = r.R16UI), N === r.UNSIGNED_INT && (q = r.R32UI), N === r.BYTE && (q = r.R8I), N === r.SHORT && (q = r.R16I), N === r.INT && (q = r.R32I)), M === r.RG && (N === r.FLOAT && (q = r.RG32F), N === r.HALF_FLOAT && (q = r.RG16F), N === r.UNSIGNED_BYTE && (q = r.RG8)), M === r.RG_INTEGER && (N === r.UNSIGNED_BYTE && (q = r.RG8UI), N === r.UNSIGNED_SHORT && (q = r.RG16UI), N === r.UNSIGNED_INT && (q = r.RG32UI), N === r.BYTE && (q = r.RG8I), N === r.SHORT && (q = r.RG16I), N === r.INT && (q = r.RG32I)), M === r.RGB_INTEGER && (N === r.UNSIGNED_BYTE && (q = r.RGB8UI), N === r.UNSIGNED_SHORT && (q = r.RGB16UI), N === r.UNSIGNED_INT && (q = r.RGB32UI), N === r.BYTE && (q = r.RGB8I), N === r.SHORT && (q = r.RGB16I), N === r.INT && (q = r.RGB32I)), M === r.RGBA_INTEGER && (N === r.UNSIGNED_BYTE && (q = r.RGBA8UI), N === r.UNSIGNED_SHORT && (q = r.RGBA16UI), N === r.UNSIGNED_INT && (q = r.RGBA32UI), N === r.BYTE && (q = r.RGBA8I), N === r.SHORT && (q = r.RGBA16I), N === r.INT && (q = r.RGBA32I)), M === r.RGB && N === r.UNSIGNED_INT_5_9_9_9_REV && (q = r.RGB9_E5), M === r.RGBA) {
          const Te = J ? po : Ke.getTransfer(Y);
          N === r.FLOAT && (q = r.RGBA32F), N === r.HALF_FLOAT && (q = r.RGBA16F), N === r.UNSIGNED_BYTE && (q = Te === ot ? r.SRGB8_ALPHA8 : r.RGBA8), N === r.UNSIGNED_SHORT_4_4_4_4 && (q = r.RGBA4), N === r.UNSIGNED_SHORT_5_5_5_1 && (q = r.RGB5_A1);
        }
        return (q === r.R16F || q === r.R32F || q === r.RG16F || q === r.RG32F || q === r.RGBA16F || q === r.RGBA32F) && e.get("EXT_color_buffer_float"), q;
      }
      function v(C, M) {
        let N;
        return C ? M === null || M === an || M === Kn ? N = r.DEPTH24_STENCIL8 : M === Bi ? N = r.DEPTH32F_STENCIL8 : M === aa && (N = r.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : M === null || M === an || M === Kn ? N = r.DEPTH_COMPONENT24 : M === Bi ? N = r.DEPTH_COMPONENT32F : M === aa && (N = r.DEPTH_COMPONENT16), N;
      }
      function A(C, M) {
        return g(C) === true || C.isFramebufferTexture && C.minFilter !== ri && C.minFilter !== _i ? Math.log2(Math.max(M.width, M.height)) + 1 : C.mipmaps !== void 0 && C.mipmaps.length > 0 ? C.mipmaps.length : C.isCompressedTexture && Array.isArray(C.image) ? M.mipmaps.length : 1;
      }
      function T(C) {
        const M = C.target;
        M.removeEventListener("dispose", T), R(M), M.isVideoTexture && u.delete(M);
      }
      function w(C) {
        const M = C.target;
        M.removeEventListener("dispose", w), b(M);
      }
      function R(C) {
        const M = i.get(C);
        if (M.__webglInit === void 0) return;
        const N = C.source, Y = d.get(N);
        if (Y) {
          const J = Y[M.__cacheKey];
          J.usedTimes--, J.usedTimes === 0 && E(C), Object.keys(Y).length === 0 && d.delete(N);
        }
        i.remove(C);
      }
      function E(C) {
        const M = i.get(C);
        r.deleteTexture(M.__webglTexture);
        const N = C.source, Y = d.get(N);
        delete Y[M.__cacheKey], a.memory.textures--;
      }
      function b(C) {
        const M = i.get(C);
        if (C.depthTexture && (C.depthTexture.dispose(), i.remove(C.depthTexture)), C.isWebGLCubeRenderTarget) for (let Y = 0; Y < 6; Y++) {
          if (Array.isArray(M.__webglFramebuffer[Y])) for (let J = 0; J < M.__webglFramebuffer[Y].length; J++) r.deleteFramebuffer(M.__webglFramebuffer[Y][J]);
          else r.deleteFramebuffer(M.__webglFramebuffer[Y]);
          M.__webglDepthbuffer && r.deleteRenderbuffer(M.__webglDepthbuffer[Y]);
        }
        else {
          if (Array.isArray(M.__webglFramebuffer)) for (let Y = 0; Y < M.__webglFramebuffer.length; Y++) r.deleteFramebuffer(M.__webglFramebuffer[Y]);
          else r.deleteFramebuffer(M.__webglFramebuffer);
          if (M.__webglDepthbuffer && r.deleteRenderbuffer(M.__webglDepthbuffer), M.__webglMultisampledFramebuffer && r.deleteFramebuffer(M.__webglMultisampledFramebuffer), M.__webglColorRenderbuffer) for (let Y = 0; Y < M.__webglColorRenderbuffer.length; Y++) M.__webglColorRenderbuffer[Y] && r.deleteRenderbuffer(M.__webglColorRenderbuffer[Y]);
          M.__webglDepthRenderbuffer && r.deleteRenderbuffer(M.__webglDepthRenderbuffer);
        }
        const N = C.textures;
        for (let Y = 0, J = N.length; Y < J; Y++) {
          const q = i.get(N[Y]);
          q.__webglTexture && (r.deleteTexture(q.__webglTexture), a.memory.textures--), i.remove(N[Y]);
        }
        i.remove(C);
      }
      let L = 0;
      function B() {
        L = 0;
      }
      function F() {
        const C = L;
        return C >= n.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + C + " texture units while this GPU supports only " + n.maxTextures), L += 1, C;
      }
      function V(C) {
        const M = [];
        return M.push(C.wrapS), M.push(C.wrapT), M.push(C.wrapR || 0), M.push(C.magFilter), M.push(C.minFilter), M.push(C.anisotropy), M.push(C.internalFormat), M.push(C.format), M.push(C.type), M.push(C.generateMipmaps), M.push(C.premultiplyAlpha), M.push(C.flipY), M.push(C.unpackAlignment), M.push(C.colorSpace), M.join();
      }
      function X(C, M) {
        const N = i.get(C);
        if (C.isVideoTexture && oe(C), C.isRenderTargetTexture === false && C.version > 0 && N.__version !== C.version) {
          const Y = C.image;
          if (Y === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
          else if (Y.complete === false) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
          else {
            j(N, C, M);
            return;
          }
        }
        t.bindTexture(r.TEXTURE_2D, N.__webglTexture, r.TEXTURE0 + M);
      }
      function k(C, M) {
        const N = i.get(C);
        if (C.version > 0 && N.__version !== C.version) {
          j(N, C, M);
          return;
        }
        t.bindTexture(r.TEXTURE_2D_ARRAY, N.__webglTexture, r.TEXTURE0 + M);
      }
      function K(C, M) {
        const N = i.get(C);
        if (C.version > 0 && N.__version !== C.version) {
          j(N, C, M);
          return;
        }
        t.bindTexture(r.TEXTURE_3D, N.__webglTexture, r.TEXTURE0 + M);
      }
      function G(C, M) {
        const N = i.get(C);
        if (C.version > 0 && N.__version !== C.version) {
          re(N, C, M);
          return;
        }
        t.bindTexture(r.TEXTURE_CUBE_MAP, N.__webglTexture, r.TEXTURE0 + M);
      }
      const ie = {
        [Yn]: r.REPEAT,
        [Ur]: r.CLAMP_TO_EDGE,
        [so]: r.MIRRORED_REPEAT
      }, ue = {
        [ri]: r.NEAREST,
        [zh]: r.NEAREST_MIPMAP_NEAREST,
        [sa]: r.NEAREST_MIPMAP_LINEAR,
        [_i]: r.LINEAR,
        [ao]: r.LINEAR_MIPMAP_NEAREST,
        [cr]: r.LINEAR_MIPMAP_LINEAR
      }, we = {
        [Lg]: r.NEVER,
        [Fg]: r.ALWAYS,
        [Dg]: r.LESS,
        [td]: r.LEQUAL,
        [Ig]: r.EQUAL,
        [Ng]: r.GEQUAL,
        [Ug]: r.GREATER,
        [Og]: r.NOTEQUAL
      };
      function Be(C, M) {
        if (M.type === Bi && e.has("OES_texture_float_linear") === false && (M.magFilter === _i || M.magFilter === ao || M.magFilter === sa || M.magFilter === cr || M.minFilter === _i || M.minFilter === ao || M.minFilter === sa || M.minFilter === cr) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), r.texParameteri(C, r.TEXTURE_WRAP_S, ie[M.wrapS]), r.texParameteri(C, r.TEXTURE_WRAP_T, ie[M.wrapT]), (C === r.TEXTURE_3D || C === r.TEXTURE_2D_ARRAY) && r.texParameteri(C, r.TEXTURE_WRAP_R, ie[M.wrapR]), r.texParameteri(C, r.TEXTURE_MAG_FILTER, ue[M.magFilter]), r.texParameteri(C, r.TEXTURE_MIN_FILTER, ue[M.minFilter]), M.compareFunction && (r.texParameteri(C, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE), r.texParameteri(C, r.TEXTURE_COMPARE_FUNC, we[M.compareFunction])), e.has("EXT_texture_filter_anisotropic") === true) {
          if (M.magFilter === ri || M.minFilter !== sa && M.minFilter !== cr || M.type === Bi && e.has("OES_texture_float_linear") === false) return;
          if (M.anisotropy > 1 || i.get(M).__currentAnisotropy) {
            const N = e.get("EXT_texture_filter_anisotropic");
            r.texParameterf(C, N.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(M.anisotropy, n.getMaxAnisotropy())), i.get(M).__currentAnisotropy = M.anisotropy;
          }
        }
      }
      function We(C, M) {
        let N = false;
        C.__webglInit === void 0 && (C.__webglInit = true, M.addEventListener("dispose", T));
        const Y = M.source;
        let J = d.get(Y);
        J === void 0 && (J = {}, d.set(Y, J));
        const q = V(M);
        if (q !== C.__cacheKey) {
          J[q] === void 0 && (J[q] = {
            texture: r.createTexture(),
            usedTimes: 0
          }, a.memory.textures++, N = true), J[q].usedTimes++;
          const Te = J[C.__cacheKey];
          Te !== void 0 && (J[C.__cacheKey].usedTimes--, Te.usedTimes === 0 && E(M)), C.__cacheKey = q, C.__webglTexture = J[q].texture;
        }
        return N;
      }
      function j(C, M, N) {
        let Y = r.TEXTURE_2D;
        (M.isDataArrayTexture || M.isCompressedArrayTexture) && (Y = r.TEXTURE_2D_ARRAY), M.isData3DTexture && (Y = r.TEXTURE_3D);
        const J = We(C, M), q = M.source;
        t.bindTexture(Y, C.__webglTexture, r.TEXTURE0 + N);
        const Te = i.get(q);
        if (q.version !== Te.__version || J === true) {
          t.activeTexture(r.TEXTURE0 + N);
          const he = Ke.getPrimaries(Ke.workingColorSpace), ye = M.colorSpace === Or ? null : Ke.getPrimaries(M.colorSpace), je = M.colorSpace === Or || he === ye ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
          r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, M.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, M.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, je);
          let ne = _(M.image, false, n.maxTextureSize);
          ne = ke(M, ne);
          const be = s.convert(M.format, M.colorSpace), Le = s.convert(M.type);
          let Ie = x(M.internalFormat, be, Le, M.colorSpace, M.isVideoTexture);
          Be(Y, M);
          let Se;
          const Ze = M.mipmaps, Ve = M.isVideoTexture !== true, pt = Te.__version === void 0 || J === true, I = q.dataReady, pe = A(M, ne);
          if (M.isDepthTexture) Ie = v(M.format === Jn, M.type), pt && (Ve ? t.texStorage2D(r.TEXTURE_2D, 1, Ie, ne.width, ne.height) : t.texImage2D(r.TEXTURE_2D, 0, Ie, ne.width, ne.height, 0, be, Le, null));
          else if (M.isDataTexture) if (Ze.length > 0) {
            Ve && pt && t.texStorage2D(r.TEXTURE_2D, pe, Ie, Ze[0].width, Ze[0].height);
            for (let W = 0, Z = Ze.length; W < Z; W++) Se = Ze[W], Ve ? I && t.texSubImage2D(r.TEXTURE_2D, W, 0, 0, Se.width, Se.height, be, Le, Se.data) : t.texImage2D(r.TEXTURE_2D, W, Ie, Se.width, Se.height, 0, be, Le, Se.data);
            M.generateMipmaps = false;
          } else Ve ? (pt && t.texStorage2D(r.TEXTURE_2D, pe, Ie, ne.width, ne.height), I && t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, ne.width, ne.height, be, Le, ne.data)) : t.texImage2D(r.TEXTURE_2D, 0, Ie, ne.width, ne.height, 0, be, Le, ne.data);
          else if (M.isCompressedTexture) if (M.isCompressedArrayTexture) {
            Ve && pt && t.texStorage3D(r.TEXTURE_2D_ARRAY, pe, Ie, Ze[0].width, Ze[0].height, ne.depth);
            for (let W = 0, Z = Ze.length; W < Z; W++) if (Se = Ze[W], M.format !== Ri) if (be !== null) if (Ve) {
              if (I) if (M.layerUpdates.size > 0) {
                const me = _p(Se.width, Se.height, M.format, M.type);
                for (const le of M.layerUpdates) {
                  const Je = Se.data.subarray(le * me / Se.data.BYTES_PER_ELEMENT, (le + 1) * me / Se.data.BYTES_PER_ELEMENT);
                  t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, W, 0, 0, le, Se.width, Se.height, 1, be, Je);
                }
                M.clearLayerUpdates();
              } else t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, W, 0, 0, 0, Se.width, Se.height, ne.depth, be, Se.data);
            } else t.compressedTexImage3D(r.TEXTURE_2D_ARRAY, W, Ie, Se.width, Se.height, ne.depth, 0, Se.data, 0, 0);
            else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            else Ve ? I && t.texSubImage3D(r.TEXTURE_2D_ARRAY, W, 0, 0, 0, Se.width, Se.height, ne.depth, be, Le, Se.data) : t.texImage3D(r.TEXTURE_2D_ARRAY, W, Ie, Se.width, Se.height, ne.depth, 0, be, Le, Se.data);
          } else {
            Ve && pt && t.texStorage2D(r.TEXTURE_2D, pe, Ie, Ze[0].width, Ze[0].height);
            for (let W = 0, Z = Ze.length; W < Z; W++) Se = Ze[W], M.format !== Ri ? be !== null ? Ve ? I && t.compressedTexSubImage2D(r.TEXTURE_2D, W, 0, 0, Se.width, Se.height, be, Se.data) : t.compressedTexImage2D(r.TEXTURE_2D, W, Ie, Se.width, Se.height, 0, Se.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ve ? I && t.texSubImage2D(r.TEXTURE_2D, W, 0, 0, Se.width, Se.height, be, Le, Se.data) : t.texImage2D(r.TEXTURE_2D, W, Ie, Se.width, Se.height, 0, be, Le, Se.data);
          }
          else if (M.isDataArrayTexture) if (Ve) {
            if (pt && t.texStorage3D(r.TEXTURE_2D_ARRAY, pe, Ie, ne.width, ne.height, ne.depth), I) if (M.layerUpdates.size > 0) {
              const W = _p(ne.width, ne.height, M.format, M.type);
              for (const Z of M.layerUpdates) {
                const me = ne.data.subarray(Z * W / ne.data.BYTES_PER_ELEMENT, (Z + 1) * W / ne.data.BYTES_PER_ELEMENT);
                t.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, Z, ne.width, ne.height, 1, be, Le, me);
              }
              M.clearLayerUpdates();
            } else t.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, 0, ne.width, ne.height, ne.depth, be, Le, ne.data);
          } else t.texImage3D(r.TEXTURE_2D_ARRAY, 0, Ie, ne.width, ne.height, ne.depth, 0, be, Le, ne.data);
          else if (M.isData3DTexture) Ve ? (pt && t.texStorage3D(r.TEXTURE_3D, pe, Ie, ne.width, ne.height, ne.depth), I && t.texSubImage3D(r.TEXTURE_3D, 0, 0, 0, 0, ne.width, ne.height, ne.depth, be, Le, ne.data)) : t.texImage3D(r.TEXTURE_3D, 0, Ie, ne.width, ne.height, ne.depth, 0, be, Le, ne.data);
          else if (M.isFramebufferTexture) {
            if (pt) if (Ve) t.texStorage2D(r.TEXTURE_2D, pe, Ie, ne.width, ne.height);
            else {
              let W = ne.width, Z = ne.height;
              for (let me = 0; me < pe; me++) t.texImage2D(r.TEXTURE_2D, me, Ie, W, Z, 0, be, Le, null), W >>= 1, Z >>= 1;
            }
          } else if (Ze.length > 0) {
            if (Ve && pt) {
              const W = de(Ze[0]);
              t.texStorage2D(r.TEXTURE_2D, pe, Ie, W.width, W.height);
            }
            for (let W = 0, Z = Ze.length; W < Z; W++) Se = Ze[W], Ve ? I && t.texSubImage2D(r.TEXTURE_2D, W, 0, 0, be, Le, Se) : t.texImage2D(r.TEXTURE_2D, W, Ie, be, Le, Se);
            M.generateMipmaps = false;
          } else if (Ve) {
            if (pt) {
              const W = de(ne);
              t.texStorage2D(r.TEXTURE_2D, pe, Ie, W.width, W.height);
            }
            I && t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, be, Le, ne);
          } else t.texImage2D(r.TEXTURE_2D, 0, Ie, be, Le, ne);
          g(M) && m(Y), Te.__version = q.version, M.onUpdate && M.onUpdate(M);
        }
        C.__version = M.version;
      }
      function re(C, M, N) {
        if (M.image.length !== 6) return;
        const Y = We(C, M), J = M.source;
        t.bindTexture(r.TEXTURE_CUBE_MAP, C.__webglTexture, r.TEXTURE0 + N);
        const q = i.get(J);
        if (J.version !== q.__version || Y === true) {
          t.activeTexture(r.TEXTURE0 + N);
          const Te = Ke.getPrimaries(Ke.workingColorSpace), he = M.colorSpace === Or ? null : Ke.getPrimaries(M.colorSpace), ye = M.colorSpace === Or || Te === he ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
          r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, M.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, M.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, M.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, ye);
          const je = M.isCompressedTexture || M.image[0].isCompressedTexture, ne = M.image[0] && M.image[0].isDataTexture, be = [];
          for (let Z = 0; Z < 6; Z++) !je && !ne ? be[Z] = _(M.image[Z], true, n.maxCubemapSize) : be[Z] = ne ? M.image[Z].image : M.image[Z], be[Z] = ke(M, be[Z]);
          const Le = be[0], Ie = s.convert(M.format, M.colorSpace), Se = s.convert(M.type), Ze = x(M.internalFormat, Ie, Se, M.colorSpace), Ve = M.isVideoTexture !== true, pt = q.__version === void 0 || Y === true, I = J.dataReady;
          let pe = A(M, Le);
          Be(r.TEXTURE_CUBE_MAP, M);
          let W;
          if (je) {
            Ve && pt && t.texStorage2D(r.TEXTURE_CUBE_MAP, pe, Ze, Le.width, Le.height);
            for (let Z = 0; Z < 6; Z++) {
              W = be[Z].mipmaps;
              for (let me = 0; me < W.length; me++) {
                const le = W[me];
                M.format !== Ri ? Ie !== null ? Ve ? I && t.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, me, 0, 0, le.width, le.height, Ie, le.data) : t.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, me, Ze, le.width, le.height, 0, le.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ve ? I && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, me, 0, 0, le.width, le.height, Ie, Se, le.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, me, Ze, le.width, le.height, 0, Ie, Se, le.data);
              }
            }
          } else {
            if (W = M.mipmaps, Ve && pt) {
              W.length > 0 && pe++;
              const Z = de(be[0]);
              t.texStorage2D(r.TEXTURE_CUBE_MAP, pe, Ze, Z.width, Z.height);
            }
            for (let Z = 0; Z < 6; Z++) if (ne) {
              Ve ? I && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, 0, 0, 0, be[Z].width, be[Z].height, Ie, Se, be[Z].data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, 0, Ze, be[Z].width, be[Z].height, 0, Ie, Se, be[Z].data);
              for (let me = 0; me < W.length; me++) {
                const le = W[me].image[Z].image;
                Ve ? I && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, me + 1, 0, 0, le.width, le.height, Ie, Se, le.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, me + 1, Ze, le.width, le.height, 0, Ie, Se, le.data);
              }
            } else {
              Ve ? I && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, 0, 0, 0, Ie, Se, be[Z]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, 0, Ze, Ie, Se, be[Z]);
              for (let me = 0; me < W.length; me++) {
                const le = W[me];
                Ve ? I && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, me + 1, 0, 0, Ie, Se, le.image[Z]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + Z, me + 1, Ze, Ie, Se, le.image[Z]);
              }
            }
          }
          g(M) && m(r.TEXTURE_CUBE_MAP), q.__version = J.version, M.onUpdate && M.onUpdate(M);
        }
        C.__version = M.version;
      }
      function _e(C, M, N, Y, J, q) {
        const Te = s.convert(N.format, N.colorSpace), he = s.convert(N.type), ye = x(N.internalFormat, Te, he, N.colorSpace), je = i.get(M), ne = i.get(N);
        if (ne.__renderTarget = M, !je.__hasExternalTextures) {
          const be = Math.max(1, M.width >> q), Le = Math.max(1, M.height >> q);
          J === r.TEXTURE_3D || J === r.TEXTURE_2D_ARRAY ? t.texImage3D(J, q, ye, be, Le, M.depth, 0, Te, he, null) : t.texImage2D(J, q, ye, be, Le, 0, Te, he, null);
        }
        t.bindFramebuffer(r.FRAMEBUFFER, C), Me(M) ? o.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, Y, J, ne.__webglTexture, 0, xe(M)) : (J === r.TEXTURE_2D || J >= r.TEXTURE_CUBE_MAP_POSITIVE_X && J <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z) && r.framebufferTexture2D(r.FRAMEBUFFER, Y, J, ne.__webglTexture, q), t.bindFramebuffer(r.FRAMEBUFFER, null);
      }
      function ae(C, M, N) {
        if (r.bindRenderbuffer(r.RENDERBUFFER, C), M.depthBuffer) {
          const Y = M.depthTexture, J = Y && Y.isDepthTexture ? Y.type : null, q = v(M.stencilBuffer, J), Te = M.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, he = xe(M);
          Me(M) ? o.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, he, q, M.width, M.height) : N ? r.renderbufferStorageMultisample(r.RENDERBUFFER, he, q, M.width, M.height) : r.renderbufferStorage(r.RENDERBUFFER, q, M.width, M.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, Te, r.RENDERBUFFER, C);
        } else {
          const Y = M.textures;
          for (let J = 0; J < Y.length; J++) {
            const q = Y[J], Te = s.convert(q.format, q.colorSpace), he = s.convert(q.type), ye = x(q.internalFormat, Te, he, q.colorSpace), je = xe(M);
            N && Me(M) === false ? r.renderbufferStorageMultisample(r.RENDERBUFFER, je, ye, M.width, M.height) : Me(M) ? o.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, je, ye, M.width, M.height) : r.renderbufferStorage(r.RENDERBUFFER, ye, M.width, M.height);
          }
        }
        r.bindRenderbuffer(r.RENDERBUFFER, null);
      }
      function Pe(C, M) {
        if (M && M.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(r.FRAMEBUFFER, C), !(M.depthTexture && M.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        const N = i.get(M.depthTexture);
        N.__renderTarget = M, (!N.__webglTexture || M.depthTexture.image.width !== M.width || M.depthTexture.image.height !== M.height) && (M.depthTexture.image.width = M.width, M.depthTexture.image.height = M.height, M.depthTexture.needsUpdate = true), X(M.depthTexture, 0);
        const Y = N.__webglTexture, J = xe(M);
        if (M.depthTexture.format === Zn) Me(M) ? o.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, Y, 0, J) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, Y, 0);
        else if (M.depthTexture.format === Jn) Me(M) ? o.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, Y, 0, J) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, Y, 0);
        else throw new Error("Unknown depthTexture format");
      }
      function Re(C) {
        const M = i.get(C), N = C.isWebGLCubeRenderTarget === true;
        if (M.__boundDepthTexture !== C.depthTexture) {
          const Y = C.depthTexture;
          if (M.__depthDisposeCallback && M.__depthDisposeCallback(), Y) {
            const J = () => {
              delete M.__boundDepthTexture, delete M.__depthDisposeCallback, Y.removeEventListener("dispose", J);
            };
            Y.addEventListener("dispose", J), M.__depthDisposeCallback = J;
          }
          M.__boundDepthTexture = Y;
        }
        if (C.depthTexture && !M.__autoAllocateDepthBuffer) {
          if (N) throw new Error("target.depthTexture not supported in Cube render targets");
          Pe(M.__webglFramebuffer, C);
        } else if (N) {
          M.__webglDepthbuffer = [];
          for (let Y = 0; Y < 6; Y++) if (t.bindFramebuffer(r.FRAMEBUFFER, M.__webglFramebuffer[Y]), M.__webglDepthbuffer[Y] === void 0) M.__webglDepthbuffer[Y] = r.createRenderbuffer(), ae(M.__webglDepthbuffer[Y], C, false);
          else {
            const J = C.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, q = M.__webglDepthbuffer[Y];
            r.bindRenderbuffer(r.RENDERBUFFER, q), r.framebufferRenderbuffer(r.FRAMEBUFFER, J, r.RENDERBUFFER, q);
          }
        } else if (t.bindFramebuffer(r.FRAMEBUFFER, M.__webglFramebuffer), M.__webglDepthbuffer === void 0) M.__webglDepthbuffer = r.createRenderbuffer(), ae(M.__webglDepthbuffer, C, false);
        else {
          const Y = C.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, J = M.__webglDepthbuffer;
          r.bindRenderbuffer(r.RENDERBUFFER, J), r.framebufferRenderbuffer(r.FRAMEBUFFER, Y, r.RENDERBUFFER, J);
        }
        t.bindFramebuffer(r.FRAMEBUFFER, null);
      }
      function De(C, M, N) {
        const Y = i.get(C);
        M !== void 0 && _e(Y.__webglFramebuffer, C, C.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, 0), N !== void 0 && Re(C);
      }
      function te(C) {
        const M = C.texture, N = i.get(C), Y = i.get(M);
        C.addEventListener("dispose", w);
        const J = C.textures, q = C.isWebGLCubeRenderTarget === true, Te = J.length > 1;
        if (Te || (Y.__webglTexture === void 0 && (Y.__webglTexture = r.createTexture()), Y.__version = M.version, a.memory.textures++), q) {
          N.__webglFramebuffer = [];
          for (let he = 0; he < 6; he++) if (M.mipmaps && M.mipmaps.length > 0) {
            N.__webglFramebuffer[he] = [];
            for (let ye = 0; ye < M.mipmaps.length; ye++) N.__webglFramebuffer[he][ye] = r.createFramebuffer();
          } else N.__webglFramebuffer[he] = r.createFramebuffer();
        } else {
          if (M.mipmaps && M.mipmaps.length > 0) {
            N.__webglFramebuffer = [];
            for (let he = 0; he < M.mipmaps.length; he++) N.__webglFramebuffer[he] = r.createFramebuffer();
          } else N.__webglFramebuffer = r.createFramebuffer();
          if (Te) for (let he = 0, ye = J.length; he < ye; he++) {
            const je = i.get(J[he]);
            je.__webglTexture === void 0 && (je.__webglTexture = r.createTexture(), a.memory.textures++);
          }
          if (C.samples > 0 && Me(C) === false) {
            N.__webglMultisampledFramebuffer = r.createFramebuffer(), N.__webglColorRenderbuffer = [], t.bindFramebuffer(r.FRAMEBUFFER, N.__webglMultisampledFramebuffer);
            for (let he = 0; he < J.length; he++) {
              const ye = J[he];
              N.__webglColorRenderbuffer[he] = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, N.__webglColorRenderbuffer[he]);
              const je = s.convert(ye.format, ye.colorSpace), ne = s.convert(ye.type), be = x(ye.internalFormat, je, ne, ye.colorSpace, C.isXRRenderTarget === true), Le = xe(C);
              r.renderbufferStorageMultisample(r.RENDERBUFFER, Le, be, C.width, C.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + he, r.RENDERBUFFER, N.__webglColorRenderbuffer[he]);
            }
            r.bindRenderbuffer(r.RENDERBUFFER, null), C.depthBuffer && (N.__webglDepthRenderbuffer = r.createRenderbuffer(), ae(N.__webglDepthRenderbuffer, C, true)), t.bindFramebuffer(r.FRAMEBUFFER, null);
          }
        }
        if (q) {
          t.bindTexture(r.TEXTURE_CUBE_MAP, Y.__webglTexture), Be(r.TEXTURE_CUBE_MAP, M);
          for (let he = 0; he < 6; he++) if (M.mipmaps && M.mipmaps.length > 0) for (let ye = 0; ye < M.mipmaps.length; ye++) _e(N.__webglFramebuffer[he][ye], C, M, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + he, ye);
          else _e(N.__webglFramebuffer[he], C, M, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + he, 0);
          g(M) && m(r.TEXTURE_CUBE_MAP), t.unbindTexture();
        } else if (Te) {
          for (let he = 0, ye = J.length; he < ye; he++) {
            const je = J[he], ne = i.get(je);
            t.bindTexture(r.TEXTURE_2D, ne.__webglTexture), Be(r.TEXTURE_2D, je), _e(N.__webglFramebuffer, C, je, r.COLOR_ATTACHMENT0 + he, r.TEXTURE_2D, 0), g(je) && m(r.TEXTURE_2D);
          }
          t.unbindTexture();
        } else {
          let he = r.TEXTURE_2D;
          if ((C.isWebGL3DRenderTarget || C.isWebGLArrayRenderTarget) && (he = C.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY), t.bindTexture(he, Y.__webglTexture), Be(he, M), M.mipmaps && M.mipmaps.length > 0) for (let ye = 0; ye < M.mipmaps.length; ye++) _e(N.__webglFramebuffer[ye], C, M, r.COLOR_ATTACHMENT0, he, ye);
          else _e(N.__webglFramebuffer, C, M, r.COLOR_ATTACHMENT0, he, 0);
          g(M) && m(he), t.unbindTexture();
        }
        C.depthBuffer && Re(C);
      }
      function $(C) {
        const M = C.textures;
        for (let N = 0, Y = M.length; N < Y; N++) {
          const J = M[N];
          if (g(J)) {
            const q = y(C), Te = i.get(J).__webglTexture;
            t.bindTexture(q, Te), m(q), t.unbindTexture();
          }
        }
      }
      const se = [], P = [];
      function fe(C) {
        if (C.samples > 0) {
          if (Me(C) === false) {
            const M = C.textures, N = C.width, Y = C.height;
            let J = r.COLOR_BUFFER_BIT;
            const q = C.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT, Te = i.get(C), he = M.length > 1;
            if (he) for (let ye = 0; ye < M.length; ye++) t.bindFramebuffer(r.FRAMEBUFFER, Te.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + ye, r.RENDERBUFFER, null), t.bindFramebuffer(r.FRAMEBUFFER, Te.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + ye, r.TEXTURE_2D, null, 0);
            t.bindFramebuffer(r.READ_FRAMEBUFFER, Te.__webglMultisampledFramebuffer), t.bindFramebuffer(r.DRAW_FRAMEBUFFER, Te.__webglFramebuffer);
            for (let ye = 0; ye < M.length; ye++) {
              if (C.resolveDepthBuffer && (C.depthBuffer && (J |= r.DEPTH_BUFFER_BIT), C.stencilBuffer && C.resolveStencilBuffer && (J |= r.STENCIL_BUFFER_BIT)), he) {
                r.framebufferRenderbuffer(r.READ_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, Te.__webglColorRenderbuffer[ye]);
                const je = i.get(M[ye]).__webglTexture;
                r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, je, 0);
              }
              r.blitFramebuffer(0, 0, N, Y, 0, 0, N, Y, J, r.NEAREST), l === true && (se.length = 0, P.length = 0, se.push(r.COLOR_ATTACHMENT0 + ye), C.depthBuffer && C.resolveDepthBuffer === false && (se.push(q), P.push(q), r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, P)), r.invalidateFramebuffer(r.READ_FRAMEBUFFER, se));
            }
            if (t.bindFramebuffer(r.READ_FRAMEBUFFER, null), t.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), he) for (let ye = 0; ye < M.length; ye++) {
              t.bindFramebuffer(r.FRAMEBUFFER, Te.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + ye, r.RENDERBUFFER, Te.__webglColorRenderbuffer[ye]);
              const je = i.get(M[ye]).__webglTexture;
              t.bindFramebuffer(r.FRAMEBUFFER, Te.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + ye, r.TEXTURE_2D, je, 0);
            }
            t.bindFramebuffer(r.DRAW_FRAMEBUFFER, Te.__webglMultisampledFramebuffer);
          } else if (C.depthBuffer && C.resolveDepthBuffer === false && l) {
            const M = C.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT;
            r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [
              M
            ]);
          }
        }
      }
      function xe(C) {
        return Math.min(n.maxSamples, C.samples);
      }
      function Me(C) {
        const M = i.get(C);
        return C.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === true && M.__useRenderToTexture !== false;
      }
      function oe(C) {
        const M = a.render.frame;
        u.get(C) !== M && (u.set(C, M), C.update());
      }
      function ke(C, M) {
        const N = C.colorSpace, Y = C.format, J = C.type;
        return C.isCompressedTexture === true || C.isVideoTexture === true || N !== ni && N !== Or && (Ke.getTransfer(N) === ot ? (Y !== Ri || J !== ur) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", N)), M;
      }
      function de(C) {
        return typeof HTMLImageElement < "u" && C instanceof HTMLImageElement ? (c.width = C.naturalWidth || C.width, c.height = C.naturalHeight || C.height) : typeof VideoFrame < "u" && C instanceof VideoFrame ? (c.width = C.displayWidth, c.height = C.displayHeight) : (c.width = C.width, c.height = C.height), c;
      }
      this.allocateTextureUnit = F, this.resetTextureUnits = B, this.setTexture2D = X, this.setTexture2DArray = k, this.setTexture3D = K, this.setTextureCube = G, this.rebindTextures = De, this.setupRenderTarget = te, this.updateRenderTargetMipmap = $, this.updateMultisampleRenderTarget = fe, this.setupDepthRenderbuffer = Re, this.setupFrameBufferTexture = _e, this.useMultisampledRTT = Me;
    }
    function Eb(r, e) {
      function t(i, n = Or) {
        let s;
        const a = Ke.getTransfer(n);
        if (i === ur) return r.UNSIGNED_BYTE;
        if (i === Ol) return r.UNSIGNED_SHORT_4_4_4_4;
        if (i === Nl) return r.UNSIGNED_SHORT_5_5_5_1;
        if (i === Vh) return r.UNSIGNED_INT_5_9_9_9_REV;
        if (i === kh) return r.BYTE;
        if (i === Hh) return r.SHORT;
        if (i === aa) return r.UNSIGNED_SHORT;
        if (i === Ul) return r.INT;
        if (i === an) return r.UNSIGNED_INT;
        if (i === Bi) return r.FLOAT;
        if (i === hr) return r.HALF_FLOAT;
        if (i === Gh) return r.ALPHA;
        if (i === Wh) return r.RGB;
        if (i === Ri) return r.RGBA;
        if (i === Xh) return r.LUMINANCE;
        if (i === jh) return r.LUMINANCE_ALPHA;
        if (i === Zn) return r.DEPTH_COMPONENT;
        if (i === Jn) return r.DEPTH_STENCIL;
        if (i === Fl) return r.RED;
        if (i === Bl) return r.RED_INTEGER;
        if (i === qh) return r.RG;
        if (i === zl) return r.RG_INTEGER;
        if (i === kl) return r.RGBA_INTEGER;
        if (i === oo || i === lo || i === co || i === uo) if (a === ot) if (s = e.get("WEBGL_compressed_texture_s3tc_srgb"), s !== null) {
          if (i === oo) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (i === lo) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (i === co) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (i === uo) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
        else if (s = e.get("WEBGL_compressed_texture_s3tc"), s !== null) {
          if (i === oo) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (i === lo) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (i === co) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (i === uo) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else return null;
        if (i === Hl || i === Vl || i === Gl || i === Wl) if (s = e.get("WEBGL_compressed_texture_pvrtc"), s !== null) {
          if (i === Hl) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (i === Vl) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (i === Gl) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (i === Wl) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        } else return null;
        if (i === Xl || i === jl || i === ql) if (s = e.get("WEBGL_compressed_texture_etc"), s !== null) {
          if (i === Xl || i === jl) return a === ot ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
          if (i === ql) return a === ot ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC;
        } else return null;
        if (i === Yl || i === Kl || i === Zl || i === Jl || i === $l || i === Ql || i === ec || i === tc || i === ic || i === rc || i === nc || i === sc || i === ac || i === oc) if (s = e.get("WEBGL_compressed_texture_astc"), s !== null) {
          if (i === Yl) return a === ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
          if (i === Kl) return a === ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
          if (i === Zl) return a === ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
          if (i === Jl) return a === ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
          if (i === $l) return a === ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
          if (i === Ql) return a === ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
          if (i === ec) return a === ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
          if (i === tc) return a === ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
          if (i === ic) return a === ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
          if (i === rc) return a === ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
          if (i === nc) return a === ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
          if (i === sc) return a === ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
          if (i === ac) return a === ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
          if (i === oc) return a === ot ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
        } else return null;
        if (i === ho || i === lc || i === cc) if (s = e.get("EXT_texture_compression_bptc"), s !== null) {
          if (i === ho) return a === ot ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
          if (i === lc) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
          if (i === cc) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
        } else return null;
        if (i === Yh || i === uc || i === hc || i === dc) if (s = e.get("EXT_texture_compression_rgtc"), s !== null) {
          if (i === ho) return s.COMPRESSED_RED_RGTC1_EXT;
          if (i === uc) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
          if (i === hc) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
          if (i === dc) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
        } else return null;
        return i === Kn ? r.UNSIGNED_INT_24_8 : r[i] !== void 0 ? r[i] : null;
      }
      return {
        convert: t
      };
    }
    const Tb = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`, wb = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
    class Ab {
      constructor() {
        this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0;
      }
      init(e, t, i) {
        if (this.texture === null) {
          const n = new Nt(), s = e.properties.get(n);
          s.__webglTexture = t.texture, (t.depthNear !== i.depthNear || t.depthFar !== i.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = n;
        }
      }
      getMesh(e) {
        if (this.texture !== null && this.mesh === null) {
          const t = e.cameras[0].viewport, i = new Zt({
            vertexShader: Tb,
            fragmentShader: wb,
            uniforms: {
              depthColor: {
                value: this.texture
              },
              depthWidth: {
                value: t.z
              },
              depthHeight: {
                value: t.w
              }
            }
          });
          this.mesh = new Rt(new Ta(20, 20), i);
        }
        return this.mesh;
      }
      reset() {
        this.texture = null, this.mesh = null;
      }
      getDepthTexture() {
        return this.texture;
      }
    }
    class Rb extends Qn {
      constructor(e, t) {
        super();
        const i = this;
        let n = null, s = 1, a = null, o = "local-floor", l = 1, c = null, u = null, h = null, d = null, p = null, f = null;
        const _ = new Ab(), g = t.getContextAttributes();
        let m = null, y = null;
        const x = [], v = [], A = new ee();
        let T = null;
        const w = new oi();
        w.viewport = new it();
        const R = new oi();
        R.viewport = new it();
        const E = [
          w,
          R
        ], b = new zv();
        let L = null, B = null;
        this.cameraAutoUpdate = true, this.enabled = false, this.isPresenting = false, this.getController = function(j) {
          let re = x[j];
          return re === void 0 && (re = new Fc(), x[j] = re), re.getTargetRaySpace();
        }, this.getControllerGrip = function(j) {
          let re = x[j];
          return re === void 0 && (re = new Fc(), x[j] = re), re.getGripSpace();
        }, this.getHand = function(j) {
          let re = x[j];
          return re === void 0 && (re = new Fc(), x[j] = re), re.getHandSpace();
        };
        function F(j) {
          const re = v.indexOf(j.inputSource);
          if (re === -1) return;
          const _e = x[re];
          _e !== void 0 && (_e.update(j.inputSource, j.frame, c || a), _e.dispatchEvent({
            type: j.type,
            data: j.inputSource
          }));
        }
        function V() {
          n.removeEventListener("select", F), n.removeEventListener("selectstart", F), n.removeEventListener("selectend", F), n.removeEventListener("squeeze", F), n.removeEventListener("squeezestart", F), n.removeEventListener("squeezeend", F), n.removeEventListener("end", V), n.removeEventListener("inputsourceschange", X);
          for (let j = 0; j < x.length; j++) {
            const re = v[j];
            re !== null && (v[j] = null, x[j].disconnect(re));
          }
          L = null, B = null, _.reset(), e.setRenderTarget(m), p = null, d = null, h = null, n = null, y = null, We.stop(), i.isPresenting = false, e.setPixelRatio(T), e.setSize(A.width, A.height, false), i.dispatchEvent({
            type: "sessionend"
          });
        }
        this.setFramebufferScaleFactor = function(j) {
          s = j, i.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
        }, this.setReferenceSpaceType = function(j) {
          o = j, i.isPresenting === true && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
        }, this.getReferenceSpace = function() {
          return c || a;
        }, this.setReferenceSpace = function(j) {
          c = j;
        }, this.getBaseLayer = function() {
          return d !== null ? d : p;
        }, this.getBinding = function() {
          return h;
        }, this.getFrame = function() {
          return f;
        }, this.getSession = function() {
          return n;
        }, this.setSession = async function(j) {
          if (n = j, n !== null) {
            if (m = e.getRenderTarget(), n.addEventListener("select", F), n.addEventListener("selectstart", F), n.addEventListener("selectend", F), n.addEventListener("squeeze", F), n.addEventListener("squeezestart", F), n.addEventListener("squeezeend", F), n.addEventListener("end", V), n.addEventListener("inputsourceschange", X), g.xrCompatible !== true && await t.makeXRCompatible(), T = e.getPixelRatio(), e.getSize(A), typeof XRWebGLBinding < "u" && "createProjectionLayer" in XRWebGLBinding.prototype) {
              let re = null, _e = null, ae = null;
              g.depth && (ae = g.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, re = g.stencil ? Jn : Zn, _e = g.stencil ? Kn : an);
              const Pe = {
                colorFormat: t.RGBA8,
                depthFormat: ae,
                scaleFactor: s
              };
              h = new XRWebGLBinding(n, t), d = h.createProjectionLayer(Pe), n.updateRenderState({
                layers: [
                  d
                ]
              }), e.setPixelRatio(1), e.setSize(d.textureWidth, d.textureHeight, false), y = new ki(d.textureWidth, d.textureHeight, {
                format: Ri,
                type: ur,
                depthTexture: new Yd(d.textureWidth, d.textureHeight, _e, void 0, void 0, void 0, void 0, void 0, void 0, re),
                stencilBuffer: g.stencil,
                colorSpace: e.outputColorSpace,
                samples: g.antialias ? 4 : 0,
                resolveDepthBuffer: d.ignoreDepthValues === false
              });
            } else {
              const re = {
                antialias: g.antialias,
                alpha: true,
                depth: g.depth,
                stencil: g.stencil,
                framebufferScaleFactor: s
              };
              p = new XRWebGLLayer(n, t, re), n.updateRenderState({
                baseLayer: p
              }), e.setPixelRatio(1), e.setSize(p.framebufferWidth, p.framebufferHeight, false), y = new ki(p.framebufferWidth, p.framebufferHeight, {
                format: Ri,
                type: ur,
                colorSpace: e.outputColorSpace,
                stencilBuffer: g.stencil
              });
            }
            y.isXRRenderTarget = true, this.setFoveation(l), c = null, a = await n.requestReferenceSpace(o), We.setContext(n), We.start(), i.isPresenting = true, i.dispatchEvent({
              type: "sessionstart"
            });
          }
        }, this.getEnvironmentBlendMode = function() {
          if (n !== null) return n.environmentBlendMode;
        }, this.getDepthTexture = function() {
          return _.getDepthTexture();
        };
        function X(j) {
          for (let re = 0; re < j.removed.length; re++) {
            const _e = j.removed[re], ae = v.indexOf(_e);
            ae >= 0 && (v[ae] = null, x[ae].disconnect(_e));
          }
          for (let re = 0; re < j.added.length; re++) {
            const _e = j.added[re];
            let ae = v.indexOf(_e);
            if (ae === -1) {
              for (let Re = 0; Re < x.length; Re++) if (Re >= v.length) {
                v.push(_e), ae = Re;
                break;
              } else if (v[Re] === null) {
                v[Re] = _e, ae = Re;
                break;
              }
              if (ae === -1) break;
            }
            const Pe = x[ae];
            Pe && Pe.connect(_e);
          }
        }
        const k = new D(), K = new D();
        function G(j, re, _e) {
          k.setFromMatrixPosition(re.matrixWorld), K.setFromMatrixPosition(_e.matrixWorld);
          const ae = k.distanceTo(K), Pe = re.projectionMatrix.elements, Re = _e.projectionMatrix.elements, De = Pe[14] / (Pe[10] - 1), te = Pe[14] / (Pe[10] + 1), $ = (Pe[9] + 1) / Pe[5], se = (Pe[9] - 1) / Pe[5], P = (Pe[8] - 1) / Pe[0], fe = (Re[8] + 1) / Re[0], xe = De * P, Me = De * fe, oe = ae / (-P + fe), ke = oe * -P;
          if (re.matrixWorld.decompose(j.position, j.quaternion, j.scale), j.translateX(ke), j.translateZ(oe), j.matrixWorld.compose(j.position, j.quaternion, j.scale), j.matrixWorldInverse.copy(j.matrixWorld).invert(), Pe[10] === -1) j.projectionMatrix.copy(re.projectionMatrix), j.projectionMatrixInverse.copy(re.projectionMatrixInverse);
          else {
            const de = De + oe, C = te + oe, M = xe - ke, N = Me + (ae - ke), Y = $ * te / C * de, J = se * te / C * de;
            j.projectionMatrix.makePerspective(M, N, Y, J, de, C), j.projectionMatrixInverse.copy(j.projectionMatrix).invert();
          }
        }
        function ie(j, re) {
          re === null ? j.matrixWorld.copy(j.matrix) : j.matrixWorld.multiplyMatrices(re.matrixWorld, j.matrix), j.matrixWorldInverse.copy(j.matrixWorld).invert();
        }
        this.updateCamera = function(j) {
          if (n === null) return;
          let re = j.near, _e = j.far;
          _.texture !== null && (_.depthNear > 0 && (re = _.depthNear), _.depthFar > 0 && (_e = _.depthFar)), b.near = R.near = w.near = re, b.far = R.far = w.far = _e, (L !== b.near || B !== b.far) && (n.updateRenderState({
            depthNear: b.near,
            depthFar: b.far
          }), L = b.near, B = b.far), w.layers.mask = j.layers.mask | 2, R.layers.mask = j.layers.mask | 4, b.layers.mask = w.layers.mask | R.layers.mask;
          const ae = j.parent, Pe = b.cameras;
          ie(b, ae);
          for (let Re = 0; Re < Pe.length; Re++) ie(Pe[Re], ae);
          Pe.length === 2 ? G(b, w, R) : b.projectionMatrix.copy(w.projectionMatrix), ue(j, b, ae);
        };
        function ue(j, re, _e) {
          _e === null ? j.matrix.copy(re.matrixWorld) : (j.matrix.copy(_e.matrixWorld), j.matrix.invert(), j.matrix.multiply(re.matrixWorld)), j.matrix.decompose(j.position, j.quaternion, j.scale), j.updateMatrixWorld(true), j.projectionMatrix.copy(re.projectionMatrix), j.projectionMatrixInverse.copy(re.projectionMatrixInverse), j.isPerspectiveCamera && (j.fov = es * 2 * Math.atan(1 / j.projectionMatrix.elements[5]), j.zoom = 1);
        }
        this.getCamera = function() {
          return b;
        }, this.getFoveation = function() {
          if (!(d === null && p === null)) return l;
        }, this.setFoveation = function(j) {
          l = j, d !== null && (d.fixedFoveation = j), p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = j);
        }, this.hasDepthSensing = function() {
          return _.texture !== null;
        }, this.getDepthSensingMesh = function() {
          return _.getMesh(b);
        };
        let we = null;
        function Be(j, re) {
          if (u = re.getViewerPose(c || a), f = re, u !== null) {
            const _e = u.views;
            p !== null && (e.setRenderTargetFramebuffer(y, p.framebuffer), e.setRenderTarget(y));
            let ae = false;
            _e.length !== b.cameras.length && (b.cameras.length = 0, ae = true);
            for (let Re = 0; Re < _e.length; Re++) {
              const De = _e[Re];
              let te = null;
              if (p !== null) te = p.getViewport(De);
              else {
                const se = h.getViewSubImage(d, De);
                te = se.viewport, Re === 0 && (e.setRenderTargetTextures(y, se.colorTexture, d.ignoreDepthValues ? void 0 : se.depthStencilTexture), e.setRenderTarget(y));
              }
              let $ = E[Re];
              $ === void 0 && ($ = new oi(), $.layers.enable(Re), $.viewport = new it(), E[Re] = $), $.matrix.fromArray(De.transform.matrix), $.matrix.decompose($.position, $.quaternion, $.scale), $.projectionMatrix.fromArray(De.projectionMatrix), $.projectionMatrixInverse.copy($.projectionMatrix).invert(), $.viewport.set(te.x, te.y, te.width, te.height), Re === 0 && (b.matrix.copy($.matrix), b.matrix.decompose(b.position, b.quaternion, b.scale)), ae === true && b.cameras.push($);
            }
            const Pe = n.enabledFeatures;
            if (Pe && Pe.includes("depth-sensing") && n.depthUsage == "gpu-optimized" && h) {
              const Re = h.getDepthInformation(_e[0]);
              Re && Re.isValid && Re.texture && _.init(e, Re, n.renderState);
            }
          }
          for (let _e = 0; _e < x.length; _e++) {
            const ae = v[_e], Pe = x[_e];
            ae !== null && Pe !== void 0 && Pe.update(ae, re, c || a);
          }
          we && we(j, re), re.detectedPlanes && i.dispatchEvent({
            type: "planesdetected",
            data: re
          }), f = null;
        }
        const We = new vp();
        We.setAnimationLoop(Be), this.setAnimationLoop = function(j) {
          we = j;
        }, this.dispose = function() {
        };
      }
    }
    const xn = new Zi(), Cb = new Fe();
    function Pb(r, e) {
      function t(g, m) {
        g.matrixAutoUpdate === true && g.updateMatrix(), m.value.copy(g.matrix);
      }
      function i(g, m) {
        m.color.getRGB(g.fogColor.value, Td(r)), m.isFog ? (g.fogNear.value = m.near, g.fogFar.value = m.far) : m.isFogExp2 && (g.fogDensity.value = m.density);
      }
      function n(g, m, y, x, v) {
        m.isMeshBasicMaterial || m.isMeshLambertMaterial ? s(g, m) : m.isMeshToonMaterial ? (s(g, m), h(g, m)) : m.isMeshPhongMaterial ? (s(g, m), u(g, m)) : m.isMeshStandardMaterial ? (s(g, m), d(g, m), m.isMeshPhysicalMaterial && p(g, m, v)) : m.isMeshMatcapMaterial ? (s(g, m), f(g, m)) : m.isMeshDepthMaterial ? s(g, m) : m.isMeshDistanceMaterial ? (s(g, m), _(g, m)) : m.isMeshNormalMaterial ? s(g, m) : m.isLineBasicMaterial ? (a(g, m), m.isLineDashedMaterial && o(g, m)) : m.isPointsMaterial ? l(g, m, y, x) : m.isSpriteMaterial ? c(g, m) : m.isShadowMaterial ? (g.color.value.copy(m.color), g.opacity.value = m.opacity) : m.isShaderMaterial && (m.uniformsNeedUpdate = false);
      }
      function s(g, m) {
        g.opacity.value = m.opacity, m.color && g.diffuse.value.copy(m.color), m.emissive && g.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity), m.map && (g.map.value = m.map, t(m.map, g.mapTransform)), m.alphaMap && (g.alphaMap.value = m.alphaMap, t(m.alphaMap, g.alphaMapTransform)), m.bumpMap && (g.bumpMap.value = m.bumpMap, t(m.bumpMap, g.bumpMapTransform), g.bumpScale.value = m.bumpScale, m.side === vt && (g.bumpScale.value *= -1)), m.normalMap && (g.normalMap.value = m.normalMap, t(m.normalMap, g.normalMapTransform), g.normalScale.value.copy(m.normalScale), m.side === vt && g.normalScale.value.negate()), m.displacementMap && (g.displacementMap.value = m.displacementMap, t(m.displacementMap, g.displacementMapTransform), g.displacementScale.value = m.displacementScale, g.displacementBias.value = m.displacementBias), m.emissiveMap && (g.emissiveMap.value = m.emissiveMap, t(m.emissiveMap, g.emissiveMapTransform)), m.specularMap && (g.specularMap.value = m.specularMap, t(m.specularMap, g.specularMapTransform)), m.alphaTest > 0 && (g.alphaTest.value = m.alphaTest);
        const y = e.get(m), x = y.envMap, v = y.envMapRotation;
        x && (g.envMap.value = x, xn.copy(v), xn.x *= -1, xn.y *= -1, xn.z *= -1, x.isCubeTexture && x.isRenderTargetTexture === false && (xn.y *= -1, xn.z *= -1), g.envMapRotation.value.setFromMatrix4(Cb.makeRotationFromEuler(xn)), g.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === false ? -1 : 1, g.reflectivity.value = m.reflectivity, g.ior.value = m.ior, g.refractionRatio.value = m.refractionRatio), m.lightMap && (g.lightMap.value = m.lightMap, g.lightMapIntensity.value = m.lightMapIntensity, t(m.lightMap, g.lightMapTransform)), m.aoMap && (g.aoMap.value = m.aoMap, g.aoMapIntensity.value = m.aoMapIntensity, t(m.aoMap, g.aoMapTransform));
      }
      function a(g, m) {
        g.diffuse.value.copy(m.color), g.opacity.value = m.opacity, m.map && (g.map.value = m.map, t(m.map, g.mapTransform));
      }
      function o(g, m) {
        g.dashSize.value = m.dashSize, g.totalSize.value = m.dashSize + m.gapSize, g.scale.value = m.scale;
      }
      function l(g, m, y, x) {
        g.diffuse.value.copy(m.color), g.opacity.value = m.opacity, g.size.value = m.size * y, g.scale.value = x * 0.5, m.map && (g.map.value = m.map, t(m.map, g.uvTransform)), m.alphaMap && (g.alphaMap.value = m.alphaMap, t(m.alphaMap, g.alphaMapTransform)), m.alphaTest > 0 && (g.alphaTest.value = m.alphaTest);
      }
      function c(g, m) {
        g.diffuse.value.copy(m.color), g.opacity.value = m.opacity, g.rotation.value = m.rotation, m.map && (g.map.value = m.map, t(m.map, g.mapTransform)), m.alphaMap && (g.alphaMap.value = m.alphaMap, t(m.alphaMap, g.alphaMapTransform)), m.alphaTest > 0 && (g.alphaTest.value = m.alphaTest);
      }
      function u(g, m) {
        g.specular.value.copy(m.specular), g.shininess.value = Math.max(m.shininess, 1e-4);
      }
      function h(g, m) {
        m.gradientMap && (g.gradientMap.value = m.gradientMap);
      }
      function d(g, m) {
        g.metalness.value = m.metalness, m.metalnessMap && (g.metalnessMap.value = m.metalnessMap, t(m.metalnessMap, g.metalnessMapTransform)), g.roughness.value = m.roughness, m.roughnessMap && (g.roughnessMap.value = m.roughnessMap, t(m.roughnessMap, g.roughnessMapTransform)), m.envMap && (g.envMapIntensity.value = m.envMapIntensity);
      }
      function p(g, m, y) {
        g.ior.value = m.ior, m.sheen > 0 && (g.sheenColor.value.copy(m.sheenColor).multiplyScalar(m.sheen), g.sheenRoughness.value = m.sheenRoughness, m.sheenColorMap && (g.sheenColorMap.value = m.sheenColorMap, t(m.sheenColorMap, g.sheenColorMapTransform)), m.sheenRoughnessMap && (g.sheenRoughnessMap.value = m.sheenRoughnessMap, t(m.sheenRoughnessMap, g.sheenRoughnessMapTransform))), m.clearcoat > 0 && (g.clearcoat.value = m.clearcoat, g.clearcoatRoughness.value = m.clearcoatRoughness, m.clearcoatMap && (g.clearcoatMap.value = m.clearcoatMap, t(m.clearcoatMap, g.clearcoatMapTransform)), m.clearcoatRoughnessMap && (g.clearcoatRoughnessMap.value = m.clearcoatRoughnessMap, t(m.clearcoatRoughnessMap, g.clearcoatRoughnessMapTransform)), m.clearcoatNormalMap && (g.clearcoatNormalMap.value = m.clearcoatNormalMap, t(m.clearcoatNormalMap, g.clearcoatNormalMapTransform), g.clearcoatNormalScale.value.copy(m.clearcoatNormalScale), m.side === vt && g.clearcoatNormalScale.value.negate())), m.dispersion > 0 && (g.dispersion.value = m.dispersion), m.iridescence > 0 && (g.iridescence.value = m.iridescence, g.iridescenceIOR.value = m.iridescenceIOR, g.iridescenceThicknessMinimum.value = m.iridescenceThicknessRange[0], g.iridescenceThicknessMaximum.value = m.iridescenceThicknessRange[1], m.iridescenceMap && (g.iridescenceMap.value = m.iridescenceMap, t(m.iridescenceMap, g.iridescenceMapTransform)), m.iridescenceThicknessMap && (g.iridescenceThicknessMap.value = m.iridescenceThicknessMap, t(m.iridescenceThicknessMap, g.iridescenceThicknessMapTransform))), m.transmission > 0 && (g.transmission.value = m.transmission, g.transmissionSamplerMap.value = y.texture, g.transmissionSamplerSize.value.set(y.width, y.height), m.transmissionMap && (g.transmissionMap.value = m.transmissionMap, t(m.transmissionMap, g.transmissionMapTransform)), g.thickness.value = m.thickness, m.thicknessMap && (g.thicknessMap.value = m.thicknessMap, t(m.thicknessMap, g.thicknessMapTransform)), g.attenuationDistance.value = m.attenuationDistance, g.attenuationColor.value.copy(m.attenuationColor)), m.anisotropy > 0 && (g.anisotropyVector.value.set(m.anisotropy * Math.cos(m.anisotropyRotation), m.anisotropy * Math.sin(m.anisotropyRotation)), m.anisotropyMap && (g.anisotropyMap.value = m.anisotropyMap, t(m.anisotropyMap, g.anisotropyMapTransform))), g.specularIntensity.value = m.specularIntensity, g.specularColor.value.copy(m.specularColor), m.specularColorMap && (g.specularColorMap.value = m.specularColorMap, t(m.specularColorMap, g.specularColorMapTransform)), m.specularIntensityMap && (g.specularIntensityMap.value = m.specularIntensityMap, t(m.specularIntensityMap, g.specularIntensityMapTransform));
      }
      function f(g, m) {
        m.matcap && (g.matcap.value = m.matcap);
      }
      function _(g, m) {
        const y = e.get(m).light;
        g.referencePosition.value.setFromMatrixPosition(y.matrixWorld), g.nearDistance.value = y.shadow.camera.near, g.farDistance.value = y.shadow.camera.far;
      }
      return {
        refreshFogUniforms: i,
        refreshMaterialUniforms: n
      };
    }
    function Lb(r, e, t, i) {
      let n = {}, s = {}, a = [];
      const o = r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS);
      function l(y, x) {
        const v = x.program;
        i.uniformBlockBinding(y, v);
      }
      function c(y, x) {
        let v = n[y.id];
        v === void 0 && (f(y), v = u(y), n[y.id] = v, y.addEventListener("dispose", g));
        const A = x.program;
        i.updateUBOMapping(y, A);
        const T = e.render.frame;
        s[y.id] !== T && (d(y), s[y.id] = T);
      }
      function u(y) {
        const x = h();
        y.__bindingPointIndex = x;
        const v = r.createBuffer(), A = y.__size, T = y.usage;
        return r.bindBuffer(r.UNIFORM_BUFFER, v), r.bufferData(r.UNIFORM_BUFFER, A, T), r.bindBuffer(r.UNIFORM_BUFFER, null), r.bindBufferBase(r.UNIFORM_BUFFER, x, v), v;
      }
      function h() {
        for (let y = 0; y < o; y++) if (a.indexOf(y) === -1) return a.push(y), y;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0;
      }
      function d(y) {
        const x = n[y.id], v = y.uniforms, A = y.__cache;
        r.bindBuffer(r.UNIFORM_BUFFER, x);
        for (let T = 0, w = v.length; T < w; T++) {
          const R = Array.isArray(v[T]) ? v[T] : [
            v[T]
          ];
          for (let E = 0, b = R.length; E < b; E++) {
            const L = R[E];
            if (p(L, T, E, A) === true) {
              const B = L.__offset, F = Array.isArray(L.value) ? L.value : [
                L.value
              ];
              let V = 0;
              for (let X = 0; X < F.length; X++) {
                const k = F[X], K = _(k);
                typeof k == "number" || typeof k == "boolean" ? (L.__data[0] = k, r.bufferSubData(r.UNIFORM_BUFFER, B + V, L.__data)) : k.isMatrix3 ? (L.__data[0] = k.elements[0], L.__data[1] = k.elements[1], L.__data[2] = k.elements[2], L.__data[3] = 0, L.__data[4] = k.elements[3], L.__data[5] = k.elements[4], L.__data[6] = k.elements[5], L.__data[7] = 0, L.__data[8] = k.elements[6], L.__data[9] = k.elements[7], L.__data[10] = k.elements[8], L.__data[11] = 0) : (k.toArray(L.__data, V), V += K.storage / Float32Array.BYTES_PER_ELEMENT);
              }
              r.bufferSubData(r.UNIFORM_BUFFER, B, L.__data);
            }
          }
        }
        r.bindBuffer(r.UNIFORM_BUFFER, null);
      }
      function p(y, x, v, A) {
        const T = y.value, w = x + "_" + v;
        if (A[w] === void 0) return typeof T == "number" || typeof T == "boolean" ? A[w] = T : A[w] = T.clone(), true;
        {
          const R = A[w];
          if (typeof T == "number" || typeof T == "boolean") {
            if (R !== T) return A[w] = T, true;
          } else if (R.equals(T) === false) return R.copy(T), true;
        }
        return false;
      }
      function f(y) {
        const x = y.uniforms;
        let v = 0;
        const A = 16;
        for (let w = 0, R = x.length; w < R; w++) {
          const E = Array.isArray(x[w]) ? x[w] : [
            x[w]
          ];
          for (let b = 0, L = E.length; b < L; b++) {
            const B = E[b], F = Array.isArray(B.value) ? B.value : [
              B.value
            ];
            for (let V = 0, X = F.length; V < X; V++) {
              const k = F[V], K = _(k), G = v % A, ie = G % K.boundary, ue = G + ie;
              v += ie, ue !== 0 && A - ue < K.storage && (v += A - ue), B.__data = new Float32Array(K.storage / Float32Array.BYTES_PER_ELEMENT), B.__offset = v, v += K.storage;
            }
          }
        }
        const T = v % A;
        return T > 0 && (v += A - T), y.__size = v, y.__cache = {}, this;
      }
      function _(y) {
        const x = {
          boundary: 0,
          storage: 0
        };
        return typeof y == "number" || typeof y == "boolean" ? (x.boundary = 4, x.storage = 4) : y.isVector2 ? (x.boundary = 8, x.storage = 8) : y.isVector3 || y.isColor ? (x.boundary = 16, x.storage = 12) : y.isVector4 ? (x.boundary = 16, x.storage = 16) : y.isMatrix3 ? (x.boundary = 48, x.storage = 48) : y.isMatrix4 ? (x.boundary = 64, x.storage = 64) : y.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", y), x;
      }
      function g(y) {
        const x = y.target;
        x.removeEventListener("dispose", g);
        const v = a.indexOf(x.__bindingPointIndex);
        a.splice(v, 1), r.deleteBuffer(n[x.id]), delete n[x.id], delete s[x.id];
      }
      function m() {
        for (const y in n) r.deleteBuffer(n[y]);
        a = [], n = {}, s = {};
      }
      return {
        bind: l,
        update: c,
        dispose: m
      };
    }
    class Db {
      constructor(e = {}) {
        const { canvas: t = t_(), context: i = null, depth: n = true, stencil: s = false, alpha: a = false, antialias: o = false, premultipliedAlpha: l = true, preserveDrawingBuffer: c = false, powerPreference: u = "default", failIfMajorPerformanceCaveat: h = false, reverseDepthBuffer: d = false } = e;
        this.isWebGLRenderer = true;
        let p;
        if (i !== null) {
          if (typeof WebGLRenderingContext < "u" && i instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
          p = i.getContextAttributes().alpha;
        } else p = a;
        const f = new Uint32Array(4), _ = new Int32Array(4);
        let g = null, m = null;
        const y = [], x = [];
        this.domElement = t, this.debug = {
          checkShaderErrors: true,
          onShaderError: null
        }, this.autoClear = true, this.autoClearColor = true, this.autoClearDepth = true, this.autoClearStencil = true, this.sortObjects = true, this.clippingPlanes = [], this.localClippingEnabled = false, this._outputColorSpace = Gt, this.toneMapping = Ir, this.toneMappingExposure = 1;
        const v = this;
        let A = false, T = 0, w = 0, R = null, E = -1, b = null;
        const L = new it(), B = new it();
        let F = null;
        const V = new Ae(0);
        let X = 0, k = t.width, K = t.height, G = 1, ie = null, ue = null;
        const we = new it(0, 0, k, K), Be = new it(0, 0, k, K);
        let We = false;
        const j = new Wc();
        let re = false, _e = false;
        this.transmissionResolutionScale = 1;
        const ae = new Fe(), Pe = new Fe(), Re = new D(), De = new it(), te = {
          background: null,
          fog: null,
          environment: null,
          overrideMaterial: null,
          isScene: true
        };
        let $ = false;
        function se() {
          return R === null ? G : 1;
        }
        let P = i;
        function fe(S, O) {
          return t.getContext(S, O);
        }
        try {
          const S = {
            alpha: true,
            depth: n,
            stencil: s,
            antialias: o,
            premultipliedAlpha: l,
            preserveDrawingBuffer: c,
            powerPreference: u,
            failIfMajorPerformanceCaveat: h
          };
          if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${rn}`), t.addEventListener("webglcontextlost", Z, false), t.addEventListener("webglcontextrestored", me, false), t.addEventListener("webglcontextcreationerror", le, false), P === null) {
            const O = "webgl2";
            if (P = fe(O, S), P === null) throw fe(O) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
          }
        } catch (S) {
          throw console.error("THREE.WebGLRenderer: " + S.message), S;
        }
        let xe, Me, oe, ke, de, C, M, N, Y, J, q, Te, he, ye, je, ne, be, Le, Ie, Se, Ze, Ve, pt, I;
        function pe() {
          xe = new Vy(P), xe.init(), Ve = new Eb(P, xe), Me = new Ny(P, xe, e, Ve), oe = new bb(P, xe), Me.reverseDepthBuffer && d && oe.buffers.depth.setReversed(true), ke = new Xy(P), de = new cb(), C = new Sb(P, xe, oe, de, Me, Ve, ke), M = new By(v), N = new Hy(v), Y = new $v(P), pt = new Uy(P, Y), J = new Gy(P, Y, ke, pt), q = new qy(P, J, Y, ke), Ie = new jy(P, Me, C), ne = new Fy(de), Te = new lb(v, M, N, xe, Me, pt, ne), he = new Pb(v, de), ye = new hb(), je = new _b(xe), Le = new Iy(v, M, N, oe, q, p, l), be = new yb(v, q, Me), I = new Lb(P, ke, Me, oe), Se = new Oy(P, xe, ke), Ze = new Wy(P, xe, ke), ke.programs = Te.programs, v.capabilities = Me, v.extensions = xe, v.properties = de, v.renderLists = ye, v.shadowMap = be, v.state = oe, v.info = ke;
        }
        pe();
        const W = new Rb(v, P);
        this.xr = W, this.getContext = function() {
          return P;
        }, this.getContextAttributes = function() {
          return P.getContextAttributes();
        }, this.forceContextLoss = function() {
          const S = xe.get("WEBGL_lose_context");
          S && S.loseContext();
        }, this.forceContextRestore = function() {
          const S = xe.get("WEBGL_lose_context");
          S && S.restoreContext();
        }, this.getPixelRatio = function() {
          return G;
        }, this.setPixelRatio = function(S) {
          S !== void 0 && (G = S, this.setSize(k, K, false));
        }, this.getSize = function(S) {
          return S.set(k, K);
        }, this.setSize = function(S, O, z = true) {
          if (W.isPresenting) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            return;
          }
          k = S, K = O, t.width = Math.floor(S * G), t.height = Math.floor(O * G), z === true && (t.style.width = S + "px", t.style.height = O + "px"), this.setViewport(0, 0, S, O);
        }, this.getDrawingBufferSize = function(S) {
          return S.set(k * G, K * G).floor();
        }, this.setDrawingBufferSize = function(S, O, z) {
          k = S, K = O, G = z, t.width = Math.floor(S * z), t.height = Math.floor(O * z), this.setViewport(0, 0, S, O);
        }, this.getCurrentViewport = function(S) {
          return S.copy(L);
        }, this.getViewport = function(S) {
          return S.copy(we);
        }, this.setViewport = function(S, O, z, H) {
          S.isVector4 ? we.set(S.x, S.y, S.z, S.w) : we.set(S, O, z, H), oe.viewport(L.copy(we).multiplyScalar(G).round());
        }, this.getScissor = function(S) {
          return S.copy(Be);
        }, this.setScissor = function(S, O, z, H) {
          S.isVector4 ? Be.set(S.x, S.y, S.z, S.w) : Be.set(S, O, z, H), oe.scissor(B.copy(Be).multiplyScalar(G).round());
        }, this.getScissorTest = function() {
          return We;
        }, this.setScissorTest = function(S) {
          oe.setScissorTest(We = S);
        }, this.setOpaqueSort = function(S) {
          ie = S;
        }, this.setTransparentSort = function(S) {
          ue = S;
        }, this.getClearColor = function(S) {
          return S.copy(Le.getClearColor());
        }, this.setClearColor = function() {
          Le.setClearColor.apply(Le, arguments);
        }, this.getClearAlpha = function() {
          return Le.getClearAlpha();
        }, this.setClearAlpha = function() {
          Le.setClearAlpha.apply(Le, arguments);
        }, this.clear = function(S = true, O = true, z = true) {
          let H = 0;
          if (S) {
            let U = false;
            if (R !== null) {
              const Q = R.texture.format;
              U = Q === kl || Q === zl || Q === Bl;
            }
            if (U) {
              const Q = R.texture.type, ge = Q === ur || Q === an || Q === aa || Q === Kn || Q === Ol || Q === Nl, ve = Le.getClearColor(), Ee = Le.getClearAlpha(), Oe = ve.r, Ue = ve.g, Ne = ve.b;
              ge ? (f[0] = Oe, f[1] = Ue, f[2] = Ne, f[3] = Ee, P.clearBufferuiv(P.COLOR, 0, f)) : (_[0] = Oe, _[1] = Ue, _[2] = Ne, _[3] = Ee, P.clearBufferiv(P.COLOR, 0, _));
            } else H |= P.COLOR_BUFFER_BIT;
          }
          O && (H |= P.DEPTH_BUFFER_BIT), z && (H |= P.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), P.clear(H);
        }, this.clearColor = function() {
          this.clear(true, false, false);
        }, this.clearDepth = function() {
          this.clear(false, true, false);
        }, this.clearStencil = function() {
          this.clear(false, false, true);
        }, this.dispose = function() {
          t.removeEventListener("webglcontextlost", Z, false), t.removeEventListener("webglcontextrestored", me, false), t.removeEventListener("webglcontextcreationerror", le, false), Le.dispose(), ye.dispose(), je.dispose(), de.dispose(), M.dispose(), N.dispose(), q.dispose(), pt.dispose(), I.dispose(), Te.dispose(), W.dispose(), W.removeEventListener("sessionstart", Wm), W.removeEventListener("sessionend", Xm), Hn.stop();
        };
        function Z(S) {
          S.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), A = true;
        }
        function me() {
          console.log("THREE.WebGLRenderer: Context Restored."), A = false;
          const S = ke.autoReset, O = be.enabled, z = be.autoUpdate, H = be.needsUpdate, U = be.type;
          pe(), ke.autoReset = S, be.enabled = O, be.autoUpdate = z, be.needsUpdate = H, be.type = U;
        }
        function le(S) {
          console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", S.statusMessage);
        }
        function Je(S) {
          const O = S.target;
          O.removeEventListener("dispose", Je), Tt(O);
        }
        function Tt(S) {
          ei(S), de.remove(S);
        }
        function ei(S) {
          const O = de.get(S).programs;
          O !== void 0 && (O.forEach(function(z) {
            Te.releaseProgram(z);
          }), S.isShaderMaterial && Te.releaseShaderCache(S));
        }
        this.renderBufferDirect = function(S, O, z, H, U, Q) {
          O === null && (O = te);
          const ge = U.isMesh && U.matrixWorld.determinant() < 0, ve = IT(S, O, z, H, U);
          oe.setMaterial(H, ge);
          let Ee = z.index, Oe = 1;
          if (H.wireframe === true) {
            if (Ee = J.getWireframeAttribute(z), Ee === void 0) return;
            Oe = 2;
          }
          const Ue = z.drawRange, Ne = z.attributes.position;
          let tt = Ue.start * Oe, ut = (Ue.start + Ue.count) * Oe;
          Q !== null && (tt = Math.max(tt, Q.start * Oe), ut = Math.min(ut, (Q.start + Q.count) * Oe)), Ee !== null ? (tt = Math.max(tt, 0), ut = Math.min(ut, Ee.count)) : Ne != null && (tt = Math.max(tt, 0), ut = Math.min(ut, Ne.count));
          const kt = ut - tt;
          if (kt < 0 || kt === 1 / 0) return;
          pt.setup(U, H, ve, z, Ee);
          let ht, ft = Se;
          if (Ee !== null && (ht = Y.get(Ee), ft = Ze, ft.setIndex(ht)), U.isMesh) H.wireframe === true ? (oe.setLineWidth(H.wireframeLinewidth * se()), ft.setMode(P.LINES)) : ft.setMode(P.TRIANGLES);
          else if (U.isLine) {
            let Ce = H.linewidth;
            Ce === void 0 && (Ce = 1), oe.setLineWidth(Ce * se()), U.isLineSegments ? ft.setMode(P.LINES) : U.isLineLoop ? ft.setMode(P.LINE_LOOP) : ft.setMode(P.LINE_STRIP);
          } else U.isPoints ? ft.setMode(P.POINTS) : U.isSprite && ft.setMode(P.TRIANGLES);
          if (U.isBatchedMesh) if (U._multiDrawInstances !== null) ft.renderMultiDrawInstances(U._multiDrawStarts, U._multiDrawCounts, U._multiDrawCount, U._multiDrawInstances);
          else if (xe.get("WEBGL_multi_draw")) ft.renderMultiDraw(U._multiDrawStarts, U._multiDrawCounts, U._multiDrawCount);
          else {
            const Ce = U._multiDrawStarts, ui = U._multiDrawCounts, Vn = U._multiDrawCount, qi = Ee ? Y.get(Ee).bytesPerElement : 1, ia = de.get(H).currentProgram.getUniforms();
            for (let Ai = 0; Ai < Vn; Ai++) ia.setValue(P, "_gl_DrawID", Ai), ft.render(Ce[Ai] / qi, ui[Ai]);
          }
          else if (U.isInstancedMesh) ft.renderInstances(tt, kt, U.count);
          else if (z.isInstancedBufferGeometry) {
            const Ce = z._maxInstanceCount !== void 0 ? z._maxInstanceCount : 1 / 0, ui = Math.min(z.instanceCount, Ce);
            ft.renderInstances(tt, kt, ui);
          } else ft.render(tt, kt);
        };
        function at(S, O, z) {
          S.transparent === true && S.side === ti && S.forceSinglePass === false ? (S.side = vt, S.needsUpdate = true, bl(S, O, z), S.side = Ot, S.needsUpdate = true, bl(S, O, z), S.side = ti) : bl(S, O, z);
        }
        this.compile = function(S, O, z = null) {
          z === null && (z = S), m = je.get(z), m.init(O), x.push(m), z.traverseVisible(function(U) {
            U.isLight && U.layers.test(O.layers) && (m.pushLight(U), U.castShadow && m.pushShadow(U));
          }), S !== z && S.traverseVisible(function(U) {
            U.isLight && U.layers.test(O.layers) && (m.pushLight(U), U.castShadow && m.pushShadow(U));
          }), m.setupLights();
          const H = /* @__PURE__ */ new Set();
          return S.traverse(function(U) {
            if (!(U.isMesh || U.isPoints || U.isLine || U.isSprite)) return;
            const Q = U.material;
            if (Q) if (Array.isArray(Q)) for (let ge = 0; ge < Q.length; ge++) {
              const ve = Q[ge];
              at(ve, z, U), H.add(ve);
            }
            else at(Q, z, U), H.add(Q);
          }), x.pop(), m = null, H;
        }, this.compileAsync = function(S, O, z = null) {
          const H = this.compile(S, O, z);
          return new Promise((U) => {
            function Q() {
              if (H.forEach(function(ge) {
                de.get(ge).currentProgram.isReady() && H.delete(ge);
              }), H.size === 0) {
                U(S);
                return;
              }
              setTimeout(Q, 10);
            }
            xe.get("KHR_parallel_shader_compile") !== null ? Q() : setTimeout(Q, 10);
          });
        };
        let ji = null;
        function Lr(S) {
          ji && ji(S);
        }
        function Wm() {
          Hn.stop();
        }
        function Xm() {
          Hn.start();
        }
        const Hn = new vp();
        Hn.setAnimationLoop(Lr), typeof self < "u" && Hn.setContext(self), this.setAnimationLoop = function(S) {
          ji = S, W.setAnimationLoop(S), S === null ? Hn.stop() : Hn.start();
        }, W.addEventListener("sessionstart", Wm), W.addEventListener("sessionend", Xm), this.render = function(S, O) {
          if (O !== void 0 && O.isCamera !== true) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return;
          }
          if (A === true) return;
          if (S.matrixWorldAutoUpdate === true && S.updateMatrixWorld(), O.parent === null && O.matrixWorldAutoUpdate === true && O.updateMatrixWorld(), W.enabled === true && W.isPresenting === true && (W.cameraAutoUpdate === true && W.updateCamera(O), O = W.getCamera()), S.isScene === true && S.onBeforeRender(v, S, O, R), m = je.get(S, x.length), m.init(O), x.push(m), Pe.multiplyMatrices(O.projectionMatrix, O.matrixWorldInverse), j.setFromProjectionMatrix(Pe), _e = this.localClippingEnabled, re = ne.init(this.clippingPlanes, _e), g = ye.get(S, y.length), g.init(), y.push(g), W.enabled === true && W.isPresenting === true) {
            const Q = v.xr.getDepthSensingMesh();
            Q !== null && Ih(Q, O, -1 / 0, v.sortObjects);
          }
          Ih(S, O, 0, v.sortObjects), g.finish(), v.sortObjects === true && g.sort(ie, ue), $ = W.enabled === false || W.isPresenting === false || W.hasDepthSensing() === false, $ && Le.addToRenderList(g, S), this.info.render.frame++, re === true && ne.beginShadows();
          const z = m.state.shadowsArray;
          be.render(z, S, O), re === true && ne.endShadows(), this.info.autoReset === true && this.info.reset();
          const H = g.opaque, U = g.transmissive;
          if (m.setupLights(), O.isArrayCamera) {
            const Q = O.cameras;
            if (U.length > 0) for (let ge = 0, ve = Q.length; ge < ve; ge++) {
              const Ee = Q[ge];
              qm(H, U, S, Ee);
            }
            $ && Le.render(S);
            for (let ge = 0, ve = Q.length; ge < ve; ge++) {
              const Ee = Q[ge];
              jm(g, S, Ee, Ee.viewport);
            }
          } else U.length > 0 && qm(H, U, S, O), $ && Le.render(S), jm(g, S, O);
          R !== null && w === 0 && (C.updateMultisampleRenderTarget(R), C.updateRenderTargetMipmap(R)), S.isScene === true && S.onAfterRender(v, S, O), pt.resetDefaultState(), E = -1, b = null, x.pop(), x.length > 0 ? (m = x[x.length - 1], re === true && ne.setGlobalState(v.clippingPlanes, m.state.camera)) : m = null, y.pop(), y.length > 0 ? g = y[y.length - 1] : g = null;
        };
        function Ih(S, O, z, H) {
          if (S.visible === false) return;
          if (S.layers.test(O.layers)) {
            if (S.isGroup) z = S.renderOrder;
            else if (S.isLOD) S.autoUpdate === true && S.update(O);
            else if (S.isLight) m.pushLight(S), S.castShadow && m.pushShadow(S);
            else if (S.isSprite) {
              if (!S.frustumCulled || j.intersectsSprite(S)) {
                H && De.setFromMatrixPosition(S.matrixWorld).applyMatrix4(Pe);
                const Q = q.update(S), ge = S.material;
                ge.visible && g.push(S, Q, ge, z, De.z, null);
              }
            } else if ((S.isMesh || S.isLine || S.isPoints) && (!S.frustumCulled || j.intersectsObject(S))) {
              const Q = q.update(S), ge = S.material;
              if (H && (S.boundingSphere !== void 0 ? (S.boundingSphere === null && S.computeBoundingSphere(), De.copy(S.boundingSphere.center)) : (Q.boundingSphere === null && Q.computeBoundingSphere(), De.copy(Q.boundingSphere.center)), De.applyMatrix4(S.matrixWorld).applyMatrix4(Pe)), Array.isArray(ge)) {
                const ve = Q.groups;
                for (let Ee = 0, Oe = ve.length; Ee < Oe; Ee++) {
                  const Ue = ve[Ee], Ne = ge[Ue.materialIndex];
                  Ne && Ne.visible && g.push(S, Q, Ne, z, De.z, Ue);
                }
              } else ge.visible && g.push(S, Q, ge, z, De.z, null);
            }
          }
          const U = S.children;
          for (let Q = 0, ge = U.length; Q < ge; Q++) Ih(U[Q], O, z, H);
        }
        function jm(S, O, z, H) {
          const U = S.opaque, Q = S.transmissive, ge = S.transparent;
          m.setupLightsView(z), re === true && ne.setGlobalState(v.clippingPlanes, z), H && oe.viewport(L.copy(H)), U.length > 0 && Ml(U, O, z), Q.length > 0 && Ml(Q, O, z), ge.length > 0 && Ml(ge, O, z), oe.buffers.depth.setTest(true), oe.buffers.depth.setMask(true), oe.buffers.color.setMask(true), oe.setPolygonOffset(false);
        }
        function qm(S, O, z, H) {
          if ((z.isScene === true ? z.overrideMaterial : null) !== null) return;
          m.state.transmissionRenderTarget[H.id] === void 0 && (m.state.transmissionRenderTarget[H.id] = new ki(1, 1, {
            generateMipmaps: true,
            type: xe.has("EXT_color_buffer_half_float") || xe.has("EXT_color_buffer_float") ? hr : ur,
            minFilter: cr,
            samples: 4,
            stencilBuffer: s,
            resolveDepthBuffer: false,
            resolveStencilBuffer: false,
            colorSpace: Ke.workingColorSpace
          }));
          const U = m.state.transmissionRenderTarget[H.id], Q = H.viewport || L;
          U.setSize(Q.z * v.transmissionResolutionScale, Q.w * v.transmissionResolutionScale);
          const ge = v.getRenderTarget();
          v.setRenderTarget(U), v.getClearColor(V), X = v.getClearAlpha(), X < 1 && v.setClearColor(16777215, 0.5), v.clear(), $ && Le.render(z);
          const ve = v.toneMapping;
          v.toneMapping = Ir;
          const Ee = H.viewport;
          if (H.viewport !== void 0 && (H.viewport = void 0), m.setupLightsView(H), re === true && ne.setGlobalState(v.clippingPlanes, H), Ml(S, z, H), C.updateMultisampleRenderTarget(U), C.updateRenderTargetMipmap(U), xe.has("WEBGL_multisampled_render_to_texture") === false) {
            let Oe = false;
            for (let Ue = 0, Ne = O.length; Ue < Ne; Ue++) {
              const tt = O[Ue], ut = tt.object, kt = tt.geometry, ht = tt.material, ft = tt.group;
              if (ht.side === ti && ut.layers.test(H.layers)) {
                const Ce = ht.side;
                ht.side = vt, ht.needsUpdate = true, Ym(ut, z, H, kt, ht, ft), ht.side = Ce, ht.needsUpdate = true, Oe = true;
              }
            }
            Oe === true && (C.updateMultisampleRenderTarget(U), C.updateRenderTargetMipmap(U));
          }
          v.setRenderTarget(ge), v.setClearColor(V, X), Ee !== void 0 && (H.viewport = Ee), v.toneMapping = ve;
        }
        function Ml(S, O, z) {
          const H = O.isScene === true ? O.overrideMaterial : null;
          for (let U = 0, Q = S.length; U < Q; U++) {
            const ge = S[U], ve = ge.object, Ee = ge.geometry, Oe = H === null ? ge.material : H, Ue = ge.group;
            ve.layers.test(z.layers) && Ym(ve, O, z, Ee, Oe, Ue);
          }
        }
        function Ym(S, O, z, H, U, Q) {
          S.onBeforeRender(v, O, z, H, U, Q), S.modelViewMatrix.multiplyMatrices(z.matrixWorldInverse, S.matrixWorld), S.normalMatrix.getNormalMatrix(S.modelViewMatrix), U.onBeforeRender(v, O, z, H, S, Q), U.transparent === true && U.side === ti && U.forceSinglePass === false ? (U.side = vt, U.needsUpdate = true, v.renderBufferDirect(z, O, H, U, S, Q), U.side = Ot, U.needsUpdate = true, v.renderBufferDirect(z, O, H, U, S, Q), U.side = ti) : v.renderBufferDirect(z, O, H, U, S, Q), S.onAfterRender(v, O, z, H, U, Q);
        }
        function bl(S, O, z) {
          O.isScene !== true && (O = te);
          const H = de.get(S), U = m.state.lights, Q = m.state.shadowsArray, ge = U.state.version, ve = Te.getParameters(S, U.state, Q, O, z), Ee = Te.getProgramCacheKey(ve);
          let Oe = H.programs;
          H.environment = S.isMeshStandardMaterial ? O.environment : null, H.fog = O.fog, H.envMap = (S.isMeshStandardMaterial ? N : M).get(S.envMap || H.environment), H.envMapRotation = H.environment !== null && S.envMap === null ? O.environmentRotation : S.envMapRotation, Oe === void 0 && (S.addEventListener("dispose", Je), Oe = /* @__PURE__ */ new Map(), H.programs = Oe);
          let Ue = Oe.get(Ee);
          if (Ue !== void 0) {
            if (H.currentProgram === Ue && H.lightsStateVersion === ge) return Zm(S, ve), Ue;
          } else ve.uniforms = Te.getUniforms(S), S.onBeforeCompile(ve, v), Ue = Te.acquireProgram(ve, Ee), Oe.set(Ee, Ue), H.uniforms = ve.uniforms;
          const Ne = H.uniforms;
          return (!S.isShaderMaterial && !S.isRawShaderMaterial || S.clipping === true) && (Ne.clippingPlanes = ne.uniform), Zm(S, ve), H.needsLights = OT(S), H.lightsStateVersion = ge, H.needsLights && (Ne.ambientLightColor.value = U.state.ambient, Ne.lightProbe.value = U.state.probe, Ne.directionalLights.value = U.state.directional, Ne.directionalLightShadows.value = U.state.directionalShadow, Ne.spotLights.value = U.state.spot, Ne.spotLightShadows.value = U.state.spotShadow, Ne.rectAreaLights.value = U.state.rectArea, Ne.ltc_1.value = U.state.rectAreaLTC1, Ne.ltc_2.value = U.state.rectAreaLTC2, Ne.pointLights.value = U.state.point, Ne.pointLightShadows.value = U.state.pointShadow, Ne.hemisphereLights.value = U.state.hemi, Ne.directionalShadowMap.value = U.state.directionalShadowMap, Ne.directionalShadowMatrix.value = U.state.directionalShadowMatrix, Ne.spotShadowMap.value = U.state.spotShadowMap, Ne.spotLightMatrix.value = U.state.spotLightMatrix, Ne.spotLightMap.value = U.state.spotLightMap, Ne.pointShadowMap.value = U.state.pointShadowMap, Ne.pointShadowMatrix.value = U.state.pointShadowMatrix), H.currentProgram = Ue, H.uniformsList = null, Ue;
        }
        function Km(S) {
          if (S.uniformsList === null) {
            const O = S.currentProgram.getUniforms();
            S.uniformsList = $o.seqWithValue(O.seq, S.uniforms);
          }
          return S.uniformsList;
        }
        function Zm(S, O) {
          const z = de.get(S);
          z.outputColorSpace = O.outputColorSpace, z.batching = O.batching, z.batchingColor = O.batchingColor, z.instancing = O.instancing, z.instancingColor = O.instancingColor, z.instancingMorph = O.instancingMorph, z.skinning = O.skinning, z.morphTargets = O.morphTargets, z.morphNormals = O.morphNormals, z.morphColors = O.morphColors, z.morphTargetsCount = O.morphTargetsCount, z.numClippingPlanes = O.numClippingPlanes, z.numIntersection = O.numClipIntersection, z.vertexAlphas = O.vertexAlphas, z.vertexTangents = O.vertexTangents, z.toneMapping = O.toneMapping;
        }
        function IT(S, O, z, H, U) {
          O.isScene !== true && (O = te), C.resetTextureUnits();
          const Q = O.fog, ge = H.isMeshStandardMaterial ? O.environment : null, ve = R === null ? v.outputColorSpace : R.isXRRenderTarget === true ? R.texture.colorSpace : ni, Ee = (H.isMeshStandardMaterial ? N : M).get(H.envMap || ge), Oe = H.vertexColors === true && !!z.attributes.color && z.attributes.color.itemSize === 4, Ue = !!z.attributes.tangent && (!!H.normalMap || H.anisotropy > 0), Ne = !!z.morphAttributes.position, tt = !!z.morphAttributes.normal, ut = !!z.morphAttributes.color;
          let kt = Ir;
          H.toneMapped && (R === null || R.isXRRenderTarget === true) && (kt = v.toneMapping);
          const ht = z.morphAttributes.position || z.morphAttributes.normal || z.morphAttributes.color, ft = ht !== void 0 ? ht.length : 0, Ce = de.get(H), ui = m.state.lights;
          if (re === true && (_e === true || S !== b)) {
            const jt = S === b && H.id === E;
            ne.setState(H, S, jt);
          }
          let Vn = false;
          H.version === Ce.__version ? (Ce.needsLights && Ce.lightsStateVersion !== ui.state.version || Ce.outputColorSpace !== ve || U.isBatchedMesh && Ce.batching === false || !U.isBatchedMesh && Ce.batching === true || U.isBatchedMesh && Ce.batchingColor === true && U.colorTexture === null || U.isBatchedMesh && Ce.batchingColor === false && U.colorTexture !== null || U.isInstancedMesh && Ce.instancing === false || !U.isInstancedMesh && Ce.instancing === true || U.isSkinnedMesh && Ce.skinning === false || !U.isSkinnedMesh && Ce.skinning === true || U.isInstancedMesh && Ce.instancingColor === true && U.instanceColor === null || U.isInstancedMesh && Ce.instancingColor === false && U.instanceColor !== null || U.isInstancedMesh && Ce.instancingMorph === true && U.morphTexture === null || U.isInstancedMesh && Ce.instancingMorph === false && U.morphTexture !== null || Ce.envMap !== Ee || H.fog === true && Ce.fog !== Q || Ce.numClippingPlanes !== void 0 && (Ce.numClippingPlanes !== ne.numPlanes || Ce.numIntersection !== ne.numIntersection) || Ce.vertexAlphas !== Oe || Ce.vertexTangents !== Ue || Ce.morphTargets !== Ne || Ce.morphNormals !== tt || Ce.morphColors !== ut || Ce.toneMapping !== kt || Ce.morphTargetsCount !== ft) && (Vn = true) : (Vn = true, Ce.__version = H.version);
          let qi = Ce.currentProgram;
          Vn === true && (qi = bl(H, O, U));
          let ia = false, Ai = false, io = false;
          const _t = qi.getUniforms(), Oi = Ce.uniforms;
          if (oe.useProgram(qi.program) && (ia = true, Ai = true, io = true), H.id !== E && (E = H.id, Ai = true), ia || b !== S) {
            oe.buffers.depth.getReversed() ? (ae.copy(S.projectionMatrix), r_(ae), n_(ae), _t.setValue(P, "projectionMatrix", ae)) : _t.setValue(P, "projectionMatrix", S.projectionMatrix), _t.setValue(P, "viewMatrix", S.matrixWorldInverse);
            const jt = _t.map.cameraPosition;
            jt !== void 0 && jt.setValue(P, Re.setFromMatrixPosition(S.matrixWorld)), Me.logarithmicDepthBuffer && _t.setValue(P, "logDepthBufFC", 2 / (Math.log(S.far + 1) / Math.LN2)), (H.isMeshPhongMaterial || H.isMeshToonMaterial || H.isMeshLambertMaterial || H.isMeshBasicMaterial || H.isMeshStandardMaterial || H.isShaderMaterial) && _t.setValue(P, "isOrthographic", S.isOrthographicCamera === true), b !== S && (b = S, Ai = true, io = true);
          }
          if (U.isSkinnedMesh) {
            _t.setOptional(P, U, "bindMatrix"), _t.setOptional(P, U, "bindMatrixInverse");
            const jt = U.skeleton;
            jt && (jt.boneTexture === null && jt.computeBoneTexture(), _t.setValue(P, "boneTexture", jt.boneTexture, C));
          }
          U.isBatchedMesh && (_t.setOptional(P, U, "batchingTexture"), _t.setValue(P, "batchingTexture", U._matricesTexture, C), _t.setOptional(P, U, "batchingIdTexture"), _t.setValue(P, "batchingIdTexture", U._indirectTexture, C), _t.setOptional(P, U, "batchingColorTexture"), U._colorsTexture !== null && _t.setValue(P, "batchingColorTexture", U._colorsTexture, C));
          const Ni = z.morphAttributes;
          if ((Ni.position !== void 0 || Ni.normal !== void 0 || Ni.color !== void 0) && Ie.update(U, z, qi), (Ai || Ce.receiveShadow !== U.receiveShadow) && (Ce.receiveShadow = U.receiveShadow, _t.setValue(P, "receiveShadow", U.receiveShadow)), H.isMeshGouraudMaterial && H.envMap !== null && (Oi.envMap.value = Ee, Oi.flipEnvMap.value = Ee.isCubeTexture && Ee.isRenderTargetTexture === false ? -1 : 1), H.isMeshStandardMaterial && H.envMap === null && O.environment !== null && (Oi.envMapIntensity.value = O.environmentIntensity), Ai && (_t.setValue(P, "toneMappingExposure", v.toneMappingExposure), Ce.needsLights && UT(Oi, io), Q && H.fog === true && he.refreshFogUniforms(Oi, Q), he.refreshMaterialUniforms(Oi, H, G, K, m.state.transmissionRenderTarget[S.id]), $o.upload(P, Km(Ce), Oi, C)), H.isShaderMaterial && H.uniformsNeedUpdate === true && ($o.upload(P, Km(Ce), Oi, C), H.uniformsNeedUpdate = false), H.isSpriteMaterial && _t.setValue(P, "center", U.center), _t.setValue(P, "modelViewMatrix", U.modelViewMatrix), _t.setValue(P, "normalMatrix", U.normalMatrix), _t.setValue(P, "modelMatrix", U.matrixWorld), H.isShaderMaterial || H.isRawShaderMaterial) {
            const jt = H.uniformsGroups;
            for (let Yi = 0, Uh = jt.length; Yi < Uh; Yi++) {
              const Gn = jt[Yi];
              I.update(Gn, qi), I.bind(Gn, qi);
            }
          }
          return qi;
        }
        function UT(S, O) {
          S.ambientLightColor.needsUpdate = O, S.lightProbe.needsUpdate = O, S.directionalLights.needsUpdate = O, S.directionalLightShadows.needsUpdate = O, S.pointLights.needsUpdate = O, S.pointLightShadows.needsUpdate = O, S.spotLights.needsUpdate = O, S.spotLightShadows.needsUpdate = O, S.rectAreaLights.needsUpdate = O, S.hemisphereLights.needsUpdate = O;
        }
        function OT(S) {
          return S.isMeshLambertMaterial || S.isMeshToonMaterial || S.isMeshPhongMaterial || S.isMeshStandardMaterial || S.isShadowMaterial || S.isShaderMaterial && S.lights === true;
        }
        this.getActiveCubeFace = function() {
          return T;
        }, this.getActiveMipmapLevel = function() {
          return w;
        }, this.getRenderTarget = function() {
          return R;
        }, this.setRenderTargetTextures = function(S, O, z) {
          de.get(S.texture).__webglTexture = O, de.get(S.depthTexture).__webglTexture = z;
          const H = de.get(S);
          H.__hasExternalTextures = true, H.__autoAllocateDepthBuffer = z === void 0, H.__autoAllocateDepthBuffer || xe.has("WEBGL_multisampled_render_to_texture") === true && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), H.__useRenderToTexture = false);
        }, this.setRenderTargetFramebuffer = function(S, O) {
          const z = de.get(S);
          z.__webglFramebuffer = O, z.__useDefaultFramebuffer = O === void 0;
        };
        const NT = P.createFramebuffer();
        this.setRenderTarget = function(S, O = 0, z = 0) {
          R = S, T = O, w = z;
          let H = true, U = null, Q = false, ge = false;
          if (S) {
            const ve = de.get(S);
            if (ve.__useDefaultFramebuffer !== void 0) oe.bindFramebuffer(P.FRAMEBUFFER, null), H = false;
            else if (ve.__webglFramebuffer === void 0) C.setupRenderTarget(S);
            else if (ve.__hasExternalTextures) C.rebindTextures(S, de.get(S.texture).__webglTexture, de.get(S.depthTexture).__webglTexture);
            else if (S.depthBuffer) {
              const Ue = S.depthTexture;
              if (ve.__boundDepthTexture !== Ue) {
                if (Ue !== null && de.has(Ue) && (S.width !== Ue.image.width || S.height !== Ue.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                C.setupDepthRenderbuffer(S);
              }
            }
            const Ee = S.texture;
            (Ee.isData3DTexture || Ee.isDataArrayTexture || Ee.isCompressedArrayTexture) && (ge = true);
            const Oe = de.get(S).__webglFramebuffer;
            S.isWebGLCubeRenderTarget ? (Array.isArray(Oe[O]) ? U = Oe[O][z] : U = Oe[O], Q = true) : S.samples > 0 && C.useMultisampledRTT(S) === false ? U = de.get(S).__webglMultisampledFramebuffer : Array.isArray(Oe) ? U = Oe[z] : U = Oe, L.copy(S.viewport), B.copy(S.scissor), F = S.scissorTest;
          } else L.copy(we).multiplyScalar(G).floor(), B.copy(Be).multiplyScalar(G).floor(), F = We;
          if (z !== 0 && (U = NT), oe.bindFramebuffer(P.FRAMEBUFFER, U) && H && oe.drawBuffers(S, U), oe.viewport(L), oe.scissor(B), oe.setScissorTest(F), Q) {
            const ve = de.get(S.texture);
            P.framebufferTexture2D(P.FRAMEBUFFER, P.COLOR_ATTACHMENT0, P.TEXTURE_CUBE_MAP_POSITIVE_X + O, ve.__webglTexture, z);
          } else if (ge) {
            const ve = de.get(S.texture), Ee = O;
            P.framebufferTextureLayer(P.FRAMEBUFFER, P.COLOR_ATTACHMENT0, ve.__webglTexture, z, Ee);
          } else if (S !== null && z !== 0) {
            const ve = de.get(S.texture);
            P.framebufferTexture2D(P.FRAMEBUFFER, P.COLOR_ATTACHMENT0, P.TEXTURE_2D, ve.__webglTexture, z);
          }
          E = -1;
        }, this.readRenderTargetPixels = function(S, O, z, H, U, Q, ge) {
          if (!(S && S.isWebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return;
          }
          let ve = de.get(S).__webglFramebuffer;
          if (S.isWebGLCubeRenderTarget && ge !== void 0 && (ve = ve[ge]), ve) {
            oe.bindFramebuffer(P.FRAMEBUFFER, ve);
            try {
              const Ee = S.texture, Oe = Ee.format, Ue = Ee.type;
              if (!Me.textureFormatReadable(Oe)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                return;
              }
              if (!Me.textureTypeReadable(Ue)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                return;
              }
              O >= 0 && O <= S.width - H && z >= 0 && z <= S.height - U && P.readPixels(O, z, H, U, Ve.convert(Oe), Ve.convert(Ue), Q);
            } finally {
              const Ee = R !== null ? de.get(R).__webglFramebuffer : null;
              oe.bindFramebuffer(P.FRAMEBUFFER, Ee);
            }
          }
        }, this.readRenderTargetPixelsAsync = async function(S, O, z, H, U, Q, ge) {
          if (!(S && S.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
          let ve = de.get(S).__webglFramebuffer;
          if (S.isWebGLCubeRenderTarget && ge !== void 0 && (ve = ve[ge]), ve) {
            const Ee = S.texture, Oe = Ee.format, Ue = Ee.type;
            if (!Me.textureFormatReadable(Oe)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
            if (!Me.textureTypeReadable(Ue)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
            if (O >= 0 && O <= S.width - H && z >= 0 && z <= S.height - U) {
              oe.bindFramebuffer(P.FRAMEBUFFER, ve);
              const Ne = P.createBuffer();
              P.bindBuffer(P.PIXEL_PACK_BUFFER, Ne), P.bufferData(P.PIXEL_PACK_BUFFER, Q.byteLength, P.STREAM_READ), P.readPixels(O, z, H, U, Ve.convert(Oe), Ve.convert(Ue), 0);
              const tt = R !== null ? de.get(R).__webglFramebuffer : null;
              oe.bindFramebuffer(P.FRAMEBUFFER, tt);
              const ut = P.fenceSync(P.SYNC_GPU_COMMANDS_COMPLETE, 0);
              return P.flush(), await i_(P, ut, 4), P.bindBuffer(P.PIXEL_PACK_BUFFER, Ne), P.getBufferSubData(P.PIXEL_PACK_BUFFER, 0, Q), P.deleteBuffer(Ne), P.deleteSync(ut), Q;
            } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
          }
        }, this.copyFramebufferToTexture = function(S, O = null, z = 0) {
          S.isTexture !== true && (ts("WebGLRenderer: copyFramebufferToTexture function signature has changed."), O = arguments[0] || null, S = arguments[1]);
          const H = Math.pow(2, -z), U = Math.floor(S.image.width * H), Q = Math.floor(S.image.height * H), ge = O !== null ? O.x : 0, ve = O !== null ? O.y : 0;
          C.setTexture2D(S, 0), P.copyTexSubImage2D(P.TEXTURE_2D, z, 0, 0, ge, ve, U, Q), oe.unbindTexture();
        };
        const FT = P.createFramebuffer(), BT = P.createFramebuffer();
        this.copyTextureToTexture = function(S, O, z = null, H = null, U = 0, Q = null) {
          S.isTexture !== true && (ts("WebGLRenderer: copyTextureToTexture function signature has changed."), H = arguments[0] || null, S = arguments[1], O = arguments[2], Q = arguments[3] || 0, z = null), Q === null && (U !== 0 ? (ts("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), Q = U, U = 0) : Q = 0);
          let ge, ve, Ee, Oe, Ue, Ne, tt, ut, kt;
          const ht = S.isCompressedTexture ? S.mipmaps[Q] : S.image;
          if (z !== null) ge = z.max.x - z.min.x, ve = z.max.y - z.min.y, Ee = z.isBox3 ? z.max.z - z.min.z : 1, Oe = z.min.x, Ue = z.min.y, Ne = z.isBox3 ? z.min.z : 0;
          else {
            const Ni = Math.pow(2, -U);
            ge = Math.floor(ht.width * Ni), ve = Math.floor(ht.height * Ni), S.isDataArrayTexture ? Ee = ht.depth : S.isData3DTexture ? Ee = Math.floor(ht.depth * Ni) : Ee = 1, Oe = 0, Ue = 0, Ne = 0;
          }
          H !== null ? (tt = H.x, ut = H.y, kt = H.z) : (tt = 0, ut = 0, kt = 0);
          const ft = Ve.convert(O.format), Ce = Ve.convert(O.type);
          let ui;
          O.isData3DTexture ? (C.setTexture3D(O, 0), ui = P.TEXTURE_3D) : O.isDataArrayTexture || O.isCompressedArrayTexture ? (C.setTexture2DArray(O, 0), ui = P.TEXTURE_2D_ARRAY) : (C.setTexture2D(O, 0), ui = P.TEXTURE_2D), P.pixelStorei(P.UNPACK_FLIP_Y_WEBGL, O.flipY), P.pixelStorei(P.UNPACK_PREMULTIPLY_ALPHA_WEBGL, O.premultiplyAlpha), P.pixelStorei(P.UNPACK_ALIGNMENT, O.unpackAlignment);
          const Vn = P.getParameter(P.UNPACK_ROW_LENGTH), qi = P.getParameter(P.UNPACK_IMAGE_HEIGHT), ia = P.getParameter(P.UNPACK_SKIP_PIXELS), Ai = P.getParameter(P.UNPACK_SKIP_ROWS), io = P.getParameter(P.UNPACK_SKIP_IMAGES);
          P.pixelStorei(P.UNPACK_ROW_LENGTH, ht.width), P.pixelStorei(P.UNPACK_IMAGE_HEIGHT, ht.height), P.pixelStorei(P.UNPACK_SKIP_PIXELS, Oe), P.pixelStorei(P.UNPACK_SKIP_ROWS, Ue), P.pixelStorei(P.UNPACK_SKIP_IMAGES, Ne);
          const _t = S.isDataArrayTexture || S.isData3DTexture, Oi = O.isDataArrayTexture || O.isData3DTexture;
          if (S.isDepthTexture) {
            const Ni = de.get(S), jt = de.get(O), Yi = de.get(Ni.__renderTarget), Uh = de.get(jt.__renderTarget);
            oe.bindFramebuffer(P.READ_FRAMEBUFFER, Yi.__webglFramebuffer), oe.bindFramebuffer(P.DRAW_FRAMEBUFFER, Uh.__webglFramebuffer);
            for (let Gn = 0; Gn < Ee; Gn++) _t && (P.framebufferTextureLayer(P.READ_FRAMEBUFFER, P.COLOR_ATTACHMENT0, de.get(S).__webglTexture, U, Ne + Gn), P.framebufferTextureLayer(P.DRAW_FRAMEBUFFER, P.COLOR_ATTACHMENT0, de.get(O).__webglTexture, Q, kt + Gn)), P.blitFramebuffer(Oe, Ue, ge, ve, tt, ut, ge, ve, P.DEPTH_BUFFER_BIT, P.NEAREST);
            oe.bindFramebuffer(P.READ_FRAMEBUFFER, null), oe.bindFramebuffer(P.DRAW_FRAMEBUFFER, null);
          } else if (U !== 0 || S.isRenderTargetTexture || de.has(S)) {
            const Ni = de.get(S), jt = de.get(O);
            oe.bindFramebuffer(P.READ_FRAMEBUFFER, FT), oe.bindFramebuffer(P.DRAW_FRAMEBUFFER, BT);
            for (let Yi = 0; Yi < Ee; Yi++) _t ? P.framebufferTextureLayer(P.READ_FRAMEBUFFER, P.COLOR_ATTACHMENT0, Ni.__webglTexture, U, Ne + Yi) : P.framebufferTexture2D(P.READ_FRAMEBUFFER, P.COLOR_ATTACHMENT0, P.TEXTURE_2D, Ni.__webglTexture, U), Oi ? P.framebufferTextureLayer(P.DRAW_FRAMEBUFFER, P.COLOR_ATTACHMENT0, jt.__webglTexture, Q, kt + Yi) : P.framebufferTexture2D(P.DRAW_FRAMEBUFFER, P.COLOR_ATTACHMENT0, P.TEXTURE_2D, jt.__webglTexture, Q), U !== 0 ? P.blitFramebuffer(Oe, Ue, ge, ve, tt, ut, ge, ve, P.COLOR_BUFFER_BIT, P.NEAREST) : Oi ? P.copyTexSubImage3D(ui, Q, tt, ut, kt + Yi, Oe, Ue, ge, ve) : P.copyTexSubImage2D(ui, Q, tt, ut, Oe, Ue, ge, ve);
            oe.bindFramebuffer(P.READ_FRAMEBUFFER, null), oe.bindFramebuffer(P.DRAW_FRAMEBUFFER, null);
          } else Oi ? S.isDataTexture || S.isData3DTexture ? P.texSubImage3D(ui, Q, tt, ut, kt, ge, ve, Ee, ft, Ce, ht.data) : O.isCompressedArrayTexture ? P.compressedTexSubImage3D(ui, Q, tt, ut, kt, ge, ve, Ee, ft, ht.data) : P.texSubImage3D(ui, Q, tt, ut, kt, ge, ve, Ee, ft, Ce, ht) : S.isDataTexture ? P.texSubImage2D(P.TEXTURE_2D, Q, tt, ut, ge, ve, ft, Ce, ht.data) : S.isCompressedTexture ? P.compressedTexSubImage2D(P.TEXTURE_2D, Q, tt, ut, ht.width, ht.height, ft, ht.data) : P.texSubImage2D(P.TEXTURE_2D, Q, tt, ut, ge, ve, ft, Ce, ht);
          P.pixelStorei(P.UNPACK_ROW_LENGTH, Vn), P.pixelStorei(P.UNPACK_IMAGE_HEIGHT, qi), P.pixelStorei(P.UNPACK_SKIP_PIXELS, ia), P.pixelStorei(P.UNPACK_SKIP_ROWS, Ai), P.pixelStorei(P.UNPACK_SKIP_IMAGES, io), Q === 0 && O.generateMipmaps && P.generateMipmap(ui), oe.unbindTexture();
        }, this.copyTextureToTexture3D = function(S, O, z = null, H = null, U = 0) {
          return S.isTexture !== true && (ts("WebGLRenderer: copyTextureToTexture3D function signature has changed."), z = arguments[0] || null, H = arguments[1] || null, S = arguments[2], O = arguments[3], U = arguments[4] || 0), ts('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(S, O, z, H, U);
        }, this.initRenderTarget = function(S) {
          de.get(S).__webglFramebuffer === void 0 && C.setupRenderTarget(S);
        }, this.initTexture = function(S) {
          S.isCubeTexture ? C.setTextureCube(S, 0) : S.isData3DTexture ? C.setTexture3D(S, 0) : S.isDataArrayTexture || S.isCompressedArrayTexture ? C.setTexture2DArray(S, 0) : C.setTexture2D(S, 0), oe.unbindTexture();
        }, this.resetState = function() {
          T = 0, w = 0, R = null, oe.reset(), pt.reset();
        }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
          detail: this
        }));
      }
      get coordinateSystem() {
        return dr;
      }
      get outputColorSpace() {
        return this._outputColorSpace;
      }
      set outputColorSpace(e) {
        this._outputColorSpace = e;
        const t = this.getContext();
        t.drawingBufferColorspace = Ke._getDrawingBufferColorSpace(e), t.unpackColorSpace = Ke._getUnpackColorSpace();
      }
    }
    function qp(r, e) {
      if (e === Ag) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), r;
      if (e === fc || e === $h) {
        let t = r.getIndex();
        if (t === null) {
          const a = [], o = r.getAttribute("position");
          if (o !== void 0) {
            for (let l = 0; l < o.count; l++) a.push(l);
            r.setIndex(a), t = r.getIndex();
          } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), r;
        }
        const i = t.count - 2, n = [];
        if (e === fc) for (let a = 1; a <= i; a++) n.push(t.getX(0)), n.push(t.getX(a)), n.push(t.getX(a + 1));
        else for (let a = 0; a < i; a++) a % 2 === 0 ? (n.push(t.getX(a)), n.push(t.getX(a + 1)), n.push(t.getX(a + 2))) : (n.push(t.getX(a + 2)), n.push(t.getX(a + 1)), n.push(t.getX(a)));
        n.length / 3 !== i && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        const s = r.clone();
        return s.setIndex(n), s.clearGroups(), s;
      } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), r;
    }
    class Ib extends fn {
      constructor(e) {
        super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
          return new Bb(t);
        }), this.register(function(t) {
          return new zb(t);
        }), this.register(function(t) {
          return new Yb(t);
        }), this.register(function(t) {
          return new Kb(t);
        }), this.register(function(t) {
          return new Zb(t);
        }), this.register(function(t) {
          return new Hb(t);
        }), this.register(function(t) {
          return new Vb(t);
        }), this.register(function(t) {
          return new Gb(t);
        }), this.register(function(t) {
          return new Wb(t);
        }), this.register(function(t) {
          return new Fb(t);
        }), this.register(function(t) {
          return new Xb(t);
        }), this.register(function(t) {
          return new kb(t);
        }), this.register(function(t) {
          return new qb(t);
        }), this.register(function(t) {
          return new jb(t);
        }), this.register(function(t) {
          return new Ob(t);
        }), this.register(function(t) {
          return new Jb(t);
        }), this.register(function(t) {
          return new $b(t);
        });
      }
      load(e, t, i, n) {
        const s = this;
        let a;
        if (this.resourcePath !== "") a = this.resourcePath;
        else if (this.path !== "") {
          const c = Ra.extractUrlBase(e);
          a = Ra.resolveURL(c, this.path);
        } else a = Ra.extractUrlBase(e);
        this.manager.itemStart(e);
        const o = function(c) {
          n ? n(c) : console.error(c), s.manager.itemError(e), s.manager.itemEnd(e);
        }, l = new au(this.manager);
        l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(c) {
          try {
            s.parse(c, a, function(u) {
              t(u), s.manager.itemEnd(e);
            }, o);
          } catch (u) {
            o(u);
          }
        }, i, o);
      }
      setDRACOLoader(e) {
        return this.dracoLoader = e, this;
      }
      setKTX2Loader(e) {
        return this.ktx2Loader = e, this;
      }
      setMeshoptDecoder(e) {
        return this.meshoptDecoder = e, this;
      }
      register(e) {
        return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this;
      }
      unregister(e) {
        return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this;
      }
      parse(e, t, i, n) {
        let s;
        const a = {}, o = {}, l = new TextDecoder();
        if (typeof e == "string") s = JSON.parse(e);
        else if (e instanceof ArrayBuffer) if (l.decode(new Uint8Array(e, 0, 4)) === Yp) {
          try {
            a[Xe.KHR_BINARY_GLTF] = new Qb(e);
          } catch (u) {
            n && n(u);
            return;
          }
          s = JSON.parse(a[Xe.KHR_BINARY_GLTF].content);
        } else s = JSON.parse(l.decode(e));
        else s = e;
        if (s.asset === void 0 || s.asset.version[0] < 2) {
          n && n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
          return;
        }
        const c = new dS(s, {
          path: t || this.resourcePath || "",
          crossOrigin: this.crossOrigin,
          requestHeader: this.requestHeader,
          manager: this.manager,
          ktx2Loader: this.ktx2Loader,
          meshoptDecoder: this.meshoptDecoder
        });
        c.fileLoader.setRequestHeader(this.requestHeader);
        for (let u = 0; u < this.pluginCallbacks.length; u++) {
          const h = this.pluginCallbacks[u](c);
          h.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), o[h.name] = h, a[h.name] = true;
        }
        if (s.extensionsUsed) for (let u = 0; u < s.extensionsUsed.length; ++u) {
          const h = s.extensionsUsed[u], d = s.extensionsRequired || [];
          switch (h) {
            case Xe.KHR_MATERIALS_UNLIT:
              a[h] = new Nb();
              break;
            case Xe.KHR_DRACO_MESH_COMPRESSION:
              a[h] = new eS(s, this.dracoLoader);
              break;
            case Xe.KHR_TEXTURE_TRANSFORM:
              a[h] = new tS();
              break;
            case Xe.KHR_MESH_QUANTIZATION:
              a[h] = new iS();
              break;
            default:
              d.indexOf(h) >= 0 && o[h] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".');
          }
        }
        c.setExtensions(a), c.setPlugins(o), c.parse(i, n);
      }
      parseAsync(e, t) {
        const i = this;
        return new Promise(function(n, s) {
          i.parse(e, t, n, s);
        });
      }
    }
    function Ub() {
      let r = {};
      return {
        get: function(e) {
          return r[e];
        },
        add: function(e, t) {
          r[e] = t;
        },
        remove: function(e) {
          delete r[e];
        },
        removeAll: function() {
          r = {};
        }
      };
    }
    const Xe = {
      KHR_BINARY_GLTF: "KHR_binary_glTF",
      KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
      KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
      KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
      KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
      KHR_MATERIALS_IOR: "KHR_materials_ior",
      KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
      KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
      KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
      KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
      KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
      KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
      KHR_MATERIALS_VOLUME: "KHR_materials_volume",
      KHR_TEXTURE_BASISU: "KHR_texture_basisu",
      KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
      KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
      KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
      EXT_MATERIALS_BUMP: "EXT_materials_bump",
      EXT_TEXTURE_WEBP: "EXT_texture_webp",
      EXT_TEXTURE_AVIF: "EXT_texture_avif",
      EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
      EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
    };
    class Ob {
      constructor(e) {
        this.parser = e, this.name = Xe.KHR_LIGHTS_PUNCTUAL, this.cache = {
          refs: {},
          uses: {}
        };
      }
      _markDefs() {
        const e = this.parser, t = this.parser.json.nodes || [];
        for (let i = 0, n = t.length; i < n; i++) {
          const s = t[i];
          s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light);
        }
      }
      _loadLight(e) {
        const t = this.parser, i = "light:" + e;
        let n = t.cache.get(i);
        if (n) return n;
        const s = t.json, a = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
        let o;
        const l = new Ae(16777215);
        a.color !== void 0 && l.setRGB(a.color[0], a.color[1], a.color[2], ni);
        const c = a.range !== void 0 ? a.range : 0;
        switch (a.type) {
          case "directional":
            o = new dp(l), o.target.position.set(0, 0, -1), o.add(o.target);
            break;
          case "point":
            o = new uu(l), o.distance = c;
            break;
          case "spot":
            o = new Ov(l), o.distance = c, a.spot = a.spot || {}, a.spot.innerConeAngle = a.spot.innerConeAngle !== void 0 ? a.spot.innerConeAngle : 0, a.spot.outerConeAngle = a.spot.outerConeAngle !== void 0 ? a.spot.outerConeAngle : Math.PI / 4, o.angle = a.spot.outerConeAngle, o.penumbra = 1 - a.spot.innerConeAngle / a.spot.outerConeAngle, o.target.position.set(0, 0, -1), o.add(o.target);
            break;
          default:
            throw new Error("THREE.GLTFLoader: Unexpected light type: " + a.type);
        }
        return o.position.set(0, 0, 0), Mr(o, a), a.intensity !== void 0 && (o.intensity = a.intensity), o.name = t.createUniqueName(a.name || "light_" + e), n = Promise.resolve(o), t.cache.add(i, n), n;
      }
      getDependency(e, t) {
        if (e === "light") return this._loadLight(t);
      }
      createNodeAttachment(e) {
        const t = this, i = this.parser, n = i.json.nodes[e], s = (n.extensions && n.extensions[this.name] || {}).light;
        return s === void 0 ? null : this._loadLight(s).then(function(a) {
          return i._getNodeRef(t.cache, s, a);
        });
      }
    }
    class Nb {
      constructor() {
        this.name = Xe.KHR_MATERIALS_UNLIT;
      }
      getMaterialType() {
        return $i;
      }
      extendParams(e, t, i) {
        const n = [];
        e.color = new Ae(1, 1, 1), e.opacity = 1;
        const s = t.pbrMetallicRoughness;
        if (s) {
          if (Array.isArray(s.baseColorFactor)) {
            const a = s.baseColorFactor;
            e.color.setRGB(a[0], a[1], a[2], ni), e.opacity = a[3];
          }
          s.baseColorTexture !== void 0 && n.push(i.assignTexture(e, "map", s.baseColorTexture, Gt));
        }
        return Promise.all(n);
      }
    }
    class Fb {
      constructor(e) {
        this.parser = e, this.name = Xe.KHR_MATERIALS_EMISSIVE_STRENGTH;
      }
      extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const n = i.extensions[this.name].emissiveStrength;
        return n !== void 0 && (t.emissiveIntensity = n), Promise.resolve();
      }
    }
    class Bb {
      constructor(e) {
        this.parser = e, this.name = Xe.KHR_MATERIALS_CLEARCOAT;
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return !t.extensions || !t.extensions[this.name] ? null : er;
      }
      extendMaterialParams(e, t) {
        const i = this.parser, n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const s = [], a = n.extensions[this.name];
        if (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor), a.clearcoatTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatMap", a.clearcoatTexture)), a.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = a.clearcoatRoughnessFactor), a.clearcoatRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "clearcoatRoughnessMap", a.clearcoatRoughnessTexture)), a.clearcoatNormalTexture !== void 0 && (s.push(i.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)), a.clearcoatNormalTexture.scale !== void 0)) {
          const o = a.clearcoatNormalTexture.scale;
          t.clearcoatNormalScale = new ee(o, o);
        }
        return Promise.all(s);
      }
    }
    class zb {
      constructor(e) {
        this.parser = e, this.name = Xe.KHR_MATERIALS_DISPERSION;
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return !t.extensions || !t.extensions[this.name] ? null : er;
      }
      extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const n = i.extensions[this.name];
        return t.dispersion = n.dispersion !== void 0 ? n.dispersion : 0, Promise.resolve();
      }
    }
    class kb {
      constructor(e) {
        this.parser = e, this.name = Xe.KHR_MATERIALS_IRIDESCENCE;
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return !t.extensions || !t.extensions[this.name] ? null : er;
      }
      extendMaterialParams(e, t) {
        const i = this.parser, n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const s = [], a = n.extensions[this.name];
        return a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor), a.iridescenceTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceMap", a.iridescenceTexture)), a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [
          100,
          400
        ]), a.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum), a.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum), a.iridescenceThicknessTexture !== void 0 && s.push(i.assignTexture(t, "iridescenceThicknessMap", a.iridescenceThicknessTexture)), Promise.all(s);
      }
    }
    class Hb {
      constructor(e) {
        this.parser = e, this.name = Xe.KHR_MATERIALS_SHEEN;
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return !t.extensions || !t.extensions[this.name] ? null : er;
      }
      extendMaterialParams(e, t) {
        const i = this.parser, n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const s = [];
        t.sheenColor = new Ae(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
        const a = n.extensions[this.name];
        if (a.sheenColorFactor !== void 0) {
          const o = a.sheenColorFactor;
          t.sheenColor.setRGB(o[0], o[1], o[2], ni);
        }
        return a.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = a.sheenRoughnessFactor), a.sheenColorTexture !== void 0 && s.push(i.assignTexture(t, "sheenColorMap", a.sheenColorTexture, Gt)), a.sheenRoughnessTexture !== void 0 && s.push(i.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)), Promise.all(s);
      }
    }
    class Vb {
      constructor(e) {
        this.parser = e, this.name = Xe.KHR_MATERIALS_TRANSMISSION;
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return !t.extensions || !t.extensions[this.name] ? null : er;
      }
      extendMaterialParams(e, t) {
        const i = this.parser, n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const s = [], a = n.extensions[this.name];
        return a.transmissionFactor !== void 0 && (t.transmission = a.transmissionFactor), a.transmissionTexture !== void 0 && s.push(i.assignTexture(t, "transmissionMap", a.transmissionTexture)), Promise.all(s);
      }
    }
    class Gb {
      constructor(e) {
        this.parser = e, this.name = Xe.KHR_MATERIALS_VOLUME;
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return !t.extensions || !t.extensions[this.name] ? null : er;
      }
      extendMaterialParams(e, t) {
        const i = this.parser, n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const s = [], a = n.extensions[this.name];
        t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0, a.thicknessTexture !== void 0 && s.push(i.assignTexture(t, "thicknessMap", a.thicknessTexture)), t.attenuationDistance = a.attenuationDistance || 1 / 0;
        const o = a.attenuationColor || [
          1,
          1,
          1
        ];
        return t.attenuationColor = new Ae().setRGB(o[0], o[1], o[2], ni), Promise.all(s);
      }
    }
    class Wb {
      constructor(e) {
        this.parser = e, this.name = Xe.KHR_MATERIALS_IOR;
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return !t.extensions || !t.extensions[this.name] ? null : er;
      }
      extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const n = i.extensions[this.name];
        return t.ior = n.ior !== void 0 ? n.ior : 1.5, Promise.resolve();
      }
    }
    class Xb {
      constructor(e) {
        this.parser = e, this.name = Xe.KHR_MATERIALS_SPECULAR;
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return !t.extensions || !t.extensions[this.name] ? null : er;
      }
      extendMaterialParams(e, t) {
        const i = this.parser, n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const s = [], a = n.extensions[this.name];
        t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1, a.specularTexture !== void 0 && s.push(i.assignTexture(t, "specularIntensityMap", a.specularTexture));
        const o = a.specularColorFactor || [
          1,
          1,
          1
        ];
        return t.specularColor = new Ae().setRGB(o[0], o[1], o[2], ni), a.specularColorTexture !== void 0 && s.push(i.assignTexture(t, "specularColorMap", a.specularColorTexture, Gt)), Promise.all(s);
      }
    }
    class jb {
      constructor(e) {
        this.parser = e, this.name = Xe.EXT_MATERIALS_BUMP;
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return !t.extensions || !t.extensions[this.name] ? null : er;
      }
      extendMaterialParams(e, t) {
        const i = this.parser, n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const s = [], a = n.extensions[this.name];
        return t.bumpScale = a.bumpFactor !== void 0 ? a.bumpFactor : 1, a.bumpTexture !== void 0 && s.push(i.assignTexture(t, "bumpMap", a.bumpTexture)), Promise.all(s);
      }
    }
    class qb {
      constructor(e) {
        this.parser = e, this.name = Xe.KHR_MATERIALS_ANISOTROPY;
      }
      getMaterialType(e) {
        const t = this.parser.json.materials[e];
        return !t.extensions || !t.extensions[this.name] ? null : er;
      }
      extendMaterialParams(e, t) {
        const i = this.parser, n = i.json.materials[e];
        if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
        const s = [], a = n.extensions[this.name];
        return a.anisotropyStrength !== void 0 && (t.anisotropy = a.anisotropyStrength), a.anisotropyRotation !== void 0 && (t.anisotropyRotation = a.anisotropyRotation), a.anisotropyTexture !== void 0 && s.push(i.assignTexture(t, "anisotropyMap", a.anisotropyTexture)), Promise.all(s);
      }
    }
    class Yb {
      constructor(e) {
        this.parser = e, this.name = Xe.KHR_TEXTURE_BASISU;
      }
      loadTexture(e) {
        const t = this.parser, i = t.json, n = i.textures[e];
        if (!n.extensions || !n.extensions[this.name]) return null;
        const s = n.extensions[this.name], a = t.options.ktx2Loader;
        if (!a) {
          if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
          return null;
        }
        return t.loadTextureImage(e, s.source, a);
      }
    }
    class Kb {
      constructor(e) {
        this.parser = e, this.name = Xe.EXT_TEXTURE_WEBP, this.isSupported = null;
      }
      loadTexture(e) {
        const t = this.name, i = this.parser, n = i.json, s = n.textures[e];
        if (!s.extensions || !s.extensions[t]) return null;
        const a = s.extensions[t], o = n.images[a.source];
        let l = i.textureLoader;
        if (o.uri) {
          const c = i.options.manager.getHandler(o.uri);
          c !== null && (l = c);
        }
        return this.detectSupport().then(function(c) {
          if (c) return i.loadTextureImage(e, a.source, l);
          if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
          return i.loadTexture(e);
        });
      }
      detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(e) {
          const t = new Image();
          t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
            e(t.height === 1);
          };
        })), this.isSupported;
      }
    }
    class Zb {
      constructor(e) {
        this.parser = e, this.name = Xe.EXT_TEXTURE_AVIF, this.isSupported = null;
      }
      loadTexture(e) {
        const t = this.name, i = this.parser, n = i.json, s = n.textures[e];
        if (!s.extensions || !s.extensions[t]) return null;
        const a = s.extensions[t], o = n.images[a.source];
        let l = i.textureLoader;
        if (o.uri) {
          const c = i.options.manager.getHandler(o.uri);
          c !== null && (l = c);
        }
        return this.detectSupport().then(function(c) {
          if (c) return i.loadTextureImage(e, a.source, l);
          if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
          return i.loadTexture(e);
        });
      }
      detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(e) {
          const t = new Image();
          t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
            e(t.height === 1);
          };
        })), this.isSupported;
      }
    }
    class Jb {
      constructor(e) {
        this.name = Xe.EXT_MESHOPT_COMPRESSION, this.parser = e;
      }
      loadBufferView(e) {
        const t = this.parser.json, i = t.bufferViews[e];
        if (i.extensions && i.extensions[this.name]) {
          const n = i.extensions[this.name], s = this.parser.getDependency("buffer", n.buffer), a = this.parser.options.meshoptDecoder;
          if (!a || !a.supported) {
            if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
            return null;
          }
          return s.then(function(o) {
            const l = n.byteOffset || 0, c = n.byteLength || 0, u = n.count, h = n.byteStride, d = new Uint8Array(o, l, c);
            return a.decodeGltfBufferAsync ? a.decodeGltfBufferAsync(u, h, d, n.mode, n.filter).then(function(p) {
              return p.buffer;
            }) : a.ready.then(function() {
              const p = new ArrayBuffer(u * h);
              return a.decodeGltfBuffer(new Uint8Array(p), u, h, d, n.mode, n.filter), p;
            });
          });
        } else return null;
      }
    }
    class $b {
      constructor(e) {
        this.name = Xe.EXT_MESH_GPU_INSTANCING, this.parser = e;
      }
      createNodeMesh(e) {
        const t = this.parser.json, i = t.nodes[e];
        if (!i.extensions || !i.extensions[this.name] || i.mesh === void 0) return null;
        const n = t.meshes[i.mesh];
        for (const l of n.primitives) if (l.mode !== Li.TRIANGLES && l.mode !== Li.TRIANGLE_STRIP && l.mode !== Li.TRIANGLE_FAN && l.mode !== void 0) return null;
        const s = i.extensions[this.name].attributes, a = [], o = {};
        for (const l in s) a.push(this.parser.getDependency("accessor", s[l]).then((c) => (o[l] = c, o[l])));
        return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then((l) => {
          const c = l.pop(), u = c.isGroup ? c.children : [
            c
          ], h = l[0].count, d = [];
          for (const p of u) {
            const f = new Fe(), _ = new D(), g = new Nr(), m = new D(1, 1, 1), y = new U_(p.geometry, p.material, h);
            for (let x = 0; x < h; x++) o.TRANSLATION && _.fromBufferAttribute(o.TRANSLATION, x), o.ROTATION && g.fromBufferAttribute(o.ROTATION, x), o.SCALE && m.fromBufferAttribute(o.SCALE, x), y.setMatrixAt(x, f.compose(_, g, m));
            for (const x in o) if (x === "_COLOR_0") {
              const v = o[x];
              y.instanceColor = new Vc(v.array, v.itemSize, v.normalized);
            } else x !== "TRANSLATION" && x !== "ROTATION" && x !== "SCALE" && p.geometry.setAttribute(x, o[x]);
            xt.prototype.copy.call(y, p), this.parser.assignFinalMaterial(y), d.push(y);
          }
          return c.isGroup ? (c.clear(), c.add(...d), c) : d[0];
        }));
      }
    }
    const Yp = "glTF", Pa = 12, Kp = {
      JSON: 1313821514,
      BIN: 5130562
    };
    class Qb {
      constructor(e) {
        this.name = Xe.KHR_BINARY_GLTF, this.content = null, this.body = null;
        const t = new DataView(e, 0, Pa), i = new TextDecoder();
        if (this.header = {
          magic: i.decode(new Uint8Array(e.slice(0, 4))),
          version: t.getUint32(4, true),
          length: t.getUint32(8, true)
        }, this.header.magic !== Yp) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const n = this.header.length - Pa, s = new DataView(e, Pa);
        let a = 0;
        for (; a < n; ) {
          const o = s.getUint32(a, true);
          a += 4;
          const l = s.getUint32(a, true);
          if (a += 4, l === Kp.JSON) {
            const c = new Uint8Array(e, Pa + a, o);
            this.content = i.decode(c);
          } else if (l === Kp.BIN) {
            const c = Pa + a;
            this.body = e.slice(c, c + o);
          }
          a += o;
        }
        if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.");
      }
    }
    class eS {
      constructor(e, t) {
        if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = Xe.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload();
      }
      decodePrimitive(e, t) {
        const i = this.json, n = this.dracoLoader, s = e.extensions[this.name].bufferView, a = e.extensions[this.name].attributes, o = {}, l = {}, c = {};
        for (const u in a) {
          const h = Su[u] || u.toLowerCase();
          o[h] = a[u];
        }
        for (const u in e.attributes) {
          const h = Su[u] || u.toLowerCase();
          if (a[u] !== void 0) {
            const d = i.accessors[e.attributes[u]], p = Rs[d.componentType];
            c[h] = p.name, l[h] = d.normalized === true;
          }
        }
        return t.getDependency("bufferView", s).then(function(u) {
          return new Promise(function(h, d) {
            n.decodeDracoFile(u, function(p) {
              for (const f in p.attributes) {
                const _ = p.attributes[f], g = l[f];
                g !== void 0 && (_.normalized = g);
              }
              h(p);
            }, o, c, ni, d);
          });
        });
      }
    }
    class tS {
      constructor() {
        this.name = Xe.KHR_TEXTURE_TRANSFORM;
      }
      extendTexture(e, t) {
        return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = true), e;
      }
    }
    class iS {
      constructor() {
        this.name = Xe.KHR_MESH_QUANTIZATION;
      }
    }
    class Zp extends wa {
      constructor(e, t, i, n) {
        super(e, t, i, n);
      }
      copySampleValue_(e) {
        const t = this.resultBuffer, i = this.sampleValues, n = this.valueSize, s = e * n * 3 + n;
        for (let a = 0; a !== n; a++) t[a] = i[s + a];
        return t;
      }
      interpolate_(e, t, i, n) {
        const s = this.resultBuffer, a = this.sampleValues, o = this.valueSize, l = o * 2, c = o * 3, u = n - t, h = (i - t) / u, d = h * h, p = d * h, f = e * c, _ = f - c, g = -2 * p + 3 * d, m = p - d, y = 1 - g, x = m - d + h;
        for (let v = 0; v !== o; v++) {
          const A = a[_ + v + o], T = a[_ + v + l] * u, w = a[f + v + o], R = a[f + v] * u;
          s[v] = y * A + x * T + g * w + m * R;
        }
        return s;
      }
    }
    const rS = new Nr();
    class nS extends Zp {
      interpolate_(e, t, i, n) {
        const s = super.interpolate_(e, t, i, n);
        return rS.fromArray(s).normalize().toArray(s), s;
      }
    }
    const Li = {
      POINTS: 0,
      LINES: 1,
      LINE_LOOP: 2,
      LINE_STRIP: 3,
      TRIANGLES: 4,
      TRIANGLE_STRIP: 5,
      TRIANGLE_FAN: 6
    }, Rs = {
      5120: Int8Array,
      5121: Uint8Array,
      5122: Int16Array,
      5123: Uint16Array,
      5125: Uint32Array,
      5126: Float32Array
    }, Jp = {
      9728: ri,
      9729: _i,
      9984: zh,
      9985: ao,
      9986: sa,
      9987: cr
    }, $p = {
      33071: Ur,
      33648: so,
      10497: Yn
    }, bu = {
      SCALAR: 1,
      VEC2: 2,
      VEC3: 3,
      VEC4: 4,
      MAT2: 4,
      MAT3: 9,
      MAT4: 16
    }, Su = {
      POSITION: "position",
      NORMAL: "normal",
      TANGENT: "tangent",
      TEXCOORD_0: "uv",
      TEXCOORD_1: "uv1",
      TEXCOORD_2: "uv2",
      TEXCOORD_3: "uv3",
      COLOR_0: "color",
      WEIGHTS_0: "skinWeight",
      JOINTS_0: "skinIndex"
    }, Xr = {
      scale: "scale",
      translation: "position",
      rotation: "quaternion",
      weights: "morphTargetInfluences"
    }, sS = {
      CUBICSPLINE: void 0,
      LINEAR: la,
      STEP: oa
    }, Eu = {
      OPAQUE: "OPAQUE",
      MASK: "MASK",
      BLEND: "BLEND"
    };
    function aS(r) {
      return r.DefaultMaterial === void 0 && (r.DefaultMaterial = new xs({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: false,
        depthTest: true,
        side: Ot
      })), r.DefaultMaterial;
    }
    function yn(r, e, t) {
      for (const i in t.extensions) r[i] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[i] = t.extensions[i]);
    }
    function Mr(r, e) {
      e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(r.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras));
    }
    function oS(r, e, t) {
      let i = false, n = false, s = false;
      for (let c = 0, u = e.length; c < u; c++) {
        const h = e[c];
        if (h.POSITION !== void 0 && (i = true), h.NORMAL !== void 0 && (n = true), h.COLOR_0 !== void 0 && (s = true), i && n && s) break;
      }
      if (!i && !n && !s) return Promise.resolve(r);
      const a = [], o = [], l = [];
      for (let c = 0, u = e.length; c < u; c++) {
        const h = e[c];
        if (i) {
          const d = h.POSITION !== void 0 ? t.getDependency("accessor", h.POSITION) : r.attributes.position;
          a.push(d);
        }
        if (n) {
          const d = h.NORMAL !== void 0 ? t.getDependency("accessor", h.NORMAL) : r.attributes.normal;
          o.push(d);
        }
        if (s) {
          const d = h.COLOR_0 !== void 0 ? t.getDependency("accessor", h.COLOR_0) : r.attributes.color;
          l.push(d);
        }
      }
      return Promise.all([
        Promise.all(a),
        Promise.all(o),
        Promise.all(l)
      ]).then(function(c) {
        const u = c[0], h = c[1], d = c[2];
        return i && (r.morphAttributes.position = u), n && (r.morphAttributes.normal = h), s && (r.morphAttributes.color = d), r.morphTargetsRelative = true, r;
      });
    }
    function lS(r, e) {
      if (r.updateMorphTargets(), e.weights !== void 0) for (let t = 0, i = e.weights.length; t < i; t++) r.morphTargetInfluences[t] = e.weights[t];
      if (e.extras && Array.isArray(e.extras.targetNames)) {
        const t = e.extras.targetNames;
        if (r.morphTargetInfluences.length === t.length) {
          r.morphTargetDictionary = {};
          for (let i = 0, n = t.length; i < n; i++) r.morphTargetDictionary[t[i]] = i;
        } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
      }
    }
    function cS(r) {
      let e;
      const t = r.extensions && r.extensions[Xe.KHR_DRACO_MESH_COMPRESSION];
      if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + Tu(t.attributes) : e = r.indices + ":" + Tu(r.attributes) + ":" + r.mode, r.targets !== void 0) for (let i = 0, n = r.targets.length; i < n; i++) e += ":" + Tu(r.targets[i]);
      return e;
    }
    function Tu(r) {
      let e = "";
      const t = Object.keys(r).sort();
      for (let i = 0, n = t.length; i < n; i++) e += t[i] + ":" + r[t[i]] + ";";
      return e;
    }
    function wu(r) {
      switch (r) {
        case Int8Array:
          return 1 / 127;
        case Uint8Array:
          return 1 / 255;
        case Int16Array:
          return 1 / 32767;
        case Uint16Array:
          return 1 / 65535;
        default:
          throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
      }
    }
    function uS(r) {
      return r.search(/\.jpe?g($|\?)/i) > 0 || r.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : r.search(/\.webp($|\?)/i) > 0 || r.search(/^data\:image\/webp/) === 0 ? "image/webp" : r.search(/\.ktx2($|\?)/i) > 0 || r.search(/^data\:image\/ktx2/) === 0 ? "image/ktx2" : "image/png";
    }
    const hS = new Fe();
    class dS {
      constructor(e = {}, t = {}) {
        this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new Ub(), this.associations = /* @__PURE__ */ new Map(), this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
          refs: {},
          uses: {}
        }, this.cameraCache = {
          refs: {},
          uses: {}
        }, this.lightCache = {
          refs: {},
          uses: {}
        }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
        let i = false, n = -1, s = false, a = -1;
        if (typeof navigator < "u") {
          const o = navigator.userAgent;
          i = /^((?!chrome|android).)*safari/i.test(o) === true;
          const l = o.match(/Version\/(\d+)/);
          n = i && l ? parseInt(l[1], 10) : -1, s = o.indexOf("Firefox") > -1, a = s ? o.match(/Firefox\/([0-9]+)\./)[1] : -1;
        }
        typeof createImageBitmap > "u" || i && n < 17 || s && a < 98 ? this.textureLoader = new Iv(this.options.manager) : this.textureLoader = new Bv(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new au(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(true);
      }
      setExtensions(e) {
        this.extensions = e;
      }
      setPlugins(e) {
        this.plugins = e;
      }
      parse(e, t) {
        const i = this, n = this.json, s = this.extensions;
        this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(a) {
          return a._markDefs && a._markDefs();
        }), Promise.all(this._invokeAll(function(a) {
          return a.beforeRoot && a.beforeRoot();
        })).then(function() {
          return Promise.all([
            i.getDependencies("scene"),
            i.getDependencies("animation"),
            i.getDependencies("camera")
          ]);
        }).then(function(a) {
          const o = {
            scene: a[0][n.scene || 0],
            scenes: a[0],
            animations: a[1],
            cameras: a[2],
            asset: n.asset,
            parser: i,
            userData: {}
          };
          return yn(s, o, n), Mr(o, n), Promise.all(i._invokeAll(function(l) {
            return l.afterRoot && l.afterRoot(o);
          })).then(function() {
            for (const l of o.scenes) l.updateMatrixWorld();
            e(o);
          });
        }).catch(t);
      }
      _markDefs() {
        const e = this.json.nodes || [], t = this.json.skins || [], i = this.json.meshes || [];
        for (let n = 0, s = t.length; n < s; n++) {
          const a = t[n].joints;
          for (let o = 0, l = a.length; o < l; o++) e[a[o]].isBone = true;
        }
        for (let n = 0, s = e.length; n < s; n++) {
          const a = e[n];
          a.mesh !== void 0 && (this._addNodeRef(this.meshCache, a.mesh), a.skin !== void 0 && (i[a.mesh].isSkinnedMesh = true)), a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
        }
      }
      _addNodeRef(e, t) {
        t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
      }
      _getNodeRef(e, t, i) {
        if (e.refs[t] <= 1) return i;
        const n = i.clone(), s = (a, o) => {
          const l = this.associations.get(a);
          l != null && this.associations.set(o, l);
          for (const [c, u] of a.children.entries()) s(u, o.children[c]);
        };
        return s(i, n), n.name += "_instance_" + e.uses[t]++, n;
      }
      _invokeOne(e) {
        const t = Object.values(this.plugins);
        t.push(this);
        for (let i = 0; i < t.length; i++) {
          const n = e(t[i]);
          if (n) return n;
        }
        return null;
      }
      _invokeAll(e) {
        const t = Object.values(this.plugins);
        t.unshift(this);
        const i = [];
        for (let n = 0; n < t.length; n++) {
          const s = e(t[n]);
          s && i.push(s);
        }
        return i;
      }
      getDependency(e, t) {
        const i = e + ":" + t;
        let n = this.cache.get(i);
        if (!n) {
          switch (e) {
            case "scene":
              n = this.loadScene(t);
              break;
            case "node":
              n = this._invokeOne(function(s) {
                return s.loadNode && s.loadNode(t);
              });
              break;
            case "mesh":
              n = this._invokeOne(function(s) {
                return s.loadMesh && s.loadMesh(t);
              });
              break;
            case "accessor":
              n = this.loadAccessor(t);
              break;
            case "bufferView":
              n = this._invokeOne(function(s) {
                return s.loadBufferView && s.loadBufferView(t);
              });
              break;
            case "buffer":
              n = this.loadBuffer(t);
              break;
            case "material":
              n = this._invokeOne(function(s) {
                return s.loadMaterial && s.loadMaterial(t);
              });
              break;
            case "texture":
              n = this._invokeOne(function(s) {
                return s.loadTexture && s.loadTexture(t);
              });
              break;
            case "skin":
              n = this.loadSkin(t);
              break;
            case "animation":
              n = this._invokeOne(function(s) {
                return s.loadAnimation && s.loadAnimation(t);
              });
              break;
            case "camera":
              n = this.loadCamera(t);
              break;
            default:
              if (n = this._invokeOne(function(s) {
                return s != this && s.getDependency && s.getDependency(e, t);
              }), !n) throw new Error("Unknown type: " + e);
              break;
          }
          this.cache.add(i, n);
        }
        return n;
      }
      getDependencies(e) {
        let t = this.cache.get(e);
        if (!t) {
          const i = this, n = this.json[e + (e === "mesh" ? "es" : "s")] || [];
          t = Promise.all(n.map(function(s, a) {
            return i.getDependency(e, a);
          })), this.cache.add(e, t);
        }
        return t;
      }
      loadBuffer(e) {
        const t = this.json.buffers[e], i = this.fileLoader;
        if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
        if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[Xe.KHR_BINARY_GLTF].body);
        const n = this.options;
        return new Promise(function(s, a) {
          i.load(Ra.resolveURL(t.uri, n.path), s, void 0, function() {
            a(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'));
          });
        });
      }
      loadBufferView(e) {
        const t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then(function(i) {
          const n = t.byteLength || 0, s = t.byteOffset || 0;
          return i.slice(s, s + n);
        });
      }
      loadAccessor(e) {
        const t = this, i = this.json, n = this.json.accessors[e];
        if (n.bufferView === void 0 && n.sparse === void 0) {
          const a = bu[n.type], o = Rs[n.componentType], l = n.normalized === true, c = new o(n.count * a);
          return Promise.resolve(new si(c, a, l));
        }
        const s = [];
        return n.bufferView !== void 0 ? s.push(this.getDependency("bufferView", n.bufferView)) : s.push(null), n.sparse !== void 0 && (s.push(this.getDependency("bufferView", n.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", n.sparse.values.bufferView))), Promise.all(s).then(function(a) {
          const o = a[0], l = bu[n.type], c = Rs[n.componentType], u = c.BYTES_PER_ELEMENT, h = u * l, d = n.byteOffset || 0, p = n.bufferView !== void 0 ? i.bufferViews[n.bufferView].byteStride : void 0, f = n.normalized === true;
          let _, g;
          if (p && p !== h) {
            const m = Math.floor(d / p), y = "InterleavedBuffer:" + n.bufferView + ":" + n.componentType + ":" + m + ":" + n.count;
            let x = t.cache.get(y);
            x || (_ = new c(o, m * p, n.count * p / u), x = new C_(_, p / u), t.cache.add(y, x)), g = new Bc(x, l, d % p / u, f);
          } else o === null ? _ = new c(n.count * l) : _ = new c(o, d, n.count * l), g = new si(_, l, f);
          if (n.sparse !== void 0) {
            const m = bu.SCALAR, y = Rs[n.sparse.indices.componentType], x = n.sparse.indices.byteOffset || 0, v = n.sparse.values.byteOffset || 0, A = new y(a[1], x, n.sparse.count * m), T = new c(a[2], v, n.sparse.count * l);
            o !== null && (g = new si(g.array.slice(), g.itemSize, g.normalized)), g.normalized = false;
            for (let w = 0, R = A.length; w < R; w++) {
              const E = A[w];
              if (g.setX(E, T[w * l]), l >= 2 && g.setY(E, T[w * l + 1]), l >= 3 && g.setZ(E, T[w * l + 2]), l >= 4 && g.setW(E, T[w * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
            }
            g.normalized = f;
          }
          return g;
        });
      }
      loadTexture(e) {
        const t = this.json, i = this.options, n = t.textures[e].source, s = t.images[n];
        let a = this.textureLoader;
        if (s.uri) {
          const o = i.manager.getHandler(s.uri);
          o !== null && (a = o);
        }
        return this.loadTextureImage(e, n, a);
      }
      loadTextureImage(e, t, i) {
        const n = this, s = this.json, a = s.textures[e], o = s.images[t], l = (o.uri || o.bufferView) + ":" + a.sampler;
        if (this.textureCache[l]) return this.textureCache[l];
        const c = this.loadImageSource(t, i).then(function(u) {
          u.flipY = false, u.name = a.name || o.name || "", u.name === "" && typeof o.uri == "string" && o.uri.startsWith("data:image/") === false && (u.name = o.uri);
          const h = (s.samplers || {})[a.sampler] || {};
          return u.magFilter = Jp[h.magFilter] || _i, u.minFilter = Jp[h.minFilter] || cr, u.wrapS = $p[h.wrapS] || Yn, u.wrapT = $p[h.wrapT] || Yn, u.generateMipmaps = !u.isCompressedTexture && u.minFilter !== ri && u.minFilter !== _i, n.associations.set(u, {
            textures: e
          }), u;
        }).catch(function() {
          return null;
        });
        return this.textureCache[l] = c, c;
      }
      loadImageSource(e, t) {
        const i = this, n = this.json, s = this.options;
        if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then((h) => h.clone());
        const a = n.images[e], o = self.URL || self.webkitURL;
        let l = a.uri || "", c = false;
        if (a.bufferView !== void 0) l = i.getDependency("bufferView", a.bufferView).then(function(h) {
          c = true;
          const d = new Blob([
            h
          ], {
            type: a.mimeType
          });
          return l = o.createObjectURL(d), l;
        });
        else if (a.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
        const u = Promise.resolve(l).then(function(h) {
          return new Promise(function(d, p) {
            let f = d;
            t.isImageBitmapLoader === true && (f = function(_) {
              const g = new Nt(_);
              g.needsUpdate = true, d(g);
            }), t.load(Ra.resolveURL(h, s.path), f, void 0, p);
          });
        }).then(function(h) {
          return c === true && o.revokeObjectURL(l), Mr(h, a), h.userData.mimeType = a.mimeType || uS(a.uri), h;
        }).catch(function(h) {
          throw console.error("THREE.GLTFLoader: Couldn't load texture", l), h;
        });
        return this.sourceCache[e] = u, u;
      }
      assignTexture(e, t, i, n) {
        const s = this;
        return this.getDependency("texture", i.index).then(function(a) {
          if (!a) return null;
          if (i.texCoord !== void 0 && i.texCoord > 0 && (a = a.clone(), a.channel = i.texCoord), s.extensions[Xe.KHR_TEXTURE_TRANSFORM]) {
            const o = i.extensions !== void 0 ? i.extensions[Xe.KHR_TEXTURE_TRANSFORM] : void 0;
            if (o) {
              const l = s.associations.get(a);
              a = s.extensions[Xe.KHR_TEXTURE_TRANSFORM].extendTexture(a, o), s.associations.set(a, l);
            }
          }
          return n !== void 0 && (a.colorSpace = n), e[t] = a, a;
        });
      }
      assignFinalMaterial(e) {
        const t = e.geometry;
        let i = e.material;
        const n = t.attributes.tangent === void 0, s = t.attributes.color !== void 0, a = t.attributes.normal === void 0;
        if (e.isPoints) {
          const o = "PointsMaterial:" + i.uuid;
          let l = this.cache.get(o);
          l || (l = new qc(), Ji.prototype.copy.call(l, i), l.color.copy(i.color), l.map = i.map, l.sizeAttenuation = false, this.cache.add(o, l)), i = l;
        } else if (e.isLine) {
          const o = "LineBasicMaterial:" + i.uuid;
          let l = this.cache.get(o);
          l || (l = new kd(), Ji.prototype.copy.call(l, i), l.color.copy(i.color), l.map = i.map, this.cache.add(o, l)), i = l;
        }
        if (n || s || a) {
          let o = "ClonedMaterial:" + i.uuid + ":";
          n && (o += "derivative-tangents:"), s && (o += "vertex-colors:"), a && (o += "flat-shading:");
          let l = this.cache.get(o);
          l || (l = i.clone(), s && (l.vertexColors = true), a && (l.flatShading = true), n && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(o, l), this.associations.set(l, this.associations.get(i))), i = l;
        }
        e.material = i;
      }
      getMaterialType() {
        return xs;
      }
      loadMaterial(e) {
        const t = this, i = this.json, n = this.extensions, s = i.materials[e];
        let a;
        const o = {}, l = s.extensions || {}, c = [];
        if (l[Xe.KHR_MATERIALS_UNLIT]) {
          const h = n[Xe.KHR_MATERIALS_UNLIT];
          a = h.getMaterialType(), c.push(h.extendParams(o, s, t));
        } else {
          const h = s.pbrMetallicRoughness || {};
          if (o.color = new Ae(1, 1, 1), o.opacity = 1, Array.isArray(h.baseColorFactor)) {
            const d = h.baseColorFactor;
            o.color.setRGB(d[0], d[1], d[2], ni), o.opacity = d[3];
          }
          h.baseColorTexture !== void 0 && c.push(t.assignTexture(o, "map", h.baseColorTexture, Gt)), o.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1, o.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1, h.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(o, "metalnessMap", h.metallicRoughnessTexture)), c.push(t.assignTexture(o, "roughnessMap", h.metallicRoughnessTexture))), a = this._invokeOne(function(d) {
            return d.getMaterialType && d.getMaterialType(e);
          }), c.push(Promise.all(this._invokeAll(function(d) {
            return d.extendMaterialParams && d.extendMaterialParams(e, o);
          })));
        }
        s.doubleSided === true && (o.side = ti);
        const u = s.alphaMode || Eu.OPAQUE;
        if (u === Eu.BLEND ? (o.transparent = true, o.depthWrite = false) : (o.transparent = false, u === Eu.MASK && (o.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)), s.normalTexture !== void 0 && a !== $i && (c.push(t.assignTexture(o, "normalMap", s.normalTexture)), o.normalScale = new ee(1, 1), s.normalTexture.scale !== void 0)) {
          const h = s.normalTexture.scale;
          o.normalScale.set(h, h);
        }
        if (s.occlusionTexture !== void 0 && a !== $i && (c.push(t.assignTexture(o, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (o.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && a !== $i) {
          const h = s.emissiveFactor;
          o.emissive = new Ae().setRGB(h[0], h[1], h[2], ni);
        }
        return s.emissiveTexture !== void 0 && a !== $i && c.push(t.assignTexture(o, "emissiveMap", s.emissiveTexture, Gt)), Promise.all(c).then(function() {
          const h = new a(o);
          return s.name && (h.name = s.name), Mr(h, s), t.associations.set(h, {
            materials: e
          }), s.extensions && yn(n, h, s), h;
        });
      }
      createUniqueName(e) {
        const t = st.sanitizeNodeName(e || "");
        return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t);
      }
      loadGeometries(e) {
        const t = this, i = this.extensions, n = this.primitiveCache;
        function s(o) {
          return i[Xe.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o, t).then(function(l) {
            return Qp(l, o, t);
          });
        }
        const a = [];
        for (let o = 0, l = e.length; o < l; o++) {
          const c = e[o], u = cS(c), h = n[u];
          if (h) a.push(h.promise);
          else {
            let d;
            c.extensions && c.extensions[Xe.KHR_DRACO_MESH_COMPRESSION] ? d = s(c) : d = Qp(new hi(), c, t), n[u] = {
              primitive: c,
              promise: d
            }, a.push(d);
          }
        }
        return Promise.all(a);
      }
      loadMesh(e) {
        const t = this, i = this.json, n = this.extensions, s = i.meshes[e], a = s.primitives, o = [];
        for (let l = 0, c = a.length; l < c; l++) {
          const u = a[l].material === void 0 ? aS(this.cache) : this.getDependency("material", a[l].material);
          o.push(u);
        }
        return o.push(t.loadGeometries(a)), Promise.all(o).then(function(l) {
          const c = l.slice(0, l.length - 1), u = l[l.length - 1], h = [];
          for (let p = 0, f = u.length; p < f; p++) {
            const _ = u[p], g = a[p];
            let m;
            const y = c[p];
            if (g.mode === Li.TRIANGLES || g.mode === Li.TRIANGLE_STRIP || g.mode === Li.TRIANGLE_FAN || g.mode === void 0) m = s.isSkinnedMesh === true ? new L_(_, y) : new Rt(_, y), m.isSkinnedMesh === true && m.normalizeSkinWeights(), g.mode === Li.TRIANGLE_STRIP ? m.geometry = qp(m.geometry, $h) : g.mode === Li.TRIANGLE_FAN && (m.geometry = qp(m.geometry, fc));
            else if (g.mode === Li.LINES) m = new F_(_, y);
            else if (g.mode === Li.LINE_STRIP) m = new jc(_, y);
            else if (g.mode === Li.LINE_LOOP) m = new B_(_, y);
            else if (g.mode === Li.POINTS) m = new jd(_, y);
            else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + g.mode);
            Object.keys(m.geometry.morphAttributes).length > 0 && lS(m, s), m.name = t.createUniqueName(s.name || "mesh_" + e), Mr(m, s), g.extensions && yn(n, m, g), t.assignFinalMaterial(m), h.push(m);
          }
          for (let p = 0, f = h.length; p < f; p++) t.associations.set(h[p], {
            meshes: e,
            primitives: p
          });
          if (h.length === 1) return s.extensions && yn(n, h[0], s), h[0];
          const d = new Gr();
          s.extensions && yn(n, d, s), t.associations.set(d, {
            meshes: e
          });
          for (let p = 0, f = h.length; p < f; p++) d.add(h[p]);
          return d;
        });
      }
      loadCamera(e) {
        let t;
        const i = this.json.cameras[e], n = i[i.type];
        if (!n) {
          console.warn("THREE.GLTFLoader: Missing camera parameters.");
          return;
        }
        return i.type === "perspective" ? t = new oi(e_.radToDeg(n.yfov), n.aspectRatio || 1, n.znear || 1, n.zfar || 2e6) : i.type === "orthographic" && (t = new Yo(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)), i.name && (t.name = this.createUniqueName(i.name)), Mr(t, i), Promise.resolve(t);
      }
      loadSkin(e) {
        const t = this.json.skins[e], i = [];
        for (let n = 0, s = t.joints.length; n < s; n++) i.push(this._loadNodeShallow(t.joints[n]));
        return t.inverseBindMatrices !== void 0 ? i.push(this.getDependency("accessor", t.inverseBindMatrices)) : i.push(null), Promise.all(i).then(function(n) {
          const s = n.pop(), a = n, o = [], l = [];
          for (let c = 0, u = a.length; c < u; c++) {
            const h = a[c];
            if (h) {
              o.push(h);
              const d = new Fe();
              s !== null && d.fromArray(s.array, c * 16), l.push(d);
            } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c]);
          }
          return new Hc(o, l);
        });
      }
      loadAnimation(e) {
        const t = this.json, i = this, n = t.animations[e], s = n.name ? n.name : "animation_" + e, a = [], o = [], l = [], c = [], u = [];
        for (let h = 0, d = n.channels.length; h < d; h++) {
          const p = n.channels[h], f = n.samplers[p.sampler], _ = p.target, g = _.node, m = n.parameters !== void 0 ? n.parameters[f.input] : f.input, y = n.parameters !== void 0 ? n.parameters[f.output] : f.output;
          _.node !== void 0 && (a.push(this.getDependency("node", g)), o.push(this.getDependency("accessor", m)), l.push(this.getDependency("accessor", y)), c.push(f), u.push(_));
        }
        return Promise.all([
          Promise.all(a),
          Promise.all(o),
          Promise.all(l),
          Promise.all(c),
          Promise.all(u)
        ]).then(function(h) {
          const d = h[0], p = h[1], f = h[2], _ = h[3], g = h[4], m = [];
          for (let y = 0, x = d.length; y < x; y++) {
            const v = d[y], A = p[y], T = f[y], w = _[y], R = g[y];
            if (v === void 0) continue;
            v.updateMatrix && v.updateMatrix();
            const E = i._createAnimationTracks(v, A, T, w, R);
            if (E) for (let b = 0; b < E.length; b++) m.push(E[b]);
          }
          return new wv(s, void 0, m);
        });
      }
      createNodeMesh(e) {
        const t = this.json, i = this, n = t.nodes[e];
        return n.mesh === void 0 ? null : i.getDependency("mesh", n.mesh).then(function(s) {
          const a = i._getNodeRef(i.meshCache, n.mesh, s);
          return n.weights !== void 0 && a.traverse(function(o) {
            if (o.isMesh) for (let l = 0, c = n.weights.length; l < c; l++) o.morphTargetInfluences[l] = n.weights[l];
          }), a;
        });
      }
      loadNode(e) {
        const t = this.json, i = this, n = t.nodes[e], s = i._loadNodeShallow(e), a = [], o = n.children || [];
        for (let c = 0, u = o.length; c < u; c++) a.push(i.getDependency("node", o[c]));
        const l = n.skin === void 0 ? Promise.resolve(null) : i.getDependency("skin", n.skin);
        return Promise.all([
          s,
          Promise.all(a),
          l
        ]).then(function(c) {
          const u = c[0], h = c[1], d = c[2];
          d !== null && u.traverse(function(p) {
            p.isSkinnedMesh && p.bind(d, hS);
          });
          for (let p = 0, f = h.length; p < f; p++) u.add(h[p]);
          return u;
        });
      }
      _loadNodeShallow(e) {
        const t = this.json, i = this.extensions, n = this;
        if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
        const s = t.nodes[e], a = s.name ? n.createUniqueName(s.name) : "", o = [], l = n._invokeOne(function(c) {
          return c.createNodeMesh && c.createNodeMesh(e);
        });
        return l && o.push(l), s.camera !== void 0 && o.push(n.getDependency("camera", s.camera).then(function(c) {
          return n._getNodeRef(n.cameraCache, s.camera, c);
        })), n._invokeAll(function(c) {
          return c.createNodeAttachment && c.createNodeAttachment(e);
        }).forEach(function(c) {
          o.push(c);
        }), this.nodeCache[e] = Promise.all(o).then(function(c) {
          let u;
          if (s.isBone === true ? u = new Od() : c.length > 1 ? u = new Gr() : c.length === 1 ? u = c[0] : u = new xt(), u !== c[0]) for (let h = 0, d = c.length; h < d; h++) u.add(c[h]);
          if (s.name && (u.userData.name = s.name, u.name = a), Mr(u, s), s.extensions && yn(i, u, s), s.matrix !== void 0) {
            const h = new Fe();
            h.fromArray(s.matrix), u.applyMatrix4(h);
          } else s.translation !== void 0 && u.position.fromArray(s.translation), s.rotation !== void 0 && u.quaternion.fromArray(s.rotation), s.scale !== void 0 && u.scale.fromArray(s.scale);
          return n.associations.has(u) || n.associations.set(u, {}), n.associations.get(u).nodes = e, u;
        }), this.nodeCache[e];
      }
      loadScene(e) {
        const t = this.extensions, i = this.json.scenes[e], n = this, s = new Gr();
        i.name && (s.name = n.createUniqueName(i.name)), Mr(s, i), i.extensions && yn(t, s, i);
        const a = i.nodes || [], o = [];
        for (let l = 0, c = a.length; l < c; l++) o.push(n.getDependency("node", a[l]));
        return Promise.all(o).then(function(l) {
          for (let u = 0, h = l.length; u < h; u++) s.add(l[u]);
          const c = (u) => {
            const h = /* @__PURE__ */ new Map();
            for (const [d, p] of n.associations) (d instanceof Ji || d instanceof Nt) && h.set(d, p);
            return u.traverse((d) => {
              const p = n.associations.get(d);
              p != null && h.set(d, p);
            }), h;
          };
          return n.associations = c(s), s;
        });
      }
      _createAnimationTracks(e, t, i, n, s) {
        const a = [], o = e.name ? e.name : e.uuid, l = [];
        Xr[s.path] === Xr.weights ? e.traverse(function(d) {
          d.morphTargetInfluences && l.push(d.name ? d.name : d.uuid);
        }) : l.push(o);
        let c;
        switch (Xr[s.path]) {
          case Xr.weights:
            c = Ms;
            break;
          case Xr.rotation:
            c = bs;
            break;
          case Xr.position:
          case Xr.scale:
            c = Es;
            break;
          default:
            switch (i.itemSize) {
              case 1:
                c = Ms;
                break;
              case 2:
              case 3:
              default:
                c = Es;
                break;
            }
            break;
        }
        const u = n.interpolation !== void 0 ? sS[n.interpolation] : la, h = this._getArrayFromAccessor(i);
        for (let d = 0, p = l.length; d < p; d++) {
          const f = new c(l[d] + "." + Xr[s.path], t.array, h, u);
          n.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(f), a.push(f);
        }
        return a;
      }
      _getArrayFromAccessor(e) {
        let t = e.array;
        if (e.normalized) {
          const i = wu(t.constructor), n = new Float32Array(t.length);
          for (let s = 0, a = t.length; s < a; s++) n[s] = t[s] * i;
          t = n;
        }
        return t;
      }
      _createCubicSplineTrackInterpolant(e) {
        e.createInterpolant = function(t) {
          const i = this instanceof bs ? nS : Zp;
          return new i(this.times, this.values, this.getValueSize() / 3, t);
        }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
      }
    }
    function pS(r, e, t) {
      const i = e.attributes, n = new fr();
      if (i.POSITION !== void 0) {
        const o = t.json.accessors[i.POSITION], l = o.min, c = o.max;
        if (l !== void 0 && c !== void 0) {
          if (n.set(new D(l[0], l[1], l[2]), new D(c[0], c[1], c[2])), o.normalized) {
            const u = wu(Rs[o.componentType]);
            n.min.multiplyScalar(u), n.max.multiplyScalar(u);
          }
        } else {
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
          return;
        }
      } else return;
      const s = e.targets;
      if (s !== void 0) {
        const o = new D(), l = new D();
        for (let c = 0, u = s.length; c < u; c++) {
          const h = s[c];
          if (h.POSITION !== void 0) {
            const d = t.json.accessors[h.POSITION], p = d.min, f = d.max;
            if (p !== void 0 && f !== void 0) {
              if (l.setX(Math.max(Math.abs(p[0]), Math.abs(f[0]))), l.setY(Math.max(Math.abs(p[1]), Math.abs(f[1]))), l.setZ(Math.max(Math.abs(p[2]), Math.abs(f[2]))), d.normalized) {
                const _ = wu(Rs[d.componentType]);
                l.multiplyScalar(_);
              }
              o.max(l);
            } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
          }
        }
        n.expandByVector(o);
      }
      r.boundingBox = n;
      const a = new Ki();
      n.getCenter(a.center), a.radius = n.min.distanceTo(n.max) / 2, r.boundingSphere = a;
    }
    function Qp(r, e, t) {
      const i = e.attributes, n = [];
      function s(a, o) {
        return t.getDependency("accessor", a).then(function(l) {
          r.setAttribute(o, l);
        });
      }
      for (const a in i) {
        const o = Su[a] || a.toLowerCase();
        o in r.attributes || n.push(s(i[a], o));
      }
      if (e.indices !== void 0 && !r.index) {
        const a = t.getDependency("accessor", e.indices).then(function(o) {
          r.setIndex(o);
        });
        n.push(a);
      }
      return Ke.workingColorSpace !== ni && "COLOR_0" in i && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Ke.workingColorSpace}" not supported.`), Mr(r, e), pS(r, e, t), Promise.all(n).then(function() {
        return e.targets !== void 0 ? oS(r, e.targets, t) : r;
      });
    }
    class Au extends fn {
      constructor(e) {
        super(e);
      }
      load(e, t, i, n) {
        const s = this, a = new au(this.manager);
        a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(o) {
          const l = s.parse(JSON.parse(o));
          t && t(l);
        }, i, n);
      }
      parse(e) {
        return new fS(e);
      }
    }
    class fS {
      constructor(e) {
        this.isFont = true, this.type = "Font", this.data = e;
      }
      generateShapes(e, t = 100) {
        const i = [], n = mS(e, t, this.data);
        for (let s = 0, a = n.length; s < a; s++) i.push(...n[s].toShapes());
        return i;
      }
    }
    function mS(r, e, t) {
      const i = Array.from(r), n = e / t.resolution, s = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * n, a = [];
      let o = 0, l = 0;
      for (let c = 0; c < i.length; c++) {
        const u = i[c];
        if (u === `
`) o = 0, l -= s;
        else {
          const h = gS(u, n, o, l, t);
          o += h.offsetX, a.push(h.path);
        }
      }
      return a;
    }
    function gS(r, e, t, i, n) {
      const s = n.glyphs[r] || n.glyphs["?"];
      if (!s) {
        console.error('THREE.Font: character "' + r + '" does not exists in font family ' + n.familyName + ".");
        return;
      }
      const a = new Zv();
      let o, l, c, u, h, d, p, f;
      if (s.o) {
        const _ = s._cachedOutline || (s._cachedOutline = s.o.split(" "));
        for (let g = 0, m = _.length; g < m; ) switch (_[g++]) {
          case "m":
            o = _[g++] * e + t, l = _[g++] * e + i, a.moveTo(o, l);
            break;
          case "l":
            o = _[g++] * e + t, l = _[g++] * e + i, a.lineTo(o, l);
            break;
          case "q":
            c = _[g++] * e + t, u = _[g++] * e + i, h = _[g++] * e + t, d = _[g++] * e + i, a.quadraticCurveTo(h, d, c, u);
            break;
          case "b":
            c = _[g++] * e + t, u = _[g++] * e + i, h = _[g++] * e + t, d = _[g++] * e + i, p = _[g++] * e + t, f = _[g++] * e + i, a.bezierCurveTo(h, d, p, f, c, u);
            break;
        }
      }
      return {
        offsetX: s.ha * e,
        path: a
      };
    }
    class Ru extends nu {
      constructor(e, t = {}) {
        const i = t.font;
        if (i === void 0) super();
        else {
          const n = i.generateShapes(e, t.size);
          t.depth === void 0 && (t.depth = 50), t.bevelThickness === void 0 && (t.bevelThickness = 10), t.bevelSize === void 0 && (t.bevelSize = 8), t.bevelEnabled === void 0 && (t.bevelEnabled = false), super(n, t);
        }
        this.type = "TextGeometry";
      }
    }
    function br(r) {
      if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return r;
    }
    function ef(r, e) {
      r.prototype = Object.create(e.prototype), r.prototype.constructor = r, r.__proto__ = e;
    }
    var yi = {
      autoSleep: 120,
      force3D: "auto",
      nullTargetWarn: 1,
      units: {
        lineHeight: ""
      }
    }, Cs = {
      duration: 0.5,
      overwrite: false,
      delay: 0
    }, Cu, Xt, mt, rr = 1e8, Jt = 1 / rr, Pu = Math.PI * 2, _S = Pu / 4, vS = 0, tf = Math.sqrt, xS = Math.cos, yS = Math.sin, Vt = function(r) {
      return typeof r == "string";
    }, Et = function(r) {
      return typeof r == "function";
    }, Sr = function(r) {
      return typeof r == "number";
    }, Lu = function(r) {
      return typeof r > "u";
    }, nr = function(r) {
      return typeof r == "object";
    }, di = function(r) {
      return r !== false;
    }, Du = function() {
      return typeof window < "u";
    }, el = function(r) {
      return Et(r) || Vt(r);
    }, rf = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {
    }, $t = Array.isArray, Iu = /(?:-?\.?\d|\.)+/gi, nf = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, Ps = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, Uu = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, sf = /[+-]=-?[.\d]+/, af = /[^,'"\[\]\s]+/gi, MS = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, Mt, sr, Ou, Nu, Mi = {}, tl = {}, of, lf = function(r) {
      return (tl = Ds(r, Mi)) && mi;
    }, Fu = function(r, e) {
      return console.warn("Invalid property", r, "set to", e, "Missing plugin? gsap.registerPlugin()");
    }, La = function(r, e) {
      return !e && console.warn(r);
    }, cf = function(r, e) {
      return r && (Mi[r] = e) && tl && (tl[r] = e) || Mi;
    }, Da = function() {
      return 0;
    }, bS = {
      suppressEvents: true,
      isStart: true,
      kill: false
    }, il = {
      suppressEvents: true,
      kill: false
    }, SS = {
      suppressEvents: true
    }, Bu = {}, jr = [], zu = {}, uf, bi = {}, ku = {}, hf = 30, rl = [], Hu = "", Vu = function(r) {
      var e = r[0], t, i;
      if (nr(e) || Et(e) || (r = [
        r
      ]), !(t = (e._gsap || {}).harness)) {
        for (i = rl.length; i-- && !rl[i].targetTest(e); ) ;
        t = rl[i];
      }
      for (i = r.length; i--; ) r[i] && (r[i]._gsap || (r[i]._gsap = new kf(r[i], t))) || r.splice(i, 1);
      return r;
    }, Mn = function(r) {
      return r._gsap || Vu(Ii(r))[0]._gsap;
    }, df = function(r, e, t) {
      return (t = r[e]) && Et(t) ? r[e]() : Lu(t) && r.getAttribute && r.getAttribute(e) || t;
    }, pi = function(r, e) {
      return (r = r.split(",")).forEach(e) || r;
    }, Ct = function(r) {
      return Math.round(r * 1e5) / 1e5 || 0;
    }, Dt = function(r) {
      return Math.round(r * 1e7) / 1e7 || 0;
    }, Ls = function(r, e) {
      var t = e.charAt(0), i = parseFloat(e.substr(2));
      return r = parseFloat(r), t === "+" ? r + i : t === "-" ? r - i : t === "*" ? r * i : r / i;
    }, ES = function(r, e) {
      for (var t = e.length, i = 0; r.indexOf(e[i]) < 0 && ++i < t; ) ;
      return i < t;
    }, nl = function() {
      var r = jr.length, e = jr.slice(0), t, i;
      for (zu = {}, jr.length = 0, t = 0; t < r; t++) i = e[t], i && i._lazy && (i.render(i._lazy[0], i._lazy[1], true)._lazy = 0);
    }, pf = function(r, e, t, i) {
      jr.length && !Xt && nl(), r.render(e, t, Xt && e < 0 && (r._initted || r._startAt)), jr.length && !Xt && nl();
    }, ff = function(r) {
      var e = parseFloat(r);
      return (e || e === 0) && (r + "").match(af).length < 2 ? e : Vt(r) ? r.trim() : r;
    }, mf = function(r) {
      return r;
    }, Si = function(r, e) {
      for (var t in e) t in r || (r[t] = e[t]);
      return r;
    }, TS = function(r) {
      return function(e, t) {
        for (var i in t) i in e || i === "duration" && r || i === "ease" || (e[i] = t[i]);
      };
    }, Ds = function(r, e) {
      for (var t in e) r[t] = e[t];
      return r;
    }, gf = function r(e, t) {
      for (var i in t) i !== "__proto__" && i !== "constructor" && i !== "prototype" && (e[i] = nr(t[i]) ? r(e[i] || (e[i] = {}), t[i]) : t[i]);
      return e;
    }, sl = function(r, e) {
      var t = {}, i;
      for (i in r) i in e || (t[i] = r[i]);
      return t;
    }, Ia = function(r) {
      var e = r.parent || Mt, t = r.keyframes ? TS($t(r.keyframes)) : Si;
      if (di(r.inherit)) for (; e; ) t(r, e.vars.defaults), e = e.parent || e._dp;
      return r;
    }, wS = function(r, e) {
      for (var t = r.length, i = t === e.length; i && t-- && r[t] === e[t]; ) ;
      return t < 0;
    }, _f = function(r, e, t, i, n) {
      var s = r[i], a;
      if (n) for (a = e[n]; s && s[n] > a; ) s = s._prev;
      return s ? (e._next = s._next, s._next = e) : (e._next = r[t], r[t] = e), e._next ? e._next._prev = e : r[i] = e, e._prev = s, e.parent = e._dp = r, e;
    }, al = function(r, e, t, i) {
      t === void 0 && (t = "_first"), i === void 0 && (i = "_last");
      var n = e._prev, s = e._next;
      n ? n._next = s : r[t] === e && (r[t] = s), s ? s._prev = n : r[i] === e && (r[i] = n), e._next = e._prev = e.parent = null;
    }, qr = function(r, e) {
      r.parent && (!e || r.parent.autoRemoveChildren) && r.parent.remove && r.parent.remove(r), r._act = 0;
    }, bn = function(r, e) {
      if (r && (!e || e._end > r._dur || e._start < 0)) for (var t = r; t; ) t._dirty = 1, t = t.parent;
      return r;
    }, AS = function(r) {
      for (var e = r.parent; e && e.parent; ) e._dirty = 1, e.totalDuration(), e = e.parent;
      return r;
    }, Gu = function(r, e, t, i) {
      return r._startAt && (Xt ? r._startAt.revert(il) : r.vars.immediateRender && !r.vars.autoRevert || r._startAt.render(e, true, i));
    }, RS = function r(e) {
      return !e || e._ts && r(e.parent);
    }, vf = function(r) {
      return r._repeat ? Is(r._tTime, r = r.duration() + r._rDelay) * r : 0;
    }, Is = function(r, e) {
      var t = Math.floor(r = Dt(r / e));
      return r && t === r ? t - 1 : t;
    }, ol = function(r, e) {
      return (r - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur);
    }, ll = function(r) {
      return r._end = Dt(r._start + (r._tDur / Math.abs(r._ts || r._rts || Jt) || 0));
    }, cl = function(r, e) {
      var t = r._dp;
      return t && t.smoothChildTiming && r._ts && (r._start = Dt(t._time - (r._ts > 0 ? e / r._ts : ((r._dirty ? r.totalDuration() : r._tDur) - e) / -r._ts)), ll(r), t._dirty || bn(t, r)), r;
    }, xf = function(r, e) {
      var t;
      if ((e._time || !e._dur && e._initted || e._start < r._time && (e._dur || !e.add)) && (t = ol(r.rawTime(), e), (!e._dur || Oa(0, e.totalDuration(), t) - e._tTime > Jt) && e.render(t, true)), bn(r, e)._dp && r._initted && r._time >= r._dur && r._ts) {
        if (r._dur < r.duration()) for (t = r; t._dp; ) t.rawTime() >= 0 && t.totalTime(t._tTime), t = t._dp;
        r._zTime = -1e-8;
      }
    }, ar = function(r, e, t, i) {
      return e.parent && qr(e), e._start = Dt((Sr(t) ? t : t || r !== Mt ? Di(r, t, e) : r._time) + e._delay), e._end = Dt(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)), _f(r, e, "_first", "_last", r._sort ? "_start" : 0), Wu(e) || (r._recent = e), i || xf(r, e), r._ts < 0 && cl(r, r._tTime), r;
    }, yf = function(r, e) {
      return (Mi.ScrollTrigger || Fu("scrollTrigger", e)) && Mi.ScrollTrigger.create(e, r);
    }, Mf = function(r, e, t, i, n) {
      if (Qu(r, e, n), !r._initted) return 1;
      if (!t && r._pt && !Xt && (r._dur && r.vars.lazy !== false || !r._dur && r.vars.lazy) && uf !== Ti.frame) return jr.push(r), r._lazy = [
        n,
        i
      ], 1;
    }, CS = function r(e) {
      var t = e.parent;
      return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || r(t));
    }, Wu = function(r) {
      var e = r.data;
      return e === "isFromStart" || e === "isStart";
    }, PS = function(r, e, t, i) {
      var n = r.ratio, s = e < 0 || !e && (!r._start && CS(r) && !(!r._initted && Wu(r)) || (r._ts < 0 || r._dp._ts < 0) && !Wu(r)) ? 0 : 1, a = r._rDelay, o = 0, l, c, u;
      if (a && r._repeat && (o = Oa(0, r._tDur, e), c = Is(o, a), r._yoyo && c & 1 && (s = 1 - s), c !== Is(r._tTime, a) && (n = 1 - s, r.vars.repeatRefresh && r._initted && r.invalidate())), s !== n || Xt || i || r._zTime === Jt || !e && r._zTime) {
        if (!r._initted && Mf(r, e, i, t, o)) return;
        for (u = r._zTime, r._zTime = e || (t ? Jt : 0), t || (t = e && !u), r.ratio = s, r._from && (s = 1 - s), r._time = 0, r._tTime = o, l = r._pt; l; ) l.r(s, l.d), l = l._next;
        e < 0 && Gu(r, e, t, true), r._onUpdate && !t && Ei(r, "onUpdate"), o && r._repeat && !t && r.parent && Ei(r, "onRepeat"), (e >= r._tDur || e < 0) && r.ratio === s && (s && qr(r, 1), !t && !Xt && (Ei(r, s ? "onComplete" : "onReverseComplete", true), r._prom && r._prom()));
      } else r._zTime || (r._zTime = e);
    }, LS = function(r, e, t) {
      var i;
      if (t > e) for (i = r._first; i && i._start <= t; ) {
        if (i.data === "isPause" && i._start > e) return i;
        i = i._next;
      }
      else for (i = r._last; i && i._start >= t; ) {
        if (i.data === "isPause" && i._start < e) return i;
        i = i._prev;
      }
    }, Us = function(r, e, t, i) {
      var n = r._repeat, s = Dt(e) || 0, a = r._tTime / r._tDur;
      return a && !i && (r._time *= s / r._dur), r._dur = s, r._tDur = n ? n < 0 ? 1e10 : Dt(s * (n + 1) + r._rDelay * n) : s, a > 0 && !i && cl(r, r._tTime = r._tDur * a), r.parent && ll(r), t || bn(r.parent, r), r;
    }, bf = function(r) {
      return r instanceof ci ? bn(r) : Us(r, r._dur);
    }, DS = {
      _start: 0,
      endTime: Da,
      totalDuration: Da
    }, Di = function r(e, t, i) {
      var n = e.labels, s = e._recent || DS, a = e.duration() >= rr ? s.endTime(false) : e._dur, o, l, c;
      return Vt(t) && (isNaN(t) || t in n) ? (l = t.charAt(0), c = t.substr(-1) === "%", o = t.indexOf("="), l === "<" || l === ">" ? (o >= 0 && (t = t.replace(/=/, "")), (l === "<" ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (c ? (o < 0 ? s : i).totalDuration() / 100 : 1)) : o < 0 ? (t in n || (n[t] = a), n[t]) : (l = parseFloat(t.charAt(o - 1) + t.substr(o + 1)), c && i && (l = l / 100 * ($t(i) ? i[0] : i).totalDuration()), o > 1 ? r(e, t.substr(0, o - 1), i) + l : a + l)) : t == null ? a : +t;
    }, Ua = function(r, e, t) {
      var i = Sr(e[1]), n = (i ? 2 : 1) + (r < 2 ? 0 : 1), s = e[n], a, o;
      if (i && (s.duration = e[1]), s.parent = t, r) {
        for (a = s, o = t; o && !("immediateRender" in a); ) a = o.vars.defaults || {}, o = di(o.vars.inherit) && o.parent;
        s.immediateRender = di(a.immediateRender), r < 2 ? s.runBackwards = 1 : s.startAt = e[n - 1];
      }
      return new It(e[0], s, e[n + 1]);
    }, Yr = function(r, e) {
      return r || r === 0 ? e(r) : e;
    }, Oa = function(r, e, t) {
      return t < r ? r : t > e ? e : t;
    }, Qt = function(r, e) {
      return !Vt(r) || !(e = MS.exec(r)) ? "" : e[1];
    }, IS = function(r, e, t) {
      return Yr(t, function(i) {
        return Oa(r, e, i);
      });
    }, Xu = [].slice, Sf = function(r, e) {
      return r && nr(r) && "length" in r && (!e && !r.length || r.length - 1 in r && nr(r[0])) && !r.nodeType && r !== sr;
    }, US = function(r, e, t) {
      return t === void 0 && (t = []), r.forEach(function(i) {
        var n;
        return Vt(i) && !e || Sf(i, 1) ? (n = t).push.apply(n, Ii(i)) : t.push(i);
      }) || t;
    }, Ii = function(r, e, t) {
      return mt && !e && mt.selector ? mt.selector(r) : Vt(r) && !t && (Ou || !Ns()) ? Xu.call((e || Nu).querySelectorAll(r), 0) : $t(r) ? US(r, t) : Sf(r) ? Xu.call(r, 0) : r ? [
        r
      ] : [];
    }, ju = function(r) {
      return r = Ii(r)[0] || La("Invalid scope") || {}, function(e) {
        var t = r.current || r.nativeElement || r;
        return Ii(e, t.querySelectorAll ? t : t === r ? La("Invalid scope") || Nu.createElement("div") : r);
      };
    }, Ef = function(r) {
      return r.sort(function() {
        return 0.5 - Math.random();
      });
    }, Tf = function(r) {
      if (Et(r)) return r;
      var e = nr(r) ? r : {
        each: r
      }, t = Sn(e.ease), i = e.from || 0, n = parseFloat(e.base) || 0, s = {}, a = i > 0 && i < 1, o = isNaN(i) || a, l = e.axis, c = i, u = i;
      return Vt(i) ? c = u = {
        center: 0.5,
        edges: 0.5,
        end: 1
      }[i] || 0 : !a && o && (c = i[0], u = i[1]), function(h, d, p) {
        var f = (p || e).length, _ = s[f], g, m, y, x, v, A, T, w, R;
        if (!_) {
          if (R = e.grid === "auto" ? 0 : (e.grid || [
            1,
            rr
          ])[1], !R) {
            for (T = -1e8; T < (T = p[R++].getBoundingClientRect().left) && R < f; ) ;
            R < f && R--;
          }
          for (_ = s[f] = [], g = o ? Math.min(R, f) * c - 0.5 : i % R, m = R === rr ? 0 : o ? f * u / R - 0.5 : i / R | 0, T = 0, w = rr, A = 0; A < f; A++) y = A % R - g, x = m - (A / R | 0), _[A] = v = l ? Math.abs(l === "y" ? x : y) : tf(y * y + x * x), v > T && (T = v), v < w && (w = v);
          i === "random" && Ef(_), _.max = T - w, _.min = w, _.v = f = (parseFloat(e.amount) || parseFloat(e.each) * (R > f ? f - 1 : l ? l === "y" ? f / R : R : Math.max(R, f / R)) || 0) * (i === "edges" ? -1 : 1), _.b = f < 0 ? n - f : n, _.u = Qt(e.amount || e.each) || 0, t = t && f < 0 ? Ff(t) : t;
        }
        return f = (_[h] - _.min) / _.max || 0, Dt(_.b + (t ? t(f) : f) * _.v) + _.u;
      };
    }, qu = function(r) {
      var e = Math.pow(10, ((r + "").split(".")[1] || "").length);
      return function(t) {
        var i = Dt(Math.round(parseFloat(t) / r) * r * e);
        return (i - i % 1) / e + (Sr(t) ? 0 : Qt(t));
      };
    }, wf = function(r, e) {
      var t = $t(r), i, n;
      return !t && nr(r) && (i = t = r.radius || rr, r.values ? (r = Ii(r.values), (n = !Sr(r[0])) && (i *= i)) : r = qu(r.increment)), Yr(e, t ? Et(r) ? function(s) {
        return n = r(s), Math.abs(n - s) <= i ? n : s;
      } : function(s) {
        for (var a = parseFloat(n ? s.x : s), o = parseFloat(n ? s.y : 0), l = rr, c = 0, u = r.length, h, d; u--; ) n ? (h = r[u].x - a, d = r[u].y - o, h = h * h + d * d) : h = Math.abs(r[u] - a), h < l && (l = h, c = u);
        return c = !i || l <= i ? r[c] : s, n || c === s || Sr(s) ? c : c + Qt(s);
      } : qu(r));
    }, Af = function(r, e, t, i) {
      return Yr($t(r) ? !e : t === true ? !!(t = 0) : !i, function() {
        return $t(r) ? r[~~(Math.random() * r.length)] : (t = t || 1e-5) && (i = t < 1 ? Math.pow(10, (t + "").length - 2) : 1) && Math.floor(Math.round((r - t / 2 + Math.random() * (e - r + t * 0.99)) / t) * t * i) / i;
      });
    }, OS = function() {
      for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++) e[t] = arguments[t];
      return function(i) {
        return e.reduce(function(n, s) {
          return s(n);
        }, i);
      };
    }, NS = function(r, e) {
      return function(t) {
        return r(parseFloat(t)) + (e || Qt(t));
      };
    }, FS = function(r, e, t) {
      return Cf(r, e, 0, 1, t);
    }, Rf = function(r, e, t) {
      return Yr(t, function(i) {
        return r[~~e(i)];
      });
    }, BS = function r(e, t, i) {
      var n = t - e;
      return $t(e) ? Rf(e, r(0, e.length), t) : Yr(i, function(s) {
        return (n + (s - e) % n) % n + e;
      });
    }, zS = function r(e, t, i) {
      var n = t - e, s = n * 2;
      return $t(e) ? Rf(e, r(0, e.length - 1), t) : Yr(i, function(a) {
        return a = (s + (a - e) % s) % s || 0, e + (a > n ? s - a : a);
      });
    }, Na = function(r) {
      for (var e = 0, t = "", i, n, s, a; ~(i = r.indexOf("random(", e)); ) s = r.indexOf(")", i), a = r.charAt(i + 7) === "[", n = r.substr(i + 7, s - i - 7).match(a ? af : Iu), t += r.substr(e, i - e) + Af(a ? n : +n[0], a ? 0 : +n[1], +n[2] || 1e-5), e = s + 1;
      return t + r.substr(e, r.length - e);
    }, Cf = function(r, e, t, i, n) {
      var s = e - r, a = i - t;
      return Yr(n, function(o) {
        return t + ((o - r) / s * a || 0);
      });
    }, kS = function r(e, t, i, n) {
      var s = isNaN(e + t) ? 0 : function(p) {
        return (1 - p) * e + p * t;
      };
      if (!s) {
        var a = Vt(e), o = {}, l, c, u, h, d;
        if (i === true && (n = 1) && (i = null), a) e = {
          p: e
        }, t = {
          p: t
        };
        else if ($t(e) && !$t(t)) {
          for (u = [], h = e.length, d = h - 2, c = 1; c < h; c++) u.push(r(e[c - 1], e[c]));
          h--, s = function(p) {
            p *= h;
            var f = Math.min(d, ~~p);
            return u[f](p - f);
          }, i = t;
        } else n || (e = Ds($t(e) ? [] : {}, e));
        if (!u) {
          for (l in t) Ju.call(o, e, l, "get", t[l]);
          s = function(p) {
            return ih(p, o) || (a ? e.p : e);
          };
        }
      }
      return Yr(i, s);
    }, Pf = function(r, e, t) {
      var i = r.labels, n = rr, s, a, o;
      for (s in i) a = i[s] - e, a < 0 == !!t && a && n > (a = Math.abs(a)) && (o = s, n = a);
      return o;
    }, Ei = function(r, e, t) {
      var i = r.vars, n = i[e], s = mt, a = r._ctx, o, l, c;
      if (n) return o = i[e + "Params"], l = i.callbackScope || r, t && jr.length && nl(), a && (mt = a), c = o ? n.apply(l, o) : n.call(l), mt = s, c;
    }, Fa = function(r) {
      return qr(r), r.scrollTrigger && r.scrollTrigger.kill(!!Xt), r.progress() < 1 && Ei(r, "onInterrupt"), r;
    }, Os, Lf = [], Df = function(r) {
      if (r) if (r = !r.name && r.default || r, Du() || r.headless) {
        var e = r.name, t = Et(r), i = e && !t && r.init ? function() {
          this._props = [];
        } : r, n = {
          init: Da,
          render: ih,
          add: Ju,
          kill: iE,
          modifier: tE,
          rawVars: 0
        }, s = {
          targetTest: 0,
          get: 0,
          getSetter: th,
          aliases: {},
          register: 0
        };
        if (Ns(), r !== i) {
          if (bi[e]) return;
          Si(i, Si(sl(r, n), s)), Ds(i.prototype, Ds(n, sl(r, s))), bi[i.prop = e] = i, r.targetTest && (rl.push(i), Bu[e] = 1), e = (e === "css" ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin";
        }
        cf(e, i), r.register && r.register(mi, i, fi);
      } else Lf.push(r);
    }, dt = 255, Ba = {
      aqua: [
        0,
        dt,
        dt
      ],
      lime: [
        0,
        dt,
        0
      ],
      silver: [
        192,
        192,
        192
      ],
      black: [
        0,
        0,
        0
      ],
      maroon: [
        128,
        0,
        0
      ],
      teal: [
        0,
        128,
        128
      ],
      blue: [
        0,
        0,
        dt
      ],
      navy: [
        0,
        0,
        128
      ],
      white: [
        dt,
        dt,
        dt
      ],
      olive: [
        128,
        128,
        0
      ],
      yellow: [
        dt,
        dt,
        0
      ],
      orange: [
        dt,
        165,
        0
      ],
      gray: [
        128,
        128,
        128
      ],
      purple: [
        128,
        0,
        128
      ],
      green: [
        0,
        128,
        0
      ],
      red: [
        dt,
        0,
        0
      ],
      pink: [
        dt,
        192,
        203
      ],
      cyan: [
        0,
        dt,
        dt
      ],
      transparent: [
        dt,
        dt,
        dt,
        0
      ]
    }, Yu = function(r, e, t) {
      return r += r < 0 ? 1 : r > 1 ? -1 : 0, (r * 6 < 1 ? e + (t - e) * r * 6 : r < 0.5 ? t : r * 3 < 2 ? e + (t - e) * (2 / 3 - r) * 6 : e) * dt + 0.5 | 0;
    }, If = function(r, e, t) {
      var i = r ? Sr(r) ? [
        r >> 16,
        r >> 8 & dt,
        r & dt
      ] : 0 : Ba.black, n, s, a, o, l, c, u, h, d, p;
      if (!i) {
        if (r.substr(-1) === "," && (r = r.substr(0, r.length - 1)), Ba[r]) i = Ba[r];
        else if (r.charAt(0) === "#") {
          if (r.length < 6 && (n = r.charAt(1), s = r.charAt(2), a = r.charAt(3), r = "#" + n + n + s + s + a + a + (r.length === 5 ? r.charAt(4) + r.charAt(4) : "")), r.length === 9) return i = parseInt(r.substr(1, 6), 16), [
            i >> 16,
            i >> 8 & dt,
            i & dt,
            parseInt(r.substr(7), 16) / 255
          ];
          r = parseInt(r.substr(1), 16), i = [
            r >> 16,
            r >> 8 & dt,
            r & dt
          ];
        } else if (r.substr(0, 3) === "hsl") {
          if (i = p = r.match(Iu), !e) o = +i[0] % 360 / 360, l = +i[1] / 100, c = +i[2] / 100, s = c <= 0.5 ? c * (l + 1) : c + l - c * l, n = c * 2 - s, i.length > 3 && (i[3] *= 1), i[0] = Yu(o + 1 / 3, n, s), i[1] = Yu(o, n, s), i[2] = Yu(o - 1 / 3, n, s);
          else if (~r.indexOf("=")) return i = r.match(nf), t && i.length < 4 && (i[3] = 1), i;
        } else i = r.match(Iu) || Ba.transparent;
        i = i.map(Number);
      }
      return e && !p && (n = i[0] / dt, s = i[1] / dt, a = i[2] / dt, u = Math.max(n, s, a), h = Math.min(n, s, a), c = (u + h) / 2, u === h ? o = l = 0 : (d = u - h, l = c > 0.5 ? d / (2 - u - h) : d / (u + h), o = u === n ? (s - a) / d + (s < a ? 6 : 0) : u === s ? (a - n) / d + 2 : (n - s) / d + 4, o *= 60), i[0] = ~~(o + 0.5), i[1] = ~~(l * 100 + 0.5), i[2] = ~~(c * 100 + 0.5)), t && i.length < 4 && (i[3] = 1), i;
    }, Uf = function(r) {
      var e = [], t = [], i = -1;
      return r.split(Kr).forEach(function(n) {
        var s = n.match(Ps) || [];
        e.push.apply(e, s), t.push(i += s.length + 1);
      }), e.c = t, e;
    }, Of = function(r, e, t) {
      var i = "", n = (r + i).match(Kr), s = e ? "hsla(" : "rgba(", a = 0, o, l, c, u;
      if (!n) return r;
      if (n = n.map(function(h) {
        return (h = If(h, e, 1)) && s + (e ? h[0] + "," + h[1] + "%," + h[2] + "%," + h[3] : h.join(",")) + ")";
      }), t && (c = Uf(r), o = t.c, o.join(i) !== c.c.join(i))) for (l = r.replace(Kr, "1").split(Ps), u = l.length - 1; a < u; a++) i += l[a] + (~o.indexOf(a) ? n.shift() || s + "0,0,0,0)" : (c.length ? c : n.length ? n : t).shift());
      if (!l) for (l = r.split(Kr), u = l.length - 1; a < u; a++) i += l[a] + n[a];
      return i + l[u];
    }, Kr = function() {
      var r = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e;
      for (e in Ba) r += "|" + e + "\\b";
      return new RegExp(r + ")", "gi");
    }(), HS = /hsl[a]?\(/, Nf = function(r) {
      var e = r.join(" "), t;
      if (Kr.lastIndex = 0, Kr.test(e)) return t = HS.test(e), r[1] = Of(r[1], t), r[0] = Of(r[0], t, Uf(r[1])), true;
    }, za, Ti = function() {
      var r = Date.now, e = 500, t = 33, i = r(), n = i, s = 1e3 / 240, a = s, o = [], l, c, u, h, d, p, f = function _(g) {
        var m = r() - n, y = g === true, x, v, A, T;
        if ((m > e || m < 0) && (i += m - t), n += m, A = n - i, x = A - a, (x > 0 || y) && (T = ++h.frame, d = A - h.time * 1e3, h.time = A = A / 1e3, a += x + (x >= s ? 4 : s - x), v = 1), y || (l = c(_)), v) for (p = 0; p < o.length; p++) o[p](A, d, T, g);
      };
      return h = {
        time: 0,
        frame: 0,
        tick: function() {
          f(true);
        },
        deltaRatio: function(_) {
          return d / (1e3 / (_ || 60));
        },
        wake: function() {
          of && (!Ou && Du() && (sr = Ou = window, Nu = sr.document || {}, Mi.gsap = mi, (sr.gsapVersions || (sr.gsapVersions = [])).push(mi.version), lf(tl || sr.GreenSockGlobals || !sr.gsap && sr || {}), Lf.forEach(Df)), u = typeof requestAnimationFrame < "u" && requestAnimationFrame, l && h.sleep(), c = u || function(_) {
            return setTimeout(_, a - h.time * 1e3 + 1 | 0);
          }, za = 1, f(2));
        },
        sleep: function() {
          (u ? cancelAnimationFrame : clearTimeout)(l), za = 0, c = Da;
        },
        lagSmoothing: function(_, g) {
          e = _ || 1 / 0, t = Math.min(g || 33, e);
        },
        fps: function(_) {
          s = 1e3 / (_ || 240), a = h.time * 1e3 + s;
        },
        add: function(_, g, m) {
          var y = g ? function(x, v, A, T) {
            _(x, v, A, T), h.remove(y);
          } : _;
          return h.remove(_), o[m ? "unshift" : "push"](y), Ns(), y;
        },
        remove: function(_, g) {
          ~(g = o.indexOf(_)) && o.splice(g, 1) && p >= g && p--;
        },
        _listeners: o
      }, h;
    }(), Ns = function() {
      return !za && Ti.wake();
    }, qe = {}, VS = /^[\d.\-M][\d.\-,\s]/, GS = /["']/g, WS = function(r) {
      for (var e = {}, t = r.substr(1, r.length - 3).split(":"), i = t[0], n = 1, s = t.length, a, o, l; n < s; n++) o = t[n], a = n !== s - 1 ? o.lastIndexOf(",") : o.length, l = o.substr(0, a), e[i] = isNaN(l) ? l.replace(GS, "").trim() : +l, i = o.substr(a + 1).trim();
      return e;
    }, XS = function(r) {
      var e = r.indexOf("(") + 1, t = r.indexOf(")"), i = r.indexOf("(", e);
      return r.substring(e, ~i && i < t ? r.indexOf(")", t + 1) : t);
    }, jS = function(r) {
      var e = (r + "").split("("), t = qe[e[0]];
      return t && e.length > 1 && t.config ? t.config.apply(null, ~r.indexOf("{") ? [
        WS(e[1])
      ] : XS(r).split(",").map(ff)) : qe._CE && VS.test(r) ? qe._CE("", r) : t;
    }, Ff = function(r) {
      return function(e) {
        return 1 - r(1 - e);
      };
    }, Bf = function r(e, t) {
      for (var i = e._first, n; i; ) i instanceof ci ? r(i, t) : i.vars.yoyoEase && (!i._yoyo || !i._repeat) && i._yoyo !== t && (i.timeline ? r(i.timeline, t) : (n = i._ease, i._ease = i._yEase, i._yEase = n, i._yoyo = t)), i = i._next;
    }, Sn = function(r, e) {
      return r && (Et(r) ? r : qe[r] || jS(r)) || e;
    }, En = function(r, e, t, i) {
      t === void 0 && (t = function(a) {
        return 1 - e(1 - a);
      }), i === void 0 && (i = function(a) {
        return a < 0.5 ? e(a * 2) / 2 : 1 - e((1 - a) * 2) / 2;
      });
      var n = {
        easeIn: e,
        easeOut: t,
        easeInOut: i
      }, s;
      return pi(r, function(a) {
        qe[a] = Mi[a] = n, qe[s = a.toLowerCase()] = t;
        for (var o in n) qe[s + (o === "easeIn" ? ".in" : o === "easeOut" ? ".out" : ".inOut")] = qe[a + "." + o] = n[o];
      }), n;
    }, zf = function(r) {
      return function(e) {
        return e < 0.5 ? (1 - r(1 - e * 2)) / 2 : 0.5 + r((e - 0.5) * 2) / 2;
      };
    }, Ku = function r(e, t, i) {
      var n = t >= 1 ? t : 1, s = (i || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1), a = s / Pu * (Math.asin(1 / n) || 0), o = function(c) {
        return c === 1 ? 1 : n * Math.pow(2, -10 * c) * yS((c - a) * s) + 1;
      }, l = e === "out" ? o : e === "in" ? function(c) {
        return 1 - o(1 - c);
      } : zf(o);
      return s = Pu / s, l.config = function(c, u) {
        return r(e, c, u);
      }, l;
    }, Zu = function r(e, t) {
      t === void 0 && (t = 1.70158);
      var i = function(s) {
        return s ? --s * s * ((t + 1) * s + t) + 1 : 0;
      }, n = e === "out" ? i : e === "in" ? function(s) {
        return 1 - i(1 - s);
      } : zf(i);
      return n.config = function(s) {
        return r(e, s);
      }, n;
    };
    pi("Linear,Quad,Cubic,Quart,Quint,Strong", function(r, e) {
      var t = e < 5 ? e + 1 : e;
      En(r + ",Power" + (t - 1), e ? function(i) {
        return Math.pow(i, t);
      } : function(i) {
        return i;
      }, function(i) {
        return 1 - Math.pow(1 - i, t);
      }, function(i) {
        return i < 0.5 ? Math.pow(i * 2, t) / 2 : 1 - Math.pow((1 - i) * 2, t) / 2;
      });
    }), qe.Linear.easeNone = qe.none = qe.Linear.easeIn, En("Elastic", Ku("in"), Ku("out"), Ku()), function(r, e) {
      var t = 1 / e, i = 2 * t, n = 2.5 * t, s = function(a) {
        return a < t ? r * a * a : a < i ? r * Math.pow(a - 1.5 / e, 2) + 0.75 : a < n ? r * (a -= 2.25 / e) * a + 0.9375 : r * Math.pow(a - 2.625 / e, 2) + 0.984375;
      };
      En("Bounce", function(a) {
        return 1 - s(1 - a);
      }, s);
    }(7.5625, 2.75), En("Expo", function(r) {
      return Math.pow(2, 10 * (r - 1)) * r + r * r * r * r * r * r * (1 - r);
    }), En("Circ", function(r) {
      return -(tf(1 - r * r) - 1);
    }), En("Sine", function(r) {
      return r === 1 ? 1 : -xS(r * _S) + 1;
    }), En("Back", Zu("in"), Zu("out"), Zu()), qe.SteppedEase = qe.steps = Mi.SteppedEase = {
      config: function(r, e) {
        r === void 0 && (r = 1);
        var t = 1 / r, i = r + (e ? 0 : 1), n = e ? 1 : 0, s = 1 - Jt;
        return function(a) {
          return ((i * Oa(0, s, a) | 0) + n) * t;
        };
      }
    }, Cs.ease = qe["quad.out"], pi("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(r) {
      return Hu += r + "," + r + "Params,";
    });
    var kf = function(r, e) {
      this.id = vS++, r._gsap = this, this.target = r, this.harness = e, this.get = e ? e.get : df, this.set = e ? e.getSetter : th;
    }, ka = function() {
      function r(t) {
        this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Us(this, +t.duration, 1, 1), this.data = t.data, mt && (this._ctx = mt, mt.data.push(this)), za || Ti.wake();
      }
      var e = r.prototype;
      return e.delay = function(t) {
        return t || t === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay;
      }, e.duration = function(t) {
        return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur;
      }, e.totalDuration = function(t) {
        return arguments.length ? (this._dirty = 0, Us(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
      }, e.totalTime = function(t, i) {
        if (Ns(), !arguments.length) return this._tTime;
        var n = this._dp;
        if (n && n.smoothChildTiming && this._ts) {
          for (cl(this, t), !n._dp || n.parent || xf(n, this); n && n.parent; ) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, true), n = n.parent;
          !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && ar(this._dp, this, this._start - this._delay);
        }
        return (this._tTime !== t || !this._dur && !i || this._initted && Math.abs(this._zTime) === Jt || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), pf(this, t, i)), this;
      }, e.time = function(t, i) {
        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + vf(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), i) : this._time;
      }, e.totalProgress = function(t, i) {
        return arguments.length ? this.totalTime(this.totalDuration() * t, i) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;
      }, e.progress = function(t, i) {
        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - t : t) + vf(this), i) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
      }, e.iteration = function(t, i) {
        var n = this.duration() + this._rDelay;
        return arguments.length ? this.totalTime(this._time + (t - 1) * n, i) : this._repeat ? Is(this._tTime, n) + 1 : 1;
      }, e.timeScale = function(t, i) {
        if (!arguments.length) return this._rts === -1e-8 ? 0 : this._rts;
        if (this._rts === t) return this;
        var n = this.parent && this._ts ? ol(this.parent._time, this) : this._tTime;
        return this._rts = +t || 0, this._ts = this._ps || t === -1e-8 ? 0 : this._rts, this.totalTime(Oa(-Math.abs(this._delay), this._tDur, n), i !== false), ll(this), AS(this);
      }, e.paused = function(t) {
        return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Ns(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Jt && (this._tTime -= Jt)))), this) : this._ps;
      }, e.startTime = function(t) {
        if (arguments.length) {
          this._start = t;
          var i = this.parent || this._dp;
          return i && (i._sort || !this.parent) && ar(i, this, t - this._delay), this;
        }
        return this._start;
      }, e.endTime = function(t) {
        return this._start + (di(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
      }, e.rawTime = function(t) {
        var i = this.parent || this._dp;
        return i ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? ol(i.rawTime(t), this) : this._tTime : this._tTime;
      }, e.revert = function(t) {
        t === void 0 && (t = SS);
        var i = Xt;
        return Xt = t, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(t), this.totalTime(-0.01, t.suppressEvents)), this.data !== "nested" && t.kill !== false && this.kill(), Xt = i, this;
      }, e.globalTime = function(t) {
        for (var i = this, n = arguments.length ? t : i.rawTime(); i; ) n = i._start + n / (Math.abs(i._ts) || 1), i = i._dp;
        return !this.parent && this._sat ? this._sat.globalTime(t) : n;
      }, e.repeat = function(t) {
        return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t, bf(this)) : this._repeat === -2 ? 1 / 0 : this._repeat;
      }, e.repeatDelay = function(t) {
        if (arguments.length) {
          var i = this._time;
          return this._rDelay = t, bf(this), i ? this.time(i) : this;
        }
        return this._rDelay;
      }, e.yoyo = function(t) {
        return arguments.length ? (this._yoyo = t, this) : this._yoyo;
      }, e.seek = function(t, i) {
        return this.totalTime(Di(this, t), di(i));
      }, e.restart = function(t, i) {
        return this.play().totalTime(t ? -this._delay : 0, di(i)), this._dur || (this._zTime = -1e-8), this;
      }, e.play = function(t, i) {
        return t != null && this.seek(t, i), this.reversed(false).paused(false);
      }, e.reverse = function(t, i) {
        return t != null && this.seek(t || this.totalDuration(), i), this.reversed(true).paused(false);
      }, e.pause = function(t, i) {
        return t != null && this.seek(t, i), this.paused(true);
      }, e.resume = function() {
        return this.paused(false);
      }, e.reversed = function(t) {
        return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0;
      }, e.invalidate = function() {
        return this._initted = this._act = 0, this._zTime = -1e-8, this;
      }, e.isActive = function() {
        var t = this.parent || this._dp, i = this._start, n;
        return !!(!t || this._ts && this._initted && t.isActive() && (n = t.rawTime(true)) >= i && n < this.endTime(true) - Jt);
      }, e.eventCallback = function(t, i, n) {
        var s = this.vars;
        return arguments.length > 1 ? (i ? (s[t] = i, n && (s[t + "Params"] = n), t === "onUpdate" && (this._onUpdate = i)) : delete s[t], this) : s[t];
      }, e.then = function(t) {
        var i = this;
        return new Promise(function(n) {
          var s = Et(t) ? t : mf, a = function() {
            var o = i.then;
            i.then = null, Et(s) && (s = s(i)) && (s.then || s === i) && (i.then = o), n(s), i.then = o;
          };
          i._initted && i.totalProgress() === 1 && i._ts >= 0 || !i._tTime && i._ts < 0 ? a() : i._prom = a;
        });
      }, e.kill = function() {
        Fa(this);
      }, r;
    }();
    Si(ka.prototype, {
      _time: 0,
      _start: 0,
      _end: 0,
      _tTime: 0,
      _tDur: 0,
      _dirty: 0,
      _repeat: 0,
      _yoyo: false,
      parent: null,
      _initted: false,
      _rDelay: 0,
      _ts: 1,
      _dp: 0,
      ratio: 0,
      _zTime: -1e-8,
      _prom: 0,
      _ps: false,
      _rts: 1
    });
    var ci = function(r) {
      ef(e, r);
      function e(i, n) {
        var s;
        return i === void 0 && (i = {}), s = r.call(this, i) || this, s.labels = {}, s.smoothChildTiming = !!i.smoothChildTiming, s.autoRemoveChildren = !!i.autoRemoveChildren, s._sort = di(i.sortChildren), Mt && ar(i.parent || Mt, br(s), n), i.reversed && s.reverse(), i.paused && s.paused(true), i.scrollTrigger && yf(br(s), i.scrollTrigger), s;
      }
      var t = e.prototype;
      return t.to = function(i, n, s) {
        return Ua(0, arguments, this), this;
      }, t.from = function(i, n, s) {
        return Ua(1, arguments, this), this;
      }, t.fromTo = function(i, n, s, a) {
        return Ua(2, arguments, this), this;
      }, t.set = function(i, n, s) {
        return n.duration = 0, n.parent = this, Ia(n).repeatDelay || (n.repeat = 0), n.immediateRender = !!n.immediateRender, new It(i, n, Di(this, s), 1), this;
      }, t.call = function(i, n, s) {
        return ar(this, It.delayedCall(0, i, n), s);
      }, t.staggerTo = function(i, n, s, a, o, l, c) {
        return s.duration = n, s.stagger = s.stagger || a, s.onComplete = l, s.onCompleteParams = c, s.parent = this, new It(i, s, Di(this, o)), this;
      }, t.staggerFrom = function(i, n, s, a, o, l, c) {
        return s.runBackwards = 1, Ia(s).immediateRender = di(s.immediateRender), this.staggerTo(i, n, s, a, o, l, c);
      }, t.staggerFromTo = function(i, n, s, a, o, l, c, u) {
        return a.startAt = s, Ia(a).immediateRender = di(a.immediateRender), this.staggerTo(i, n, a, o, l, c, u);
      }, t.render = function(i, n, s) {
        var a = this._time, o = this._dirty ? this.totalDuration() : this._tDur, l = this._dur, c = i <= 0 ? 0 : Dt(i), u = this._zTime < 0 != i < 0 && (this._initted || !l), h, d, p, f, _, g, m, y, x, v, A, T;
        if (this !== Mt && c > o && i >= 0 && (c = o), c !== this._tTime || s || u) {
          if (a !== this._time && l && (c += this._time - a, i += this._time - a), h = c, x = this._start, y = this._ts, g = !y, u && (l || (a = this._zTime), (i || !n) && (this._zTime = i)), this._repeat) {
            if (A = this._yoyo, _ = l + this._rDelay, this._repeat < -1 && i < 0) return this.totalTime(_ * 100 + i, n, s);
            if (h = Dt(c % _), c === o ? (f = this._repeat, h = l) : (v = Dt(c / _), f = ~~v, f && f === v && (h = l, f--), h > l && (h = l)), v = Is(this._tTime, _), !a && this._tTime && v !== f && this._tTime - v * _ - this._dur <= 0 && (v = f), A && f & 1 && (h = l - h, T = 1), f !== v && !this._lock) {
              var w = A && v & 1, R = w === (A && f & 1);
              if (f < v && (w = !w), a = w ? 0 : c % l ? l : c, this._lock = 1, this.render(a || (T ? 0 : Dt(f * _)), n, !l)._lock = 0, this._tTime = c, !n && this.parent && Ei(this, "onRepeat"), this.vars.repeatRefresh && !T && (this.invalidate()._lock = 1), a && a !== this._time || g !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
              if (l = this._dur, o = this._tDur, R && (this._lock = 2, a = w ? l : -1e-4, this.render(a, true), this.vars.repeatRefresh && !T && this.invalidate()), this._lock = 0, !this._ts && !g) return this;
              Bf(this, T);
            }
          }
          if (this._hasPause && !this._forcing && this._lock < 2 && (m = LS(this, Dt(a), Dt(h)), m && (c -= h - (h = m._start))), this._tTime = c, this._time = h, this._act = !y, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = i, a = 0), !a && h && !n && !f && (Ei(this, "onStart"), this._tTime !== c)) return this;
          if (h >= a && i >= 0) for (d = this._first; d; ) {
            if (p = d._next, (d._act || h >= d._start) && d._ts && m !== d) {
              if (d.parent !== this) return this.render(i, n, s);
              if (d.render(d._ts > 0 ? (h - d._start) * d._ts : (d._dirty ? d.totalDuration() : d._tDur) + (h - d._start) * d._ts, n, s), h !== this._time || !this._ts && !g) {
                m = 0, p && (c += this._zTime = -1e-8);
                break;
              }
            }
            d = p;
          }
          else {
            d = this._last;
            for (var E = i < 0 ? i : h; d; ) {
              if (p = d._prev, (d._act || E <= d._end) && d._ts && m !== d) {
                if (d.parent !== this) return this.render(i, n, s);
                if (d.render(d._ts > 0 ? (E - d._start) * d._ts : (d._dirty ? d.totalDuration() : d._tDur) + (E - d._start) * d._ts, n, s || Xt && (d._initted || d._startAt)), h !== this._time || !this._ts && !g) {
                  m = 0, p && (c += this._zTime = E ? -1e-8 : Jt);
                  break;
                }
              }
              d = p;
            }
          }
          if (m && !n && (this.pause(), m.render(h >= a ? 0 : -1e-8)._zTime = h >= a ? 1 : -1, this._ts)) return this._start = x, ll(this), this.render(i, n, s);
          this._onUpdate && !n && Ei(this, "onUpdate", true), (c === o && this._tTime >= this.totalDuration() || !c && a) && (x === this._start || Math.abs(y) !== Math.abs(this._ts)) && (this._lock || ((i || !l) && (c === o && this._ts > 0 || !c && this._ts < 0) && qr(this, 1), !n && !(i < 0 && !a) && (c || a || !o) && (Ei(this, c === o && i >= 0 ? "onComplete" : "onReverseComplete", true), this._prom && !(c < o && this.timeScale() > 0) && this._prom())));
        }
        return this;
      }, t.add = function(i, n) {
        var s = this;
        if (Sr(n) || (n = Di(this, n, i)), !(i instanceof ka)) {
          if ($t(i)) return i.forEach(function(a) {
            return s.add(a, n);
          }), this;
          if (Vt(i)) return this.addLabel(i, n);
          if (Et(i)) i = It.delayedCall(0, i);
          else return this;
        }
        return this !== i ? ar(this, i, n) : this;
      }, t.getChildren = function(i, n, s, a) {
        i === void 0 && (i = true), n === void 0 && (n = true), s === void 0 && (s = true), a === void 0 && (a = -1e8);
        for (var o = [], l = this._first; l; ) l._start >= a && (l instanceof It ? n && o.push(l) : (s && o.push(l), i && o.push.apply(o, l.getChildren(true, n, s)))), l = l._next;
        return o;
      }, t.getById = function(i) {
        for (var n = this.getChildren(1, 1, 1), s = n.length; s--; ) if (n[s].vars.id === i) return n[s];
      }, t.remove = function(i) {
        return Vt(i) ? this.removeLabel(i) : Et(i) ? this.killTweensOf(i) : (i.parent === this && al(this, i), i === this._recent && (this._recent = this._last), bn(this));
      }, t.totalTime = function(i, n) {
        return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Dt(Ti.time - (this._ts > 0 ? i / this._ts : (this.totalDuration() - i) / -this._ts))), r.prototype.totalTime.call(this, i, n), this._forcing = 0, this) : this._tTime;
      }, t.addLabel = function(i, n) {
        return this.labels[i] = Di(this, n), this;
      }, t.removeLabel = function(i) {
        return delete this.labels[i], this;
      }, t.addPause = function(i, n, s) {
        var a = It.delayedCall(0, n || Da, s);
        return a.data = "isPause", this._hasPause = 1, ar(this, a, Di(this, i));
      }, t.removePause = function(i) {
        var n = this._first;
        for (i = Di(this, i); n; ) n._start === i && n.data === "isPause" && qr(n), n = n._next;
      }, t.killTweensOf = function(i, n, s) {
        for (var a = this.getTweensOf(i, s), o = a.length; o--; ) Zr !== a[o] && a[o].kill(i, n);
        return this;
      }, t.getTweensOf = function(i, n) {
        for (var s = [], a = Ii(i), o = this._first, l = Sr(n), c; o; ) o instanceof It ? ES(o._targets, a) && (l ? (!Zr || o._initted && o._ts) && o.globalTime(0) <= n && o.globalTime(o.totalDuration()) > n : !n || o.isActive()) && s.push(o) : (c = o.getTweensOf(a, n)).length && s.push.apply(s, c), o = o._next;
        return s;
      }, t.tweenTo = function(i, n) {
        n = n || {};
        var s = this, a = Di(s, i), o = n, l = o.startAt, c = o.onStart, u = o.onStartParams, h = o.immediateRender, d, p = It.to(s, Si({
          ease: n.ease || "none",
          lazy: false,
          immediateRender: false,
          time: a,
          overwrite: "auto",
          duration: n.duration || Math.abs((a - (l && "time" in l ? l.time : s._time)) / s.timeScale()) || Jt,
          onStart: function() {
            if (s.pause(), !d) {
              var f = n.duration || Math.abs((a - (l && "time" in l ? l.time : s._time)) / s.timeScale());
              p._dur !== f && Us(p, f, 0, 1).render(p._time, true, true), d = 1;
            }
            c && c.apply(p, u || []);
          }
        }, n));
        return h ? p.render(0) : p;
      }, t.tweenFromTo = function(i, n, s) {
        return this.tweenTo(n, Si({
          startAt: {
            time: Di(this, i)
          }
        }, s));
      }, t.recent = function() {
        return this._recent;
      }, t.nextLabel = function(i) {
        return i === void 0 && (i = this._time), Pf(this, Di(this, i));
      }, t.previousLabel = function(i) {
        return i === void 0 && (i = this._time), Pf(this, Di(this, i), 1);
      }, t.currentLabel = function(i) {
        return arguments.length ? this.seek(i, true) : this.previousLabel(this._time + Jt);
      }, t.shiftChildren = function(i, n, s) {
        s === void 0 && (s = 0);
        for (var a = this._first, o = this.labels, l; a; ) a._start >= s && (a._start += i, a._end += i), a = a._next;
        if (n) for (l in o) o[l] >= s && (o[l] += i);
        return bn(this);
      }, t.invalidate = function(i) {
        var n = this._first;
        for (this._lock = 0; n; ) n.invalidate(i), n = n._next;
        return r.prototype.invalidate.call(this, i);
      }, t.clear = function(i) {
        i === void 0 && (i = true);
        for (var n = this._first, s; n; ) s = n._next, this.remove(n), n = s;
        return this._dp && (this._time = this._tTime = this._pTime = 0), i && (this.labels = {}), bn(this);
      }, t.totalDuration = function(i) {
        var n = 0, s = this, a = s._last, o = rr, l, c, u;
        if (arguments.length) return s.timeScale((s._repeat < 0 ? s.duration() : s.totalDuration()) / (s.reversed() ? -i : i));
        if (s._dirty) {
          for (u = s.parent; a; ) l = a._prev, a._dirty && a.totalDuration(), c = a._start, c > o && s._sort && a._ts && !s._lock ? (s._lock = 1, ar(s, a, c - a._delay, 1)._lock = 0) : o = c, c < 0 && a._ts && (n -= c, (!u && !s._dp || u && u.smoothChildTiming) && (s._start += c / s._ts, s._time -= c, s._tTime -= c), s.shiftChildren(-c, false, -1 / 0), o = 0), a._end > n && a._ts && (n = a._end), a = l;
          Us(s, s === Mt && s._time > n ? s._time : n, 1, 1), s._dirty = 0;
        }
        return s._tDur;
      }, e.updateRoot = function(i) {
        if (Mt._ts && (pf(Mt, ol(i, Mt)), uf = Ti.frame), Ti.frame >= hf) {
          hf += yi.autoSleep || 120;
          var n = Mt._first;
          if ((!n || !n._ts) && yi.autoSleep && Ti._listeners.length < 2) {
            for (; n && !n._ts; ) n = n._next;
            n || Ti.sleep();
          }
        }
      }, e;
    }(ka);
    Si(ci.prototype, {
      _lock: 0,
      _hasPause: 0,
      _forcing: 0
    });
    var qS = function(r, e, t, i, n, s, a) {
      var o = new fi(this._pt, r, e, 0, 1, jf, null, n), l = 0, c = 0, u, h, d, p, f, _, g, m;
      for (o.b = t, o.e = i, t += "", i += "", (g = ~i.indexOf("random(")) && (i = Na(i)), s && (m = [
        t,
        i
      ], s(m, r, e), t = m[0], i = m[1]), h = t.match(Uu) || []; u = Uu.exec(i); ) p = u[0], f = i.substring(l, u.index), d ? d = (d + 1) % 5 : f.substr(-5) === "rgba(" && (d = 1), p !== h[c++] && (_ = parseFloat(h[c - 1]) || 0, o._pt = {
        _next: o._pt,
        p: f || c === 1 ? f : ",",
        s: _,
        c: p.charAt(1) === "=" ? Ls(_, p) - _ : parseFloat(p) - _,
        m: d && d < 4 ? Math.round : 0
      }, l = Uu.lastIndex);
      return o.c = l < i.length ? i.substring(l, i.length) : "", o.fp = a, (sf.test(i) || g) && (o.e = 0), this._pt = o, o;
    }, Ju = function(r, e, t, i, n, s, a, o, l, c) {
      Et(i) && (i = i(n || 0, r, s));
      var u = r[e], h = t !== "get" ? t : Et(u) ? l ? r[e.indexOf("set") || !Et(r["get" + e.substr(3)]) ? e : "get" + e.substr(3)](l) : r[e]() : u, d = Et(u) ? l ? $S : Wf : eh, p;
      if (Vt(i) && (~i.indexOf("random(") && (i = Na(i)), i.charAt(1) === "=" && (p = Ls(h, i) + (Qt(h) || 0), (p || p === 0) && (i = p))), !c || h !== i || $u) return !isNaN(h * i) && i !== "" ? (p = new fi(this._pt, r, e, +h || 0, i - (h || 0), typeof u == "boolean" ? eE : Xf, 0, d), l && (p.fp = l), a && p.modifier(a, this, r), this._pt = p) : (!u && !(e in r) && Fu(e, i), qS.call(this, r, e, h, i, d, o || yi.stringFilter, l));
    }, YS = function(r, e, t, i, n) {
      if (Et(r) && (r = Ha(r, n, e, t, i)), !nr(r) || r.style && r.nodeType || $t(r) || rf(r)) return Vt(r) ? Ha(r, n, e, t, i) : r;
      var s = {}, a;
      for (a in r) s[a] = Ha(r[a], n, e, t, i);
      return s;
    }, Hf = function(r, e, t, i, n, s) {
      var a, o, l, c;
      if (bi[r] && (a = new bi[r]()).init(n, a.rawVars ? e[r] : YS(e[r], i, n, s, t), t, i, s) !== false && (t._pt = o = new fi(t._pt, n, r, 0, 1, a.render, a, 0, a.priority), t !== Os)) for (l = t._ptLookup[t._targets.indexOf(n)], c = a._props.length; c--; ) l[a._props[c]] = o;
      return a;
    }, Zr, $u, Qu = function r(e, t, i) {
      var n = e.vars, s = n.ease, a = n.startAt, o = n.immediateRender, l = n.lazy, c = n.onUpdate, u = n.runBackwards, h = n.yoyoEase, d = n.keyframes, p = n.autoRevert, f = e._dur, _ = e._startAt, g = e._targets, m = e.parent, y = m && m.data === "nested" ? m.vars.targets : g, x = e._overwrite === "auto" && !Cu, v = e.timeline, A, T, w, R, E, b, L, B, F, V, X, k, K;
      if (v && (!d || !s) && (s = "none"), e._ease = Sn(s, Cs.ease), e._yEase = h ? Ff(Sn(h === true ? s : h, Cs.ease)) : 0, h && e._yoyo && !e._repeat && (h = e._yEase, e._yEase = e._ease, e._ease = h), e._from = !v && !!n.runBackwards, !v || d && !n.stagger) {
        if (B = g[0] ? Mn(g[0]).harness : 0, k = B && n[B.prop], A = sl(n, Bu), _ && (_._zTime < 0 && _.progress(1), t < 0 && u && o && !p ? _.render(-1, true) : _.revert(u && f ? il : bS), _._lazy = 0), a) {
          if (qr(e._startAt = It.set(g, Si({
            data: "isStart",
            overwrite: false,
            parent: m,
            immediateRender: true,
            lazy: !_ && di(l),
            startAt: null,
            delay: 0,
            onUpdate: c && function() {
              return Ei(e, "onUpdate");
            },
            stagger: 0
          }, a))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (Xt || !o && !p) && e._startAt.revert(il), o && f && t <= 0 && i <= 0) {
            t && (e._zTime = t);
            return;
          }
        } else if (u && f && !_) {
          if (t && (o = false), w = Si({
            overwrite: false,
            data: "isFromStart",
            lazy: o && !_ && di(l),
            immediateRender: o,
            stagger: 0,
            parent: m
          }, A), k && (w[B.prop] = k), qr(e._startAt = It.set(g, w)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (Xt ? e._startAt.revert(il) : e._startAt.render(-1, true)), e._zTime = t, !o) r(e._startAt, Jt, Jt);
          else if (!t) return;
        }
        for (e._pt = e._ptCache = 0, l = f && di(l) || l && !f, T = 0; T < g.length; T++) {
          if (E = g[T], L = E._gsap || Vu(g)[T]._gsap, e._ptLookup[T] = V = {}, zu[L.id] && jr.length && nl(), X = y === g ? T : y.indexOf(E), B && (F = new B()).init(E, k || A, e, X, y) !== false && (e._pt = R = new fi(e._pt, E, F.name, 0, 1, F.render, F, 0, F.priority), F._props.forEach(function(G) {
            V[G] = R;
          }), F.priority && (b = 1)), !B || k) for (w in A) bi[w] && (F = Hf(w, A, e, X, E, y)) ? F.priority && (b = 1) : V[w] = R = Ju.call(e, E, w, "get", A[w], X, y, 0, n.stringFilter);
          e._op && e._op[T] && e.kill(E, e._op[T]), x && e._pt && (Zr = e, Mt.killTweensOf(E, V, e.globalTime(t)), K = !e.parent, Zr = 0), e._pt && l && (zu[L.id] = 1);
        }
        b && qf(e), e._onInit && e._onInit(e);
      }
      e._onUpdate = c, e._initted = (!e._op || e._pt) && !K, d && t <= 0 && v.render(rr, true, true);
    }, KS = function(r, e, t, i, n, s, a, o) {
      var l = (r._pt && r._ptCache || (r._ptCache = {}))[e], c, u, h, d;
      if (!l) for (l = r._ptCache[e] = [], h = r._ptLookup, d = r._targets.length; d--; ) {
        if (c = h[d][e], c && c.d && c.d._pt) for (c = c.d._pt; c && c.p !== e && c.fp !== e; ) c = c._next;
        if (!c) return $u = 1, r.vars[e] = "+=0", Qu(r, a), $u = 0, o ? La(e + " not eligible for reset") : 1;
        l.push(c);
      }
      for (d = l.length; d--; ) u = l[d], c = u._pt || u, c.s = (i || i === 0) && !n ? i : c.s + (i || 0) + s * c.c, c.c = t - c.s, u.e && (u.e = Ct(t) + Qt(u.e)), u.b && (u.b = c.s + Qt(u.b));
    }, ZS = function(r, e) {
      var t = r[0] ? Mn(r[0]).harness : 0, i = t && t.aliases, n, s, a, o;
      if (!i) return e;
      n = Ds({}, e);
      for (s in i) if (s in n) for (o = i[s].split(","), a = o.length; a--; ) n[o[a]] = n[s];
      return n;
    }, JS = function(r, e, t, i) {
      var n = e.ease || i || "power1.inOut", s, a;
      if ($t(e)) a = t[r] || (t[r] = []), e.forEach(function(o, l) {
        return a.push({
          t: l / (e.length - 1) * 100,
          v: o,
          e: n
        });
      });
      else for (s in e) a = t[s] || (t[s] = []), s === "ease" || a.push({
        t: parseFloat(r),
        v: e[s],
        e: n
      });
    }, Ha = function(r, e, t, i, n) {
      return Et(r) ? r.call(e, t, i, n) : Vt(r) && ~r.indexOf("random(") ? Na(r) : r;
    }, Vf = Hu + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", Gf = {};
    pi(Vf + ",id,stagger,delay,duration,paused,scrollTrigger", function(r) {
      return Gf[r] = 1;
    });
    var It = function(r) {
      ef(e, r);
      function e(i, n, s, a) {
        var o;
        typeof n == "number" && (s.duration = n, n = s, s = null), o = r.call(this, a ? n : Ia(n)) || this;
        var l = o.vars, c = l.duration, u = l.delay, h = l.immediateRender, d = l.stagger, p = l.overwrite, f = l.keyframes, _ = l.defaults, g = l.scrollTrigger, m = l.yoyoEase, y = n.parent || Mt, x = ($t(i) || rf(i) ? Sr(i[0]) : "length" in n) ? [
          i
        ] : Ii(i), v, A, T, w, R, E, b, L;
        if (o._targets = x.length ? Vu(x) : La("GSAP target " + i + " not found. https://gsap.com", !yi.nullTargetWarn) || [], o._ptLookup = [], o._overwrite = p, f || d || el(c) || el(u)) {
          if (n = o.vars, v = o.timeline = new ci({
            data: "nested",
            defaults: _ || {},
            targets: y && y.data === "nested" ? y.vars.targets : x
          }), v.kill(), v.parent = v._dp = br(o), v._start = 0, d || el(c) || el(u)) {
            if (w = x.length, b = d && Tf(d), nr(d)) for (R in d) ~Vf.indexOf(R) && (L || (L = {}), L[R] = d[R]);
            for (A = 0; A < w; A++) T = sl(n, Gf), T.stagger = 0, m && (T.yoyoEase = m), L && Ds(T, L), E = x[A], T.duration = +Ha(c, br(o), A, E, x), T.delay = (+Ha(u, br(o), A, E, x) || 0) - o._delay, !d && w === 1 && T.delay && (o._delay = u = T.delay, o._start += u, T.delay = 0), v.to(E, T, b ? b(A, E, x) : 0), v._ease = qe.none;
            v.duration() ? c = u = 0 : o.timeline = 0;
          } else if (f) {
            Ia(Si(v.vars.defaults, {
              ease: "none"
            })), v._ease = Sn(f.ease || n.ease || "none");
            var B = 0, F, V, X;
            if ($t(f)) f.forEach(function(k) {
              return v.to(x, k, ">");
            }), v.duration();
            else {
              T = {};
              for (R in f) R === "ease" || R === "easeEach" || JS(R, f[R], T, f.easeEach);
              for (R in T) for (F = T[R].sort(function(k, K) {
                return k.t - K.t;
              }), B = 0, A = 0; A < F.length; A++) V = F[A], X = {
                ease: V.e,
                duration: (V.t - (A ? F[A - 1].t : 0)) / 100 * c
              }, X[R] = V.v, v.to(x, X, B), B += X.duration;
              v.duration() < c && v.to({}, {
                duration: c - v.duration()
              });
            }
          }
          c || o.duration(c = v.duration());
        } else o.timeline = 0;
        return p === true && !Cu && (Zr = br(o), Mt.killTweensOf(x), Zr = 0), ar(y, br(o), s), n.reversed && o.reverse(), n.paused && o.paused(true), (h || !c && !f && o._start === Dt(y._time) && di(h) && RS(br(o)) && y.data !== "nested") && (o._tTime = -1e-8, o.render(Math.max(0, -u) || 0)), g && yf(br(o), g), o;
      }
      var t = e.prototype;
      return t.render = function(i, n, s) {
        var a = this._time, o = this._tDur, l = this._dur, c = i < 0, u = i > o - Jt && !c ? o : i < Jt ? 0 : i, h, d, p, f, _, g, m, y, x;
        if (!l) PS(this, i, n, s);
        else if (u !== this._tTime || !i || s || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== c || this._lazy) {
          if (h = u, y = this.timeline, this._repeat) {
            if (f = l + this._rDelay, this._repeat < -1 && c) return this.totalTime(f * 100 + i, n, s);
            if (h = Dt(u % f), u === o ? (p = this._repeat, h = l) : (_ = Dt(u / f), p = ~~_, p && p === _ ? (h = l, p--) : h > l && (h = l)), g = this._yoyo && p & 1, g && (x = this._yEase, h = l - h), _ = Is(this._tTime, f), h === a && !s && this._initted && p === _) return this._tTime = u, this;
            p !== _ && (y && this._yEase && Bf(y, g), this.vars.repeatRefresh && !g && !this._lock && h !== f && this._initted && (this._lock = s = 1, this.render(Dt(f * p), true).invalidate()._lock = 0));
          }
          if (!this._initted) {
            if (Mf(this, c ? i : h, s, n, u)) return this._tTime = 0, this;
            if (a !== this._time && !(s && this.vars.repeatRefresh && p !== _)) return this;
            if (l !== this._dur) return this.render(i, n, s);
          }
          if (this._tTime = u, this._time = h, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = m = (x || this._ease)(h / l), this._from && (this.ratio = m = 1 - m), h && !a && !n && !p && (Ei(this, "onStart"), this._tTime !== u)) return this;
          for (d = this._pt; d; ) d.r(m, d.d), d = d._next;
          y && y.render(i < 0 ? i : y._dur * y._ease(h / this._dur), n, s) || this._startAt && (this._zTime = i), this._onUpdate && !n && (c && Gu(this, i, n, s), Ei(this, "onUpdate")), this._repeat && p !== _ && this.vars.onRepeat && !n && this.parent && Ei(this, "onRepeat"), (u === this._tDur || !u) && this._tTime === u && (c && !this._onUpdate && Gu(this, i, true, true), (i || !l) && (u === this._tDur && this._ts > 0 || !u && this._ts < 0) && qr(this, 1), !n && !(c && !a) && (u || a || g) && (Ei(this, u === o ? "onComplete" : "onReverseComplete", true), this._prom && !(u < o && this.timeScale() > 0) && this._prom()));
        }
        return this;
      }, t.targets = function() {
        return this._targets;
      }, t.invalidate = function(i) {
        return (!i || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(i), r.prototype.invalidate.call(this, i);
      }, t.resetTo = function(i, n, s, a, o) {
        za || Ti.wake(), this._ts || this.play();
        var l = Math.min(this._dur, (this._dp._time - this._start) * this._ts), c;
        return this._initted || Qu(this, l), c = this._ease(l / this._dur), KS(this, i, n, s, a, c, l, o) ? this.resetTo(i, n, s, a, 1) : (cl(this, 0), this.parent || _f(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0));
      }, t.kill = function(i, n) {
        if (n === void 0 && (n = "all"), !i && (!n || n === "all")) return this._lazy = this._pt = 0, this.parent ? Fa(this) : this.scrollTrigger && this.scrollTrigger.kill(!!Xt), this;
        if (this.timeline) {
          var s = this.timeline.totalDuration();
          return this.timeline.killTweensOf(i, n, Zr && Zr.vars.overwrite !== true)._first || Fa(this), this.parent && s !== this.timeline.totalDuration() && Us(this, this._dur * this.timeline._tDur / s, 0, 1), this;
        }
        var a = this._targets, o = i ? Ii(i) : a, l = this._ptLookup, c = this._pt, u, h, d, p, f, _, g;
        if ((!n || n === "all") && wS(a, o)) return n === "all" && (this._pt = 0), Fa(this);
        for (u = this._op = this._op || [], n !== "all" && (Vt(n) && (f = {}, pi(n, function(m) {
          return f[m] = 1;
        }), n = f), n = ZS(a, n)), g = a.length; g--; ) if (~o.indexOf(a[g])) {
          h = l[g], n === "all" ? (u[g] = n, p = h, d = {}) : (d = u[g] = u[g] || {}, p = n);
          for (f in p) _ = h && h[f], _ && ((!("kill" in _.d) || _.d.kill(f) === true) && al(this, _, "_pt"), delete h[f]), d !== "all" && (d[f] = 1);
        }
        return this._initted && !this._pt && c && Fa(this), this;
      }, e.to = function(i, n) {
        return new e(i, n, arguments[2]);
      }, e.from = function(i, n) {
        return Ua(1, arguments);
      }, e.delayedCall = function(i, n, s, a) {
        return new e(n, 0, {
          immediateRender: false,
          lazy: false,
          overwrite: false,
          delay: i,
          onComplete: n,
          onReverseComplete: n,
          onCompleteParams: s,
          onReverseCompleteParams: s,
          callbackScope: a
        });
      }, e.fromTo = function(i, n, s) {
        return Ua(2, arguments);
      }, e.set = function(i, n) {
        return n.duration = 0, n.repeatDelay || (n.repeat = 0), new e(i, n);
      }, e.killTweensOf = function(i, n, s) {
        return Mt.killTweensOf(i, n, s);
      }, e;
    }(ka);
    Si(It.prototype, {
      _targets: [],
      _lazy: 0,
      _startAt: 0,
      _op: 0,
      _onInit: 0
    }), pi("staggerTo,staggerFrom,staggerFromTo", function(r) {
      It[r] = function() {
        var e = new ci(), t = Xu.call(arguments, 0);
        return t.splice(r === "staggerFromTo" ? 5 : 4, 0, 0), e[r].apply(e, t);
      };
    });
    var eh = function(r, e, t) {
      return r[e] = t;
    }, Wf = function(r, e, t) {
      return r[e](t);
    }, $S = function(r, e, t, i) {
      return r[e](i.fp, t);
    }, QS = function(r, e, t) {
      return r.setAttribute(e, t);
    }, th = function(r, e) {
      return Et(r[e]) ? Wf : Lu(r[e]) && r.setAttribute ? QS : eh;
    }, Xf = function(r, e) {
      return e.set(e.t, e.p, Math.round((e.s + e.c * r) * 1e6) / 1e6, e);
    }, eE = function(r, e) {
      return e.set(e.t, e.p, !!(e.s + e.c * r), e);
    }, jf = function(r, e) {
      var t = e._pt, i = "";
      if (!r && e.b) i = e.b;
      else if (r === 1 && e.e) i = e.e;
      else {
        for (; t; ) i = t.p + (t.m ? t.m(t.s + t.c * r) : Math.round((t.s + t.c * r) * 1e4) / 1e4) + i, t = t._next;
        i += e.c;
      }
      e.set(e.t, e.p, i, e);
    }, ih = function(r, e) {
      for (var t = e._pt; t; ) t.r(r, t.d), t = t._next;
    }, tE = function(r, e, t, i) {
      for (var n = this._pt, s; n; ) s = n._next, n.p === i && n.modifier(r, e, t), n = s;
    }, iE = function(r) {
      for (var e = this._pt, t, i; e; ) i = e._next, e.p === r && !e.op || e.op === r ? al(this, e, "_pt") : e.dep || (t = 1), e = i;
      return !t;
    }, rE = function(r, e, t, i) {
      i.mSet(r, e, i.m.call(i.tween, t, i.mt), i);
    }, qf = function(r) {
      for (var e = r._pt, t, i, n, s; e; ) {
        for (t = e._next, i = n; i && i.pr > e.pr; ) i = i._next;
        (e._prev = i ? i._prev : s) ? e._prev._next = e : n = e, (e._next = i) ? i._prev = e : s = e, e = t;
      }
      r._pt = n;
    }, fi = function() {
      function r(t, i, n, s, a, o, l, c, u) {
        this.t = i, this.s = s, this.c = a, this.p = n, this.r = o || Xf, this.d = l || this, this.set = c || eh, this.pr = u || 0, this._next = t, t && (t._prev = this);
      }
      var e = r.prototype;
      return e.modifier = function(t, i, n) {
        this.mSet = this.mSet || this.set, this.set = rE, this.m = t, this.mt = n, this.tween = i;
      }, r;
    }();
    pi(Hu + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(r) {
      return Bu[r] = 1;
    }), Mi.TweenMax = Mi.TweenLite = It, Mi.TimelineLite = Mi.TimelineMax = ci, Mt = new ci({
      sortChildren: false,
      defaults: Cs,
      autoRemoveChildren: true,
      id: "root",
      smoothChildTiming: true
    }), yi.stringFilter = Nf;
    var Tn = [], ul = {}, nE = [], Yf = 0, sE = 0, rh = function(r) {
      return (ul[r] || nE).map(function(e) {
        return e();
      });
    }, nh = function() {
      var r = Date.now(), e = [];
      r - Yf > 2 && (rh("matchMediaInit"), Tn.forEach(function(t) {
        var i = t.queries, n = t.conditions, s, a, o, l;
        for (a in i) s = sr.matchMedia(i[a]).matches, s && (o = 1), s !== n[a] && (n[a] = s, l = 1);
        l && (t.revert(), o && e.push(t));
      }), rh("matchMediaRevert"), e.forEach(function(t) {
        return t.onMatch(t, function(i) {
          return t.add(null, i);
        });
      }), Yf = r, rh("matchMedia"));
    }, Kf = function() {
      function r(t, i) {
        this.selector = i && ju(i), this.data = [], this._r = [], this.isReverted = false, this.id = sE++, t && this.add(t);
      }
      var e = r.prototype;
      return e.add = function(t, i, n) {
        Et(t) && (n = i, i = t, t = Et);
        var s = this, a = function() {
          var o = mt, l = s.selector, c;
          return o && o !== s && o.data.push(s), n && (s.selector = ju(n)), mt = s, c = i.apply(s, arguments), Et(c) && s._r.push(c), mt = o, s.selector = l, s.isReverted = false, c;
        };
        return s.last = a, t === Et ? a(s, function(o) {
          return s.add(null, o);
        }) : t ? s[t] = a : a;
      }, e.ignore = function(t) {
        var i = mt;
        mt = null, t(this), mt = i;
      }, e.getTweens = function() {
        var t = [];
        return this.data.forEach(function(i) {
          return i instanceof r ? t.push.apply(t, i.getTweens()) : i instanceof It && !(i.parent && i.parent.data === "nested") && t.push(i);
        }), t;
      }, e.clear = function() {
        this._r.length = this.data.length = 0;
      }, e.kill = function(t, i) {
        var n = this;
        if (t ? function() {
          for (var a = n.getTweens(), o = n.data.length, l; o--; ) l = n.data[o], l.data === "isFlip" && (l.revert(), l.getChildren(true, true, false).forEach(function(c) {
            return a.splice(a.indexOf(c), 1);
          }));
          for (a.map(function(c) {
            return {
              g: c._dur || c._delay || c._sat && !c._sat.vars.immediateRender ? c.globalTime(0) : -1 / 0,
              t: c
            };
          }).sort(function(c, u) {
            return u.g - c.g || -1 / 0;
          }).forEach(function(c) {
            return c.t.revert(t);
          }), o = n.data.length; o--; ) l = n.data[o], l instanceof ci ? l.data !== "nested" && (l.scrollTrigger && l.scrollTrigger.revert(), l.kill()) : !(l instanceof It) && l.revert && l.revert(t);
          n._r.forEach(function(c) {
            return c(t, n);
          }), n.isReverted = true;
        }() : this.data.forEach(function(a) {
          return a.kill && a.kill();
        }), this.clear(), i) for (var s = Tn.length; s--; ) Tn[s].id === this.id && Tn.splice(s, 1);
      }, e.revert = function(t) {
        this.kill(t || {});
      }, r;
    }(), aE = function() {
      function r(t) {
        this.contexts = [], this.scope = t, mt && mt.data.push(this);
      }
      var e = r.prototype;
      return e.add = function(t, i, n) {
        nr(t) || (t = {
          matches: t
        });
        var s = new Kf(0, n || this.scope), a = s.conditions = {}, o, l, c;
        mt && !s.selector && (s.selector = mt.selector), this.contexts.push(s), i = s.add("onMatch", i), s.queries = t;
        for (l in t) l === "all" ? c = 1 : (o = sr.matchMedia(t[l]), o && (Tn.indexOf(s) < 0 && Tn.push(s), (a[l] = o.matches) && (c = 1), o.addListener ? o.addListener(nh) : o.addEventListener("change", nh)));
        return c && i(s, function(u) {
          return s.add(null, u);
        }), this;
      }, e.revert = function(t) {
        this.kill(t || {});
      }, e.kill = function(t) {
        this.contexts.forEach(function(i) {
          return i.kill(t, true);
        });
      }, r;
    }(), hl = {
      registerPlugin: function() {
        for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++) e[t] = arguments[t];
        e.forEach(function(i) {
          return Df(i);
        });
      },
      timeline: function(r) {
        return new ci(r);
      },
      getTweensOf: function(r, e) {
        return Mt.getTweensOf(r, e);
      },
      getProperty: function(r, e, t, i) {
        Vt(r) && (r = Ii(r)[0]);
        var n = Mn(r || {}).get, s = t ? mf : ff;
        return t === "native" && (t = ""), r && (e ? s((bi[e] && bi[e].get || n)(r, e, t, i)) : function(a, o, l) {
          return s((bi[a] && bi[a].get || n)(r, a, o, l));
        });
      },
      quickSetter: function(r, e, t) {
        if (r = Ii(r), r.length > 1) {
          var i = r.map(function(c) {
            return mi.quickSetter(c, e, t);
          }), n = i.length;
          return function(c) {
            for (var u = n; u--; ) i[u](c);
          };
        }
        r = r[0] || {};
        var s = bi[e], a = Mn(r), o = a.harness && (a.harness.aliases || {})[e] || e, l = s ? function(c) {
          var u = new s();
          Os._pt = 0, u.init(r, t ? c + t : c, Os, 0, [
            r
          ]), u.render(1, u), Os._pt && ih(1, Os);
        } : a.set(r, o);
        return s ? l : function(c) {
          return l(r, o, t ? c + t : c, a, 1);
        };
      },
      quickTo: function(r, e, t) {
        var i, n = mi.to(r, Si((i = {}, i[e] = "+=0.1", i.paused = true, i.stagger = 0, i), t || {})), s = function(a, o, l) {
          return n.resetTo(e, a, o, l);
        };
        return s.tween = n, s;
      },
      isTweening: function(r) {
        return Mt.getTweensOf(r, true).length > 0;
      },
      defaults: function(r) {
        return r && r.ease && (r.ease = Sn(r.ease, Cs.ease)), gf(Cs, r || {});
      },
      config: function(r) {
        return gf(yi, r || {});
      },
      registerEffect: function(r) {
        var e = r.name, t = r.effect, i = r.plugins, n = r.defaults, s = r.extendTimeline;
        (i || "").split(",").forEach(function(a) {
          return a && !bi[a] && !Mi[a] && La(e + " effect requires " + a + " plugin.");
        }), ku[e] = function(a, o, l) {
          return t(Ii(a), Si(o || {}, n), l);
        }, s && (ci.prototype[e] = function(a, o, l) {
          return this.add(ku[e](a, nr(o) ? o : (l = o) && {}, this), l);
        });
      },
      registerEase: function(r, e) {
        qe[r] = Sn(e);
      },
      parseEase: function(r, e) {
        return arguments.length ? Sn(r, e) : qe;
      },
      getById: function(r) {
        return Mt.getById(r);
      },
      exportRoot: function(r, e) {
        r === void 0 && (r = {});
        var t = new ci(r), i, n;
        for (t.smoothChildTiming = di(r.smoothChildTiming), Mt.remove(t), t._dp = 0, t._time = t._tTime = Mt._time, i = Mt._first; i; ) n = i._next, (e || !(!i._dur && i instanceof It && i.vars.onComplete === i._targets[0])) && ar(t, i, i._start - i._delay), i = n;
        return ar(Mt, t, 0), t;
      },
      context: function(r, e) {
        return r ? new Kf(r, e) : mt;
      },
      matchMedia: function(r) {
        return new aE(r);
      },
      matchMediaRefresh: function() {
        return Tn.forEach(function(r) {
          var e = r.conditions, t, i;
          for (i in e) e[i] && (e[i] = false, t = 1);
          t && r.revert();
        }) || nh();
      },
      addEventListener: function(r, e) {
        var t = ul[r] || (ul[r] = []);
        ~t.indexOf(e) || t.push(e);
      },
      removeEventListener: function(r, e) {
        var t = ul[r], i = t && t.indexOf(e);
        i >= 0 && t.splice(i, 1);
      },
      utils: {
        wrap: BS,
        wrapYoyo: zS,
        distribute: Tf,
        random: Af,
        snap: wf,
        normalize: FS,
        getUnit: Qt,
        clamp: IS,
        splitColor: If,
        toArray: Ii,
        selector: ju,
        mapRange: Cf,
        pipe: OS,
        unitize: NS,
        interpolate: kS,
        shuffle: Ef
      },
      install: lf,
      effects: ku,
      ticker: Ti,
      updateRoot: ci.updateRoot,
      plugins: bi,
      globalTimeline: Mt,
      core: {
        PropTween: fi,
        globals: cf,
        Tween: It,
        Timeline: ci,
        Animation: ka,
        getCache: Mn,
        _removeLinkedListItem: al,
        reverting: function() {
          return Xt;
        },
        context: function(r) {
          return r && mt && (mt.data.push(r), r._ctx = mt), mt;
        },
        suppressOverwrites: function(r) {
          return Cu = r;
        }
      }
    };
    pi("to,from,fromTo,delayedCall,set,killTweensOf", function(r) {
      return hl[r] = It[r];
    }), Ti.add(ci.updateRoot), Os = hl.to({}, {
      duration: 0
    });
    var oE = function(r, e) {
      for (var t = r._pt; t && t.p !== e && t.op !== e && t.fp !== e; ) t = t._next;
      return t;
    }, lE = function(r, e) {
      var t = r._targets, i, n, s;
      for (i in e) for (n = t.length; n--; ) s = r._ptLookup[n][i], s && (s = s.d) && (s._pt && (s = oE(s, i)), s && s.modifier && s.modifier(e[i], r, t[n], i));
    }, sh = function(r, e) {
      return {
        name: r,
        rawVars: 1,
        init: function(t, i, n) {
          n._onInit = function(s) {
            var a, o;
            if (Vt(i) && (a = {}, pi(i, function(l) {
              return a[l] = 1;
            }), i = a), e) {
              a = {};
              for (o in i) a[o] = e(i[o]);
              i = a;
            }
            lE(s, i);
          };
        }
      };
    }, mi = hl.registerPlugin({
      name: "attr",
      init: function(r, e, t, i, n) {
        var s, a, o;
        this.tween = t;
        for (s in e) o = r.getAttribute(s) || "", a = this.add(r, "setAttribute", (o || 0) + "", e[s], i, n, 0, 0, s), a.op = s, a.b = o, this._props.push(s);
      },
      render: function(r, e) {
        for (var t = e._pt; t; ) Xt ? t.set(t.t, t.p, t.b, t) : t.r(r, t.d), t = t._next;
      }
    }, {
      name: "endArray",
      init: function(r, e) {
        for (var t = e.length; t--; ) this.add(r, t, r[t] || 0, e[t], 0, 0, 0, 0, 0, 1);
      }
    }, sh("roundProps", qu), sh("modifiers"), sh("snap", wf)) || hl;
    It.version = ci.version = mi.version = "3.12.7", of = 1, Du() && Ns(), qe.Power0, qe.Power1, qe.Power2, qe.Power3, qe.Power4, qe.Linear, qe.Quad, qe.Cubic, qe.Quart, qe.Quint, qe.Strong, qe.Elastic, qe.Back, qe.SteppedEase, qe.Bounce, qe.Sine, qe.Expo, qe.Circ;
    var Zf, Jr, Fs, ah, wn, Jf, oh, cE = function() {
      return typeof window < "u";
    }, Er = {}, An = 180 / Math.PI, Bs = Math.PI / 180, zs = Math.atan2, $f = 1e8, lh = /([A-Z])/g, uE = /(left|right|width|margin|padding|x)/i, hE = /[\s,\(]\S/, or = {
      autoAlpha: "opacity,visibility",
      scale: "scaleX,scaleY",
      alpha: "opacity"
    }, ch = function(r, e) {
      return e.set(e.t, e.p, Math.round((e.s + e.c * r) * 1e4) / 1e4 + e.u, e);
    }, dE = function(r, e) {
      return e.set(e.t, e.p, r === 1 ? e.e : Math.round((e.s + e.c * r) * 1e4) / 1e4 + e.u, e);
    }, pE = function(r, e) {
      return e.set(e.t, e.p, r ? Math.round((e.s + e.c * r) * 1e4) / 1e4 + e.u : e.b, e);
    }, fE = function(r, e) {
      var t = e.s + e.c * r;
      e.set(e.t, e.p, ~~(t + (t < 0 ? -0.5 : 0.5)) + e.u, e);
    }, Qf = function(r, e) {
      return e.set(e.t, e.p, r ? e.e : e.b, e);
    }, em = function(r, e) {
      return e.set(e.t, e.p, r !== 1 ? e.b : e.e, e);
    }, mE = function(r, e, t) {
      return r.style[e] = t;
    }, gE = function(r, e, t) {
      return r.style.setProperty(e, t);
    }, _E = function(r, e, t) {
      return r._gsap[e] = t;
    }, vE = function(r, e, t) {
      return r._gsap.scaleX = r._gsap.scaleY = t;
    }, xE = function(r, e, t, i, n) {
      var s = r._gsap;
      s.scaleX = s.scaleY = t, s.renderTransform(n, s);
    }, yE = function(r, e, t, i, n) {
      var s = r._gsap;
      s[e] = t, s.renderTransform(n, s);
    }, bt = "transform", gi = bt + "Origin", ME = function r(e, t) {
      var i = this, n = this.target, s = n.style, a = n._gsap;
      if (e in Er && s) {
        if (this.tfm = this.tfm || {}, e !== "transform") e = or[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function(o) {
          return i.tfm[o] = Tr(n, o);
        }) : this.tfm[e] = a.x ? a[e] : Tr(n, e), e === gi && (this.tfm.zOrigin = a.zOrigin);
        else return or.transform.split(",").forEach(function(o) {
          return r.call(i, o, t);
        });
        if (this.props.indexOf(bt) >= 0) return;
        a.svg && (this.svgo = n.getAttribute("data-svg-origin"), this.props.push(gi, t, "")), e = bt;
      }
      (s || t) && this.props.push(e, t, s[e]);
    }, tm = function(r) {
      r.translate && (r.removeProperty("translate"), r.removeProperty("scale"), r.removeProperty("rotate"));
    }, bE = function() {
      var r = this.props, e = this.target, t = e.style, i = e._gsap, n, s;
      for (n = 0; n < r.length; n += 3) r[n + 1] ? r[n + 1] === 2 ? e[r[n]](r[n + 2]) : e[r[n]] = r[n + 2] : r[n + 2] ? t[r[n]] = r[n + 2] : t.removeProperty(r[n].substr(0, 2) === "--" ? r[n] : r[n].replace(lh, "-$1").toLowerCase());
      if (this.tfm) {
        for (s in this.tfm) i[s] = this.tfm[s];
        i.svg && (i.renderTransform(), e.setAttribute("data-svg-origin", this.svgo || "")), n = oh(), (!n || !n.isStart) && !t[bt] && (tm(t), i.zOrigin && t[gi] && (t[gi] += " " + i.zOrigin + "px", i.zOrigin = 0, i.renderTransform()), i.uncache = 1);
      }
    }, im = function(r, e) {
      var t = {
        target: r,
        props: [],
        revert: bE,
        save: ME
      };
      return r._gsap || mi.core.getCache(r), e && r.style && r.nodeType && e.split(",").forEach(function(i) {
        return t.save(i);
      }), t;
    }, rm, uh = function(r, e) {
      var t = Jr.createElementNS ? Jr.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), r) : Jr.createElement(r);
      return t && t.style ? t : Jr.createElement(r);
    }, lr = function r(e, t, i) {
      var n = getComputedStyle(e);
      return n[t] || n.getPropertyValue(t.replace(lh, "-$1").toLowerCase()) || n.getPropertyValue(t) || !i && r(e, ks(t) || t, 1) || "";
    }, nm = "O,Moz,ms,Ms,Webkit".split(","), ks = function(r, e, t) {
      var i = e || wn, n = i.style, s = 5;
      if (r in n && !t) return r;
      for (r = r.charAt(0).toUpperCase() + r.substr(1); s-- && !(nm[s] + r in n); ) ;
      return s < 0 ? null : (s === 3 ? "ms" : s >= 0 ? nm[s] : "") + r;
    }, hh = function() {
      cE() && window.document && (Zf = window, Jr = Zf.document, Fs = Jr.documentElement, wn = uh("div") || {
        style: {}
      }, uh("div"), bt = ks(bt), gi = bt + "Origin", wn.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", rm = !!ks("perspective"), oh = mi.core.reverting, ah = 1);
    }, sm = function(r) {
      var e = r.ownerSVGElement, t = uh("svg", e && e.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = r.cloneNode(true), n;
      i.style.display = "block", t.appendChild(i), Fs.appendChild(t);
      try {
        n = i.getBBox();
      } catch {
      }
      return t.removeChild(i), Fs.removeChild(t), n;
    }, am = function(r, e) {
      for (var t = e.length; t--; ) if (r.hasAttribute(e[t])) return r.getAttribute(e[t]);
    }, om = function(r) {
      var e, t;
      try {
        e = r.getBBox();
      } catch {
        e = sm(r), t = 1;
      }
      return e && (e.width || e.height) || t || (e = sm(r)), e && !e.width && !e.x && !e.y ? {
        x: +am(r, [
          "x",
          "cx",
          "x1"
        ]) || 0,
        y: +am(r, [
          "y",
          "cy",
          "y1"
        ]) || 0,
        width: 0,
        height: 0
      } : e;
    }, lm = function(r) {
      return !!(r.getCTM && (!r.parentNode || r.ownerSVGElement) && om(r));
    }, Rn = function(r, e) {
      if (e) {
        var t = r.style, i;
        e in Er && e !== gi && (e = bt), t.removeProperty ? (i = e.substr(0, 2), (i === "ms" || e.substr(0, 6) === "webkit") && (e = "-" + e), t.removeProperty(i === "--" ? e : e.replace(lh, "-$1").toLowerCase())) : t.removeAttribute(e);
      }
    }, $r = function(r, e, t, i, n, s) {
      var a = new fi(r._pt, e, t, 0, 1, s ? em : Qf);
      return r._pt = a, a.b = i, a.e = n, r._props.push(t), a;
    }, cm = {
      deg: 1,
      rad: 1,
      turn: 1
    }, SE = {
      grid: 1,
      flex: 1
    }, Qr = function r(e, t, i, n) {
      var s = parseFloat(i) || 0, a = (i + "").trim().substr((s + "").length) || "px", o = wn.style, l = uE.test(t), c = e.tagName.toLowerCase() === "svg", u = (c ? "client" : "offset") + (l ? "Width" : "Height"), h = 100, d = n === "px", p = n === "%", f, _, g, m;
      if (n === a || !s || cm[n] || cm[a]) return s;
      if (a !== "px" && !d && (s = r(e, t, i, "px")), m = e.getCTM && lm(e), (p || a === "%") && (Er[t] || ~t.indexOf("adius"))) return f = m ? e.getBBox()[l ? "width" : "height"] : e[u], Ct(p ? s / f * h : s / 100 * f);
      if (o[l ? "width" : "height"] = h + (d ? a : n), _ = n !== "rem" && ~t.indexOf("adius") || n === "em" && e.appendChild && !c ? e : e.parentNode, m && (_ = (e.ownerSVGElement || {}).parentNode), (!_ || _ === Jr || !_.appendChild) && (_ = Jr.body), g = _._gsap, g && p && g.width && l && g.time === Ti.time && !g.uncache) return Ct(s / g.width * h);
      if (p && (t === "height" || t === "width")) {
        var y = e.style[t];
        e.style[t] = h + n, f = e[u], y ? e.style[t] = y : Rn(e, t);
      } else (p || a === "%") && !SE[lr(_, "display")] && (o.position = lr(e, "position")), _ === e && (o.position = "static"), _.appendChild(wn), f = wn[u], _.removeChild(wn), o.position = "absolute";
      return l && p && (g = Mn(_), g.time = Ti.time, g.width = _[u]), Ct(d ? f * s / h : f && s ? h / f * s : 0);
    }, Tr = function(r, e, t, i) {
      var n;
      return ah || hh(), e in or && e !== "transform" && (e = or[e], ~e.indexOf(",") && (e = e.split(",")[0])), Er[e] && e !== "transform" ? (n = Ga(r, i), n = e !== "transformOrigin" ? n[e] : n.svg ? n.origin : pl(lr(r, gi)) + " " + n.zOrigin + "px") : (n = r.style[e], (!n || n === "auto" || i || ~(n + "").indexOf("calc(")) && (n = dl[e] && dl[e](r, e, t) || lr(r, e) || df(r, e) || (e === "opacity" ? 1 : 0))), t && !~(n + "").trim().indexOf(" ") ? Qr(r, e, n, t) + t : n;
    }, EE = function(r, e, t, i) {
      if (!t || t === "none") {
        var n = ks(e, r, 1), s = n && lr(r, n, 1);
        s && s !== t ? (e = n, t = s) : e === "borderColor" && (t = lr(r, "borderTopColor"));
      }
      var a = new fi(this._pt, r.style, e, 0, 1, jf), o = 0, l = 0, c, u, h, d, p, f, _, g, m, y, x, v;
      if (a.b = t, a.e = i, t += "", i += "", i === "auto" && (f = r.style[e], r.style[e] = i, i = lr(r, e) || i, f ? r.style[e] = f : Rn(r, e)), c = [
        t,
        i
      ], Nf(c), t = c[0], i = c[1], h = t.match(Ps) || [], v = i.match(Ps) || [], v.length) {
        for (; u = Ps.exec(i); ) _ = u[0], m = i.substring(o, u.index), p ? p = (p + 1) % 5 : (m.substr(-5) === "rgba(" || m.substr(-5) === "hsla(") && (p = 1), _ !== (f = h[l++] || "") && (d = parseFloat(f) || 0, x = f.substr((d + "").length), _.charAt(1) === "=" && (_ = Ls(d, _) + x), g = parseFloat(_), y = _.substr((g + "").length), o = Ps.lastIndex - y.length, y || (y = y || yi.units[e] || x, o === i.length && (i += y, a.e += y)), x !== y && (d = Qr(r, e, f, y) || 0), a._pt = {
          _next: a._pt,
          p: m || l === 1 ? m : ",",
          s: d,
          c: g - d,
          m: p && p < 4 || e === "zIndex" ? Math.round : 0
        });
        a.c = o < i.length ? i.substring(o, i.length) : "";
      } else a.r = e === "display" && i === "none" ? em : Qf;
      return sf.test(i) && (a.e = 0), this._pt = a, a;
    }, um = {
      top: "0%",
      bottom: "100%",
      left: "0%",
      right: "100%",
      center: "50%"
    }, TE = function(r) {
      var e = r.split(" "), t = e[0], i = e[1] || "50%";
      return (t === "top" || t === "bottom" || i === "left" || i === "right") && (r = t, t = i, i = r), e[0] = um[t] || t, e[1] = um[i] || i, e.join(" ");
    }, wE = function(r, e) {
      if (e.tween && e.tween._time === e.tween._dur) {
        var t = e.t, i = t.style, n = e.u, s = t._gsap, a, o, l;
        if (n === "all" || n === true) i.cssText = "", o = 1;
        else for (n = n.split(","), l = n.length; --l > -1; ) a = n[l], Er[a] && (o = 1, a = a === "transformOrigin" ? gi : bt), Rn(t, a);
        o && (Rn(t, bt), s && (s.svg && t.removeAttribute("transform"), i.scale = i.rotate = i.translate = "none", Ga(t, 1), s.uncache = 1, tm(i)));
      }
    }, dl = {
      clearProps: function(r, e, t, i, n) {
        if (n.data !== "isFromStart") {
          var s = r._pt = new fi(r._pt, e, t, 0, 0, wE);
          return s.u = i, s.pr = -10, s.tween = n, r._props.push(t), 1;
        }
      }
    }, Va = [
      1,
      0,
      0,
      1,
      0,
      0
    ], hm = {}, dm = function(r) {
      return r === "matrix(1, 0, 0, 1, 0, 0)" || r === "none" || !r;
    }, pm = function(r) {
      var e = lr(r, bt);
      return dm(e) ? Va : e.substr(7).match(nf).map(Ct);
    }, dh = function(r, e) {
      var t = r._gsap || Mn(r), i = r.style, n = pm(r), s, a, o, l;
      return t.svg && r.getAttribute("transform") ? (o = r.transform.baseVal.consolidate().matrix, n = [
        o.a,
        o.b,
        o.c,
        o.d,
        o.e,
        o.f
      ], n.join(",") === "1,0,0,1,0,0" ? Va : n) : (n === Va && !r.offsetParent && r !== Fs && !t.svg && (o = i.display, i.display = "block", s = r.parentNode, (!s || !r.offsetParent && !r.getBoundingClientRect().width) && (l = 1, a = r.nextElementSibling, Fs.appendChild(r)), n = pm(r), o ? i.display = o : Rn(r, "display"), l && (a ? s.insertBefore(r, a) : s ? s.appendChild(r) : Fs.removeChild(r))), e && n.length > 6 ? [
        n[0],
        n[1],
        n[4],
        n[5],
        n[12],
        n[13]
      ] : n);
    }, ph = function(r, e, t, i, n, s) {
      var a = r._gsap, o = n || dh(r, true), l = a.xOrigin || 0, c = a.yOrigin || 0, u = a.xOffset || 0, h = a.yOffset || 0, d = o[0], p = o[1], f = o[2], _ = o[3], g = o[4], m = o[5], y = e.split(" "), x = parseFloat(y[0]) || 0, v = parseFloat(y[1]) || 0, A, T, w, R;
      t ? o !== Va && (T = d * _ - p * f) && (w = x * (_ / T) + v * (-f / T) + (f * m - _ * g) / T, R = x * (-p / T) + v * (d / T) - (d * m - p * g) / T, x = w, v = R) : (A = om(r), x = A.x + (~y[0].indexOf("%") ? x / 100 * A.width : x), v = A.y + (~(y[1] || y[0]).indexOf("%") ? v / 100 * A.height : v)), i || i !== false && a.smooth ? (g = x - l, m = v - c, a.xOffset = u + (g * d + m * f) - g, a.yOffset = h + (g * p + m * _) - m) : a.xOffset = a.yOffset = 0, a.xOrigin = x, a.yOrigin = v, a.smooth = !!i, a.origin = e, a.originIsAbsolute = !!t, r.style[gi] = "0px 0px", s && ($r(s, a, "xOrigin", l, x), $r(s, a, "yOrigin", c, v), $r(s, a, "xOffset", u, a.xOffset), $r(s, a, "yOffset", h, a.yOffset)), r.setAttribute("data-svg-origin", x + " " + v);
    }, Ga = function(r, e) {
      var t = r._gsap || new kf(r);
      if ("x" in t && !e && !t.uncache) return t;
      var i = r.style, n = t.scaleX < 0, s = "px", a = "deg", o = getComputedStyle(r), l = lr(r, gi) || "0", c, u, h, d, p, f, _, g, m, y, x, v, A, T, w, R, E, b, L, B, F, V, X, k, K, G, ie, ue, we, Be, We, j;
      return c = u = h = f = _ = g = m = y = x = 0, d = p = 1, t.svg = !!(r.getCTM && lm(r)), o.translate && ((o.translate !== "none" || o.scale !== "none" || o.rotate !== "none") && (i[bt] = (o.translate !== "none" ? "translate3d(" + (o.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (o.rotate !== "none" ? "rotate(" + o.rotate + ") " : "") + (o.scale !== "none" ? "scale(" + o.scale.split(" ").join(",") + ") " : "") + (o[bt] !== "none" ? o[bt] : "")), i.scale = i.rotate = i.translate = "none"), T = dh(r, t.svg), t.svg && (t.uncache ? (K = r.getBBox(), l = t.xOrigin - K.x + "px " + (t.yOrigin - K.y) + "px", k = "") : k = !e && r.getAttribute("data-svg-origin"), ph(r, k || l, !!k || t.originIsAbsolute, t.smooth !== false, T)), v = t.xOrigin || 0, A = t.yOrigin || 0, T !== Va && (b = T[0], L = T[1], B = T[2], F = T[3], c = V = T[4], u = X = T[5], T.length === 6 ? (d = Math.sqrt(b * b + L * L), p = Math.sqrt(F * F + B * B), f = b || L ? zs(L, b) * An : 0, m = B || F ? zs(B, F) * An + f : 0, m && (p *= Math.abs(Math.cos(m * Bs))), t.svg && (c -= v - (v * b + A * B), u -= A - (v * L + A * F))) : (j = T[6], Be = T[7], ie = T[8], ue = T[9], we = T[10], We = T[11], c = T[12], u = T[13], h = T[14], w = zs(j, we), _ = w * An, w && (R = Math.cos(-w), E = Math.sin(-w), k = V * R + ie * E, K = X * R + ue * E, G = j * R + we * E, ie = V * -E + ie * R, ue = X * -E + ue * R, we = j * -E + we * R, We = Be * -E + We * R, V = k, X = K, j = G), w = zs(-B, we), g = w * An, w && (R = Math.cos(-w), E = Math.sin(-w), k = b * R - ie * E, K = L * R - ue * E, G = B * R - we * E, We = F * E + We * R, b = k, L = K, B = G), w = zs(L, b), f = w * An, w && (R = Math.cos(w), E = Math.sin(w), k = b * R + L * E, K = V * R + X * E, L = L * R - b * E, X = X * R - V * E, b = k, V = K), _ && Math.abs(_) + Math.abs(f) > 359.9 && (_ = f = 0, g = 180 - g), d = Ct(Math.sqrt(b * b + L * L + B * B)), p = Ct(Math.sqrt(X * X + j * j)), w = zs(V, X), m = Math.abs(w) > 2e-4 ? w * An : 0, x = We ? 1 / (We < 0 ? -We : We) : 0), t.svg && (k = r.getAttribute("transform"), t.forceCSS = r.setAttribute("transform", "") || !dm(lr(r, bt)), k && r.setAttribute("transform", k))), Math.abs(m) > 90 && Math.abs(m) < 270 && (n ? (d *= -1, m += f <= 0 ? 180 : -180, f += f <= 0 ? 180 : -180) : (p *= -1, m += m <= 0 ? 180 : -180)), e = e || t.uncache, t.x = c - ((t.xPercent = c && (!e && t.xPercent || (Math.round(r.offsetWidth / 2) === Math.round(-c) ? -50 : 0))) ? r.offsetWidth * t.xPercent / 100 : 0) + s, t.y = u - ((t.yPercent = u && (!e && t.yPercent || (Math.round(r.offsetHeight / 2) === Math.round(-u) ? -50 : 0))) ? r.offsetHeight * t.yPercent / 100 : 0) + s, t.z = h + s, t.scaleX = Ct(d), t.scaleY = Ct(p), t.rotation = Ct(f) + a, t.rotationX = Ct(_) + a, t.rotationY = Ct(g) + a, t.skewX = m + a, t.skewY = y + a, t.transformPerspective = x + s, (t.zOrigin = parseFloat(l.split(" ")[2]) || !e && t.zOrigin || 0) && (i[gi] = pl(l)), t.xOffset = t.yOffset = 0, t.force3D = yi.force3D, t.renderTransform = t.svg ? RE : rm ? fm : AE, t.uncache = 0, t;
    }, pl = function(r) {
      return (r = r.split(" "))[0] + " " + r[1];
    }, fh = function(r, e, t) {
      var i = Qt(e);
      return Ct(parseFloat(e) + parseFloat(Qr(r, "x", t + "px", i))) + i;
    }, AE = function(r, e) {
      e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, fm(r, e);
    }, Cn = "0deg", Wa = "0px", Pn = ") ", fm = function(r, e) {
      var t = e || this, i = t.xPercent, n = t.yPercent, s = t.x, a = t.y, o = t.z, l = t.rotation, c = t.rotationY, u = t.rotationX, h = t.skewX, d = t.skewY, p = t.scaleX, f = t.scaleY, _ = t.transformPerspective, g = t.force3D, m = t.target, y = t.zOrigin, x = "", v = g === "auto" && r && r !== 1 || g === true;
      if (y && (u !== Cn || c !== Cn)) {
        var A = parseFloat(c) * Bs, T = Math.sin(A), w = Math.cos(A), R;
        A = parseFloat(u) * Bs, R = Math.cos(A), s = fh(m, s, T * R * -y), a = fh(m, a, -Math.sin(A) * -y), o = fh(m, o, w * R * -y + y);
      }
      _ !== Wa && (x += "perspective(" + _ + Pn), (i || n) && (x += "translate(" + i + "%, " + n + "%) "), (v || s !== Wa || a !== Wa || o !== Wa) && (x += o !== Wa || v ? "translate3d(" + s + ", " + a + ", " + o + ") " : "translate(" + s + ", " + a + Pn), l !== Cn && (x += "rotate(" + l + Pn), c !== Cn && (x += "rotateY(" + c + Pn), u !== Cn && (x += "rotateX(" + u + Pn), (h !== Cn || d !== Cn) && (x += "skew(" + h + ", " + d + Pn), (p !== 1 || f !== 1) && (x += "scale(" + p + ", " + f + Pn), m.style[bt] = x || "translate(0, 0)";
    }, RE = function(r, e) {
      var t = e || this, i = t.xPercent, n = t.yPercent, s = t.x, a = t.y, o = t.rotation, l = t.skewX, c = t.skewY, u = t.scaleX, h = t.scaleY, d = t.target, p = t.xOrigin, f = t.yOrigin, _ = t.xOffset, g = t.yOffset, m = t.forceCSS, y = parseFloat(s), x = parseFloat(a), v, A, T, w, R;
      o = parseFloat(o), l = parseFloat(l), c = parseFloat(c), c && (c = parseFloat(c), l += c, o += c), o || l ? (o *= Bs, l *= Bs, v = Math.cos(o) * u, A = Math.sin(o) * u, T = Math.sin(o - l) * -h, w = Math.cos(o - l) * h, l && (c *= Bs, R = Math.tan(l - c), R = Math.sqrt(1 + R * R), T *= R, w *= R, c && (R = Math.tan(c), R = Math.sqrt(1 + R * R), v *= R, A *= R)), v = Ct(v), A = Ct(A), T = Ct(T), w = Ct(w)) : (v = u, w = h, A = T = 0), (y && !~(s + "").indexOf("px") || x && !~(a + "").indexOf("px")) && (y = Qr(d, "x", s, "px"), x = Qr(d, "y", a, "px")), (p || f || _ || g) && (y = Ct(y + p - (p * v + f * T) + _), x = Ct(x + f - (p * A + f * w) + g)), (i || n) && (R = d.getBBox(), y = Ct(y + i / 100 * R.width), x = Ct(x + n / 100 * R.height)), R = "matrix(" + v + "," + A + "," + T + "," + w + "," + y + "," + x + ")", d.setAttribute("transform", R), m && (d.style[bt] = R);
    }, CE = function(r, e, t, i, n) {
      var s = 360, a = Vt(n), o = parseFloat(n) * (a && ~n.indexOf("rad") ? An : 1), l = o - i, c = i + l + "deg", u, h;
      return a && (u = n.split("_")[1], u === "short" && (l %= s, l !== l % (s / 2) && (l += l < 0 ? s : -360)), u === "cw" && l < 0 ? l = (l + s * $f) % s - ~~(l / s) * s : u === "ccw" && l > 0 && (l = (l - s * $f) % s - ~~(l / s) * s)), r._pt = h = new fi(r._pt, e, t, i, l, dE), h.e = c, h.u = "deg", r._props.push(t), h;
    }, mm = function(r, e) {
      for (var t in e) r[t] = e[t];
      return r;
    }, PE = function(r, e, t) {
      var i = mm({}, t._gsap), n = "perspective,force3D,transformOrigin,svgOrigin", s = t.style, a, o, l, c, u, h, d, p;
      i.svg ? (l = t.getAttribute("transform"), t.setAttribute("transform", ""), s[bt] = e, a = Ga(t, 1), Rn(t, bt), t.setAttribute("transform", l)) : (l = getComputedStyle(t)[bt], s[bt] = e, a = Ga(t, 1), s[bt] = l);
      for (o in Er) l = i[o], c = a[o], l !== c && n.indexOf(o) < 0 && (d = Qt(l), p = Qt(c), u = d !== p ? Qr(t, o, l, p) : parseFloat(l), h = parseFloat(c), r._pt = new fi(r._pt, a, o, u, h - u, ch), r._pt.u = p || 0, r._props.push(o));
      mm(a, i);
    };
    pi("padding,margin,Width,Radius", function(r, e) {
      var t = "Top", i = "Right", n = "Bottom", s = "Left", a = (e < 3 ? [
        t,
        i,
        n,
        s
      ] : [
        t + s,
        t + i,
        n + i,
        n + s
      ]).map(function(o) {
        return e < 2 ? r + o : "border" + o + r;
      });
      dl[e > 1 ? "border" + r : r] = function(o, l, c, u, h) {
        var d, p;
        if (arguments.length < 4) return d = a.map(function(f) {
          return Tr(o, f, c);
        }), p = d.join(" "), p.split(d[0]).length === 5 ? d[0] : p;
        d = (u + "").split(" "), p = {}, a.forEach(function(f, _) {
          return p[f] = d[_] = d[_] || d[(_ - 1) / 2 | 0];
        }), o.init(l, p, h);
      };
    });
    var gm = {
      name: "css",
      register: hh,
      targetTest: function(r) {
        return r.style && r.nodeType;
      },
      init: function(r, e, t, i, n) {
        var s = this._props, a = r.style, o = t.vars.startAt, l, c, u, h, d, p, f, _, g, m, y, x, v, A, T, w;
        ah || hh(), this.styles = this.styles || im(r), w = this.styles.props, this.tween = t;
        for (f in e) if (f !== "autoRound" && (c = e[f], !(bi[f] && Hf(f, e, t, i, r, n)))) {
          if (d = typeof c, p = dl[f], d === "function" && (c = c.call(t, i, r, n), d = typeof c), d === "string" && ~c.indexOf("random(") && (c = Na(c)), p) p(this, r, f, c, t) && (T = 1);
          else if (f.substr(0, 2) === "--") l = (getComputedStyle(r).getPropertyValue(f) + "").trim(), c += "", Kr.lastIndex = 0, Kr.test(l) || (_ = Qt(l), g = Qt(c)), g ? _ !== g && (l = Qr(r, f, l, g) + g) : _ && (c += _), this.add(a, "setProperty", l, c, i, n, 0, 0, f), s.push(f), w.push(f, 0, a[f]);
          else if (d !== "undefined") {
            if (o && f in o ? (l = typeof o[f] == "function" ? o[f].call(t, i, r, n) : o[f], Vt(l) && ~l.indexOf("random(") && (l = Na(l)), Qt(l + "") || l === "auto" || (l += yi.units[f] || Qt(Tr(r, f)) || ""), (l + "").charAt(1) === "=" && (l = Tr(r, f))) : l = Tr(r, f), h = parseFloat(l), m = d === "string" && c.charAt(1) === "=" && c.substr(0, 2), m && (c = c.substr(2)), u = parseFloat(c), f in or && (f === "autoAlpha" && (h === 1 && Tr(r, "visibility") === "hidden" && u && (h = 0), w.push("visibility", 0, a.visibility), $r(this, a, "visibility", h ? "inherit" : "hidden", u ? "inherit" : "hidden", !u)), f !== "scale" && f !== "transform" && (f = or[f], ~f.indexOf(",") && (f = f.split(",")[0]))), y = f in Er, y) {
              if (this.styles.save(f), x || (v = r._gsap, v.renderTransform && !e.parseTransform || Ga(r, e.parseTransform), A = e.smoothOrigin !== false && v.smooth, x = this._pt = new fi(this._pt, a, bt, 0, 1, v.renderTransform, v, 0, -1), x.dep = 1), f === "scale") this._pt = new fi(this._pt, v, "scaleY", v.scaleY, (m ? Ls(v.scaleY, m + u) : u) - v.scaleY || 0, ch), this._pt.u = 0, s.push("scaleY", f), f += "X";
              else if (f === "transformOrigin") {
                w.push(gi, 0, a[gi]), c = TE(c), v.svg ? ph(r, c, 0, A, 0, this) : (g = parseFloat(c.split(" ")[2]) || 0, g !== v.zOrigin && $r(this, v, "zOrigin", v.zOrigin, g), $r(this, a, f, pl(l), pl(c)));
                continue;
              } else if (f === "svgOrigin") {
                ph(r, c, 1, A, 0, this);
                continue;
              } else if (f in hm) {
                CE(this, v, f, h, m ? Ls(h, m + c) : c);
                continue;
              } else if (f === "smoothOrigin") {
                $r(this, v, "smooth", v.smooth, c);
                continue;
              } else if (f === "force3D") {
                v[f] = c;
                continue;
              } else if (f === "transform") {
                PE(this, c, r);
                continue;
              }
            } else f in a || (f = ks(f) || f);
            if (y || (u || u === 0) && (h || h === 0) && !hE.test(c) && f in a) _ = (l + "").substr((h + "").length), u || (u = 0), g = Qt(c) || (f in yi.units ? yi.units[f] : _), _ !== g && (h = Qr(r, f, l, g)), this._pt = new fi(this._pt, y ? v : a, f, h, (m ? Ls(h, m + u) : u) - h, !y && (g === "px" || f === "zIndex") && e.autoRound !== false ? fE : ch), this._pt.u = g || 0, _ !== g && g !== "%" && (this._pt.b = l, this._pt.r = pE);
            else if (f in a) EE.call(this, r, f, l, m ? m + c : c);
            else if (f in r) this.add(r, f, l || r[f], m ? m + c : c, i, n);
            else if (f !== "parseTransform") {
              Fu(f, c);
              continue;
            }
            y || (f in a ? w.push(f, 0, a[f]) : typeof r[f] == "function" ? w.push(f, 2, r[f]()) : w.push(f, 1, l || r[f])), s.push(f);
          }
        }
        T && qf(this);
      },
      render: function(r, e) {
        if (e.tween._time || !oh()) for (var t = e._pt; t; ) t.r(r, t.d), t = t._next;
        else e.styles.revert();
      },
      get: Tr,
      aliases: or,
      getSetter: function(r, e, t) {
        var i = or[e];
        return i && i.indexOf(",") < 0 && (e = i), e in Er && e !== gi && (r._gsap.x || Tr(r, "x")) ? t && Jf === t ? e === "scale" ? vE : _E : (Jf = t || {}) && (e === "scale" ? xE : yE) : r.style && !Lu(r.style[e]) ? mE : ~e.indexOf("-") ? gE : th(r, e);
      },
      core: {
        _removeProperty: Rn,
        _getMatrix: dh
      }
    };
    mi.utils.checkPrefix = ks, mi.core.getStyleSaver = im, function(r, e, t, i) {
      var n = pi(r + "," + e + "," + t, function(s) {
        Er[s] = 1;
      });
      pi(e, function(s) {
        yi.units[s] = "deg", hm[s] = 1;
      }), or[n[13]] = r + "," + e, pi(i, function(s) {
        var a = s.split(":");
        or[a[1]] = n[a[0]];
      });
    }("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"), pi("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(r) {
      yi.units[r] = "px";
    }), mi.registerPlugin(gm), St = mi.registerPlugin(gm) || mi, St.core.Tween;
    const mh = /* @__PURE__ */ new Map(), gh = [], Hs = new mn(), fl = new ee();
    let Ut = null;
    const _h = new ee(), Ln = [];
    async function ml(r) {
      return await (await fetch(r)).text();
    }
    async function vh(r, e, t, i = 1.5, n) {
      return new Promise((s, a) => {
        new Au().load("./../../res/font/GenosThin_Regular.json", async (o) => {
          try {
            const l = new Ru(r, {
              font: o,
              size: i,
              depth: 0.05,
              curveSegments: 12,
              bevelEnabled: true,
              bevelThickness: 0.03,
              bevelSize: 0.02,
              bevelOffset: 0,
              bevelSegments: 5
            }), c = await ml("./../../res/shaders/textVertexShader.glsl"), u = await ml("./../../res/shaders/textFragmentShader.glsl"), h = new Zt({
              uniforms: {
                textColor: {
                  value: new Ae(249 / 255, 159 / 255, 0 / 255)
                },
                opacity: {
                  value: 1
                }
              },
              vertexShader: c,
              fragmentShader: u,
              transparent: true
            }), d = new Rt(l, h);
            d.position.set(e.x, e.y, e.z), d.rotation.set(t.x, t.y, t.z), n.add(d), s(d);
          } catch (l) {
            a(l);
          }
        }, void 0, a);
      });
    }
    function gl(r, e, t, i, n, s, a, o) {
      if (mh.has(r)) {
        const l = mh.get(r);
        return l.position.set(t.x, t.y, t.z), l.scale.set(i, i, i), l.rotation.set(n.x, n.y, n.z), a.add(l), _m(l, s), o && o(l), l;
      }
      new Ib().load(e, (l) => {
        const c = l.scene;
        c.position.set(t.x, t.y, t.z), c.scale.set(i, i, i), c.rotation.set(n.x, n.y, n.z), c.traverse((u) => {
          u.isMesh && u.geometry.computeBoundingSphere();
        }), mh.set(r, c), a.add(c), _m(c, s), o && o(c);
      }, void 0, (l) => {
        console.error(`Error loading model ${r}:`, l);
      });
    }
    function _m(r, e) {
      (e == null ? void 0 : e.position) && St.to(r.position, {
        x: e.position.x,
        y: e.position.y,
        z: e.position.z,
        duration: e.position.duration || 3,
        ease: e.position.ease || "power2.out"
      }), (e == null ? void 0 : e.rotation) && St.to(r.rotation, {
        x: r.rotation.x + (e.rotation.x || 0),
        y: r.rotation.y + (e.rotation.y || 0),
        z: r.rotation.z + (e.rotation.z || 0),
        duration: e.rotation.duration || 45,
        ease: e.rotation.ease || "linear",
        repeat: e.rotation.repeat ?? -1
      });
    }
    function LE(r, e, t, i) {
      const n = new Gr();
      n.position.set(e.x, e.y, e.z), n.rotation.set(t.x, t.y, t.z);
      const s = 1.2, a = 0;
      r.forEach((o, l) => {
        const c = {
          x: 0,
          y: a - l * s,
          z: 0
        }, u = vm(o.text, c, i, o.onClick);
        n.add(u);
      }), i.add(n);
    }
    function vm(r, e, t, i, n = 0.5) {
      const s = new Au(), a = new Rt();
      return s.load("./../../res/font/GenosThin_Regular.json", (o) => {
        const l = new Ru(r, {
          font: o,
          size: n,
          depth: 0.05,
          curveSegments: 12,
          bevelEnabled: true,
          bevelThickness: 0.03,
          bevelSize: 0.02,
          bevelOffset: 0,
          bevelSegments: 5
        }), c = new xs({
          color: 16777215,
          transparent: true,
          opacity: 1,
          emissive: 0,
          metalness: 0,
          roughness: 1
        });
        a.geometry = l, a.material = c, a.position.set(e.x + 1, e.y - 1.25, e.z), a.userData.onClick = i, a.userData.originalColor = c.color.getHex(), gh.push(a), St.to(c, {
          opacity: 1,
          duration: 2,
          delay: Math.abs(e.y) * 0.15,
          ease: "power2.out"
        });
      }), a;
    }
    function DE(r, e, t) {
      const i = t.domElement.getBoundingClientRect();
      fl.x = (r.clientX - i.left) / i.width * 2 - 1, fl.y = -((r.clientY - i.top) / i.height) * 2 + 1, Hs.setFromCamera(fl, e);
      const n = Hs.intersectObjects(gh);
      if (n.length > 0) {
        const s = n[0].object;
        Ut !== s && (Ut && (St.to(Ut.material.color, {
          r: (Ut.userData.originalColor >> 16 & 255) / 255,
          g: (Ut.userData.originalColor >> 8 & 255) / 255,
          b: (Ut.userData.originalColor & 255) / 255,
          duration: 0.3
        }), St.to(Ut.scale, {
          x: 1,
          y: 1,
          z: 1,
          duration: 0.3
        })), Ut = s, document.body.style.cursor = "pointer", Ut.userData.originalColorStored || (Ut.userData.originalColor = Ut.material.color.getHex(), Ut.userData.originalColorStored = true), St.to(Ut.material.color, {
          r: 1,
          g: 0.5,
          b: 0,
          duration: 0.3
        }));
      } else Ut && (St.to(Ut.material.color, {
        r: (Ut.userData.originalColor >> 16 & 255) / 255,
        g: (Ut.userData.originalColor >> 8 & 255) / 255,
        b: (Ut.userData.originalColor & 255) / 255,
        duration: 0.3
      }), St.to(Ut.scale, {
        x: 1,
        y: 1,
        z: 1,
        duration: 0.3
      }), Ut = null), document.body.style.cursor = "default";
    }
    function IE(r, e) {
      Hs.setFromCamera(fl, e);
      const t = Hs.intersectObjects(gh);
      if (t.length > 0) {
        const i = t[0].object;
        i.userData.onClick && i.userData.onClick();
      }
    }
    function UE(r, e, t) {
      window.addEventListener("mousemove", (i) => DE(i, r, t)), window.addEventListener("click", (i) => IE(i, r));
    }
    function xh(r, e) {
      r.traverse((t) => {
        t.isMesh && (t.userData.onClick = e, Ln.push(t));
      });
    }
    function OE(r, e) {
      window.addEventListener("click", (t) => {
        const i = e.domElement.getBoundingClientRect();
        _h.x = (t.clientX - i.left) / i.width * 2 - 1, _h.y = -((t.clientY - i.top) / i.height) * 2 + 1, Hs.setFromCamera(_h, r);
        const n = Hs.intersectObjects(Ln, true);
        if (n.length > 0) {
          const s = n[0].object;
          s.userData.onClick && s.userData.onClick();
        }
      });
    }
    async function Vs(r, e, t, i = 0.7, n, s) {
      return new Promise((a, o) => {
        new Au().load("/res/font/Roboto_Regular.json", async (l) => {
          try {
            const c = new Ru(r, {
              font: l,
              size: i,
              depth: 0.05,
              curveSegments: 12,
              bevelEnabled: true,
              bevelThickness: 0.03,
              bevelSize: 0.02,
              bevelOffset: 0,
              bevelSegments: 5
            });
            c.computeBoundingBox(), c.center();
            const u = await ml("/res/shaders/textVertexShader.glsl"), h = await ml("/res/shaders/textFragmentShader.glsl"), d = new Zt({
              uniforms: {
                textColor: {
                  value: new Ae(249 / 255, 159 / 255, 0 / 255)
                }
              },
              vertexShader: u,
              fragmentShader: h
            }), p = new Rt(c, d);
            p.position.set(e.x, e.y, e.z + 0.02), p.rotation.set(t.x, t.y, t.z), n.add(p);
            const f = c.boundingBox.getSize(new D()), _ = 0.3, g = new un(f.x + _, f.y + _, 0.2), m = new xs({
              color: 0,
              transparent: true,
              opacity: 0.05,
              emissive: new Ae(0),
              emissiveIntensity: 1
            }), y = new Rt(g, m);
            y.position.set(e.x, e.y, e.z), y.rotation.set(t.x, t.y, t.z), y.name = `button-${r.replace(/\s+/g, "-")}`, s && xh(y, s), n.add(y), a({
              textMesh: p,
              buttonMesh: y
            });
          } catch (c) {
            o(c);
          }
        }, void 0, o);
      });
    }
    function yh(r, e = {}) {
      if (!r || !r.material || !("emissive" in r.material)) return;
      const { color: t = "#ff9900", intensity: i = 1.5 } = e;
      r.material.emissive = new Ae(t), r.material.emissiveIntensity = i, r.material.needsUpdate = true;
    }
    const xm = {
      name: "CopyShader",
      uniforms: {
        tDiffuse: {
          value: null
        },
        opacity: {
          value: 1
        }
      },
      vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
      fragmentShader: `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;


		}`
    };
    class Xa {
      constructor() {
        this.isPass = true, this.enabled = true, this.needsSwap = true, this.clear = false, this.renderToScreen = false;
      }
      setSize() {
      }
      render() {
        console.error("THREE.Pass: .render() must be implemented in derived pass.");
      }
      dispose() {
      }
    }
    const NE = new Yo(-1, 1, 1, -1, 0, 1);
    class FE extends hi {
      constructor() {
        super(), this.setAttribute("position", new Wt([
          -1,
          3,
          0,
          -1,
          -1,
          0,
          3,
          -1,
          0
        ], 3)), this.setAttribute("uv", new Wt([
          0,
          2,
          0,
          0,
          2,
          0
        ], 2));
      }
    }
    const BE = new FE();
    class ym {
      constructor(e) {
        this._mesh = new Rt(BE, e);
      }
      dispose() {
        this._mesh.geometry.dispose();
      }
      render(e) {
        e.render(this._mesh, NE);
      }
      get material() {
        return this._mesh.material;
      }
      set material(e) {
        this._mesh.material = e;
      }
    }
    class zE extends Xa {
      constructor(e, t) {
        super(), this.textureID = t !== void 0 ? t : "tDiffuse", e instanceof Zt ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = Lo.clone(e.uniforms), this.material = new Zt({
          name: e.name !== void 0 ? e.name : "unspecified",
          defines: Object.assign({}, e.defines),
          uniforms: this.uniforms,
          vertexShader: e.vertexShader,
          fragmentShader: e.fragmentShader
        })), this.fsQuad = new ym(this.material);
      }
      render(e, t, i) {
        this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
      }
      dispose() {
        this.material.dispose(), this.fsQuad.dispose();
      }
    }
    class Mm extends Xa {
      constructor(e, t) {
        super(), this.scene = e, this.camera = t, this.clear = true, this.needsSwap = false, this.inverse = false;
      }
      render(e, t, i) {
        const n = e.getContext(), s = e.state;
        s.buffers.color.setMask(false), s.buffers.depth.setMask(false), s.buffers.color.setLocked(true), s.buffers.depth.setLocked(true);
        let a, o;
        this.inverse ? (a = 0, o = 1) : (a = 1, o = 0), s.buffers.stencil.setTest(true), s.buffers.stencil.setOp(n.REPLACE, n.REPLACE, n.REPLACE), s.buffers.stencil.setFunc(n.ALWAYS, a, 4294967295), s.buffers.stencil.setClear(o), s.buffers.stencil.setLocked(true), e.setRenderTarget(i), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), s.buffers.color.setLocked(false), s.buffers.depth.setLocked(false), s.buffers.color.setMask(true), s.buffers.depth.setMask(true), s.buffers.stencil.setLocked(false), s.buffers.stencil.setFunc(n.EQUAL, 1, 4294967295), s.buffers.stencil.setOp(n.KEEP, n.KEEP, n.KEEP), s.buffers.stencil.setLocked(true);
      }
    }
    class kE extends Xa {
      constructor() {
        super(), this.needsSwap = false;
      }
      render(e) {
        e.state.buffers.stencil.setLocked(false), e.state.buffers.stencil.setTest(false);
      }
    }
    class HE {
      constructor(e, t) {
        if (this.renderer = e, this._pixelRatio = e.getPixelRatio(), t === void 0) {
          const i = e.getSize(new ee());
          this._width = i.width, this._height = i.height, t = new ki(this._width * this._pixelRatio, this._height * this._pixelRatio, {
            type: hr
          }), t.texture.name = "EffectComposer.rt1";
        } else this._width = t.width, this._height = t.height;
        this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = true, this.passes = [], this.copyPass = new zE(xm), this.copyPass.material.blending = Fi, this.clock = new kv();
      }
      swapBuffers() {
        const e = this.readBuffer;
        this.readBuffer = this.writeBuffer, this.writeBuffer = e;
      }
      addPass(e) {
        this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
      }
      insertPass(e, t) {
        this.passes.splice(t, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
      }
      removePass(e) {
        const t = this.passes.indexOf(e);
        t !== -1 && this.passes.splice(t, 1);
      }
      isLastEnabledPass(e) {
        for (let t = e + 1; t < this.passes.length; t++) if (this.passes[t].enabled) return false;
        return true;
      }
      render(e) {
        e === void 0 && (e = this.clock.getDelta());
        const t = this.renderer.getRenderTarget();
        let i = false;
        for (let n = 0, s = this.passes.length; n < s; n++) {
          const a = this.passes[n];
          if (a.enabled !== false) {
            if (a.renderToScreen = this.renderToScreen && this.isLastEnabledPass(n), a.render(this.renderer, this.writeBuffer, this.readBuffer, e, i), a.needsSwap) {
              if (i) {
                const o = this.renderer.getContext(), l = this.renderer.state.buffers.stencil;
                l.setFunc(o.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), l.setFunc(o.EQUAL, 1, 4294967295);
              }
              this.swapBuffers();
            }
            Mm !== void 0 && (a instanceof Mm ? i = true : a instanceof kE && (i = false));
          }
        }
        this.renderer.setRenderTarget(t);
      }
      reset(e) {
        if (e === void 0) {
          const t = this.renderer.getSize(new ee());
          this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, e = this.renderTarget1.clone(), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
        }
        this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
      }
      setSize(e, t) {
        this._width = e, this._height = t;
        const i = this._width * this._pixelRatio, n = this._height * this._pixelRatio;
        this.renderTarget1.setSize(i, n), this.renderTarget2.setSize(i, n);
        for (let s = 0; s < this.passes.length; s++) this.passes[s].setSize(i, n);
      }
      setPixelRatio(e) {
        this._pixelRatio = e, this.setSize(this._width, this._height);
      }
      dispose() {
        this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
      }
    }
    class VE extends Xa {
      constructor(e, t, i = null, n = null, s = null) {
        super(), this.scene = e, this.camera = t, this.overrideMaterial = i, this.clearColor = n, this.clearAlpha = s, this.clear = true, this.clearDepth = false, this.needsSwap = false, this._oldClearColor = new Ae();
      }
      render(e, t, i) {
        const n = e.autoClear;
        e.autoClear = false;
        let s, a;
        this.overrideMaterial !== null && (a = this.scene.overrideMaterial, this.scene.overrideMaterial = this.overrideMaterial), this.clearColor !== null && (e.getClearColor(this._oldClearColor), e.setClearColor(this.clearColor, e.getClearAlpha())), this.clearAlpha !== null && (s = e.getClearAlpha(), e.setClearAlpha(this.clearAlpha)), this.clearDepth == true && e.clearDepth(), e.setRenderTarget(this.renderToScreen ? null : i), this.clear === true && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), e.render(this.scene, this.camera), this.clearColor !== null && e.setClearColor(this._oldClearColor), this.clearAlpha !== null && e.setClearAlpha(s), this.overrideMaterial !== null && (this.scene.overrideMaterial = a), e.autoClear = n;
      }
    }
    const GE = {
      uniforms: {
        tDiffuse: {
          value: null
        },
        luminosityThreshold: {
          value: 1
        },
        smoothWidth: {
          value: 1
        },
        defaultColor: {
          value: new Ae(0)
        },
        defaultOpacity: {
          value: 0
        }
      },
      vertexShader: `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
      fragmentShader: `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			float v = luminance( texel.xyz );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`
    };
    class Gs extends Xa {
      constructor(e, t, i, n) {
        super(), this.strength = t !== void 0 ? t : 1, this.radius = i, this.threshold = n, this.resolution = e !== void 0 ? new ee(e.x, e.y) : new ee(256, 256), this.clearColor = new Ae(0, 0, 0), this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
        let s = Math.round(this.resolution.x / 2), a = Math.round(this.resolution.y / 2);
        this.renderTargetBright = new ki(s, a, {
          type: hr
        }), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = false;
        for (let h = 0; h < this.nMips; h++) {
          const d = new ki(s, a, {
            type: hr
          });
          d.texture.name = "UnrealBloomPass.h" + h, d.texture.generateMipmaps = false, this.renderTargetsHorizontal.push(d);
          const p = new ki(s, a, {
            type: hr
          });
          p.texture.name = "UnrealBloomPass.v" + h, p.texture.generateMipmaps = false, this.renderTargetsVertical.push(p), s = Math.round(s / 2), a = Math.round(a / 2);
        }
        const o = GE;
        this.highPassUniforms = Lo.clone(o.uniforms), this.highPassUniforms.luminosityThreshold.value = n, this.highPassUniforms.smoothWidth.value = 0.01, this.materialHighPassFilter = new Zt({
          uniforms: this.highPassUniforms,
          vertexShader: o.vertexShader,
          fragmentShader: o.fragmentShader
        }), this.separableBlurMaterials = [];
        const l = [
          3,
          5,
          7,
          9,
          11
        ];
        s = Math.round(this.resolution.x / 2), a = Math.round(this.resolution.y / 2);
        for (let h = 0; h < this.nMips; h++) this.separableBlurMaterials.push(this.getSeparableBlurMaterial(l[h])), this.separableBlurMaterials[h].uniforms.invSize.value = new ee(1 / s, 1 / a), s = Math.round(s / 2), a = Math.round(a / 2);
        this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = t, this.compositeMaterial.uniforms.bloomRadius.value = 0.1;
        const c = [
          1,
          0.8,
          0.6,
          0.4,
          0.2
        ];
        this.compositeMaterial.uniforms.bloomFactors.value = c, this.bloomTintColors = [
          new D(1, 1, 1),
          new D(1, 1, 1),
          new D(1, 1, 1),
          new D(1, 1, 1),
          new D(1, 1, 1)
        ], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors;
        const u = xm;
        this.copyUniforms = Lo.clone(u.uniforms), this.blendMaterial = new Zt({
          uniforms: this.copyUniforms,
          vertexShader: u.vertexShader,
          fragmentShader: u.fragmentShader,
          blending: Wn,
          depthTest: false,
          depthWrite: false,
          transparent: true
        }), this.enabled = true, this.needsSwap = false, this._oldClearColor = new Ae(), this.oldClearAlpha = 1, this.basic = new $i(), this.fsQuad = new ym(null);
      }
      dispose() {
        for (let e = 0; e < this.renderTargetsHorizontal.length; e++) this.renderTargetsHorizontal[e].dispose();
        for (let e = 0; e < this.renderTargetsVertical.length; e++) this.renderTargetsVertical[e].dispose();
        this.renderTargetBright.dispose();
        for (let e = 0; e < this.separableBlurMaterials.length; e++) this.separableBlurMaterials[e].dispose();
        this.compositeMaterial.dispose(), this.blendMaterial.dispose(), this.basic.dispose(), this.fsQuad.dispose();
      }
      setSize(e, t) {
        let i = Math.round(e / 2), n = Math.round(t / 2);
        this.renderTargetBright.setSize(i, n);
        for (let s = 0; s < this.nMips; s++) this.renderTargetsHorizontal[s].setSize(i, n), this.renderTargetsVertical[s].setSize(i, n), this.separableBlurMaterials[s].uniforms.invSize.value = new ee(1 / i, 1 / n), i = Math.round(i / 2), n = Math.round(n / 2);
      }
      render(e, t, i, n, s) {
        e.getClearColor(this._oldClearColor), this.oldClearAlpha = e.getClearAlpha();
        const a = e.autoClear;
        e.autoClear = false, e.setClearColor(this.clearColor, 0), s && e.state.buffers.stencil.setTest(false), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = i.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), this.highPassUniforms.tDiffuse.value = i.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, e.setRenderTarget(this.renderTargetBright), e.clear(), this.fsQuad.render(e);
        let o = this.renderTargetBright;
        for (let l = 0; l < this.nMips; l++) this.fsQuad.material = this.separableBlurMaterials[l], this.separableBlurMaterials[l].uniforms.colorTexture.value = o.texture, this.separableBlurMaterials[l].uniforms.direction.value = Gs.BlurDirectionX, e.setRenderTarget(this.renderTargetsHorizontal[l]), e.clear(), this.fsQuad.render(e), this.separableBlurMaterials[l].uniforms.colorTexture.value = this.renderTargetsHorizontal[l].texture, this.separableBlurMaterials[l].uniforms.direction.value = Gs.BlurDirectionY, e.setRenderTarget(this.renderTargetsVertical[l]), e.clear(), this.fsQuad.render(e), o = this.renderTargetsVertical[l];
        this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, e.setRenderTarget(this.renderTargetsHorizontal[0]), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.blendMaterial, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, s && e.state.buffers.stencil.setTest(true), this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(i), this.fsQuad.render(e)), e.setClearColor(this._oldClearColor, this.oldClearAlpha), e.autoClear = a;
      }
      getSeparableBlurMaterial(e) {
        const t = [];
        for (let i = 0; i < e; i++) t.push(0.39894 * Math.exp(-0.5 * i * i / (e * e)) / e);
        return new Zt({
          defines: {
            KERNEL_RADIUS: e
          },
          uniforms: {
            colorTexture: {
              value: null
            },
            invSize: {
              value: new ee(0.5, 0.5)
            },
            direction: {
              value: new ee(0.5, 0.5)
            },
            gaussianCoefficients: {
              value: t
            }
          },
          vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
          fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 invSize;
				uniform vec2 direction;
				uniform float gaussianCoefficients[KERNEL_RADIUS];

				void main() {
					float weightSum = gaussianCoefficients[0];
					vec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianCoefficients[i];
						vec2 uvOffset = direction * invSize * x;
						vec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;
						vec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum, 1.0);
				}`
        });
      }
      getCompositeMaterial(e) {
        return new Zt({
          defines: {
            NUM_MIPS: e
          },
          uniforms: {
            blurTexture1: {
              value: null
            },
            blurTexture2: {
              value: null
            },
            blurTexture3: {
              value: null
            },
            blurTexture4: {
              value: null
            },
            blurTexture5: {
              value: null
            },
            bloomStrength: {
              value: 1
            },
            bloomFactors: {
              value: null
            },
            bloomTintColors: {
              value: null
            },
            bloomRadius: {
              value: 0
            }
          },
          vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
				}`,
          fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`
        });
      }
    }
    Gs.BlurDirectionX = new ee(1, 0), Gs.BlurDirectionY = new ee(0, 1);
    function WE(r, e = {
      density: 1
    }) {
      const t = new hi(), i = [], n = 4e3, s = 6e3, a = Math.floor(5e3 * e.density);
      for (let c = 0; c < a; c++) {
        let u, h, d, p;
        do
          u = (Math.random() - 0.5) * s * 2, h = (Math.random() - 0.5) * s * 2, d = (Math.random() - 0.5) * s * 2, p = Math.sqrt(u * u + h * h + d * d);
        while (p < n);
        i.push(u, h, d);
      }
      t.setAttribute("position", new Wt(i, 3));
      const o = new qc({
        color: 16777164,
        size: 3,
        sizeAttenuation: true,
        transparent: true,
        opacity: 1,
        blending: Wn
      }), l = new jd(t, o);
      r.add(l);
    }
    function XE(r, e, t, i = 2) {
      const n = new su(6, 32, 32), s = new xs({
        emissive: new Ae(16777164),
        emissiveIntensity: 3,
        roughness: 0.1
      }), a = new Rt(n, s);
      a.position.set(-100, 250, -500), r.add(a);
      const o = new uu(16755200, 10, 500);
      o.position.copy(a.position), r.add(o);
      const l = new HE(e);
      l.addPass(new VE(r, t));
      const c = new Gs(new ee(window.innerWidth, window.innerHeight), i, 0.4, 1.2);
      return l.addPass(c), l;
    }
    let lt = null, wr = null, Xi = null;
    function jE() {
      if (lt) {
        lt.style.display = "flex";
        return;
      }
      console.log("Creating Name viewport"), lt = document.createElement("div"), lt.id = "name-viewport-container", lt.style.position = "fixed", lt.style.top = "50%", lt.style.left = "50%", lt.style.transform = "translate(-50%, -50%)", lt.style.width = "80%", lt.style.maxWidth = "1200px", lt.style.height = "80vh", lt.style.backgroundColor = "rgba(0, 0, 0, 0.9)", lt.style.border = "0.5px solid #FFFF", lt.style.borderRadius = "20px", lt.style.boxShadow = "0 0 30px rgba(0, 123, 255, 0.5)", lt.style.zIndex = "1000", lt.style.display = "flex", lt.style.flexDirection = "column", lt.style.overflow = "hidden";
      const r = document.createElement("div");
      r.style.display = "flex", r.style.justifyContent = "space-between", r.style.alignItems = "center", r.style.padding = "1px 2px", r.style.backgroundColor = "rgba(0, 0, 0, 0.3)", r.style.color = "white", r.style.borderTopLeftRadius = "20px", r.style.borderTopRightRadius = "20px";
      const e = document.createElement("h2");
      e.style.fontSize = "1.2rem", Xi = document.createElement("button"), Xi.textContent = "\u2715", Xi.style.background = "none", Xi.style.border = "none", Xi.style.color = "white", Xi.style.fontSize = "1.5rem", Xi.style.cursor = "pointer", Xi.style.padding = "0 5px", Xi.style.lineHeight = "1", r.appendChild(Xi), lt.appendChild(r), wr = document.createElement("iframe"), wr.src = "./public/psycheName/public/name/psycheName.html", wr.style.width = "100%", wr.style.height = "100%", wr.style.border = "none", wr.style.backgroundColor = "#222", wr.onerror = () => {
        console.error("Failed to load iframe content");
      }, wr.onload = () => {
        console.log("Iframe loaded successfully");
      }, lt.appendChild(wr), document.body.appendChild(lt), St.from(lt, {
        opacity: 0,
        scale: 0.8,
        duration: 0.4,
        ease: "power2.out"
      }), Xi.addEventListener("click", Mh), document.addEventListener("keydown", qE);
    }
    function Mh() {
      lt && St.to(lt, {
        opacity: 0,
        scale: 0.8,
        duration: 0.3,
        ease: "power2.in",
        onComplete: () => {
          lt.style.display = "none", lt.style.opacity = 1, lt.style.transform = "translate(-50%, -50%) scale(1)";
        }
      });
    }
    function qE(r) {
      r.key === "Escape" && Mh();
    }
    function Ws(r, e = {}) {
      const { backgroundColor: t = "rgba(0, 0, 0, 0.125)", borderColor: i = "#ffffcc", borderWidth: n = "2px", borderRadius: s = "10px", boxShadow: a = "0 0 25px rgba(255, 255, 204, 0.6)", zIndex: o = "900" } = e;
      r.style.position = "fixed", r.style.top = "50%", r.style.left = "50%", r.style.transform = "translate(-50%, -50%)", r.style.backgroundColor = t, r.style.border = `${n} solid ${i}`, r.style.borderRadius = s, r.style.boxShadow = a, r.style.zIndex = o, r.style.display = "flex", r.style.flexDirection = "column", r.style.overflow = "hidden";
    }
    function Xs(r, e = {}) {
      const { backgroundColor: t = "rgba(26, 26, 58, 0.125)", gradientStart: i = "rgba(26, 26, 58, 0.125)", gradientEnd: n = "rgba(58, 58, 106, 0.125)", textColor: s = "white", padding: a = "10px 15px" } = e;
      r.style.display = "flex", r.style.justifyContent = "space-between", r.style.alignItems = "center", r.style.padding = a, r.style.backgroundColor = t, r.style.backgroundImage = `linear-gradient(to right, ${i}, ${n})`, r.style.color = s, r.style.borderTopLeftRadius = "8px", r.style.borderTopRightRadius = "8px";
    }
    function js(r, e = {}) {
      const { fontSize: t = "1.2rem", textShadow: i = "0 0 5px rgba(255, 255, 204, 0.7)", letterSpacing: n = "0.5px" } = e;
      r.style.margin = "0", r.style.fontSize = t, r.style.textShadow = i, r.style.letterSpacing = n;
    }
    function qs(r, e = {}) {
      const { color: t = "white", fontSize: i = "1.5rem" } = e;
      r.style.background = "none", r.style.border = "none", r.style.color = t, r.style.fontSize = i, r.style.cursor = "pointer", r.style.padding = "0 5px", r.style.lineHeight = "1";
    }
    function YE(r, e = {}) {
      const { color: t = "white", fontSize: i = "1.2rem" } = e;
      r.style.background = "none", r.style.border = "none", r.style.color = t, r.style.fontSize = i, r.style.cursor = "pointer", r.style.padding = "0 5px", r.style.lineHeight = "1", r.style.marginRight = "5px";
    }
    function Ys(r, e = {}) {
      const { backgroundColor: t = "rgba(0, 0, 0, 0.1)" } = e;
      r.style.width = "100%", r.style.height = "100%", r.style.border = "none", r.style.backgroundColor = t, r.style.overflow = "auto", r.scrolling = "yes";
    }
    function Ks(r) {
      const e = r.createElement("style");
      e.textContent = `
        /* Hide scrollbars for WebKit browsers */
        iframe::-webkit-scrollbar,
        *::-webkit-scrollbar {
            width: 0 !important;
            height: 0 !important;
            display: none !important;
        }
        
        /* Hide scrollbars for Firefox */
        iframe,
        * {
            scrollbar-width: none !important;
            -ms-overflow-style: none !important;
        }
        
        /* Allow scrolling but hide scrollbars */
        iframe {
            overflow: auto !important;
        }
    `, r.head.appendChild(e);
    }
    function Zs(r) {
      try {
        const e = r.contentDocument || r.contentWindow.document, t = e.createElement("style");
        t.textContent = `
            /* Hide all scrollbars in the iframe content */
            ::-webkit-scrollbar { 
                width: 0 !important; 
                height: 0 !important; 
                display: none !important; 
            }
            * { 
                scrollbar-width: none !important; 
                -ms-overflow-style: none !important;
            }
            html, body {
                overflow: auto !important;
                scrollbar-width: none !important;
                -ms-overflow-style: none !important;
            }
            
            /* Ensure content is scrollable */
            body {
                overflow-y: auto !important;
                overflow-x: auto !important;
            }
        `, e.head.appendChild(t);
      } catch (e) {
        console.error("Could not modify iframe content due to cross-origin restrictions:", e);
      }
    }
    function Js(r) {
      const e = document.createElement("div");
      e.style.position = "absolute", e.style.top = "0", e.style.left = "0", e.style.width = "100%", e.style.height = "100%", e.style.pointerEvents = "none", e.style.background = "radial-gradient(circle at 50% 50%, rgba(255, 255, 204, 0.03) 0%, transparent 80%)", e.style.borderRadius = "10px", e.style.zIndex = "1", r.appendChild(e);
    }
    function $s(r, e = 20) {
      const t = document.createElement("div");
      t.style.position = "absolute", t.style.top = "0", t.style.left = "0", t.style.width = "100%", t.style.height = "100%", t.style.overflow = "hidden", t.style.pointerEvents = "none", t.style.zIndex = "0", t.style.borderRadius = "10px", r.appendChild(t);
      for (let i = 0; i < e; i++) {
        const n = document.createElement("div"), s = Math.random() * 2 + 1, a = Math.random() * 100, o = Math.random() * 100, l = Math.random() * 0.5 + 0.1, c = Math.random() * 3 + 2, u = Math.random() * 2;
        n.style.position = "absolute", n.style.width = `${s}px`, n.style.height = `${s}px`, n.style.borderRadius = "50%", n.style.backgroundColor = "#ffffcc", n.style.left = `${a}%`, n.style.top = `${o}%`, n.style.opacity = `${l}`, t.appendChild(n), St.to(n, {
          opacity: 0.1,
          duration: c,
          repeat: -1,
          yoyo: true,
          ease: "sine.inOut",
          delay: u
        });
      }
      return t;
    }
    function Qs(r, e, t) {
      const i = St.timeline();
      return i.from(r, {
        opacity: 0,
        scale: 0.7,
        duration: 0.6,
        ease: "power2.out"
      }), i.from(e, {
        y: -50,
        opacity: 0,
        duration: 0.4,
        ease: "back.out(1.7)"
      }, "-=0.3"), i.from(t, {
        opacity: 0,
        y: 30,
        duration: 0.5,
        ease: "power2.out"
      }, "-=0.2"), i;
    }
    function ea(r, e = {}) {
      const { color: t = "rgba(255, 255, 204, 0.7)", intensity: i = "30px", duration: n = 2 } = e;
      return St.to(r, {
        boxShadow: `0 0 ${i} ${t}`,
        repeat: -1,
        yoyo: true,
        duration: n,
        ease: "sine.inOut"
      });
    }
    function en(r, e) {
      const t = St.timeline({
        onComplete: e
      });
      return t.to(r, {
        boxShadow: "0 0 40px rgba(255, 255, 204, 0.9)",
        duration: 0.3,
        ease: "power1.in"
      }), t.to(r, {
        opacity: 0,
        scale: 0.7,
        duration: 0.5,
        ease: "power2.in"
      }, "-=0.1"), t;
    }
    ra = function() {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", ra);
        return;
      }
      const r = document.querySelectorAll("button"), e = Array.from(r).filter((t) => t.textContent === "\u21A9" || t.innerHTML === "\u21A9");
      console.log("Found return buttons:", e.length), e.forEach((t) => {
        const i = t.cloneNode(true);
        t.parentNode.replaceChild(i, t), i.addEventListener("click", function(n) {
          n.preventDefault(), n.stopPropagation();
          let s = i.closest('[id$="-viewport-container"]');
          if (!s) {
            console.error("No viewport found for return button");
            return;
          }
          console.log("Found viewport for return button:", s.id);
          const a = s.querySelector("iframe");
          if (!a) {
            console.error("No iframe found in viewport");
            return;
          }
          const o = s.querySelector("h2");
          o && (o.textContent = "Psyche Mission Games"), a.src = "./games/games.html", console.log("Loading games HTML in viewport:", s.id);
        });
      });
    }, ra(), document.addEventListener("DOMContentLoaded", ra), setInterval(ra, 1e3);
    let $e = null, Ar = null, Dn = null, ja = null;
    function bm() {
      const r = window.innerWidth, e = window.innerHeight, t = window.devicePixelRatio || 1;
      console.log(`Screen size: ${r}x${e}, Pixel ratio: ${t}`);
      let i, n, s;
      return r === 2388 && e === 1668 || e === 2388 && r === 1668 ? (console.log('iPad Pro 11" detected'), i = "90%", s = "2000px", n = "90vh") : r >= 2e3 ? (i = "85%", s = "2400px", n = "85vh") : r >= 1600 ? (i = "88%", s = "1900px", n = "88vh") : r >= 1200 ? (i = "90%", s = "1500px", n = "90vh") : r >= 992 ? (i = "92%", s = "1150px", n = "92vh") : r >= 768 ? (i = "95%", s = "950px", n = "95vh") : (i = "98%", s = "100%", n = "98vh"), {
        width: i,
        maxWidth: s,
        height: n
      };
    }
    function qa() {
      if (!$e) return;
      const { width: r, maxWidth: e, height: t } = bm();
      $e.style.width = r, $e.style.maxWidth = e, $e.style.height = t, console.log(`Viewport resized to: width=${r}, maxWidth=${e}, height=${t}`);
    }
    function KE() {
      if ($e) {
        $e.style.display = "flex", qa();
        return;
      }
      console.log("Creating games viewport"), $e = document.createElement("div"), $e.id = "games-viewport-container", Ws($e, {
        backgroundColor: "rgba(0, 0, 0, 0.05)",
        borderColor: "rgba(122, 95, 62, 0.3)",
        boxShadow: "0 0 15px rgba(122, 95, 62, 0.3)"
      });
      const { width: r, maxWidth: e, height: t } = bm();
      $e.style.width = r, $e.style.maxWidth = e, $e.style.height = t;
      const i = document.createElement("div");
      Xs(i, {
        backgroundColor: "rgba(10, 10, 20, 0.2)",
        gradientStart: "rgba(10, 10, 20, 0.2)",
        gradientEnd: "rgba(20, 20, 40, 0.2)"
      });
      const n = document.createElement("h2");
      n.textContent = "Psyche Mission Games", js(n);
      const s = document.createElement("div");
      s.style.display = "flex", s.style.alignItems = "center";
      const a = document.createElement("button");
      a.textContent = "\u21A9", YE(a), Dn = document.createElement("button"), Dn.textContent = "\u2715", qs(Dn), s.appendChild(a), s.appendChild(Dn), i.appendChild(n), i.appendChild(s), $e.appendChild(i), Ar = document.createElement("iframe"), Ar.src = "/public/games/games.html", Ys(Ar, {
        backgroundColor: "rgba(0, 0, 0, 0.0)"
      }), Ks(document), Ar.onerror = () => {
        console.error("Failed to load games iframe content");
      }, Ar.onload = () => {
        console.log("Games iframe loaded successfully"), Zs(Ar);
      }, $e.appendChild(Ar), document.body.appendChild($e), Js($e), $s($e), Qs($e, i, Ar), ea($e), Dn.addEventListener("click", _l), a.addEventListener("click", _l), document.addEventListener("keydown", Sm), window.addEventListener("resize", qa), ja = new ResizeObserver((o) => {
        console.log("ResizeObserver detected size change"), qa();
      }), ja.observe(document.body);
    }
    function _l() {
      $e && en($e, () => {
        $e.style.display = "none", $e.style.opacity = 1, $e.style.transform = "translate(-50%, -50%) scale(1)";
      });
    }
    function Sm(r) {
      r.key === "Escape" && _l();
    }
    function ZE() {
      $e && (Dn.removeEventListener("click", _l), document.removeEventListener("keydown", Sm), window.removeEventListener("resize", qa), ja && (ja.disconnect(), ja = null), document.body.removeChild($e), $e = null, Ar = null, Dn = null);
    }
    window.setGamesViewportSize = function(r, e) {
      if (!$e) {
        console.warn("Games viewport is not currently active");
        return;
      }
      return console.log(`Manually setting viewport size to ${r}x${e}`), $e.style.width = `${r}px`, $e.style.maxWidth = `${r}px`, $e.style.height = `${e}px`, $e.style.transform = "translate(-50%, -50%)", `Viewport size set to ${r}x${e}`;
    }, window.resetGamesViewportSize = function() {
      if (!$e) {
        console.warn("Games viewport is not currently active");
        return;
      }
      return qa(), "Viewport size reset to responsive mode";
    };
    let Ye = null, zt = null, In = null, Ya = null;
    function Em() {
      const r = window.innerWidth, e = window.innerHeight, t = window.devicePixelRatio || 1;
      console.log(`Screen size: ${r}x${e}, Pixel ratio: ${t}`);
      let i, n, s;
      return r === 2388 && e === 1668 || e === 2388 && r === 1668 ? (console.log('iPad Pro 11" detected'), i = "90%", s = "2000px", n = "90vh") : r >= 2e3 ? (i = "85%", s = "2400px", n = "85vh") : r >= 1600 ? (i = "88%", s = "1900px", n = "88vh") : r >= 1200 ? (i = "90%", s = "1500px", n = "90vh") : r >= 992 ? (i = "92%", s = "1150px", n = "92vh") : r >= 768 ? (i = "95%", s = "950px", n = "95vh") : (i = "98%", s = "100%", n = "98vh"), {
        width: i,
        maxWidth: s,
        height: n
      };
    }
    function Un() {
      if (!Ye) return;
      const { width: r, maxWidth: e, height: t } = Em();
      if (Ye.style.width = r, Ye.style.maxWidth = e, Ye.style.height = t, console.log(`Viewport resized to: width=${r}, maxWidth=${e}, height=${t}`), zt && zt.contentDocument) try {
        const i = zt.contentDocument || zt.contentWindow.document;
        if (i.getElementById("container1")) {
          const n = Math.min(1, window.innerWidth / 1920);
          let s = i.getElementById("responsive-scaling");
          s || (s = i.createElement("style"), s.id = "responsive-scaling", i.head.appendChild(s)), s.textContent = `
                    #container1 {
                        transform: scale(${n});
                        transform-origin: center top;
                        width: calc(100% / ${n});
                        margin-left: auto;
                        margin-right: auto;
                    }
                    
                    #astronautCar {
                        max-width: 100%;
                        height: auto;
                    }
                `, console.log(`Applied responsive scaling: ${n}`);
        }
      } catch (i) {
        console.error("Could not modify iframe content:", i);
      }
    }
    function Tm() {
      if (Ye) {
        Ye.style.display = "flex", Un();
        return;
      }
      console.log("Creating kids viewport"), Ye = document.createElement("div"), Ye.id = "kids-viewport-container", Ws(Ye);
      const { width: r, maxWidth: e, height: t } = Em();
      Ye.style.width = r, Ye.style.maxWidth = e, Ye.style.height = t;
      const i = document.createElement("div");
      Xs(i);
      const n = document.createElement("h2");
      n.textContent = "Psyche Jr - Kids Space Explorer", js(n), In = document.createElement("button"), In.textContent = "\u2715", qs(In), i.appendChild(n), i.appendChild(In), Ye.appendChild(i), zt = document.createElement("iframe"), zt.src = "/public/PsycheJR/kids.html", Ys(zt), Ks(document), zt.onerror = () => {
        console.error("Failed to load kids iframe content");
      }, zt.onload = () => {
        console.log("Kids iframe loaded successfully"), Zs(zt), Un();
        try {
          const s = zt.contentDocument || zt.contentWindow.document;
          new MutationObserver(() => {
            Un();
          }).observe(s.body, {
            childList: true,
            subtree: true
          });
        } catch (s) {
          console.error("Could not set up MutationObserver:", s);
        }
      }, Ye.appendChild(zt), document.body.appendChild(Ye), Js(Ye), $s(Ye), Qs(Ye, i, zt), ea(Ye), In.addEventListener("click", () => {
        en(Ye, Sh);
      }), document.addEventListener("keydown", wm), window.addEventListener("resize", Un), Ya = new ResizeObserver((s) => {
        console.log("ResizeObserver detected size change"), Un();
      }), Ya.observe(document.body);
    }
    function bh() {
      Ye && en(Ye, () => {
        Ye.style.display = "none", Ye.style.opacity = 1, Ye.style.transform = "translate(-50%, -50%) scale(1)";
      });
    }
    function wm(r) {
      r.key === "Escape" && en(Ye, Sh);
    }
    function Sh() {
      Ye && (In.removeEventListener("click", bh), document.removeEventListener("keydown", wm), window.removeEventListener("resize", Un), Ya && (Ya.disconnect(), Ya = null), document.body.removeChild(Ye), Ye = null, zt = null, In = null);
    }
    window.setKidsViewportSize = function(r, e) {
      if (!Ye) {
        console.warn("Kids viewport is not currently active");
        return;
      }
      if (console.log(`Manually setting viewport size to ${r}x${e}`), Ye.style.width = `${r}px`, Ye.style.maxWidth = `${r}px`, Ye.style.height = `${e}px`, Ye.style.transform = "translate(-50%, -50%)", zt && zt.contentDocument) try {
        const t = (zt.contentDocument || zt.contentWindow.document).getElementById("container1");
        if (t) {
          const i = Math.min(1, r / 1920);
          t.style.transform = `scale(${i})`, t.style.transformOrigin = "center top", t.style.width = `calc(100% / ${i})`, console.log(`Applied manual scaling: ${i}`);
        }
      } catch (t) {
        console.error("Could not modify iframe content:", t);
      }
      return `Viewport size set to ${r}x${e}`;
    }, window.resetKidsViewportSize = function() {
      if (!Ye) {
        console.warn("Kids viewport is not currently active");
        return;
      }
      return Un(), "Viewport size reset to responsive mode";
    };
    const JE = Object.freeze(Object.defineProperty({
      __proto__: null,
      destroyKidsViewport: Sh,
      hideKidsViewport: bh,
      showKidsViewport: Tm
    }, Symbol.toStringTag, {
      value: "Module"
    }));
    let gt = null, Rr = null, On = null, Nn = null, Ka = null, Cr = null;
    function $E() {
      if (gt) {
        gt.style.display = "flex";
        return;
      }
      console.log("Creating Year viewport"), gt = document.createElement("div"), gt.id = "year-viewport-container", Ws(gt, {
        backgroundColor: "rgba(0, 0, 0, 0.9)",
        borderColor: "rgb(255, 255, 255)",
        boxShadow: "0 0 20px rgba(255, 255, 204, 0.6)"
      }), gt.style.width = "80%", gt.style.maxWidth = "1440px", gt.style.height = "95vh", Nn = document.createElement("div"), Xs(Nn, {
        backgroundColor: "#f9a000",
        gradientStart: "#f9a000",
        gradientEnd: "#f9a000"
      }), Ka = document.createElement("h2"), Ka.textContent = "Compare Earth and Psyche", js(Ka), On = document.createElement("button"), On.textContent = "\u2715", qs(On), Nn.appendChild(Ka), Nn.appendChild(On), gt.appendChild(Nn), Rr = document.createElement("iframe"), Rr.src = "./../../public/year/year.html", Ys(Rr, {
        backgroundColor: "#222"
      }), Rr.onerror = () => {
        console.error("Failed to load iframe content");
      }, Rr.onload = () => {
        console.log("Iframe loaded successfully"), Zs(Rr);
      }, gt.appendChild(Rr), document.body.appendChild(gt), Js(gt), $s(gt, 15), Qs(gt, Nn, Rr), Cr = ea(gt, {
        color: "rgba(255, 255, 255, 0.6)",
        intensity: "25px"
      }), Ks(document), On.addEventListener("click", Eh), document.addEventListener("keydown", Am);
    }
    function Eh() {
      gt && (Cr && Cr.kill(), en(gt, () => {
        gt.style.display = "none", gt.style.opacity = 1, gt.style.transform = "translate(-50%, -50%) scale(1)", document.body.classList.add("overlay-open"), Cr && (Cr.restart(), Cr.pause());
      }).play());
    }
    function Am(r) {
      r.key === "Escape" && Eh();
    }
    function QE() {
      gt ? (Cr && Cr.kill(), St.to(gt, {
        y: "100%",
        duration: 0.5,
        ease: "power1.in",
        onComplete: () => {
          On.removeEventListener("click", Eh), document.removeEventListener("keydown", Am), document.body.removeChild(gt), gt = null, Rr = null, On = null, Nn = null, Ka = null, Cr = null;
        }
      })) : console.log("No viewport container found to destroy.");
    }
    function eT(r, e, t, i) {
      var n;
      const s = (n = t[4]) == null ? void 0 : n.position;
      if (!s) return console.error("Section 4 position not found."), Promise.reject("Section 4 position not found.");
      const a = {
        x: s.x,
        y: s.y + 2,
        z: s.z - 12
      }, o = {
        x: 0.2,
        y: 0,
        z: 0
      };
      return new Promise((l, c) => {
        try {
          const { buttonMesh: u } = Vs(`Explore the Cosmic Comparison
between Earth and Psyche`, a, o, 0.7, r, () => {
            $E(), console.log("Cosmic Comparison button clicked.");
          }), h = new mn(), d = new ee();
          window.addEventListener("mousemove", (p) => {
            const f = i.domElement.getBoundingClientRect();
            d.x = (p.clientX - f.left) / f.width * 2 - 1, d.y = -((p.clientY - f.top) / f.height) * 2 + 1, h.setFromCamera(d, e);
            const _ = h.intersectObjects(Ln);
            i.domElement.style.cursor = _.length > 0 ? "pointer" : "default";
          }), l();
        } catch (u) {
          c(u);
        }
      });
    }
    function tT(r, e) {
      const t = Qa() === 4;
      for (let i = 0; i < e.children.length; i++) {
        const n = e.children[i];
        n.userData && n.userData.section4Element && (n.visible = t);
      }
    }
    function iT() {
    }
    window.setWebsiteViewportSize = function(r, e) {
      {
        console.warn("Website viewport is not currently active");
        return;
      }
    }, window.resetWebsiteViewportSize = function() {
      {
        console.warn("Website viewport is not currently active");
        return;
      }
    };
    let Qe = null, Pt = null, Fn = null, Za = null;
    function Rm() {
      const r = window.innerWidth, e = window.innerHeight, t = window.devicePixelRatio || 1;
      console.log(`Screen size: ${r}x${e}, Pixel ratio: ${t}`);
      let i, n, s;
      return r === 2388 && e === 1668 || e === 2388 && r === 1668 ? (console.log('iPad Pro 11" detected'), i = "90%", s = "2000px", n = "90vh") : r >= 2e3 ? (i = "85%", s = "2400px", n = "85vh") : r >= 1600 ? (i = "88%", s = "1900px", n = "88vh") : r >= 1200 ? (i = "90%", s = "1500px", n = "90vh") : r >= 992 ? (i = "92%", s = "1150px", n = "92vh") : r >= 768 ? (i = "95%", s = "950px", n = "95vh") : (i = "98%", s = "100%", n = "98vh"), {
        width: i,
        maxWidth: s,
        height: n
      };
    }
    function Bn() {
      if (!Qe) return;
      const { width: r, maxWidth: e, height: t } = Rm();
      if (Qe.style.width = r, Qe.style.maxWidth = e, Qe.style.height = t, console.log(`Viewport resized to: width=${r}, maxWidth=${e}, height=${t}`), Pt && Pt.contentDocument) try {
        const i = Pt.contentDocument || Pt.contentWindow.document;
        if (i.getElementById("psyche-container")) {
          const n = parseInt(r) || window.innerWidth * (parseInt(r) / 100), s = Math.min(1, n / 1920);
          let a = i.getElementById("responsive-scaling");
          a || (a = i.createElement("style"), a.id = "responsive-scaling", i.head.appendChild(a)), a.textContent = `
                    /* Responsive scaling for surface2 content */
                    #psyche-container {
                        width: 100% !important;
                        height: ${Math.max(300, 50 * s)}vh !important;
                        max-width: 100% !important;
                    }
                    
                    #header-h1 {
                        font-size: ${Math.max(40, 90 * s)}px !important;
                    }
                    
                    #materials, #features, #dimensions, #comparable, #explore {
                        width: 90% !important;
                    }
                    
                    #inner-materials h1, #inner-features h1, #inner-dimensions h1, 
                    #inner-comparable h1, #inner-explore h1 {
                        font-size: ${Math.max(30, 60 * s)}px !important;
                    }
                    
                    #inner-materials p, #inner-features p, #inner-dimensions p, 
                    #inner-comparable p, #inner-explore p {
                        font-size: ${Math.max(18, 40 * s)}px !important;
                    }
                    
                    #comparable h3 {
                        font-size: ${Math.max(25, 50 * s)}px !important;
                    }
                    
                    #comparable h4 {
                        font-size: ${Math.max(20, 40 * s)}px !important;
                    }
                    
                    /* Ensure content is scrollable */
                    body {
                        overflow-y: auto !important;
                    }
                `, console.log(`Applied responsive scaling: ${s}`), Pt.contentWindow.updatePsycheModelSize && setTimeout(() => {
            Pt.contentWindow.updatePsycheModelSize(), console.log("Triggered 3D model resize");
          }, 100);
        }
      } catch (i) {
        console.error("Could not modify iframe content:", i);
      }
    }
    function rT() {
      if (Qe) {
        Qe.style.display = "flex", Bn();
        return;
      }
      console.log("Creating surface2 viewport"), Qe = document.createElement("div"), Qe.id = "surface2-viewport-container", Ws(Qe, {
        backgroundColor: "rgba(0, 0, 0, 0.05)",
        borderColor: "rgba(122, 95, 62, 0.3)",
        boxShadow: "0 0 15px rgba(122, 95, 62, 0.3)"
      });
      const { width: r, maxWidth: e, height: t } = Rm();
      Qe.style.width = r, Qe.style.maxWidth = e, Qe.style.height = t;
      const i = document.createElement("div");
      Xs(i, {
        backgroundColor: "rgba(10, 10, 20, 0.2)",
        gradientStart: "rgba(10, 10, 20, 0.2)",
        gradientEnd: "rgba(20, 20, 40, 0.2)"
      });
      const n = document.createElement("h2");
      n.textContent = "The Surface of Psyche", js(n), Fn = document.createElement("button"), Fn.textContent = "\u2715", qs(Fn), i.appendChild(n), i.appendChild(Fn), Qe.appendChild(i), Pt = document.createElement("iframe"), Pt.src = "/public/PsycheJR/surface2.html", Ys(Pt, {
        backgroundColor: "rgba(0, 0, 0, 0.0)"
      }), Ks(document), Pt.onerror = () => {
        console.error("Failed to load surface2 iframe content");
      }, Pt.onload = () => {
        console.log("Surface2 iframe loaded successfully"), Zs(Pt), Bn();
        try {
          const s = Pt.contentDocument || Pt.contentWindow.document, a = new MutationObserver(() => {
            Bn();
          });
          a.observe(s.body, {
            childList: true,
            subtree: true
          });
          const o = s.getElementById("psyche-container");
          if (o) {
            a.observe(o, {
              childList: true,
              subtree: true,
              attributes: true
            });
            const l = new Event("resize");
            window.dispatchEvent(l);
          }
        } catch (s) {
          console.error("Could not set up MutationObserver:", s);
        }
      }, Qe.appendChild(Pt), document.body.appendChild(Qe), Js(Qe), $s(Qe), Qs(Qe, i, Pt), ea(Qe), Fn.addEventListener("click", Th), document.addEventListener("keydown", Cm), window.addEventListener("resize", Bn), Za = new ResizeObserver((s) => {
        console.log("ResizeObserver detected size change"), Bn();
      }), Za.observe(document.body);
    }
    function Th() {
      Qe && en(Qe, () => {
        Qe.style.display = "none", Qe.style.opacity = 1, Qe.style.transform = "translate(-50%, -50%) scale(1)", document.body.classList.add("overlay-open");
      });
    }
    function Cm(r) {
      r.key === "Escape" && Th();
    }
    function nT() {
      Qe && (Fn.removeEventListener("click", Th), document.removeEventListener("keydown", Cm), window.removeEventListener("resize", Bn), Za && (Za.disconnect(), Za = null), document.body.removeChild(Qe), Qe = null, Pt = null, Fn = null);
    }
    window.setSurface2ViewportSize = function(r, e) {
      if (!Qe) {
        console.warn("Surface2 viewport is not currently active");
        return;
      }
      if (console.log(`Manually setting viewport size to ${r}x${e}`), Qe.style.width = `${r}px`, Qe.style.maxWidth = `${r}px`, Qe.style.height = `${e}px`, Qe.style.transform = "translate(-50%, -50%)", Pt && Pt.contentDocument) try {
        const t = Pt.contentDocument || Pt.contentWindow.document;
        if (t.getElementById("psyche-container")) {
          const i = Math.min(1, r / 1920);
          let n = t.getElementById("responsive-scaling");
          n || (n = t.createElement("style"), n.id = "responsive-scaling", t.head.appendChild(n)), n.textContent = `
                    /* Responsive scaling for surface2 content */
                    #psyche-container {
                        width: 100% !important;
                        height: ${Math.max(300, 50 * i)}vh !important;
                        max-width: 100% !important;
                    }
                    
                    #header-h1 {
                        font-size: ${Math.max(40, 90 * i)}px !important;
                    }
                    
                    #materials, #features, #dimensions, #comparable, #explore {
                        width: 90% !important;
                    }
                    
                    #inner-materials h1, #inner-features h1, #inner-dimensions h1, 
                    #inner-comparable h1, #inner-explore h1 {
                        font-size: ${Math.max(30, 60 * i)}px !important;
                    }
                    
                    #inner-materials p, #inner-features p, #inner-dimensions p, 
                    #inner-comparable p, #inner-explore p {
                        font-size: ${Math.max(18, 40 * i)}px !important;
                    }
                    
                    #comparable h3 {
                        font-size: ${Math.max(25, 50 * i)}px !important;
                    }
                    
                    #comparable h4 {
                        font-size: ${Math.max(20, 40 * i)}px !important;
                    }
                `, console.log(`Applied manual scaling: ${i}`);
          const s = new Event("resize");
          window.dispatchEvent(s);
        }
      } catch (t) {
        console.error("Could not modify iframe content:", t);
      }
      return `Viewport size set to ${r}x${e}`;
    }, window.resetSurface2ViewportSize = function() {
      if (!Qe) {
        console.warn("Surface2 viewport is not currently active");
        return;
      }
      return Bn(), "Viewport size reset to responsive mode";
    };
    let et = null, Pr = null, zn = null, Ja = null;
    function Pm() {
      const r = window.innerWidth, e = window.innerHeight, t = window.devicePixelRatio || 1;
      console.log(`Screen size: ${r}x${e}, Pixel ratio: ${t}`);
      let i, n, s;
      return r === 2388 && e === 1668 || e === 2388 && r === 1668 ? (console.log('iPad Pro 11" detected'), i = "90%", s = "2000px", n = "90vh") : r >= 2e3 ? (i = "85%", s = "2400px", n = "85vh") : r >= 1600 ? (i = "88%", s = "1900px", n = "88vh") : r >= 1200 ? (i = "90%", s = "1500px", n = "90vh") : r >= 992 ? (i = "92%", s = "1150px", n = "92vh") : r >= 768 ? (i = "95%", s = "950px", n = "95vh") : (i = "98%", s = "100%", n = "98vh"), {
        width: i,
        maxWidth: s,
        height: n
      };
    }
    function $a() {
      if (!et) return;
      const { width: r, maxWidth: e, height: t } = Pm();
      et.style.width = r, et.style.maxWidth = e, et.style.height = t, console.log(`Viewport resized to: width=${r}, maxWidth=${e}, height=${t}`);
    }
    function sT() {
      if (et) {
        et.style.display = "flex", $a();
        return;
      }
      console.log("Creating location2 viewport"), et = document.createElement("div"), et.id = "location2-viewport-container", Ws(et, {
        backgroundColor: "rgba(0, 0, 0, 0.05)",
        borderColor: "rgba(122, 95, 62, 0.3)",
        boxShadow: "0 0 15px rgba(122, 95, 62, 0.3)"
      });
      const { width: r, maxWidth: e, height: t } = Pm();
      et.style.width = r, et.style.maxWidth = e, et.style.height = t;
      const i = document.createElement("div");
      Xs(i, {
        backgroundColor: "rgba(10, 10, 20, 0.2)",
        gradientStart: "rgba(10, 10, 20, 0.2)",
        gradientEnd: "rgba(20, 20, 40, 0.2)"
      });
      const n = document.createElement("h2");
      n.textContent = "Psyche's Location in Space", js(n), zn = document.createElement("button"), zn.textContent = "\u2715", qs(zn), i.appendChild(n), i.appendChild(zn), et.appendChild(i), Pr = document.createElement("iframe"), Pr.src = "/public/PsycheJR/location2.html", Ys(Pr, {
        backgroundColor: "rgba(0, 0, 0, 0.0)"
      }), Ks(document), Pr.onerror = () => {
        console.error("Failed to load location2 iframe content");
      }, Pr.onload = () => {
        console.log("Location2 iframe loaded successfully"), Zs(Pr);
      }, et.appendChild(Pr), document.body.appendChild(et), Js(et), $s(et), Qs(et, i, Pr), ea(et), zn.addEventListener("click", wh), document.addEventListener("keydown", Lm), window.addEventListener("resize", $a), Ja = new ResizeObserver((s) => {
        console.log("ResizeObserver detected size change"), $a();
      }), Ja.observe(document.body);
    }
    function wh() {
      et && en(et, () => {
        et.style.display = "none", et.style.opacity = 1, et.style.transform = "translate(-50%, -50%) scale(1)", document.body.classList.add("overlay-open");
      });
    }
    function Lm(r) {
      r.key === "Escape" && wh();
    }
    function aT() {
      et && (zn.removeEventListener("click", wh), document.removeEventListener("keydown", Lm), window.removeEventListener("resize", $a), Ja && (Ja.disconnect(), Ja = null), document.body.removeChild(et), et = null, Pr = null, zn = null);
    }
    window.setLocation2ViewportSize = function(r, e) {
      if (!et) {
        console.warn("Location2 viewport is not currently active");
        return;
      }
      return console.log(`Manually setting viewport size to ${r}x${e}`), et.style.width = `${r}px`, et.style.maxWidth = `${r}px`, et.style.height = `${e}px`, et.style.transform = "translate(-50%, -50%)", `Viewport size set to ${r}x${e}`;
    }, window.resetLocation2ViewportSize = function() {
      if (!et) {
        console.warn("Location2 viewport is not currently active");
        return;
      }
      return $a(), "Viewport size reset to responsive mode";
    };
    let kn, Dm, Ah, ta = 1, Rh = false, Ch = 0;
    const Im = {
      2: Mh,
      3: bh,
      4: QE,
      5: iT,
      6: ZE,
      7: nT,
      8: aT
    };
    let Ph = ta;
    function oT(r) {
      Ch = r.touches[0].clientY;
    }
    function lT(r) {
      const e = r.touches[0].clientY, t = Ch - e;
      Ch = e, Om({
        deltaY: t
      }), r.preventDefault();
    }
    function cT(r, e, t) {
      kn = r, Dm = t, Ah = e, window.addEventListener("wheel", Om, {
        passive: false
      }), window.addEventListener("touchstart", oT, {
        passive: false
      }), window.addEventListener("touchmove", lT, {
        passive: false
      }), window.addEventListener("resize", () => Um(kn, Dm));
    }
    function Um(r, e) {
      if (!r || !e) {
        console.error("onResize called without a valid camera or renderer.");
        return;
      }
      const t = Math.max(window.innerWidth, 768), i = t / window.innerHeight;
      if (r.aspect = i, r.updateProjectionMatrix(), e.setSize(t, window.innerHeight), e.setPixelRatio(Math.min(window.devicePixelRatio, 2)), t < 1300) {
        const n = (1300 - t) * 0.048;
        r.fov = Math.min(75 + n, 100);
      } else r.fov = 75;
      r.updateProjectionMatrix();
    }
    function Om(r) {
      if (Rh) return;
      const e = r.deltaY > 0 ? 1 : -1;
      let t = ta + e;
      console.log("Swipe Direction: ", e), t > 8 ? t = 1 : t < 1 && (t = 8), Rh = true, Lh(t);
    }
    function Lh(r, e = null) {
      if (r < 0 || r >= Ah.length) return;
      Im[Ph] && Im[Ph](), ta = r, Ph = r, ta = r;
      const t = Ah[r].position;
      St.to(kn.position, {
        x: t.x,
        y: t.y,
        z: t.z,
        duration: 2,
        ease: "power4.inOut",
        onUpdate: () => {
        },
        onComplete: () => {
          r !== 6 && new D(kn.position.x, kn.position.y, kn.position.z - 1), Rh = false, console.log("Moved to Section:", ta);
          const i = new D();
          kn.getWorldDirection(i), console.log("Camera is now looking in direction:", i);
        }
      });
    }
    function Qa() {
      return ta;
    }
    const uT = "modulepreload", hT = function(r) {
      return "/" + r;
    }, Nm = {}, Dh = function(r, e, t) {
      let i = Promise.resolve();
      if (e && e.length > 0) {
        document.getElementsByTagName("link");
        const s = document.querySelector("meta[property=csp-nonce]"), a = (s == null ? void 0 : s.nonce) || (s == null ? void 0 : s.getAttribute("nonce"));
        i = Promise.allSettled(e.map((o) => {
          if (o = hT(o), o in Nm) return;
          Nm[o] = true;
          const l = o.endsWith(".css"), c = l ? '[rel="stylesheet"]' : "";
          if (document.querySelector(`link[href="${o}"]${c}`)) return;
          const u = document.createElement("link");
          if (u.rel = l ? "stylesheet" : uT, l || (u.as = "script"), u.crossOrigin = "", u.href = o, a && u.setAttribute("nonce", a), document.head.appendChild(u), l) return new Promise((h, d) => {
            u.addEventListener("load", h), u.addEventListener("error", () => d(new Error(`Unable to preload CSS for ${o}`)));
          });
        }));
      }
      function n(s) {
        const a = new Event("vite:preloadError", {
          cancelable: true
        });
        if (a.payload = s, window.dispatchEvent(a), !a.defaultPrevented) throw s;
      }
      return i.then((s) => {
        for (const a of s || []) a.status === "rejected" && n(a.reason);
        return r().catch(n);
      });
    };
    function dT() {
      const r = document.getElementById("mouse-scroll-indicator");
      r.style.display = "block";
      const e = document.querySelector(".mouse-scroll-indicator");
      if (!e) return;
      const t = window.innerWidth, i = window.innerHeight, n = Math.min(t, i) / 300;
      document.documentElement.style.setProperty("--dynamic-scale", n);
      const s = document.createElement("div");
      s.id = "scroll-text", s.textContent = "SCROLL UP OR DOWN TO EXPLORE", document.body.appendChild(s), setTimeout(() => {
        e.classList.add("moved"), s.classList.add("fade-out");
      }, 3e3), setTimeout(() => {
        s.remove();
      }, 4500);
    }
    function pT(r) {
      const e = document.getElementById("cn-icon-wrapper"), t = document.getElementById("cn-wrapper"), i = document.getElementById("cn-overlay"), n = document.createElement("ul");
      n.style.listStyle = "none", n.style.padding = "0";
      let s = false, a = false, o = null, l = null;
      n.innerHTML = "", r.forEach((p, f) => {
        const _ = document.createElement("li"), g = document.createElement("div");
        g.textContent = p.name;
        const m = document.createElement("span");
        if (m.textContent = "\u25BA", m.style.cursor = "pointer", m.style.marginLeft = "15px", _.style.cursor = "pointer", _.style.padding = "10px", _.style.color = "black", _.style.borderBottom = "1px solid rgba(255,255,255,0.3)", _.textContent = p.name, _.addEventListener("click", () => {
          Lh(f, p.position), u();
        }), p.subsections && p.subsections.length > 0) {
          _.appendChild(m);
          const y = document.createElement("ul");
          y.style.listStyle = "none", y.style.marginLeft = "5px", y.style.display = "none", p.subsections.forEach((x) => {
            const v = document.createElement("li");
            v.textContent = x.name, v.style.cursor = "pointer", v.addEventListener("click", (A) => {
              A.stopPropagation(), Lh(f, x.position), u();
            }), y.appendChild(v);
          }), m.addEventListener("click", (x) => {
            x.stopPropagation(), y.style.display === "none" ? (y.style.display = "block", m.classList.toggle("arrow-rotated")) : (y.style.display = "none", m.classList.toggle("arrow-rotated"));
          }), _.appendChild(y);
        }
        if (n.appendChild(_), p.name === "Games Section") {
          const y = document.createElement("ul");
          y.className = "submenu", y.style.listStyle = "none", y.style.padding = "0", y.style.marginLeft = "20px", y.style.display = "block", y.style.backgroundColor = "rgba(0, 0, 0, 0.8)", y.style.borderRadius = "5px", y.style.overflow = "hidden", [
            {
              name: "PsycheJR",
              path: "../PsycheJR/kids.html"
            },
            {
              name: "Escape Velocity",
              path: "../escapeVelocity/escape-velocity.html"
            },
            {
              name: "SpacePic",
              path: "../spacepic/photo.html"
            }
          ].forEach((v) => {
            const A = document.createElement("li");
            A.textContent = v.name, A.style.cursor = "pointer", A.style.padding = "8px 15px", A.style.color = "#00aaff", A.style.borderBottom = "1px solid rgba(255,255,255,0.1)", A.style.fontSize = "0.9em", A.addEventListener("mouseover", () => {
              A.style.backgroundColor = "rgba(0, 170, 255, 0.2)", A.style.opacity = "1", A.style.color = "black";
            }), A.addEventListener("mouseout", () => {
              A.style.backgroundColor = "transparent", A.style.opacity = "1", A.style.color = "#00aaff";
            }), A.addEventListener("click", (T) => {
              T.stopPropagation(), v.name === "PsycheJR" ? Dh(() => Promise.resolve().then(() => JE), void 0).then((w) => {
                w.showKidsViewport();
              }) : v.name === "Escape Velocity" ? Dh(() => Promise.resolve().then(() => RT), void 0).then((w) => {
                w.showEscapeVelocityViewport();
              }) : v.name === "SpacePic" && Dh(() => HT(() => import("./viewportspacepic-vBhYZtMZ-CaoZ_fz_.js"), []), []).then((w) => {
                w.showSpacePicViewport();
              }), document.body.classList.remove("overlay-open");
            }), y.appendChild(A);
          }), _.appendChild(y), _.addEventListener("click", (v) => {
            const A = y.style.display;
            document.querySelectorAll(".submenu").forEach((T) => {
              T.style.display = "none";
            }), y.style.display = A === "none" ? "block" : "none", v.stopPropagation();
          });
          const x = document.createElement("span");
          x.textContent = " \u25BC", x.style.fontSize = "0.8em", x.style.marginLeft = "5px", _.appendChild(x);
        }
      }), t.appendChild(n);
      function c() {
        clearTimeout(o), clearTimeout(l), s = true, a = true, t.classList.remove("closing"), t.classList.add("opened-nav"), i.classList.add("active"), e.classList.add("active"), e.style.transition = "transform 0.5s ease-in-out", e.style.transform = "rotate(360deg)";
      }
      function u() {
        s && (s = false, a = false, t.classList.add("closing"), o = setTimeout(() => {
          t.classList.remove("opened-nav"), t.classList.remove("closing");
        }, 300), i.classList.remove("active"), e.classList.remove("active"), e.style.transition = "transform 0.5s ease-in-out", e.style.transform = "rotate(0deg)");
      }
      function h() {
        s ? u() : c();
      }
      function d() {
        a || (l = setTimeout(() => {
          u();
        }, 250));
      }
      e.addEventListener("mouseenter", () => {
        a || c();
      }), t.addEventListener("mouseenter", () => {
        a || c();
      }), e.addEventListener("mouseleave", d), t.addEventListener("mouseleave", d), e.addEventListener("click", h), i.addEventListener("click", u), document.addEventListener("click", (p) => {
        !t.contains(p.target) && !e.contains(p.target) && u();
      });
    }
    function fT(r, e, t) {
      return new Promise((i) => {
        var n;
        const s = (n = t[0]) == null ? void 0 : n.position, a = {
          x: s.x - 12,
          y: s.y + 6,
          z: s.z - 13
        };
        console.log("TMP", a);
        const o = {
          x: 0,
          y: 0.1,
          z: 0
        };
        vh("REFERENCES", a, o, 1, r), LE([
          {
            text: "Development Team",
            onClick: () => console.log("DevTeam Clicked")
          },
          {
            text: "Sponsor",
            onClick: () => console.log("Sponsor Clicked")
          },
          {
            text: "Code",
            onClick: () => console.log("Explore Clicked")
          },
          {
            text: "Images",
            onClick: () => console.log("Surface Clicked")
          }
        ], a, o, r), i();
      });
    }
    function mT(r, e, t) {
      var i;
      const n = (i = t[1]) == null ? void 0 : i.position;
      if (!n) return console.error("Section 1 position not found."), Promise.reject("Section 1 position not found.");
      const s = {
        x: n.x - 12,
        y: n.y + 3,
        z: n.z - 13
      }, a = {
        x: 0,
        y: Math.PI / 12,
        z: 0
      }, o = {
        x: n.x - 11,
        y: n.y - 2,
        z: n.z - 13
      }, l = {
        x: 0,
        y: Math.PI / 12,
        z: 0
      };
      return new Promise(async (c, u) => {
        vh("YEAR ON PSYCHE", s, a, 1.5, r);
        const h = await vh(`16 Psyche is a giant asteroid in our solar system!
    Explore this site to learn about 16 Psyche,
     its origin, orbit, and what makes it unique!
`, o, l, 0.5, r);
        h.material.uniforms.opacity.value = 0, St.to(h.material.uniforms.opacity, {
          value: 1,
          duration: 2.5,
          delay: 4
        }), gl("asteroid", "/res/models/psyche_new.glb", {
          x: 80,
          y: 60,
          z: 20
        }, 6, {
          x: 0,
          y: 0,
          z: 0
        }, {
          position: {
            x: 20,
            y: 16,
            z: -45,
            duration: 3,
            ease: "power2.out"
          },
          rotation: {
            y: -6.28319,
            z: 6.28319,
            duration: 45,
            ease: "linear",
            repeat: -1
          }
        }, r, (d) => {
          c();
        }), setTimeout(() => u("Model load timeout"), 1e4);
      }).then(() => {
        console.log("section 1 loaded");
      }).catch((c) => {
        console.error("Error loading Section 1:", c);
      });
    }
    function gT(r, e, t, i) {
      var n;
      const s = (n = t[2]) == null ? void 0 : n.position;
      if (!s) return console.error("Section 2 position not found."), Promise.reject("Section 2 position not found.");
      const a = {
        x: s.x,
        y: s.y + 6,
        z: s.z - 12
      }, o = {
        x: 0.2,
        y: 0,
        z: 0
      };
      return new Promise((l, c) => {
        try {
          const { buttonMesh: u } = Vs("CLICK HERE TO LEARN HOW PSYCHE GOT ITS NAME!", a, o, 0.7, r, () => {
            console.log("Origin button clicked."), jE();
          }), h = new mn(), d = new ee();
          window.addEventListener("mousemove", (p) => {
            const f = i.domElement.getBoundingClientRect();
            d.x = (p.clientX - f.left) / f.width * 2 - 1, d.y = -((p.clientY - f.top) / f.height) * 2 + 1, h.setFromCamera(d, e);
            const _ = h.intersectObjects(Ln);
            i.domElement.style.cursor = _.length > 0 ? "pointer" : "default";
          }), l();
        } catch (u) {
          c(u);
        }
      });
    }
    function _T() {
      const r = window.innerWidth;
      let e, t, i, n = 1, s = 1;
      return r >= 2e3 ? (n = 1.3, s = 1.3, e = 50) : r >= 1600 ? (n = 1.2, s = 1.2, e = 45) : r >= 1200 ? (n = 1.1, s = 1.1, e = 42) : r >= 992 ? (n = 1, s = 1) : r >= 768 ? (n = 0.9, s = 0.9, e = 38) : (n = 0.8, s = 0.8, e = 35), {
        posX: e,
        posY: t,
        posZ: i,
        buttonScale: n,
        labelScale: s
      };
    }
    function vT(r, e, t, i) {
      return new Promise((n, s) => {
        var a;
        const o = (a = t[3]) == null ? void 0 : a.position;
        if (!o) {
          console.error("Section 3 position not found."), s("Section 3 position not found.");
          return;
        }
        const { buttonScale: l } = _T(), c = {
          x: o.x,
          y: o.y + 2,
          z: o.z - 12
        }, u = {
          x: 0.2,
          y: 0,
          z: 0
        };
        try {
          Vs("Explore the Psyche Jr Kids Experience", c, u, l, r, () => {
            Tm(), console.log("Psyche Jr button clicked.");
          }).then(({ textMesh: h, buttonMesh: d }) => {
            const p = d.material.emissive.clone(), f = d.material.emissiveIntensity, _ = new mn(), g = new ee();
            window.addEventListener("mousemove", (m) => {
              const y = i.domElement.getBoundingClientRect();
              g.x = (m.clientX - y.left) / y.width * 2 - 1, g.y = -((m.clientY - y.top) / y.height) * 2 + 1, _.setFromCamera(g, e), _.intersectObjects([
                d
              ]).length > 0 ? (yh(d, {
                color: "#ff9900",
                intensity: 2
              }), i.domElement.style.cursor = "pointer") : (d.material.emissive = p, d.material.emissiveIntensity = f, d.material.needsUpdate = true, i.domElement.style.cursor = "default");
            });
          }), n();
        } catch (h) {
          console.error("Error setting up Section 3:", h), s(h);
        }
      });
    }
    function xT(r, e) {
      const t = Qa() === 3;
      for (let i = 0; i < e.children.length; i++) {
        const n = e.children[i];
        n.userData && n.userData.section3Element && (n.visible = t);
      }
    }
    let rt = null, tn = null, eo = null, Fm = null;
    function Bm() {
      const r = window.innerWidth, e = window.innerHeight, t = window.devicePixelRatio || 1;
      console.log(`Screen size: ${r}x${e}, Pixel ratio: ${t}`);
      let i, n, s;
      return r === 2388 && e === 1668 || e === 2388 && r === 1668 ? (console.log('iPad Pro 11" detected'), i = "90%", s = "2000px", n = "90vh") : r >= 2e3 ? (i = "85%", s = "2400px", n = "85vh") : r >= 1600 ? (i = "88%", s = "1900px", n = "88vh") : r >= 1200 ? (i = "90%", s = "1500px", n = "90vh") : r >= 992 ? (i = "92%", s = "1150px", n = "92vh") : r >= 768 ? (i = "95%", s = "950px", n = "95vh") : (i = "98%", s = "100%", n = "98vh"), {
        width: i,
        maxWidth: s,
        height: n
      };
    }
    function vl() {
      if (!rt) return;
      const { width: r, maxWidth: e, height: t } = Bm();
      rt.style.width = r, rt.style.maxWidth = e, rt.style.height = t, console.log(`Viewport resized to: width=${r}, maxWidth=${e}, height=${t}`);
    }
    function yT() {
      if (rt) {
        rt.style.display = "flex", vl();
        return;
      }
      console.log("Creating website viewport"), rt = document.createElement("div"), rt.id = "website-viewport-container", Ws(rt, {
        backgroundColor: "rgba(0, 0, 0, 0.05)",
        borderColor: "rgba(122, 95, 62, 0.3)",
        boxShadow: "0 0 15px rgba(122, 95, 62, 0.3)"
      });
      const { width: r, maxWidth: e, height: t } = Bm();
      rt.style.width = r, rt.style.maxWidth = e, rt.style.height = t;
      const i = document.createElement("div");
      Xs(i, {
        backgroundColor: "rgba(10, 10, 20, 0.2)",
        gradientStart: "rgba(10, 10, 20, 0.2)",
        gradientEnd: "rgba(20, 20, 40, 0.2)"
      });
      const n = document.createElement("h2");
      n.textContent = "Psyche Mission Website", js(n);
      const s = document.createElement("div");
      s.style.display = "flex", s.style.alignItems = "center", eo = document.createElement("button"), eo.textContent = "\u2715", qs(eo), s.appendChild(eo), i.appendChild(n), i.appendChild(s), rt.appendChild(i), tn = document.createElement("iframe"), tn.src = "./../../public/website/index.html", Ys(tn, {
        backgroundColor: "rgba(0, 0, 0, 0.0)"
      }), Ks(document), tn.onerror = () => {
        console.error("Failed to load website iframe content");
      }, tn.onload = () => {
        console.log("Website iframe loaded successfully"), Zs(tn);
      }, rt.appendChild(tn), document.body.appendChild(rt), Js(rt), $s(rt), Qs(rt, i, tn), ea(rt), eo.addEventListener("click", zm), document.addEventListener("keydown", MT), window.addEventListener("resize", vl), Fm = new ResizeObserver((a) => {
        console.log("ResizeObserver detected size change"), vl();
      }), Fm.observe(document.body);
    }
    function zm() {
      rt && en(rt, () => {
        rt.style.display = "none", rt.style.opacity = 1, rt.style.transform = "translate(-50%, -50%) scale(1)", document.body.classList.add("overlay-open");
      });
    }
    function MT(r) {
      r.key === "Escape" && zm();
    }
    window.setWebsiteViewportSize = function(r, e) {
      if (!rt) {
        console.warn("Website viewport is not currently active");
        return;
      }
      return console.log(`Manually setting viewport size to ${r}x${e}`), rt.style.width = `${r}px`, rt.style.maxWidth = `${r}px`, rt.style.height = `${e}px`, rt.style.transform = "translate(-50%, -50%)", `Viewport size set to ${r}x${e}`;
    }, window.resetWebsiteViewportSize = function() {
      if (!rt) {
        console.warn("Website viewport is not currently active");
        return;
      }
      return vl(), "Viewport size reset to responsive mode";
    };
    function bT(r, e, t, i) {
      var n;
      const s = (n = t[5]) == null ? void 0 : n.position;
      if (!s) return console.error("Section 5 position not found."), Promise.reject("Section 5 position not found.");
      const a = {
        x: s.x,
        y: s.y + 2,
        z: s.z - 12
      }, o = {
        x: s.x,
        y: s.y - 3,
        z: s.z - 20
      }, l = {
        x: 0.2,
        y: 0,
        z: 0
      }, c = {
        x: 0.2,
        y: 0,
        z: 0
      };
      return new Promise((u, h) => {
        try {
          gl("probe", "./../../res/models/nasaLogo.glb", o, 0.7, c, null, r, () => {
            console.log("loaded model");
          });
          const { buttonMesh: d } = Vs("Explore the Mission Website", a, l, 0.7, r, () => {
            yT(), console.log("Psyche Jr button clicked.");
          }), p = new mn(), f = new ee();
          window.addEventListener("mousemove", (_) => {
            const g = i.domElement.getBoundingClientRect();
            f.x = (_.clientX - g.left) / g.width * 2 - 1, f.y = -((_.clientY - g.top) / g.height) * 2 + 1, p.setFromCamera(f, e);
            const m = p.intersectObjects(Ln);
            i.domElement.style.cursor = m.length > 0 ? "pointer" : "default";
          }), u();
        } catch (d) {
          console.error("Error loading Section 5:", d), h(d);
        }
      });
    }
    let ST = false;
    function ET(r, e, t, i) {
      return new Promise((n, s) => {
        var a;
        const o = (a = t[6]) == null ? void 0 : a.position;
        if (!o) return console.error("Section 6 position not found."), s("Section 6 position not found.");
        const l = {
          x: o.x,
          y: o.y + 2,
          z: o.z - 12
        }, c = {
          x: o.x,
          y: o.y - 5,
          z: o.z - 12
        }, u = {
          x: 0.2,
          y: 0,
          z: 0
        }, h = {
          x: 0.2,
          y: 0.5,
          z: 0
        };
        try {
          gl("controller", "./../../res/models/arcade_controller.glb", c, 2, h, null, r, () => {
            console.log("loaded model");
          });
          const { buttonMesh: d } = Vs("Try some Psyche inspired games!", l, u, 0.7, r, () => {
            KE(), console.log("Games button clicked.");
          });
          yh(d, {
            color: "#ff9900",
            intensity: 2
          });
          const p = new mn(), f = new ee();
          window.addEventListener("mousemove", (_) => {
            const g = i.domElement.getBoundingClientRect();
            f.x = (_.clientX - g.left) / g.width * 2 - 1, f.y = -((_.clientY - g.top) / g.height) * 2 + 1, p.setFromCamera(f, e);
            const m = p.intersectObjects(Ln);
            i.domElement.style.cursor = m.length > 0 ? "pointer" : "default";
          }), ST = true, n();
        } catch (d) {
          s(d);
        }
      });
    }
    function TT(r, e, t) {
      return new Promise((i, n) => {
        var s;
        const a = (s = t[7]) == null ? void 0 : s.position;
        if (!a) {
          console.error("Error: Section 7 position not found."), n("Section 7 position not found.");
          return;
        }
        const o = {
          x: a.x + 5,
          y: a.y + 10,
          z: a.z - 20
        };
        r.add(vm("Surface of Psyche", o, r, rT, 1.5)), i();
      });
    }
    function wT(r, e, t, i) {
      var n;
      const s = (n = t[8]) == null ? void 0 : n.position;
      if (!s) return console.error("Section 8 position not found."), Promise.reject("Section 8 position not found.");
      const a = {
        x: s.x,
        y: s.y + 2,
        z: s.z - 12
      }, o = {
        x: s.x,
        y: s.y - 3,
        z: s.z - 12
      };
      console.log("map pin location: ", o);
      const l = {
        x: 0.2,
        y: 0,
        z: 0
      }, c = {
        x: -0.02,
        y: 0.5,
        z: 0
      };
      return new Promise((u, h) => {
        try {
          gl("controller", "./../../res/models/navigation_pin.glb", o, 1, c, {
            rotation: {
              x: 0,
              y: -40,
              z: 0,
              duration: 45,
              ease: "linear",
              repeat: -1
            }
          }, r, () => {
            console.log("loaded model");
          });
          const { buttonMesh: d } = Vs("Explore Psyche's Location!", a, l, 0.7, r, () => {
            sT(), console.log("Location button clicked.");
          });
          yh(d, {
            color: "#ff9900",
            intensity: 2
          });
          const p = new mn(), f = new ee();
          window.addEventListener("mousemove", (_) => {
            const g = i.domElement.getBoundingClientRect();
            f.x = (_.clientX - g.left) / g.width * 2 - 1, f.y = -((_.clientY - g.top) / g.height) * 2 + 1, p.setFromCamera(f, e);
            const m = p.intersectObjects(Ln);
            i.domElement.style.cursor = m.length > 0 ? "pointer" : "default";
          }), u();
        } catch (d) {
          h(d);
        }
      });
    }
    const km = [];
    function AT(r, e) {
      if (km.length === 0) return;
      const t = Qa() === 8;
      km.forEach((i) => {
        i.visible !== t && (i.visible = t);
      });
    }
    let ct = null, Ui = null, wi = null;
    function xl() {
      if (ct) {
        ct.style.display = "flex";
        return;
      }
      console.log("Creating escape velocity viewport"), ct = document.createElement("div"), ct.id = "escape-velocity-viewport-container", ct.style.position = "fixed", ct.style.top = "50%", ct.style.left = "50%", ct.style.transform = "translate(-50%, -50%)", ct.style.width = "80%", ct.style.maxWidth = "1440px", ct.style.height = "80vh", ct.style.backgroundColor = "rgba(0, 0, 0, 0.9)", ct.style.border = "2px solid #007bff", ct.style.borderRadius = "10px", ct.style.boxShadow = "0 0 20px rgba(0, 123, 255, 0.5)", ct.style.zIndex = "900", ct.style.display = "flex", ct.style.flexDirection = "column", ct.style.overflow = "hidden";
      const r = document.createElement("div");
      r.style.display = "flex", r.style.justifyContent = "space-between", r.style.alignItems = "center", r.style.padding = "10px 15px", r.style.backgroundColor = "#007bff", r.style.color = "white", r.style.borderTopLeftRadius = "8px", r.style.borderTopRightRadius = "8px";
      const e = document.createElement("h2");
      e.textContent = "Escape Velocity Game", e.style.margin = "0", e.style.fontSize = "1.2rem";
      const t = document.createElement("div");
      t.style.display = "flex", t.style.alignItems = "center", t.style.gap = "10px";
      const i = document.createElement("button");
      i.textContent = "\u21A9", i.style.background = "none", i.style.border = "none", i.style.color = "white", i.style.fontSize = "1.2rem", i.style.cursor = "pointer", i.style.padding = "0 5px", i.style.lineHeight = "1", i.style.marginRight = "5px", wi = document.createElement("button"), wi.textContent = "\u2715", wi.style.background = "none", wi.style.border = "none", wi.style.color = "white", wi.style.fontSize = "1.5rem", wi.style.cursor = "pointer", wi.style.padding = "0 5px", wi.style.lineHeight = "1", t.appendChild(i), t.appendChild(wi), r.appendChild(e), r.appendChild(t), ct.appendChild(r), Ui = document.createElement("iframe"), Ui.src = "./escapeVelocity/escape-velocity.html", Ui.style.width = "100%", Ui.style.height = "100%", Ui.style.border = "none", Ui.style.backgroundColor = "#222", Ui.onerror = () => {
        console.error("Failed to load iframe content");
      }, Ui.onload = () => {
        console.log("Iframe loaded successfully");
      }, ct.appendChild(Ui), document.body.appendChild(ct);
      const n = St.timeline();
      n.from(ct, {
        opacity: 0,
        scale: 0.8,
        duration: 0.4,
        ease: "power2.out"
      }), n.from(r, {
        y: -50,
        duration: 0.3,
        ease: "back.out(1.7)"
      }, "-=0.2"), n.from(Ui, {
        opacity: 0,
        y: 20,
        duration: 0.3,
        ease: "power2.out"
      }, "-=0.1"), wi.addEventListener("click", to), i.addEventListener("click", function(s) {
        s.preventDefault(), s.stopPropagation(), e.textContent = "Psyche Mission Games", Ui.src = "./games/games.html", console.log("Loading games HTML in escape velocity viewport");
      }), document.addEventListener("keydown", Hm), setTimeout(ra, 100);
    }
    function to() {
      ct && St.to(ct, {
        opacity: 0,
        scale: 0.8,
        duration: 0.3,
        ease: "power2.in",
        onComplete: () => {
          Vm(), document.body.classList.add("overlay-open");
        }
      });
    }
    function Hm(r) {
      r.key === "Escape" && to();
    }
    function Vm() {
      ct && (wi.removeEventListener("click", to), document.removeEventListener("keydown", Hm), document.body.removeChild(ct), ct = null, Ui = null, wi = null);
    }
    const RT = Object.freeze(Object.defineProperty({
      __proto__: null,
      destroyEscapeVelocityViewport: Vm,
      hideEscapeVelocityViewport: to,
      showEscapeVelocityViewport: xl
    }, Symbol.toStringTag, {
      value: "Module"
    }));
    let Gm = [], yl = false;
    function CT(r, e, t, i) {
      return new Promise((n, s) => {
        try {
          const a = new un(40, 20, 5), o = new $i({
            color: 31743,
            transparent: false
          }), l = new Rt(a, o);
          l.position.set(200, 300, -110), l.userData.section9Element = true, r.add(l);
          const c = [];
          c.push(l);
          const u = document.createElement("canvas");
          u.width = 256, u.height = 128;
          const h = u.getContext("2d");
          h.fillStyle = "#007bff", h.fillRect(0, 0, u.width, u.height), h.font = "bold 24px Arial", h.fillStyle = "white", h.textAlign = "center", h.textBaseline = "middle", h.fillText("Escape Velocity", u.width / 2, u.height / 2);
          const d = new z_(u), p = new $i({
            map: d,
            transparent: true
          }), f = new Ta(50, 25), _ = new Rt(f, p);
          _.position.set(200, 300, -107), _.userData.section9Element = true, r.add(_), c.push(_);
          const g = new uu(16777215, 2, 200);
          g.position.set(200, 300, -100), g.userData.section9Element = true, r.add(g), c.push(g);
          const m = new pp(16777215, 0.5);
          m.userData.section9Element = true, r.add(m), c.push(m), xh(l, () => {
            xl();
          }), xh(_, () => {
            xl();
          });
          let y = false;
          l.userData.onPointerOver = () => {
            y || (St.to(l.material.color, {
              r: 0,
              g: 0.337,
              b: 0.702,
              duration: 0.3
            }), y = true);
          }, l.userData.onPointerOut = () => {
            y && (St.to(l.material.color, {
              r: 0,
              g: 0.482,
              b: 1,
              duration: 0.3
            }), y = false);
          }, c.forEach((x) => {
            x.visible = false;
          }), n();
        } catch (a) {
          s(a);
        }
      });
    }
    function PT(r, e) {
      if (Gm.length === 0) return;
      const t = Qa() === 9;
      Gm.forEach((i) => {
        i.visible !== t && (i.visible = t);
      }), t && !yl ? setTimeout(() => {
        xl(), yl = true;
      }, 500) : !t && yl && (to(), yl = false);
    }
    function LT() {
      document.getElementById("loading-screen");
      const r = document.getElementById("progress-bar"), e = [
        {
          name: "REFERENCES",
          position: {
            x: -150,
            y: -150,
            z: 13
          }
        },
        {
          name: "WELCOME",
          position: {
            x: 0,
            y: 0,
            z: 13
          }
        },
        {
          name: "16 PSYCHE",
          position: {
            x: 20,
            y: 30,
            z: 10
          }
        },
        {
          name: "PSYCHE Jr",
          position: {
            x: -150,
            y: 150,
            z: 13
          }
        },
        {
          name: "COSMIC COMPARISON",
          position: {
            x: 0,
            y: 300,
            z: 13
          }
        },
        {
          name: "MISSION",
          position: {
            x: 150,
            y: 150,
            z: 13
          }
        },
        {
          name: "GAMES",
          position: {
            x: 300,
            y: 0,
            z: 13
          },
          subsections: [
            {
              name: "Temperature Control",
              position: {
                x: 300,
                y: 0,
                z: 13
              }
            },
            {
              name: "Balance Game",
              position: {
                x: 300,
                y: 0,
                z: 13
              }
            },
            {
              name: "Escape Velocity",
              position: {
                x: 300,
                y: 0,
                z: 13
              }
            },
            {
              name: "SpacePic",
              position: {
                x: 300,
                y: 0,
                z: 13
              }
            }
          ]
        },
        {
          name: "SURFACE OF PSYCHE",
          position: {
            x: 150,
            y: -150,
            z: 13
          }
        },
        {
          name: "LOCATION OF PYSCHE",
          position: {
            x: 0,
            y: -300,
            z: 13
          }
        }
      ];
      pT(e);
      const t = new R_(), i = new oi(75, window.innerWidth / window.innerHeight, 0.1, 5e3);
      i.position.set(0, 0, 13);
      const n = new Db({
        antialias: true
      });
      n.setSize(window.innerWidth, window.innerHeight), n.setPixelRatio(window.devicePixelRatio), document.getElementById("canvas-container").appendChild(n.domElement);
      const s = new pp(16777215, 0.5);
      t.add(s);
      const a = new dp(8019774, 10);
      a.position.set(-15, 5, 5), t.add(a), cT(i, e, n);
      const o = navigator.hardwareConcurrency < 4 || window.devicePixelRatio < 1.5, l = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent), c = o ? 0.5 : 1, u = o ? 1 : 2, h = document.getElementById("debug-panel");
      function d() {
        const y = Qa();
        h.innerHTML = `
      <strong>DEBUG PANEL:</strong><br>
      <strong>Current Section:</strong>
      ${y}<br>
      <strong>Camera Position:</strong><br>
      X: ${i.position.x.toFixed(2)}<br>
      Y: ${i.position.y.toFixed(2)}<br>
      Z: ${i.position.z.toFixed(2)}<br>
      Is Mobile: ${l}<br>
      Concurrency: ${navigator.hardwareConcurrency}<br>
      PixelRatio: ${window.devicePixelRatio}
    `;
      }
      function p() {
        requestAnimationFrame(p), d(), f ? f.render() : n.render(t, i), xT(i, t), tT(i, t), AT(), PT();
      }
      UE(i, t, n);
      const f = XE(t, n, i, u), _ = [
        fT(t, i, e),
        mT(t, i, e),
        gT(t, i, e, n),
        vT(t, i, e, n),
        eT(t, i, e, n),
        bT(t, i, e, n),
        ET(t, i, e, n),
        TT(t, i, e),
        wT(t, i, e, n),
        CT(t)
      ];
      let g = 0;
      const m = _.length;
      _.forEach((y) => {
        y.then(() => {
          g++;
          const x = g / m * 100;
          r.style.width = `${x}%`, g === m && (console.log("All sections loaded."), WE(t, {
            density: c
          }), OE(i, n), dT(), p(), DT(), document.getElementById("cn-icon-wrapper").style.display = "flex");
        }).catch((x) => {
          console.error("Error loading a section:", x);
        });
      });
    }
    function DT() {
      const r = document.getElementById("loading-screen");
      r.style.transition = "opacity 0.5s ease", r.style.opacity = "0", setTimeout(() => r.remove(), 500);
    }
    window.addEventListener("resize", () => {
      camera && renderer ? Um(camera, renderer) : console.warn("Resize event fired, but camera or renderer is not defined.");
    }), LT();
  })();
})();
export {
  ra as $,
  St as T,
  __tla
};
